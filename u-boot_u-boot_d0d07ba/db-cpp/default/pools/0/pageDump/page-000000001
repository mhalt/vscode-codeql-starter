EFI_GUID(0x62da6a56, 0x13fb, 0x485a, 0xa8, 0xda, 0xa3, 0xdd, 0x79, 0x12, 0xcb, 0x6b)EFI_EVENT_GROUP_READY_TO_BOOTEFI_GUID(0x7ce88fb3, 0x4bd7, 0x4679, 0x87, 0xa8, 0xa8, 0xd8, 0xde, 0xe5, 0x0d, 0x2b)EFI_EVENT_GROUP_MEMORY_MAP_CHANGEEFI_GUID(0x78bee926, 0x692f, 0x48fd, 0x9e, 0xdb, 0x01, 0x42, 0x2e, 0xf0, 0xd7, 0xab)EFI_EVENT_GROUP_VIRTUAL_ADDRESS_CHANGEEFI_GUID(0x13fa7698, 0xc831, 0x49c7, 0x87, 0xea, 0x8f, 0x43, 0xfc, 0xc2, 0x51, 0x96)EFI_EVENT_GROUP_EXIT_BOOT_SERVICESEFI_GUID(0x27abf055, 0xb1b8, 0x4c26, 0x80, 0x48, 0x74, 0x8f, 0x37, 0xba, 0xa2, 0xdf)EFI_RT_SUPPORTED_QUERY_VARIABLE_INFOEFI_RT_SUPPORTED_QUERY_CAPSULE_CAPABILITIESEFI_RT_SUPPORTED_UPDATE_CAPSULEEFI_RT_SUPPORTED_RESET_SYSTEMEFI_RT_SUPPORTED_GET_NEXT_HIGH_MONOTONIC_COUNTEFI_RT_SUPPORTED_CONVERT_POINTEREFI_RT_SUPPORTED_SET_VIRTUAL_ADDRESS_MAPEFI_RT_SUPPORTED_SET_VARIABLEEFI_RT_SUPPORTED_GET_NEXT_VARIABLE_NAMEEFI_RT_SUPPORTED_GET_VARIABLEEFI_RT_SUPPORTED_SET_WAKEUP_TIMEEFI_RT_SUPPORTED_GET_WAKEUP_TIMEEFI_RT_SUPPORTED_SET_TIMEEFI_RT_SUPPORTED_GET_TIMECAPSULE_FLAGS_INITIATE_RESETCAPSULE_FLAGS_POPULATE_SYSTEM_TABLECAPSULE_FLAGS_PERSIST_ACROSS_RESETEFI_RUNTIME_SERVICES_SIGNATURE0x56524553544e5552ULLEFI_OPEN_PROTOCOL_EXCLUSIVEEFI_OPEN_PROTOCOL_BY_DRIVEREFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLEREFI_OPEN_PROTOCOL_TEST_PROTOCOLEFI_OPEN_PROTOCOL_GET_PROTOCOLEFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOLEFI_NATIVE_INTERFACEEFI_BOOT_SERVICES_SIGNATURE0x56524553544f4f42TPL_HIGH_LEVELTPL_NOTIFYTPL_CALLBACKTPL_APPLICATIONEVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE0x60000202EVT_SIGNAL_EXIT_BOOT_SERVICES0x00000201EVT_NOTIFY_SIGNALEVT_NOTIFY_WAITEVT_RUNTIMEEVT_TIMERefi_uintn_tefi_intn_tEFI_SPECIFICATION_VERSION(2 << 16 | 80)_EFI_API_HCONFIG_EFI_LOADERefi_event/* All values 0x00000200-0x00001F00 are reserved *//* Boot manager load options *//* Current version of the Unicode collation protocol *//* Deprecated version of the Unicode collation protocol *//*
	 * TODO: We currently only support EFI file protocol revision 0x00010000
	 *	 while UEFI specs 2.4 - 2.7 prescribe revision 0x00020000.
	 *//* revision of the simple network protocol *//* interrupt status bit mask *//* receive_filters bit mask *//*
 * HII protocols
 *//*
 * HII keyboard package
 */// u8 buffer[];			// EFI_IFR_TYPE_BUFFER// EFI_IFR_TYPE_REF// EFI_IFR_TYPE_STRING, EFI_IFR_TYPE_ACTION// EFI_IFR_TYPE_DATE// EFI_IFR_TYPE_TIME// EFI_IFR_TYPE_BOOLEAN// EFI_IFR_TYPE_NUM_SIZE_64// EFI_IFR_TYPE_NUM_SIZE_32// EFI_IFR_TYPE_NUM_SIZE_16// EFI_IFR_TYPE_NUM_SIZE_8/*
 * HII forms package
 * TODO: full scope of definitions
 *//* u8 block_body[]; *//*
 * HII string package
 *//*
 * HII GUID package
 *//**
 * struct efi_hii_package_header - EFI HII package header
 *
 * @fields:	'fields' replaces the bit-fields defined in the EFI
 *		specification to to avoid possible compiler incompatibilities::
 *
 *		u32 length:24;
 *		u32 type:8;
 *//*
 * Human Interface Infrastructure (HII)
 *//* extract background color from EFI attribute *//* treat high bit of FG as bright/bold (similar to edk2) *//* extract foreground color from EFI attribute *//* Added in revision 3 of the protocol *//* Added in revision 2 of the protocol *//* physical addr of wchar_t vendor string *//* EFI Configuration Table and GUID definitions *//* EFI event group GUID definitions *//* EFI Runtime Services table *//* Types and defines for EFI ResetSystem *//* EFI Boot Services table *//* Types and defines for EFI CreateEvent *//* UEFI spec version 2.8 *//opt/src/include/efi_loader.hefi_loaderefi_bootmgr_loadefi_serialize_load_optionefi_load_option *efi_deserialize_load_optionefi_query_variable_infoefi_set_variableefi_get_next_variable_nameefi_get_variableefi_set_timeefi_get_timeefi_reset_system_initefi_reset_systemefi_add_runtime_mmioefi_update_table_header_crc32efi_table_hdr *efi_init_runtime_supportedguidcmpsizeof(efi_guid_t)ascii2unicodeefi_dp_from_nameefi_dp_split_file_pathefi_dp_last_nodeefi_dp_from_memefi_dp_from_ethefi_dp_from_fileefi_dp_part_nodeefi_dp_from_partefi_dp_from_devefi_dp_is_multi_instanceefi_dp_get_next_instanceefi_dp_append_instanceefi_dp_create_device_nodeefi_dp_append_nodeefi_dp_appendefi_dp_dupefi_dp_sizeefi_dp_instance_sizeefi_dp_find_objefi_dp_matchefi_dp_nextefi_print_image_infosefi_setup_loaded_imageefi_loaded_image_obj *efi_loaded_image_obj **efi_loaded_image *efi_loaded_image **efi_install_configuration_tableefi_memory_initefi_driver_initefi_add_memory_mapefi_get_memory_mapefi_free_poolefi_allocate_poolefi_free_pagesefi_allocate_pagesefi_allocefi_file_from_pathefi_simple_file_systemefi_signal_eventefi_set_timerefi_create_eventefi_install_multiple_protocol_interfacesefi_remove_all_protocolsefi_remove_protocolefi_add_protocolefi_search_protocolefi_handler *efi_handler **efi_unload_imageefi_start_imageefi_load_imageefi_search_objefi_delete_handleefi_create_handleefi_add_handleefi_runtime_relocateefi_restore_gdefi_save_gdefi_load_peefi_timer_checkefi_set_watchdogefi_net_set_dhcp_ackefi_fs_from_pathefi_smbios_registerefi_acpi_registerefi_watchdog_registerefi_net_registerefi_gop_registerefi_disk_create_partitionsefi_disk_registerefi_console_registerefi_runtime_detachefi_initialize_system_tableefi_root_node_registerefi_variables_boot_exit_notifyefi_init_variablesefi_init_obj_listefi_dp_str__efi_nesting_dec__efi_nesting_inc__efi_nesting__efi_exit_check__efi_entry_checkefi_load_optionefi_register_notify_eventefi_protocol_notificationefi_loaded_image_objefi_handlerefi_open_protocol_info_itemefi_console_control_protocolefi_object_typeEFI_OBJECT_TYPE_UNDEFINEDEFI_OBJECT_TYPE_U_BOOT_FIRMWAREEFI_OBJECT_TYPE_LOADED_IMAGEEFI_OBJECT_TYPE_STARTED_IMAGEoptional_datafile_path_lengthhandlesimage_typeexit_jmpexit_dataexit_data_sizeexit_statusopen_infosprotocol_interfaceis_signaledtrigger_typetrigger_timetrigger_nextgroupnotify_contextnotify_functionnotify_tplqueue_linkprotocolsconst efi_unicode_collation_protocolconst efi_device_path_utilities_protocolconst efi_device_path_to_text_protocol__efi_runtime__attribute__ ((section (".text.efi_runtime")))__efi_runtime_data__attribute__ ((section (".data.efi_runtime")))EFI_DP_TYPE(_dp,_type,_subtype)(((_dp)->type == DEVICE_PATH_TYPE_ ## _type) && ((_dp)->sub_type == DEVICE_PATH_SUB_TYPE_ ## _subtype))efi_size_in_pages(size)((size + EFI_PAGE_MASK) >> EFI_PAGE_SHIFT)EFI_CACHELINE_SIZECONFIG_SYS_CACHELINE_SIZEEFI_PRINT(format,__VA_ARGS__...)({ debug("%sEFI: " format, __efi_nesting(), ## __VA_ARGS__); })EFI_CALL_VOID(exp)do { debug("%sEFI: Call: %s\n", __efi_nesting_inc(), #exp); assert(__efi_exit_check()); exp; assert(__efi_entry_check()); debug("%sEFI: Return From: %s\n", __efi_nesting_dec(), #exp); } while(0)EFI_CALL(exp)({ debug("%sEFI: Call: %s\n", __efi_nesting_inc(), #exp); assert(__efi_exit_check()); typeof(exp) _r = exp; assert(__efi_entry_check()); debug("%sEFI: %lu returned by %s\n", __efi_nesting_dec(), (unsigned long)((uintptr_t)_r & ~EFI_ERROR_MASK), #exp); _r; })EFI_EXIT(ret)({ typeof(ret) _r = ret; debug("%sEFI: Exit: %s: %u\n", __efi_nesting_dec(), __func__, (u32)((uintptr_t) _r & ~EFI_ERROR_MASK)); assert(__efi_exit_check()); _r; })EFI_ENTRY(format,__VA_ARGS__...)do { assert(__efi_entry_check()); debug("%sEFI: Entry %s(" format ")\n", __efi_nesting_inc(), __func__, ## __VA_ARGS__); } while(0)U_BOOT_GUIDEFI_GUID(0xe61d73b9, 0xa384, 0x4acc, 0xae, 0xab, 0x82, 0xe8, 0x28, 0xf3, 0x62, 0x8b)EFI_MAX_CONFIGURATION_TABLES_EFI_LOADER_HCONFIG_IS_ENABLED(EFI_LOADER)CONFIG_EFI_LOADER_BOUNCE_BUFFERCONFIG_CMD_BOOTEFI_SELFTEST.text.efi_runtimeefi_set_bootdevefi_register_notify_eventsefi_eventsefi_obj_listefi_guid_hii_string_protocolefi_guid_hii_database_protocolefi_guid_hii_config_access_protocolefi_guid_hii_config_routing_protocolefi_guid_unicode_collation_protocol2efi_guid_unicode_collation_protocolefi_guid_device_path_utilities_protocolefi_file_system_info_guidefi_file_info_guidefi_simple_file_system_protocol_guidefi_guid_device_path_to_text_protocolefi_guid_loaded_image_device_pathefi_guid_loaded_imageefi_guid_fdtefi_guid_event_group_reset_systemefi_guid_event_group_ready_to_bootefi_guid_event_group_memory_map_changeefi_guid_event_group_virtual_address_changeefi_guid_event_group_exit_boot_servicesefi_guid_driver_binding_protocolefi_guid_device_pathefi_guid_console_controlefi_global_variable_guidefi_block_io_guidefi_u_boot_guidefi_hii_stringefi_hii_databaseefi_hii_config_accessefi_hii_config_routingefi_unicode_collation_protocol2efi_device_path_utilitiesefi_device_path_to_textefi_console_controlefi_con_inefi_con_outsystabefi_memory_map_keyefi_rootEFI_LOADERCONFIG_VAL(EFI_LOADER_MODULE)CONFIG_EFI_LOADER_MODULE__ARG_PLACEHOLDER_CONFIG_EFI_LOADER_MODULE__ARG_PLACEHOLDER_CONFIG_EFI_LOADER_MODULE 1EFI_LOADER_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_EFI_LOADER_MODULECONFIG_VAL(EFI_LOADER)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_EFI_LOADER/* _EFI_LOADER_H *//* CONFIG_IS_ENABLED(EFI_LOADER) *//* No loader configured, stub out EFI_ENTRY *//* Without CONFIG_EFI_LOADER we don't have a runtime section, stub it out *//*
 * See section 3.1.3 in the v2.7 UEFI spec for more details on
 * the layout of EFI_LOAD_OPTION.  In short it is:
 *
 *    typedef struct _EFI_LOAD_OPTION {
 *        UINT32 Attributes;
 *        UINT16 FilePathListLength;
 *        // CHAR16 Description[];   <-- variable length, NULL terminated
 *        // EFI_DEVICE_PATH_PROTOCOL FilePathList[];
 *						 <-- FilePathListLength bytes
 *        // UINT8 OptionalData[];
 *    } EFI_LOAD_OPTION;
 *//*
 * Entry point for the tests of the EFI API.
 * It is called by 'bootefi selftest'
 *//* Architecture specific initialization of the EFI subsystem *//* Boards may provide the functions below to implement RTS functionality *//* Call this with mmio_ptr as the _pointer_ to a pointer to an MMIO region
 * to make it available at runtime *//* Update CRC32 in table header *//* Indicate supported runtime services *//*
 * Use these to indicate that your code / data should go into the EFI runtime
 * section and thus still be available when the OS is running
 *//**
 * ascii2unicode() - convert ASCII string to UTF-16 string
 *
 * A zero terminated ASCII string is converted to a zero terminated UTF-16
 * string. The output buffer must be preassigned.
 *
 * @unicode:	preassigned output buffer for UTF-16 string
 * @ascii:	ASCII string to be converted
 *//* Determine the last device path node that is not the end node. *//* Create a device node for a block device partition. *//* Check if a device path contains muliple instances *//* Get next device path instance *//* Append device path instance *//* Create a device path node of given type, sub-type, length *//* size of multi-instance device path excluding end node *//* get size of the first device path instance excluding end node *//* Print information about all loaded images *//* Sets up a loaded image *//* Adds new or overrides configuration table entry to the system table *//* Called by board init to initialize the EFI memory map *//* Called by board init to initialize the EFI drivers *//* Adds a range into the EFI memory map *//* Returns the EFI memory map *//* EFI pool memory free function. *//* EFI memory allocator for small allocations *//* EFI memory free function. *//* More specific EFI memory allocator, called by EFI payloads *//* Generic EFI memory allocator, call this to get memory *//**
 * efi_size_in_pages() - convert size in bytes to size in pages
 *
 * This macro returns the number of EFI memory pages required to hold 'size'
 * bytes.
 *
 * @size:	size in bytes
 * Return:	size in pages
 *//* open file from device-path: *//* open file system: *//* Call this to signal an event *//* Call this to set a timer *//* Call this to create an event *//* Install multiple protocol interfaces *//* Delete all protocols from a handle *//* Delete protocol from a handle *//* Install new protocol on a handle *//* Find a protocol on a handle *//* Unload image *//* Start image *//* Load image *//* Call this to validate a handle and find the EFI object for it *//* Delete handle *//* Create handle *//* Add a new object to the object list. *//* Call this to set the current device name *//* Call this to relocate the runtime section to an address space *//* Special case handler for error/abort that just tries to dtrt to get
 * back to u-boot world *//* Called once to store the pristine gd pointer *//* PE loader implementation *//* Called from places to check whether a timer expired *//* Called by efi_set_watchdog_timer to reset the timer *//* Called by networking code to memorize the dhcp ack package *//**
 * efi_smbios_register() - write out SMBIOS tables
 *
 * Called by bootefi to make SMBIOS tables available
 *
 * @return 0 if OK, -ENOMEM if no memory is available for the tables
 *//**
 * efi_acpi_register() - write out ACPI tables
 *
 * Called by bootefi to make ACPI tables available
 *
 * @return 0 if OK, -ENOMEM if no memory is available for the tables
 *//* Called by bootefi to make SMBIOS tables available *//* Called by bootefi to make the watchdog available *//* Called by bootefi to make the network interface available *//* Called by bootefi to make GOP (graphical) interface available *//* Create handles and protocols for the partitions of a block device *//* Called by bootefi to make all disk storage accessible as EFI objects *//* Called by bootefi to make console interface available *//* efi_runtime_detach() - detach unimplemented runtime functions *//* Called by bootefi to initialize runtime *//* Called by bootefi to initialize root node *//* Notify ExitBootServices() is called *//* Initialize variable services *//* Initialize efi execution environment *//* List of all events registered by RegisterProtocolNotify() *//**
 * efi_register_notify_event - event registered by RegisterProtocolNotify()
 *
 * The address of this structure serves as registration value.
 *
 * @link:	link to list of all registered events
 * @event:	registered event. The same event may registered for multiple
 *		GUIDs.
 * @protocol:	protocol for which the event is registered
 * @handles:	linked list of all handles on which the notified protocol was
 *		installed
 *//**
 * struct efi_protocol_notification - handle for notified protocol
 *
 * When a protocol interface is installed for which an event was registered with
 * the RegisterProtocolNotify() service this structure is used to hold the
 * handle on which the protocol interface was installed.
 *
 * @link:	link to list of all handles notified for this event
 * @handle:	handle on which the notified protocol interface was installed
 *//* List of all events *//* This list contains all UEFI objects we know of *//**
 * struct efi_event
 *
 * @link:		Link to list of all events
 * @queue_link:		Link to the list of queued events
 * @type:		Type of event, see efi_create_event
 * @notify_tpl:		Task priority level of notifications
 * @nofify_function:	Function to call when the event is triggered
 * @notify_context:	Data to be passed to the notify function
 * @group:		Event group
 * @trigger_time:	Period of the timer
 * @trigger_next:	Next time to trigger the timer
 * @trigger_type:	Type of timer, see efi_set_timer
 * @is_signaled:	The event occurred. The event is in the signaled state.
 *//**
 * struct efi_loaded_image_obj - handle of a loaded image
 *
 * @header:		EFI object header
 * @exit_status:	exit status passed to Exit()
 * @exit_data_size:	exit data size passed to Exit()
 * @exit_data:		exit data passed to Exit()
 * @exit_jmp:		long jump buffer for returning form started image
 * @entry:		entry address of the relocated image
 *//* The list of protocols *//* Every UEFI object is part of a global object list *//**
 * struct efi_object - dereferenced EFI handle
 *
 * @link:	pointers to put the handle into a linked list
 * @protocols:	linked list with the protocol interfaces installed on this
 *		handle
 *
 * UEFI offers a flexible and expandable object model. The objects in the UEFI
 * API are devices, drivers, and loaded images. struct efi_object is our storage
 * structure for these objects.
 *
 * When including this structure into a larger structure always put it first so
 * that when deleting a handle the whole encompassing structure can be freed.
 *
 * A pointer to this structure is referred to as a handle. Typedef efi_handle_t
 * has been created for such pointers.
 *//**
 * enum efi_object_type - type of EFI object
 *
 * In UnloadImage we must be able to identify if the handle relates to a
 * started image.
 *//**
 * struct efi_handler - single protocol interface of a handle
 *
 * When the UEFI payload wants to open a protocol on an object to get its
 * interface (usually a struct with callback functions), this struct maps the
 * protocol GUID to the respective protocol interface
 *
 * @link:		link to the list of protocols of a handle
 * @guid:		GUID of the protocol
 * @protocol_interface:	protocol interface
 * @open_infos		link to the list of open protocol info items
 *//**
 * struct efi_open_protocol_info_item - open protocol info item
 *
 * When a protocol is opened a open protocol info entry is created.
 * These are maintained in a list.
 *
 * @link:	link to the list of open protocol info entries of a protocol
 * @info:	information about the opening of a protocol
 *//* GUID of the Unicode collation protocol *//* GUID of the deprecated Unicode collation protocol *//* GUID for file system information *//* GUID of the device tree table *//* event group ResetSystem() invoked (before ExitBootServices) *//* event group boot manager about to boot *//* event group memory map changed *//* event group SetVirtualAddressMap() invoked *//* event group ExitBootServices() invoked *//* GUID of the EFI_DRIVER_BINDING_PROTOCOL *//* GUID of the EFI_BLOCK_IO_PROTOCOL *//* GUID of the U-Boot root node *//* current version of the EFI_UNICODE_COLLATION_PROTOCOL *//* deprecated version of the EFI_UNICODE_COLLATION_PROTOCOL *//* implementation of the EFI_DEVICE_PATH_UTILITIES_PROTOCOL *//* Key identifying current memory map *//* Just use the greatest cache flush alignment requirement I'm aware of *//*
 * Write an indented message with EFI prefix
 *//*
 * Call void UEFI function from u-boot:
 *//*
 * Call non-void UEFI function from u-boot and retrieve return value:
 *//*
 * Exit the u-boot world back to UEFI:
 *//*
 * Enter the u-boot world from UEFI:
 *//* Root node *//* GUID used by the root node *//* Maximum number of configuration tables *//* No need for efi loader support in SPL *//*
 *  EFI application loader
 *
 *  Copyright (c) 2016 Alexander Graf
 */<efi_api.h><part_efi.h>g1g2asciilomaximum_variable_storage_sizeremaining_variable_storage_sizemaximum_variable_sizevariable_namevariable_name_sizecapabilitiesreset_typereset_statusreset_datammio_ptrdevnrfull_pathdpidp1dp2pchandle_ptrinfo_ptrpagesoverlap_only_rammemory_map_sizememory_mapmap_keydescriptor_sizedescriptor_versionpool_typeprotocol_guidhandlerboot_policysource_buffersource_sizeloaded_image_infopktdiskidpdevname/opt/src/include/efi_selftest.hefi_selftestefi_st_get_keyefi_st_strcmp_16_8efi_st_translate_codeefi_st_translate_charefi_st_printcefi_st_exit_boot_servicesefi_unit_testefi_test_phaseEFI_EXECUTE_BEFORE_BOOTTIME_EXITEFI_SETUP_BEFORE_BOOTTIME_EXITEFI_SETUP_AFTER_BOOTTIME_EXITon_requestteardownexecuteconst efi_system_tableconst efi_system_table *setupconst efi_test_phaseEFI_UNIT_TEST(__name)ll_entry_declare(struct efi_unit_test, __name, efi_unit_test)efi_st_todo(__VA_ARGS__...)(efi_st_printc(EFI_YELLOW, "%s(%u):\nTODO: ", __FILE__, __LINE__), efi_st_printc(EFI_YELLOW, __VA_ARGS__))efi_st_error(__VA_ARGS__...)(efi_st_printc(EFI_LIGHTRED, "%s(%u):\nERROR: ", __FILE__, __LINE__), efi_st_printc(EFI_LIGHTRED, __VA_ARGS__))efi_st_printf(__VA_ARGS__...)(efi_st_printc(-1, __VA_ARGS__))EFI_ST_SUCCESS_STRL"SUCCESS"EFI_ST_FAILUREEFI_ST_SUCCESS_EFI_SELFTEST_H/* _EFI_SELFTEST_H *//* Declare a new EFI unit test *//**
 * struct efi_unit_test - EFI unit test
 *
 * An efi_unit_test provides a interface to an EFI unit test.
 *
 * @name:	name of unit test
 * @phase:	specifies when setup and execute are executed
 * @setup:	set up the unit test
 * @teardown:	tear down the unit test
 * @execute:	execute the unit test
 * @on_request:	test is only executed on request
 *//*
 * Reads an Unicode character from the input device.
 *
 * @return: Unicode character
 *//*
 * Compare an u16 string to a char string.
 *
 * @buf1:	u16 string
 * @buf2:	char string
 * @return:	0 if both buffers contain the same bytes
 *//**
 * efi_st_translate_code() - translate a scan code to a human readable string
 *
 * @code:	unicode character
 * Return:	string
 *//**
 * efi_st_translate_char() - translate a unicode character to a string
 *
 * @code:	unicode character
 * Return:	string
 *//*
 * Print a colored message
 *
 * @color	color, see constants in efi_api.h, use -1 for no color
 * @fmt		printf format
 * @...		arguments to be printed
 *		on return position of terminating zero word
 *//*
 * Exit the boot services.
 *
 * The size of the memory map is determined.
 * Pool memory is allocated to copy the memory map.
 * The memory amp is copied and the map key is obtained.
 * The map key is used to exit the boot services.
 *//*
 * A test may be setup and executed at boottime,
 * it may be setup at boottime and executed at runtime,
 * or it may be setup and executed at runtime.
 *//*
 * Prints a TODO message.
 *
 * @...	format string followed by fields to print
 *//*
 * Prints an error message.
 *
 * @...	format string followed by fields to print
 *//*
 * Prints a message.
 *//*
 *  EFI application loader
 *
 *  Copyright (c) 2017 Heinrich Schuchardt <xypron.glpk@gmx.de>
 */<efi_loader.h>buf1buf2libfdt_envUSE_HOSTCCLIBFDT_ENV_H/* LIBFDT_ENV_H *//* U-Boot: for strtoul in fdt_overlay.c *//*
 * This position of the include guard is intentional.
 * Using the same guard name as that of scripts/dtc/libfdt/libfdt_env.h
 * prevents it from being included.
 *//opt/src/include/memalign.hmalloc_cache_alignedARCH_DMA_MINALIGN(size)(typeof(size))(16)-1ALIGN(size, ARCH_DMA_MINALIGN)18446744073709551600DEFINE_CACHE_ALIGN_BUFFER(type,name,size)DEFINE_ALIGN_BUFFER(type, name, size, ARCH_DMA_MINALIGN)DEFINE_ALIGN_BUFFER(type,name,size,align)static char __ ## name[ALIGN(size * sizeof(type), align)] __aligned(align); static type *name = (type *)__ ## nameALLOC_CACHE_ALIGN_BUFFER(type,name,size)ALLOC_ALIGN_BUFFER(type, name, size, ARCH_DMA_MINALIGN)ALLOC_CACHE_ALIGN_BUFFER_PAD(type,name,size,pad)ALLOC_ALIGN_BUFFER_PAD(type, name, size, ARCH_DMA_MINALIGN, pad)ALLOC_ALIGN_BUFFER(type,name,size,align)ALLOC_ALIGN_BUFFER_PAD(type, name, size, align, 1)ALLOC_ALIGN_BUFFER_PAD(type,name,size,align,pad)char __ ## name[ROUND(PAD_SIZE((size) * sizeof(type), pad), align) + (align - 1)]; type *name = (type *)ALIGN((uintptr_t)__ ## name, align)PAD_SIZE(s,pad)(PAD_COUNT(s, pad) * pad)PAD_COUNT(s,pad)(((s) - 1) / (pad) + 1)__ALIGNMEM_H__BIGGEST_ALIGNMENT__/* __ALIGNMEM_H *//**
 * malloc_cache_aligned() - allocate a memory region aligned to cache line size
 *
 * This allocates memory at a cache-line boundary. The amount allocated may
 * be larger than requested as it is rounded up to the nearest multiple of the
 * cache-line size. This ensured that subsequent cache operations on this
 * memory (flush, invalidate) will not affect subsequently allocated regions.
 *
 * @size:	Minimum number of bytes to allocate
 *
 * @return pointer to new memory region, or NULL if there is no more memory
 * available.
 *//*
 * DEFINE_CACHE_ALIGN_BUFFER() is similar to ALLOC_CACHE_ALIGN_BUFFER, but it's
 * purpose is to allow allocating aligned buffers outside of function scope.
 * Usage of this macro shall be avoided or used with extreme care!
 *//*
 * The ALLOC_CACHE_ALIGN_BUFFER macro is used to allocate a buffer on the
 * stack that meets the minimum architecture alignment requirements for DMA.
 * Such a buffer is useful for DMA operations where flushing and invalidating
 * the cache before and after a read and/or write operation is required for
 * correct operations.
 *
 * When called the macro creates an array on the stack that is sized such
 * that:
 *
 * 1) The beginning of the array can be advanced enough to be aligned.
 *
 * 2) The size of the aligned portion of the array is a multiple of the minimum
 *    architecture alignment required for DMA.
 *
 * 3) The aligned portion contains enough space for the original number of
 *    elements requested.
 *
 * The macro then creates a pointer to the aligned portion of this array and
 * assigns to the pointer the address of the first element in the aligned
 * portion of the array.
 *
 * Calling the macro as:
 *
 *     ALLOC_CACHE_ALIGN_BUFFER(uint32_t, buffer, 1024);
 *
 * Will result in something similar to saying:
 *
 *     uint32_t    buffer[1024];
 *
 * The following differences exist:
 *
 * 1) The resulting buffer is guaranteed to be aligned to the value of
 *    ARCH_DMA_MINALIGN.
 *
 * 2) The buffer variable created by the macro is a pointer to the specified
 *    type, and NOT an array of the specified type.  This can be very important
 *    if you want the address of the buffer, which you probably do, to pass it
 *    to the DMA hardware.  The value of &buffer is different in the two cases.
 *    In the macro case it will be the address of the pointer, not the address
 *    of the space reserved for the buffer.  However, in the second case it
 *    would be the address of the buffer.  So if you are replacing hard coded
 *    stack buffers with this macro you need to make sure you remove the & from
 *    the locations where you are taking the address of the buffer.
 *
 * Note that the size parameter is the number of array elements to allocate,
 * not the number of bytes.
 *
 * This macro can not be used outside of function scope, or for the creation
 * of a function scoped static buffer.  It can not be used to create a cache
 * line aligned global buffer.
 *//*
 * ARCH_DMA_MINALIGN is defined in asm/cache.h for each architecture.  It
 * is used to align DMA buffers.
 *//*
 * Copyright (c) 2015 Google, Inc
 */<asm/cache.h>/opt/src/cmd/bootefi.cbootefiimage_tmpdo_bootefiError: Cannot initialize UEFI sub-system, r = %lu
"Error: Cannot initialize UEFI sub-system, r = %lu\n"92233720368547758089223372036854775807~EFI_ERROR_MASK9223372036854775810bootmgr"bootmgr"do_bootefi_imagesize_strfilesize"filesize"'0'image_bufimage_pathmem_handledevice_path && image_pathassert(device_path && image_path)cmd/bootefi.c422const char[17]_refi_load_image(false, efi_root, file_path, image_buf, size, &handle)efi_load_image(0, efi_root, file_path, image_buf, size, &handle)EFI_CALL(efi_load_image(false, efi_root,
				      file_path, image_buf, size, &handle))"%sEFI: Call: %s\n"__efi_nesting_inc(), "efi_load_image(false, efi_root, file_path, image_buf, size, &handle)"<memalign.h><linux/libfdt_env.h><efi_selftest.h>image_opt427%sEFI: Call: %s
efi_load_image(false, efi_root,
				      file_path, image_buf, size, &handle)char[69]__efi_exit_check()__efi_entry_check()"%sEFI: %lu returned by %s\n"__efi_nesting_dec(), (unsigned long)((uintptr_t)_r & ~EFI_ERROR_MASK), "efi_load_image(false, efi_root, file_path, image_buf, size, &handle)"%sEFI: %lu returned by %s
do_efibootmgrEFI boot manager: Cannot load any image
"EFI boot manager: Cannot load any image\n"do_bootefi_execbootargs"bootargs"efi_start_image(handle, &exit_data_size, &exit_data)__efi_nesting_inc(), "efi_start_image(handle, &exit_data_size, &exit_data)"EFI_CALL(efi_start_image(handle, &exit_data_size, &exit_data))__efi_nesting_dec(), (unsigned long)((uintptr_t)_r & ~EFI_ERROR_MASK), "efi_start_image(handle, &exit_data_size, &exit_data)"## Application terminated, r = %lu
"## Application terminated, r = %lu\n"## %ls
"## %ls\n"efi_install_fdtfdt_addrfdtcontroladdr"fdtcontroladdr"ERROR: need device tree
"ERROR: need device tree\n"9223372036854775822ERROR: invalid $fdtcontroladdr
"ERROR: invalid $fdtcontroladdr\n"9223372036854775809ERROR: invalid device tree
"ERROR: invalid device tree\n"ERROR: out of memory
"ERROR: out of memory\n"9223372036854775817lmb *imgimage_header_t *image_header *ERROR: failed to process device tree
"ERROR: failed to process device tree\n"ERROR: failed to install device tree
"ERROR: failed to install device tree\n"GENERATE_ACPI_TABLECONFIG_VAL(GENERATE_ACPI_TABLE)CONFIG_GENERATE_ACPI_TABLE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_GENERATE_ACPI_TABLE__ARG_PLACEHOLDER_CONFIG_GENERATE_ACPI_TABLE__ARG_PLACEHOLDER_CONFIG_GENERATE_ACPI_TABLE 1CONFIG_VAL(GENERATE_ACPI_TABLE_MODULE)CONFIG_GENERATE_ACPI_TABLE_MODULEGENERATE_ACPI_TABLE_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_GENERATE_ACPI_TABLE_MODULE__ARG_PLACEHOLDER_CONFIG_GENERATE_ACPI_TABLE_MODULE__ARG_PLACEHOLDER_CONFIG_GENERATE_ACPI_TABLE_MODULE 1get_config_tableefi_carve_out_dt_rsvnr_rsvsize + (addr & EFI_PAGE_MASK)size + (addr & ((1ULL << 12) - 1))efi_size_in_pages(size + (addr & EFI_PAGE_MASK))18446744073709547520~EFI_PAGE_MASKfdt_optFDT memrsv map %d: Failed to add to map
"FDT memrsv map %d: Failed to add to map\n"copy_fdtram_startfdt_ram_start1L-1Lfdt_pagesfdt_totalsize(fdt) + 0x3000(((__builtin_constant_p((__u32)((__u32)(__be32)(((const struct fdt_header *)(fdt))->totalsize))) ? ((__u32)( (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(fdt))->totalsize))) & (__u32)0x000000ffUL) << 24) | (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(fdt))->totalsize))) & (__u32)0x0000ff00UL) << 8) | (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(fdt))->totalsize))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(fdt))->totalsize))) & (__u32)0xff000000UL) >> 24) )) : __fswab32(((__u32)(__be32)(((const struct fdt_header *)(fdt))->totalsize)))))) + 0x3000((const struct fdt_header *)(fdt))->totalsize(__force __u32)(__be32)(((const struct fdt_header *)(fdt))->totalsize)(__u32)(__be32)(((const struct fdt_header *)(fdt))->totalsize)((__u32)(__be32)(((const struct fdt_header *)(fdt))->totalsize))efi_size_in_pages(fdt_totalsize(fdt) + 0x3000)12288new_fdt_addr1331691520x7f00000ERROR: Failed to reserve space for FDT
"ERROR: Failed to reserve space for FDT\n"fdt_totalsize(fdt)set_load_optionssystab.boottime->open_protocol( handle, &efi_guid_loaded_image, (void **)&loaded_image_info, efi_root, NULL, EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL)systab.boottime->open_protocol( handle, &efi_guid_loaded_image, (void **)&loaded_image_info, efi_root, ((void *)0), 0x00000001)EFI_CALL(systab.boottime->open_protocol(
					handle,
					&efi_guid_loaded_image,
					(void **)&loaded_image_info,
					efi_root, NULL,
					EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL))__efi_nesting_inc(), "systab.boottime->open_protocol( handle, &efi_guid_loaded_image, (void **)&loaded_image_info, efi_root, NULL, EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL)"fdtpenv_varsystab.boottime->open_protocol(
					handle,
					&efi_guid_loaded_image,
					(void **)&loaded_image_info,
					efi_root, NULL,
					EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL)char[147]__efi_nesting_dec(), (unsigned long)((uintptr_t)_r & ~EFI_ERROR_MASK), "systab.boottime->open_protocol( handle, &efi_guid_loaded_image, (void **)&loaded_image_info, efi_root, NULL, EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL)"envutf8_utf16_strlen(env)sizeof(u16)ERROR: Out of memory
"ERROR: Out of memory\n"systab.boottime->close_protocol(handle, &efi_guid_loaded_image, efi_root, NULL)systab.boottime->close_protocol(handle, &efi_guid_loaded_image, efi_root, ((void *)0))EFI_CALL(systab.boottime->close_protocol(handle,
							 &efi_guid_loaded_image,
							 efi_root, NULL))__efi_nesting_inc(), "systab.boottime->close_protocol(handle, &efi_guid_loaded_image, efi_root, NULL)"systab.boottime->close_protocol(handle,
							 &efi_guid_loaded_image,
							 efi_root, NULL)char[80]__efi_nesting_dec(), (unsigned long)((uintptr_t)_r & ~EFI_ERROR_MASK), "systab.boottime->close_protocol(handle, &efi_guid_loaded_image, efi_root, NULL)"&posutf8_utf16_strcpy(&pos, env)EFI_CALL(systab.boottime->close_protocol(handle,
							&efi_guid_loaded_image,
							efi_root, NULL))systab.boottime->close_protocol(handle,
							&efi_guid_loaded_image,
							efi_root, NULL)"Boots an EFI payload from memory"bootefi_help_textBoots an EFI payload from memorychar[395]U_BOOT_CMD(
	bootefi, 3, 0, do_bootefi,
	"Boots an EFI payload from memory",
	bootefi_help_text
)_u_boot_list_2_cmd_2_bootefi.u_boot_list_2_cmd_2_bootefi<image address> [fdt address]
  - boot EFI payload stored at address <image address>.
    If specified, the device tree located at <fdt address> gets
    exposed as EFI configuration table.
bootefi bootmgr [fdt address]
  - load and boot EFI payload based on BootOrder/BootXXXX variables.

    If specified, the device tree located at <fdt address> gets
    exposed as EFI configuration table.
bootefi_device_pathbootefi_image_path!CONFIG_IS_ENABLED(GENERATE_ACPI_TABLE)CONFIG_IS_ENABLED(GENERATE_ACPI_TABLE)CONFIG_CMD_BOOTEFI_HELLO/* FIXME: image should not contain device *//* efi_set_bootdev is typically called repeatedly, recover memory *//**
 * efi_set_bootdev() - set boot device
 *
 * This function is called when a file is loaded, e.g. via the 'load' command.
 * We use the path to this file to inform the UEFI binary about the boot device.
 *
 * @dev:	device, e.g. "MMC"
 * @devnr:	number of the device, e.g. "1:2"
 * @path:	path to file loaded
 *//* Initialize EFI drivers *//**
 * do_bootefi() - execute `bootefi` command
 *
 * @cmdtp:	table entry describing command
 * @flag:	bitmap indicating how the command was invoked
 * @argc:	number of arguments
 * @argv:	command line arguments
 * Return:	status code
 *//* CONFIG_CMD_BOOTEFI_SELFTEST *//* Execute the test *//**
 * do_efi_selftest() - execute EFI selftest
 *
 * Return:	status code
 *//**
 * bootefi_run_finish() - finish up after running an EFI test
 *
 * @loaded_image_info: Pointer to a struct which holds the loaded image info
 * @image_obj: Pointer to a struct which holds the loaded image object
 *//* Construct a dummy device path *//**
 * bootefi_test_prepare() - prepare to run an EFI test
 *
 * Prepare to run a test as if it were provided by a loaded image.
 *
 * @image_objp:		pointer to be set to the loaded image handle
 * @loaded_image_infop:	pointer to be set to the loaded image protocol
 * @path:		dummy file path used to construct the device path
 *			set in the loaded image protocol
 * @load_options_path:	name of a U-Boot environment variable. Its value is
 *			set as load options in the loaded image protocol.
 * Return:		status code
 *//* Transfer environment variable as load options *//*
		 * Make sure that device for device_path exist
		 * in load_image(). Otherwise, shell and grub will fail.
		 *//*
		 * Special case for efi payload not loaded from disk,
		 * such as 'bootefi hello' or for example payload
		 * loaded directly into memory via JTAG, etc:
		 *//* Check that a numeric value was passed *//**
 * do_bootefi_image() - execute EFI binary
 *
 * Set up memory image for the binary to be loaded, prepare device path, and
 * then call do_bootefi_exec() to execute it.
 *
 * @image_opt:	string of image start address
 * Return:	status code
 *//**
 * do_efibootmgr() - execute EFI boot manager
 *
 * Return:	status code
 *//*
	 * FIXME: Who is responsible for
	 *	free(loaded_image_info->load_options);
	 * Once efi_exit() is implemented correctly,
	 * handle itself doesn't exist here.
	 *//* Call our payload! *//**
 * do_bootefi_exec() - execute EFI binary
 *
 * @handle:		handle of loaded image
 * Return:		status code
 *
 * Load the EFI binary into a newly assigned memory unwinding the relocation
 * information, install the loaded image protocol, and call the binary.
 *//* GENERATE_ACPI_TABLE *//* Install device tree as UEFI table *//* Prepare device tree for payload *//* Create memory reservations as indicated by the device tree *//* Install device tree *//* Use our own device tree as default *//* Look for device tree that is already installed *//*
	 * The EBBR spec requires that we have either an FDT or an ACPI table
	 * but not both.
	 *//**
 * efi_install_fdt() - install fdt passed by a command argument
 *
 * If fdt_opt is available, the device tree located at that memory address will
 * will be installed as configuration table, otherwise the device tree located
 * at the address indicated by environment variable fdtcontroladdr will be used.
 *
 * On architectures (x86) using ACPI tables device trees shall not be installed
 * as configuration table.
 *
 * @fdt_opt:	pointer to argument
 * Return:	status code
 *//* !CONFIG_IS_ENABLED(GENERATE_ACPI_TABLE) *//**
 * get_config_table() - get configuration table
 *
 * @guid:	GUID of the configuration table
 * Return:	pointer to configuration table or NULL
 *//* Convert from sandbox address space. *//* Look for an existing entry and add it to the efi mem map. *//**
 * efi_carve_out_dt_rsv() - Carve out DT reserved memory ranges
 *
 * The mem_rsv entries of the FDT are added to the memory map. Any failures are
 * ignored because this is not critical and we would rather continue to try to
 * boot.
 *
 * @fdt: Pointer to device tree
 *//* If we can't put it there, put it somewhere *//*
	 * Safe fdt location is at 127 MiB.
	 * On the sandbox convert from the sandbox address space.
	 *//*
	 * Give us at least 12 KiB of breathing room in case the device tree
	 * needs to be expanded later.
	 *//**
 * copy_fdt() - Copy the device tree to a new location available to EFI
 *
 * The FDT is copied to a suitable location within the EFI memory map.
 * Additional 12 KiB are added to the space in case the device tree needs to be
 * expanded later with fdt_open_into().
 *
 * @fdtp:	On entry a pointer to the flattened device tree.
 *		On exit a pointer to the copy of the flattened device tree.
 *		FDT start
 * Return:	status code
 *//**
 * Set the load options of an image from an environment variable.
 *
 * @handle:	the image handle
 * @env_var:	name of the environment variable
 * Return:	status code
 *//opt/src/include/bootm.hswitch_to_non_secure_modeboard_quiesce_devicesarch_preboot_osdo_bootm_statesbootm_find_imagesbootm_disable_interruptsboot_selected_osboot_os_fn *bootm_host_load_imagesbootm_os_get_boot_funclynxkdi_bootdo_bootelfdo_bootm_vxworksboot_os_fnBOOTM_ERR_UNIMPLEMENTED(-3)BOOTM_ERR_OVERLAP(-2)BOOTM_ERR_RESET_BOOTM_Hdefined(CONFIG_FIT_SIGNATURE)/**
 * switch_to_non_secure_mode() - switch to non-secure mode
 *//*
 * boards should define this to disable devices when EFI exits from boot
 * services.
 *
 * TODO(sjg@chromium.org>): Update this to use driver model's device_remove().
 *//* This is a special function used by booti/bootz *//*
 *  Continue booting an OS image; caller already has:
 *  - copied image header to global variable `header'
 *  - checked header magic number, checksums (both header & image),
 *  - verified image architecture (PPC) and type (KERNEL or MULTI),
 *  - loaded (first part of) image to header load address,
 *  - disabled interrupts.
 *
 * @flag: Flags indicating what to do (BOOTM_STATE_...)
 * @argc: Number of arguments. Note that the arguments are shifted down
 *	 so that 0 is the first argument not processed by U-Boot, and
 *	 argc is adjusted accordingly. This avoids confusion as to how
 *	 many arguments are available for the OS.
 * @images: Pointers to os/initrd/fdt
 * @return 1 on error. On success the OS boots so this function does
 * not return.
 */statesboot_progressboot_fnfitcfg_noffset/opt/src/include/env_attr.henv_attrenv_attr_lookupenv_attr_walkENV_ATTR_SEPENV_ATTR_LIST_DELIM','__ENV_ATTR_H__/* __ENV_ATTR_H__ *//*
 * env_attr_lookup takes as input an "attr_list" with the same form as above.
 * It also takes as input a "name" to look for.
 * If the name is found in the list, it's value is copied into "attributes".
 * There is no protection on attributes being too small for the value.
 * It returns -1 if attributes is NULL, 1 if "name" is not found, 2 if
 * "attr_list" is NULL.
 * Returns 0 on success.
 *//*
 * env_attr_walk takes as input an "attr_list" that takes the form:
 *	attributes = [^,:\s]*
 *	entry = name[:attributes]
 *	list = entry[,list]
 * It will call the "callback" function with the "name" and "attributes"
 * The callback may return a non-0 to abort the list walk.
 * This return value will be passed through to the caller.
 * 0 is returned on success.
 *//*
 * (C) Copyright 2012
 * Joe Hershberger, National Instruments, joe.hershberger@ni.com
 */attr_list/opt/src/include/search.hhwalk_rhsearch_data *ENTRY *entry *himport_rhexport_rhdelete_rhmatch_rENTRY **entry **hsearch_rhdestroy_rhcreate_rhsearch_data_ENTRYENTRYACTIONFINDENTERenv_openv_op_createenv_op_deleteenv_op_overwriteconst ENTRYconst ENTRY *change_okfilled_ENTRY *H_ORIGIN_FLAGS(H_INTERACTIVE | H_PROGRAMMATIC)H_PROGRAMMATICH_MATCH_METHOD(H_MATCH_IDENT | H_MATCH_SUBSTR | H_MATCH_REGEX)H_MATCH_REGEXH_MATCH_SUBSTRH_MATCH_IDENTH_MATCH_BOTH(H_MATCH_KEY | H_MATCH_DATA)H_MATCH_DATAH_MATCH_KEYH_HIDE_DOTH_INTERACTIVEH_FORCEH_NOCLEAR__set_errno(val)do { errno = val; } while (0)_SEARCH_H_/* _SEARCH_H_ *//* indicate that an import is from env_set() *//* search for regular expression matches    *//* search for substring matches	     *//* search for indentical strings	     *//* search/grep both     *//* search/grep data = variable values	     *//* search/grep key  = variable names	     *//* don't print env vars that begin with '.' *//* indicate that an import is user directed *//* overwrite read-only/write-once variables *//* do not clear hash table before importing *//* Flags for himport_r(), hexport_r(), hdelete_r(), and hsearch_r() *//* Walk the whole table calling the callback on each element *//*
 * nvars: length of vars array
 * vars: array of strings (variable names) to import (nvars == 0 means all)
 *//* Search and delete entry matching "__key" in internal hash table. *//*
 * Search for an entry matching "__match".  Otherwise, Same semantics
 * as hsearch_r().
 *//*
 * Search for entry matching __item.key in internal hash table.  If
 * ACTION is `FIND' return found entry or signal error by returning
 * NULL.  If ACTION is `ENTER' replace existing data (if any) with
 * __item.data.
 * *//* Destroy current internal hash table.  *//* Create a new hash table which will contain at most "__nel" elements.  *//*
 * Callback function which will check whether the given change for variable
 * "__item" to "newval" may be applied or not, and possibly apply such change.
 * When (flag & H_FORCE) is set, it shall not print out any error message and
 * shall force overwriting of write-once variables.
 * Must return 0 for approval, 1 for denial.
 *//* Data type for reentrant functions.  *//*
 * Family of hash table handling functions.  The functions also
 * have reentrant counterparts ending with _r.  The non-reentrant
 * functions all work on a single internal hash table.
 *//* Opaque type for internal use.  *//* Action which shall be performed in the call to hsearch.  *//*
 * Based on code from uClibc-0.9.30.3
 * Extensions for use within U-Boot
 * Copyright (C) 2010-2013 Wolfgang Denk <wd@denx.de>
 *//*
 * Declarations for System V style searching functions.
 * Copyright (C) 1995-1999, 2000 Free Software Foundation, Inc.
 * This file is part of the GNU C Library.
 *//* SPDX-License-Identifier: LGPL-2.1+ */__htab__sep__crlf_is_lfnvarsvars__resp__match__last_idx__retval__item__nel/opt/src/include/env_flags.henv_flagsenv_flags_validateenv_flags_initeth_validate_ethaddr_strenv_flags_parse_varaccess_from_binflagsenv_flags_parse_varaccessenv_flags_parse_vartypeenv_flags_get_varaccess_nameenv_flags_get_vartype_nameenv_flags_print_varaccessenv_flags_print_vartypesenv_flags_varaccessenv_flags_varaccess_anyenv_flags_varaccess_readonlyenv_flags_varaccess_writeonceenv_flags_varaccess_changedefaultenv_flags_varaccess_endenv_flags_vartypeenv_flags_vartype_stringenv_flags_vartype_decimalenv_flags_vartype_hexenv_flags_vartype_boolenv_flags_vartype_ipaddrenv_flags_vartype_macaddrenv_flags_vartype_endENV_FLAGS_VARACCESS_BIN_MASK0x00000078ENV_FLAGS_VARACCESS_PREVENT_NONDEF_OVERWRENV_FLAGS_VARACCESS_PREVENT_OVERWRENV_FLAGS_VARACCESS_PREVENT_CREATEENV_FLAGS_VARACCESS_PREVENT_DELETEENV_FLAGS_VARTYPE_BIN_MASKENV_FLAGS_LIST_STATICETHADDR_FLAGS NET_FLAGS SERIAL_FLAGS CONFIG_ENV_FLAGS_LIST_STATICSERIAL_FLAGS"serial#:so,"NET_FLAGS"ipaddr:i," "gatewayip:i," "netmask:i," "serverip:i," "nvlan:d," "vlan:d," "dnsip:i,"ETHADDR_FLAGS"eth" ETHADDR_WILDCARD "addr:mo,"ETHADDR_WILDCARD"\\d*"CONFIG_ENV_FLAGS_LIST_STATICENV_FLAGS_VARACCESS_LOCENV_FLAGS_VARTYPE_LOCENV_FLAGS_ATTR_MAX_LENENV_FLAGS_VAR".flags"__ENV_FLAGS_H__CONFIG_CMD_NETCONFIG_REGEXCONFIG_ENV_OVERWRITECONFIG_OVERWRITE_ETHADDR_ONCECONFIG_CMD_ENV_FLAGS/* __ENV_FLAGS_H__ *//* The actual variable type values use the enum value (within the mask) *//*
 * These are the binary flags used in the environment entry->flags variable to
 * decribe properties of veriables in the table
 *//* USE_HOSTCC *//*
 * Validate the newval for to conform with the requirements defined by its flags
 *//*
 * When adding a variable to the environment, initialize the flags for that
 * variable.
 *//* !USE_HOSTCC *//*
 * Validate the parameters passed to "env set" for type compliance
 *//*
 * Validate that the proposed access to variable "name" is valid according to
 * the defined flags for that variable, if any.
 *//*
 * Validate the newval for its access to conform with the requirements defined
 * by its flags (directly looked at the .flags var).
 *//*
 * Validate the newval for its type to conform with the requirements defined by
 * its flags (directly looked at the .flags var).
 *//*
 * Look up the access of a variable directly from the .flags var.
 *//*
 * Look up the type of a variable directly from the .flags var.
 *//*
 * Check if a string has the format of an Ethernet MAC address
 *//*
 * Parse the binary flags from a hash table entry into the varaccess enum.
 *//*
 * Parse the flags string from a .flags attribute list into the varaccess enum.
 *//*
 * Parse the flags string from a .flags attribute list into the vartype enum.
 *//*
 * Return the name of the access.
 *//*
 * Return the name of the type.
 *//*
 * Print the whole list of available access flags.
 *//*
 * Print the whole list of available type flags.
 */<search.h>newvalvar_entrybinflags/opt/src/include/env_callback.henv_callbackenv_callback_initenv_clbk_tblU_BOOT_ENV_CALLBACK(name,callback)ll_entry_declare(struct env_clbk_tbl, name, env_clbk) = {#name, callback}ENV_CALLBACK_LIST_STATICENV_DOT_ESCAPE ENV_CALLBACK_VAR ":callbacks," ENV_DOT_ESCAPE ENV_FLAGS_VAR ":flags," "baudrate:baudrate," NET_CALLBACKS "loadaddr:loadaddr," SILENT_CALLBACK SPLASHIMAGE_CALLBACK "stdin:console,stdout:console,stderr:console," "serial#:serialno," CONFIG_ENV_CALLBACK_LIST_STATICNET_CALLBACKS"bootfile:bootfile," "ipaddr:ipaddr," "gatewayip:gatewayip," "netmask:netmask," "serverip:serverip," "nvlan:nvlan," "vlan:vlan," DNS_CALLBACK "eth" ETHADDR_WILDCARD "addr:ethaddr,"DNS_CALLBACK"dnsip:dnsip,"ENV_DOT_ESCAPE"\\"SPLASHIMAGE_CALLBACKSILENT_CALLBACK"silent:silent,"CONFIG_ENV_CALLBACK_LIST_STATICENV_CALLBACK_VAR".callbacks"__ENV_CALLBACK_H__CONFIG_SILENT_CONSOLECONFIG_SPLASHIMAGE_GUARDCONFIG_CMD_DNS/* __ENV_CALLBACK_H__ *//*
 * Define a callback that can be associated with variables.
 * when associated through the ".callbacks" environment variable, the callback
 * will be executed any time the variable is inserted, overwritten, or deleted.
 *//* Callback name *//*
 * This list of callback bindings is static, but may be overridden by defining
 * a new association in the ".callbacks" environment variable.
 *//* Board configs can define additional static callback bindings */<env_flags.h>/opt/src/include/environment.henvironmenteth_env_set_enetaddreth_env_get_enetaddreth_parse_enetaddrenv_fix_driversenv_eraseenv_saveenv_loadenv_get_charenv_exportenv_t *environment_s *env_importset_default_varsset_default_envenv_get_defaultenv_crc_updateenv_driverenv_operationENVOP_GET_CHARENVOP_INITENVOP_LOADENVOP_SAVEENVOP_ERASEenv_locationENVL_UNKNOWNENVL_EEPROMENVL_EXT4ENVL_FATENVL_FLASHENVL_MMCENVL_NANDENVL_NVRAMENVL_ONENANDENVL_REMOTEENVL_SPI_FLASHENVL_UBIENVL_NOWHEREENVL_COUNTENV_INVALIDENV_VALIDENV_REDUNDenv_tenvironment_sloadunsigned char[8188]ENV_SIZE8188crcconst unsigned char[]env_save_ptr(x)ENV_NAME(_name).name = _name,U_BOOT_ENV_LOCATION(__name)ll_entry_declare(struct env_driver, __name, env_driver)(CONFIG_ENV_SIZE - ENV_HEADER_SIZE)ENV_HEADER_SIZE(sizeof(uint32_t))_ENVIRONMENT_H_defined(CONFIG_ENV_IS_IN_FLASH)CONFIG_ENV_ADDRCONFIG_ENV_OFFSET!defined(CONFIG_ENV_ADDR_REDUND) && defined(CONFIG_ENV_OFFSET_REDUND)defined(CONFIG_ENV_SECT_SIZE) || defined(CONFIG_ENV_SIZE)CONFIG_ENV_SECT_SIZECONFIG_ENV_SIZEdefined(CONFIG_ENV_ADDR_REDUND) && !defined(CONFIG_ENV_SIZE_REDUND)(CONFIG_ENV_ADDR >= CONFIG_SYS_MONITOR_BASE) &&		\defined(CONFIG_ENV_ADDR_REDUND) || defined(CONFIG_ENV_OFFSET_REDUND)CONFIG_ENV_IS_EMBEDDEDdefined(CONFIG_ENV_IS_IN_MMC)CONFIG_ENV_OFFSET_REDUNDdefined(CONFIG_ENV_IS_IN_NAND)defined(CONFIG_ENV_OFFSET_OOB)defined(CONFIG_ENV_IS_IN_UBI)CONFIG_ENV_UBI_PARTCONFIG_ENV_UBI_VOLUMEdefined(CONFIG_ENV_UBI_VOLUME_REDUND)CONFIG_CMD_UBI!defined(CONFIG_ENV_IS_IN_FLASH)	&& \defined(CONFIG_ENV_IS_EMBEDDED) && !defined(ENV_IS_EMBEDDED)ENV_IS_EMBEDDEDCONFIG_SYS_REDUNDAND_ENVIRONMENTdefined(CONFIG_NEEDS_MANUAL_RELOC)CONFIG_CMD_SAVEENVenv_htabdefault_environment/* _ENVIRONMENT_H_ *//* DO_DEPS_ONLY *//**
 * env_fix_drivers() - Updates envdriver as per relocation
 *//**
 * env_erase() - Erase the environment on storage
 *
 * @return 0 if OK, -ve on error
 *//**
 * env_save() - Save the environment to storage
 *
 * @return 0 if OK, -ve on error
 *//**
 * env_load() - Load the environment from storage
 *
 * @return 0 if OK, -ve on error
 *//**
 * env_get_char() - Get a character from the early environment
 *
 * This reads from the pre-relocation environment
 *
 * @index: Index of character to read (0 = first)
 * @return character read, or -ve on error
 *//* Select and import one of two redundant environments *//* Export from hash table into binary representation *//* Import from binary representation into hash table *//* [re]set individual variables to their value in the default environment *//* [re]set to the default environment *//* Look up the variable from the default environment *//* Function that updates CRC of the enironment *//* Declare the name of a location *//* Declare a new environment location driver *//**
	 * init() - Set up the initial pre-relocation environment
	 *
	 * This method is optional.
	 *
	 * @return 0 if OK, -ENOENT if no initial environment could be found,
	 * other -ve on error
	 *//**
	 * erase() - Erase the environment on storage
	 *
	 * This method is optional and required for 'eraseenv' to work.
	 *
	 * @return 0 if OK, -ve on error
	 *//**
	 * save() - Save the environment to storage
	 *
	 * This method is required for 'saveenv' to work.
	 *
	 * @return 0 if OK, -ve on error
	 *//**
	 * load() - Load the environment from storage
	 *
	 * This method is optional. If not provided, no environment will be
	 * loaded.
	 *
	 * @return 0 if OK, -ve on error
	 *//* we want to call the erase function *//* we want to call the save function *//* we want to call the load function *//* we want to call the init function *//* we want to call the get_char function *//* value for the various operations we want to perform on the env *//* Redundant environment is valid *//* First or only environment is valid *//* No valid environment *//* Value for environment validity *//* ENV_IS_EMBEDDED *//* Environment data		*//* active/obsolete flags	*//* CRC32 over data bytes	*//* The build system likes to know if the env is embedded *//*
 * For the flash types where embedded env is supported, but it cannot be
 * calculated automatically (i.e. NAND), take the board opt-in.
 *//* Embedded env is only supported for some flash types *//* CONFIG_ENV_IS_IN_UBI *//* CONFIG_ENV_IS_IN_NAND *//* CONFIG_ENV_OFFSET_OOB *//* CONFIG_ENV_IS_IN_FLASH *//**************************************************************************
 *
 * The "environment" is stored as a list of '\0' terminated
 * "name=value" strings. The end of the list is marked by a double
 * '\0'. New entries are always added at the end. Deleting an entry
 * shifts the remaining entries to the front. Replacing an entry is a
 * combination of deleting the old value and adding the new one.
 *
 * The environment is preceded by a 32 bit CRC over the data part.
 *
 *************************************************************************//*
 * (C) Copyright 2002
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 */<env_callback.h><env_attr.h>"compiler.h"<linux/kconfig.h>enetaddrenv_out/opt/src/include/mtd/mtd-abi.hmtd-abimtd_type_is_nand_userconst mtd_info_userconst mtd_info_user *mtd_info_user *MTD_NANDFLASHMTD_MLCNANDFLASHmtd_file_modesMTD_FILE_MODE_NORMALMTD_OTP_OFFMTD_FILE_MODE_OTP_FACTORYMTD_OTP_FACTORYMTD_FILE_MODE_OTP_USERMTD_OTP_USERMTD_FILE_MODE_RAWmtd_ecc_statsnand_ecclayout_usernand_oobfreenand_oobinfootp_inforegion_info_usermtd_info_usermtd_write_reqMTD_OPS_PLACE_OOBMTD_OPS_AUTO_OOBMTD_OPS_RAWmtd_oob_buf64mtd_oob_buferase_info_user64erase_info_userbbtblocksbadblocksfailedcorrectednand_oobfree[8]MTD_MAX_OOBFREE_ENTRIESoobfreeoobavail__u32[64]unsigned int[64]MTD_MAX_ECCPOS_ENTRIESeccposeccbytes__u32[32]__u32[2]__u32[8][2]unsigned int[8][2]useeccregionindexnumblockserasesizeoobsizewritesize__u8[7]unsigned char[7]usr_oobusr_dataooblenusr_ptrMEMWRITE_IOWR('M', 24, struct mtd_write_req)MEMISLOCKED_IOR('M', 23, struct erase_info_user)MEMREADOOB64_IOWR('M', 22, struct mtd_oob_buf64)MEMWRITEOOB64_IOWR('M', 21, struct mtd_oob_buf64)MEMERASE64_IOW('M', 20, struct erase_info_user64)MTDFILEMODE_IO('M', 19)ECCGETSTATS_IOR('M', 18, struct mtd_ecc_stats)ECCGETLAYOUT_IOR('M', 17, struct nand_ecclayout_user)OTPLOCK_IOR('M', 16, struct otp_info)OTPGETREGIONINFO_IOW('M', 15, struct otp_info)OTPGETREGIONCOUNT_IOW('M', 14, int)OTPSELECT_IOR('M', 13, int)MEMSETBADBLOCK_IOW('M', 12, __kernel_loff_t)MEMGETBADBLOCK_IOW('M', 11, __kernel_loff_t)MEMGETOOBSEL_IOR('M', 10, struct nand_oobinfo)MEMGETREGIONINFO_IOWR('M', 8, struct region_info_user)MEMGETREGIONCOUNT_IOR('M', 7, int)MEMUNLOCK_IOW('M', 6, struct erase_info_user)MEMLOCK_IOW('M', 5, struct erase_info_user)MEMREADOOB_IOWR('M', 4, struct mtd_oob_buf)MEMWRITEOOB_IOWR('M', 3, struct mtd_oob_buf)MEMERASE_IOW('M', 2, struct erase_info_user)MEMGETINFO_IOR('M', 1, struct mtd_info_user)MTD_NANDECC_AUTOPL_USRMTD_NANDECC_PLACEONLYMTD_NANDECC_AUTOPLACEMTD_NANDECC_PLACEMTD_NANDECC_OFFMTD_CAP_NANDFLASH(MTD_WRITEABLE)MTD_CAP_NORFLASH(MTD_WRITEABLE | MTD_BIT_WRITEABLE)MTD_CAP_RAM(MTD_WRITEABLE | MTD_BIT_WRITEABLE | MTD_NO_ERASE)MTD_CAP_ROMMTD_POWERUP_LOCKMTD_NO_ERASEMTD_BIT_WRITEABLEMTD_WRITEABLEMTD_UBIVOLUMEMTD_DATAFLASHMTD_NORFLASHMTD_ROMMTD_RAMMTD_ABSENT__MTD_ABI_H____UBOOT__/* __MTD_ABI_H__ *//*
 * MTD file modes - for read/write access to MTD
 *
 * @MTD_FILE_MODE_NORMAL:	OTP disabled, ECC enabled
 * @MTD_FILE_MODE_OTP_FACTORY:	OTP enabled in factory mode
 * @MTD_FILE_MODE_OTP_USER:	OTP enabled in user mode
 * @MTD_FILE_MODE_RAW:		OTP disabled, ECC disabled
 *
 * These modes can be set via ioctl(MTDFILEMODE). The mode mode will be retained
 * separately for each open file descriptor.
 *
 * Note: %MTD_FILE_MODE_RAW provides the same functionality as %MTD_OPS_RAW -
 * raw access to the flash, without error correction or autoplacement schemes.
 * Wherever possible, the MTD_OPS_* mode will override the MTD_FILE_MODE_* mode
 * (e.g., when using ioctl(MEMWRITE)), but in some cases, the MTD_FILE_MODE is
 * used out of necessity (e.g., `write()', ioctl(MEMWRITEOOB64)).
 *//**
 * struct mtd_ecc_stats - error correction stats
 *
 * @corrected:	number of corrected bits
 * @failed:	number of uncorrectable errors
 * @badblocks:	number of bad blocks in this partition
 * @bbtblocks:	number of blocks reserved for bad block tables
 *//*
 * OBSOLETE: ECC layout control structure. Exported to user-space via ioctl
 * ECCGETLAYOUT for backwards compatbility and should not be mistaken as a
 * complete set of ECC information. The ioctl truncates the larger internal
 * structure to retain binary compatibility with the static declaration of the
 * ioctl. Note that the "MTD_MAX_..._ENTRIES" macros represent the max size of
 * the user struct, not the MAX size of the internal struct nand_ecclayout.
 *//*
 * Obsolete legacy interface. Keep it in order not to break userspace
 * interfaces
 *//*
 * Most generic write interface; can write in-band and/or out-of-band in various
 * modes (see "struct mtd_write_req"). This ioctl is not supported for flashes
 * without OOB, e.g., NOR flash.
 *//* Check if chip is locked (for MTD that supports it) *//* Read data from OOB (64-bit version) *//* Write data to OOB (64-bit version) *//* Erase segment of MTD (supports 64-bit address) *//* Set MTD mode on a per-file-descriptor basis (see "MTD file modes") *//* Get statistics about corrected/uncorrected errors *//* Get ECC layout (deprecated) *//* Lock a given range of user data (must be in mode %MTD_FILE_MODE_OTP_USER) *//* Get all OTP (One-Time Programmable) info about MTD *//* Get number of OTP (One-Time Programmable) regions *//* Set OTP (One-Time Programmable) mode (factory vs. user) *//* Mark an eraseblock as bad *//* Check if an eraseblock is bad *//* Get info about OOB modes (e.g., RAW, PLACE, AUTO) - legacy interface *//* Get information about the erase region for a specific index *//* Get the number of different erase regions *//* Unlock a chip (for MTD that supports it) *//* Lock a chip (for MTD that supports it) *//* Read out-of-band data from MTD *//* Write out-of-band data from MTD *//* Erase segment of MTD *//* Get basic MTD characteristics info (better to use sysfs) *//*
 * Note, the following ioctl existed in the past and was removed:
 * #define MEMSETOOBSEL           _IOW('M', 9, struct nand_oobinfo)
 * Try to avoid adding a new ioctl with the same ioctl number.
 *//* Number of blocks in this region *//* For this region *//* At which this region starts,
				 * from the beginning of the MTD *//* Old obsolete field; do not use *//* Amount of OOB data per block (e.g. 16) *//* Total size of the MTD *//* OTP mode selection */// Use the given autoplacement scheme rather than using the default// Use the given placement in the structure (Do not store ecc result on read)// Use the default placement scheme// Use the given placement in the structure (YAFFS1 legacy mode)// Switch off ECC (Not recommended)/* Obsolete ECC byte placement modes (used with obsolete MEMGETOOBSEL) *//* Some common devices / combinations of capabilities *//* Always locked after reset *//* No erase necessary *//* Single bits can be flipped *//* Device is writeable *//* MLC NAND (including TLC) *//* SLC NAND *//**
 * struct mtd_write_req - data structure for requesting a write operation
 *
 * @start:	start address
 * @len:	length of data buffer
 * @ooblen:	length of OOB buffer
 * @usr_data:	user-provided data buffer
 * @usr_oob:	user-provided OOB buffer
 * @mode:	MTD mode (see "MTD operation modes")
 * @padding:	reserved, must be set to 0
 *
 * This structure supports ioctl(MEMWRITE) operations, allowing data and/or OOB
 * writes in various modes. To write to OOB-only, set @usr_data == NULL, and to
 * write data-only, set @usr_oob == NULL. However, setting both @usr_data and
 * @usr_oob to NULL is not allowed.
 *//**
 * MTD operation modes
 *
 * @MTD_OPS_PLACE_OOB:	OOB data are placed at the given offset (default)
 * @MTD_OPS_AUTO_OOB:	OOB data are automatically placed at the free areas
 *			which are defined by the internal ecclayout
 * @MTD_OPS_RAW:	data are transferred as-is, with no error correction;
 *			this mode implies %MTD_OPS_PLACE_OOB
 *
 * These modes can be passed to ioctl(MEMWRITE) and are also used internally.
 * See notes on "MTD file modes" for discussion on %MTD_OPS_RAW vs.
 * %MTD_FILE_MODE_RAW.
 *//*
 * Copyright  1999-2010 David Woodhouse <dwmw2@infradead.org> et al.
 *
 *//opt/src/include/mtdmtd/opt/src/include/linux/log2.hlog2__order_base_2n - 1ilog2(n - 1)461168601842738790423058430092136939521152921504606846976576460752303423488288230376151711744144115188075855872720575940379279363602879701896396818014398509481984900719925474099245035996273704962251799813685248112589990684262456294995342131228147497671065614073748835532870368744177664351843720888321759218604441687960930222084398046511104219902325555210995116277765497558138882748779069441374389534726871947673634359738368171798691848589934592429496729621474836488388608419430420971521048576__rounddown_pow_of_two__roundup_pow_of_twois_power_of_2__ilog2_u64__ilog2_u32order_base_2(n)( __builtin_constant_p(n) ? ( ((n) == 0 || (n) == 1) ? 0 : ilog2((n) - 1) + 1) : __order_base_2(n) )rounddown_pow_of_two(n)( __builtin_constant_p(n) ? ( (1UL << ilog2(n))) : __rounddown_pow_of_two(n) )roundup_pow_of_two(n)( __builtin_constant_p(n) ? ( (n == 1) ? 1 : (1UL << (ilog2((n) - 1) + 1)) ) : __roundup_pow_of_two(n) )ilog2(n)( __builtin_constant_p(n) ? ( (n) < 2 ? 0 : (n) & (1ULL << 63) ? 63 : (n) & (1ULL << 62) ? 62 : (n) & (1ULL << 61) ? 61 : (n) & (1ULL << 60) ? 60 : (n) & (1ULL << 59) ? 59 : (n) & (1ULL << 58) ? 58 : (n) & (1ULL << 57) ? 57 : (n) & (1ULL << 56) ? 56 : (n) & (1ULL << 55) ? 55 : (n) & (1ULL << 54) ? 54 : (n) & (1ULL << 53) ? 53 : (n) & (1ULL << 52) ? 52 : (n) & (1ULL << 51) ? 51 : (n) & (1ULL << 50) ? 50 : (n) & (1ULL << 49) ? 49 : (n) & (1ULL << 48) ? 48 : (n) & (1ULL << 47) ? 47 : (n) & (1ULL << 46) ? 46 : (n) & (1ULL << 45) ? 45 : (n) & (1ULL << 44) ? 44 : (n) & (1ULL << 43) ? 43 : (n) & (1ULL << 42) ? 42 : (n) & (1ULL << 41) ? 41 : (n) & (1ULL << 40) ? 40 : (n) & (1ULL << 39) ? 39 : (n) & (1ULL << 38) ? 38 : (n) & (1ULL << 37) ? 37 : (n) & (1ULL << 36) ? 36 : (n) & (1ULL << 35) ? 35 : (n) & (1ULL << 34) ? 34 : (n) & (1ULL << 33) ? 33 : (n) & (1ULL << 32) ? 32 : (n) & (1ULL << 31) ? 31 : (n) & (1ULL << 30) ? 30 : (n) & (1ULL << 29) ? 29 : (n) & (1ULL << 28) ? 28 : (n) & (1ULL << 27) ? 27 : (n) & (1ULL << 26) ? 26 : (n) & (1ULL << 25) ? 25 : (n) & (1ULL << 24) ? 24 : (n) & (1ULL << 23) ? 23 : (n) & (1ULL << 22) ? 22 : (n) & (1ULL << 21) ? 21 : (n) & (1ULL << 20) ? 20 : (n) & (1ULL << 19) ? 19 : (n) & (1ULL << 18) ? 18 : (n) & (1ULL << 17) ? 17 : (n) & (1ULL << 16) ? 16 : (n) & (1ULL << 15) ? 15 : (n) & (1ULL << 14) ? 14 : (n) & (1ULL << 13) ? 13 : (n) & (1ULL << 12) ? 12 : (n) & (1ULL << 11) ? 11 : (n) & (1ULL << 10) ? 10 : (n) & (1ULL << 9) ? 9 : (n) & (1ULL << 8) ? 8 : (n) & (1ULL << 7) ? 7 : (n) & (1ULL << 6) ? 6 : (n) & (1ULL << 5) ? 5 : (n) & (1ULL << 4) ? 4 : (n) & (1ULL << 3) ? 3 : (n) & (1ULL << 2) ? 2 : 1) : (sizeof(n) <= 4) ? __ilog2_u32(n) : __ilog2_u64(n) )_LINUX_LOG2_HCONFIG_ARCH_HAS_ILOG2_U32CONFIG_ARCH_HAS_ILOG2_U64/* _LINUX_LOG2_H *//**
 * order_base_2 - calculate the (rounded up) base 2 order of the argument
 * @n: parameter
 *
 * The first few values calculated by this routine:
 *  ob2(0) = 0
 *  ob2(1) = 0
 *  ob2(2) = 1
 *  ob2(3) = 2
 *  ob2(4) = 2
 *  ob2(5) = 3
 *  ... and so on.
 *//**
 * rounddown_pow_of_two - round the given value down to nearest power of two
 * @n: parameter
 *
 * round the given value down to the nearest power of two
 * - the result is undefined when n == 0
 * - this can be used to initialise global variables from constant data
 *//**
 * roundup_pow_of_two - round the given value up to nearest power of two
 * @n: parameter
 *
 * round the given value up to the nearest power of two
 * - the result is undefined when n == 0
 * - this can be used to initialise global variables from constant data
 *//**
 * ilog2 - log base 2 of 32-bit or a 64-bit unsigned value
 * @n: parameter
 *
 * constant-capable log of base 2 calculation
 * - this can be used to initialise global variables from constant data, hence
 * the massive ternary operator construction
 *
 * selects the appropriately-sized optimised version depending on sizeof(n)
 *//**
 * __rounddown_pow_of_two() - round down to nearest power of two
 * @n: value to round down
 *//**
 * __roundup_pow_of_two() - round up to nearest power of two
 * @n: value to round up
 *//**
 * is_power_of_2() - check if a value is a power of two
 * @n: the value to check
 *
 * Determine whether some value is a power of two, where zero is
 * *not* considered a power of two.
 * Return: true if @n is a power of 2, otherwise false.
 *//*
 * non-constant log of base 2 calculators
 * - the arch may override these in asm/bitops.h if they can be implemented
 *   more efficiently than using fls() and fls64()
 * - the arch is not required to handle n==0 if implementing the fallback
 *//* Integer base 2 logarithm calculation
 *
 * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.
 * Written by David Howells (dhowells@redhat.com)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 *//opt/src/include/div64.hdiv64divisordo_div(__res, divisor)<linux/log2.h>__res_lo__n_lo___res___x___t___m___n___p___bias4294967295___bitsconst u64((__res) >> 32) == 0__div64_32__arch_xprod_64m_lon_lo1ULL1ULL << 63(1ULL << 63)1ULL << 31(1ULL << 31)9223372039002259456(1ULL << 63) | (1ULL << 31)((1ULL << 63) | (1ULL << 31))tmp1ULL << 32(1ULL << 32)n_him_hido_div(n,base)({ u32 __base = (base); u32 __rem; (void)(((typeof((n)) *)0) == ((u64 *)0)); if (__builtin_constant_p(__base) && is_power_of_2(__base)) { __rem = (n) & (__base - 1); (n) >>= ilog2(__base); } else if (__div64_const32_is_OK && __builtin_constant_p(__base) && __base != 0) { u32 __res_lo, __n_lo = (n); (n) = __div64_const32(n, __base); __res_lo = (n); __rem = __n_lo - __res_lo * __base; } else if (likely(((n) >> 32) == 0)) { __rem = (u32)(n) % __base; (n) = (u32)(n) / __base; } else __rem = __div64_32(&(n), __base); __rem; })__div64_const32(n,___b)({ u64 ___res, ___x, ___t, ___m, ___n = (n); u32 ___p, ___bias; ___p = 1 << ilog2(___b); ___m = (~0ULL / ___b) * ___p; ___m += (((~0ULL % ___b + 1) * ___p) + ___b - 1) / ___b; ___x = ~0ULL / ___b * ___b - 1; ___res = ((___m & 0xffffffff) * (___x & 0xffffffff)) >> 32; ___t = ___res += (___m & 0xffffffff) * (___x >> 32); ___res += (___x & 0xffffffff) * (___m >> 32); ___t = (___res < ___t) ? (1ULL << 32) : 0; ___res = (___res >> 32) + ___t; ___res += (___m >> 32) * (___x >> 32); ___res /= ___p; if (~0ULL % (___b / (___b & -___b)) == 0) { ___n /= (___b & -___b); ___m = ~0ULL / (___b / (___b & -___b)); ___p = 1; ___bias = 1; } else if (___res != ___x / ___b) { ___bias = 1; ___m = (~0ULL / ___b) * ___p; ___m += ((~0ULL % ___b + 1) * ___p) / ___b; } else { u32 ___bits = -(___m & -___m); ___bits |= ___m >> 32; ___bits = (~___bits) << 1; if (!___bits) { ___p /= (___m & -___m); ___m /= (___m & -___m); } else { ___p >>= ilog2(___bits); ___m >>= ilog2(___bits); } ___bias = 0; } ___res = __arch_xprod_64(___m, ___n, ___bias); ___res /= ___p; })__div64_const32_is_OK(__GNUC__ >= 4)_ASM_GENERIC_DIV64_HBITS_PER_LONG == 64BITS_PER_LONG == 32/* _ASM_GENERIC_DIV64_H *//* Wrapper for do_div(). Doesn't modify dividend and returns
 * the result, not remainder.
 *//* BITS_PER_LONG *//* BITS_PER_LONG == ?? *//* the remainder can be computed with 32-bit regs *//* The unnecessary pointer compare is there
 * to check for type safety (n must be 64bit)
 *//* there can't be any overflow here *//*
 * Default C implementation for __arch_xprod_64()
 *
 * Prototype: u64 __arch_xprod_64(const u64 m, u64 n, bool bias)
 * Semantic:  retval = ((bias ? m : 0) + m * n) >> 64
 *
 * The product is a 128-bit value, scaled down to 64 bits.
 * Assuming constant propagation to optimize away unused conditional code.
 * Architectures may provide their own optimized assembly implementation.
 *//*								\
	 * Now we have a combination of 2 conditions:			\
	 *								\
	 * 1) whether or not we need to apply a bias, and		\
	 *								\
	 * 2) whether or not there might be an overflow in the cross	\
	 *    product determined by (___m & ((1 << 63) | (1 << 31))).	\
	 *								\
	 * Select the best way to do (m_bias + m * n) / (1 << 64).	\
	 * From now on there will be actual runtime code generated.	\
	 *//* No bias needed. *//*							\
		 * If ___bits == 0 then setting bit 31 is  unavoidable.	\
		 * Simply apply the maximum possible reduction in that	\
		 * case. Otherwise the MSB of ___bits indicates the	\
		 * best reduction we should apply.			\
		 *//*							\
		 * Reduce m / p, and try to clear bit 31 of m when	\
		 * possible, otherwise that'll need extra overflow	\
		 * handling later.					\
		 *//* Compute m = (p << 64) / b *//*							\
		 * We can't get away without a bias to compensate	\
		 * for bit truncation errors.  To avoid it we'd need an	\
		 * additional bit to represent m which would overflow	\
		 * a 64-bit variable.					\
		 *							\
		 * Instead we do m = p / b and n / b = (n * m + m) / p.	\
		 *//* special case, can be simplified to ... *//* Now sanitize and optimize what we've got. *//* test our ___m with res = m * x / (p << 64) *//* one less than the dividend with highest result *//* compute m = ((p << 64) + b - 1) / b *//* determine MSB of b *//*								\
	 * Multiplication by reciprocal of b: n / b = n * (p / b) / p	\
	 *								\
	 * We rely on the fact that most of this code gets optimized	\
	 * away at compile time due to constant propagation and only	\
	 * a few multiplication instructions should remain.		\
	 * Hence this monstrous macro (static inline doesn't always	\
	 * do the trick here).						\
	 *//*
 * If the divisor happens to be constant, we determine the appropriate
 * inverse at compile time to turn the division into a few inline
 * multiplications which ought to be much faster. And yet only if compiling
 * with a sufficiently recent gcc version to perform proper 64-bit constant
 * propagation.
 *
 * (It is unfortunate that gcc doesn't perform all this internally.)
 *//*
 * Copyright (C) 2003 Bernardo Innocenti <bernie@develer.com>
 * Based on former asm-ppc/div64.h and asm-m68knommu/div64.h
 *
 * Optimization for constant divisors on 32-bit machines:
 * Copyright (C) 2006-2015 Nicolas Pitre
 *
 * The semantics of do_div() are:
 *
 * u32 do_div(u64 *n, u32 base)
 * {
 *	u32 remainder = *n % base;
 *	*n = *n / base;
 *	return remainder;
 * }
 *
 * NOTE: macro parameter n is evaluated multiple times,
 *       beware of side effects!
 */bias/opt/src/include/linux/mtd/mtd.hmtd_search_alternate_namemtd_dev_list_updatedmtd_get_len_incl_badmtd_info *const uint64_tmtd_arg_off_sizemtd_arg_off__mtd_next_devicedel_mtd_partitionsadd_mtd_partitionsconst mtd_partitionconst mtd_partition *mtd_partition *del_mtd_deviceadd_mtd_devicemtd_mmap_capabilitiesmtd_is_bitflip_or_eccerrmtd_is_eccerrEBADMSG-74-EBADMSGmtd_is_bitflipEUCLEAN-117-EUCLEANmtd_erase_callbackerase_info *mtd_kmalloc_up_toconst mtd_infoconst mtd_info *put_mtd_deviceget_mtd_device_nm__put_mtd_device__get_mtd_deviceget_mtd_devicemtd_device_unregistermtd_device_parse_registermtd_part_parser_data *mtd_can_have_bbmtd_type_is_nandmtd_has_oobmtd_oob_ops *mtd_mod_by_wsmtd->writesizedo_div(sz, mtd->writesize)/opt/src/include/linux/mtd<div64.h><mtd/mtd-abi.h>partsnpartsinstr((sz) >> 32) == 0mtd_div_by_wsmtd_mod_by_ebmtd->erasesizedo_div(sz, mtd->erasesize)mtd_div_by_ebmtd_block_markbadmtd_block_isbadmtd_block_isreservedmtd_is_lockedmtd_unlockmtd_lockmtd_syncmtd_lock_user_prot_regmtd_write_user_prot_regu_char *mtd_read_user_prot_regmtd_get_user_prot_infootp_info *mtd_read_fact_prot_regmtd_get_fact_prot_infomtd_write_oobmtd_read_oobmtd_panic_writeconst u_charconst u_char *mtd_writemtd_readmtd_get_unmapped_areamtd_erasemtd_oobavailmtd_set_ooblayoutconst mtd_ooblayout_opsconst mtd_ooblayout_ops *mtd_ooblayout_ops *mtd_ooblayout_count_eccbytesmtd_ooblayout_count_freebytesmtd_ooblayout_set_databytesmtd_ooblayout_get_databytesmtd_ooblayout_freemtd_oob_region *mtd_ooblayout_set_eccbytesmtd_ooblayout_get_eccbytesmtd_ooblayout_find_eccregionmtd_ooblayout_eccmtd_partitions_usedmtd_has_partitionsmtd_is_partitionmtd_get_of_nodemtd_set_of_nodemtd_part_parser_datamtd_partitionerase_infomtd_infomodulemtd_oob_opsmtd_erase_region_infonand_ecclayoutmtd_ooblayout_opsmtd_oob_regionscrubretriesfail_addrpartitionsusecountmodule *subpage_sftecc_stats_put_device_get_device_block_markbad_block_isbad_block_isreserved_is_locked_unlock_lock_sync_lock_user_prot_reg_write_user_prot_reg_read_user_prot_reg_get_user_prot_info_read_fact_prot_reg_get_fact_prot_info_write_oob_read_ooboobbufdatbufooboffsoobretlenretlen_panic_write_write_read_get_unmapped_area_erasemtd_erase_region_info *eraseregionslockmapnumeraseregionsecc_strengthecc_step_sizenand_ecclayout *ecclayoutnand_oobfree[32]MTD_MAX_OOBFREE_ENTRIES_LARGE__u32[680]unsigned int[680]680MTD_MAX_ECCPOS_ENTRIES_LARGEooblayouteccbitflip_thresholdwritesize_maskerasesize_maskwritesize_shifterasesize_shiftwritebufsizemtd_for_each_device(mtd)for ((mtd) = __mtd_next_device(0); (mtd) != NULL; (mtd) = __mtd_next_device(mtd->index + 1))mtd_device_register(master,parts,nr_parts)mtd_device_parse_register(master, NULL, NULL, parts, nr_parts)MTD_FAIL_ADDR_UNKNOWN-1LLMTD_ERASE_FAILEDMTD_ERASE_DONEMTD_ERASE_SUSPENDMTD_ERASINGMTD_ERASE_PENDINGMAX_MTD_DEVICES__MTD_MTD_H__IS_ENABLED(CONFIG_DM)CONFIG_SYS_NAND_MAX_OOBFREECONFIG_SYS_NAND_MAX_ECCPOSCONFIG_MTD_PARTITIONSCONFIG_DM_MODULE__ARG_PLACEHOLDER_CONFIG_DM_MODULE__ARG_PLACEHOLDER_CONFIG_DM_MODULE 1/* __MTD_MTD_H__ *//* drivers/mtd/mtd_uboot.c *//* drivers/mtd/mtdcore.c *//* drivers/mtd/mtdcore.h *//* Kernel-side ioctl definitions *//*
	 * List of partitions attached to this MTD device (the parent
	 * MTD device can itself be a partition).
	 *//*
	 * List node used to add an MTD partition to the parent
	 * partition list.
	 *//*
	 * Offset of the partition relatively to the parent offset.
	 * Is 0 for real MTD devices (ie. not partitions).
	 *//* MTD devices do not have any parent. MTD partitions do. *//* Subpage shift (NAND) *//* ECC status information *//* default mode before reboot *//* Backing device capabilities for this device
	 * - provides mmap capabilities
	 *//*
	 * If the driver is something smart, like UBI, it may need to maintain
	 * its own reference counting. The below functions are only for driver.
	 *//*
	 * Do not call via these pointers, use corresponding mtd_*()
	 * wrappers instead.
	 *//* Data for variable erase regions. If numeraseregions is zero,
	 * it means that the whole device has erasesize as given above.
	 *//* max number of correctible bit errors per ecc step *//* the ecc step size. *//* ECC layout structure pointer - read only! *//* OOB layout description */// Kernel-only stuff starts here./*
	 * read ops return -EUCLEAN if max number of bitflips corrected on any
	 * one region comprising an ecc step equals or exceeds this value.
	 * Settable by driver, else defaults to ecc_strength.  User can override
	 * in sysfs.  N.B. The meaning of the -EUCLEAN return code has changed;
	 * see Documentation/ABI/testing/sysfs-class-mtd for more detail.
	 *//* Masks based on erasesize_shift and writesize_shift *//*
	 * If erasesize is a power of 2 then the shift is stored in
	 * erasesize_shift otherwise erasesize_shift is zero. Ditto writesize.
	 */// Available OOB bytes per block// Amount of OOB data per block (e.g. 16)/*
	 * Size of the write buffer used by the MTD. MTD devices having a write
	 * buffer can write multiple writesize chunks at a time. E.g. while
	 * writing 4 * writesize bytes to a device with 2 * writesize bytes
	 * buffer the MTD driver can (but doesn't have to) do 2 writesize
	 * operations, but not 4. Currently, all NANDs have writebufsize
	 * equivalent to writesize (NAND page size). Some NOR flashes do have
	 * writebufsize greater than writesize.
	 *//* Minimal writable flash unit size. In case of NOR flash it is 1 (even
	 * though individual bits can be cleared), in case of NAND flash it is
	 * one NAND page (or half, or one-fourths of it), in case of ECC-ed NOR
	 * it is of ECC block size, etc. It is illegal to have writesize = 0.
	 * Any driver registering a struct mtd_info must ensure a writesize of
	 * 1 or larger.
	 *//* "Major" erase size for the device. Nave users may take this
	 * to be the only erase size available, or may use the more detailed
	 * information below if they desire
	 */// Total size of the MTD/* only needed for owner field in mtd_info *//*
 * Internal ECC layout control structure. For historical reasons, there is a
 * similar, smaller struct nand_ecclayout_user (in mtd-abi.h) that is retained
 * for export to user-space via the ECCGETLAYOUT ioctl.
 * nand_ecclayout should be expandable in the future simply by the above macros.
 *//*
 * struct mtd_ooblayout_ops - NAND OOB layout operations
 * @ecc: function returning an ECC region in the OOB area.
 *	 Should return -ERANGE if %section exceeds the total number of
 *	 ECC sections.
 * @free: function returning a free region in the OOB area.
 *	  Should return -ERANGE if %section exceeds the total number of
 *	  free sections.
 *//**
 * struct mtd_oob_region - oob region definition
 * @offset: region offset
 * @length: region length
 *
 * This structure describes a region of the OOB area, and is used
 * to retrieve ECC or free bytes sections.
 * Each section is defined by an offset within the OOB area and a
 * length.
 *//**
 * struct mtd_oob_ops - oob operation operands
 * @mode:	operation mode
 *
 * @len:	number of data bytes to write/read
 *
 * @retlen:	number of data bytes written/read
 *
 * @ooblen:	number of oob bytes to write/read
 * @oobretlen:	number of oob bytes written/read
 * @ooboffs:	offset of oob data in the oob area (only relevant when
 *		mode = MTD_OPS_PLACE_OOB or MTD_OPS_RAW)
 * @datbuf:	data buffer - if NULL only oob data are read/written
 * @oobbuf:	oob data buffer
 *//* If keeping bitmap of locks *//* Number of blocks of erasesize in this region *//* At which this region starts, from the beginning of the MTD *//*
 * If the erase fails, fail_addr might indicate exactly which block failed. If
 * fail_addr = MTD_FAIL_ADDR_UNKNOWN, the failure was not at the device level
 * or was not specific to any particular block.
 */mtdnamealtnamemax_lenlen_incl_badtruncatedmaxsizedevtypechipsizemasterpart_probe_typesparser_datadefpartsdefnr_partsofstodatabufeccbufeccbyteoobregionoobecc/opt/src/include/linux/mtd/flashchip.hflashchipflchip_sharedflchipflstate_tFL_READYFL_STATUSFL_CFI_QUERYFL_JEDEC_QUERYFL_ERASINGFL_ERASE_SUSPENDINGFL_ERASE_SUSPENDEDFL_WRITINGFL_WRITING_TO_BUFFERFL_OTP_WRITEFL_WRITE_SUSPENDINGFL_WRITE_SUSPENDEDFL_PM_SUSPENDEDFL_SYNCINGFL_UNLOADINGFL_LOCKINGFL_UNLOCKINGFL_POINTFL_XIP_WHILE_ERASINGFL_XIP_WHILE_WRITINGFL_SHUTDOWNFL_READINGFL_CACHEDPRGFL_RESETINGFL_OTPINGFL_PREPARING_ERASEFL_VERIFYING_ERASEFL_UNKNOWNflchip *erasingwritinglockerase_time_maxbuffer_write_time_maxword_write_time_maxerase_timebuffer_write_timeword_write_timein_progress_block_addrerase_suspendedwrite_suspendedoldstateref_point_counter__MTD_FLASHCHIP_H__/* __MTD_FLASHCHIP_H__ *//* This is used to handle contention on write/erase operations
   between partitions of the same physical chip. *//* Wait on here when we're waiting for the chip
			     to be ready *//* We omit len for now, because when we group them together
	   we insist that they're all of the same size, and the chip size
	   is held in the next level up. If we get more versatile later,
	   it'll make it a damn sight harder to find which chip we want from
	   a given offset, and we'll want to add the per-chip length field
	   back in.
	*///	unsigned long len;/* Offset within the map *//* NOTE: confusingly, this can be used to refer to more than one chip at a time,
   if they're interleaved.  This can even refer to individual partitions on
   the same physical chip when present. *//* These 4 come from onenand_state_t, which has been unified here *//* These 2 come from nand_state_t, which has been unified here *//* For spinlocks. sched.h includes spinlock.h from whichever directory it
 * happens to be in - so we don't have to care whether we're on 2.2, which
 * has asm/spinlock.h, or 2.4, which has linux/spinlock.h
 *//*
 * Copyright  2000      Red Hat UK Limited
 * Copyright  2000-2010 David Woodhouse <dwmw2@infradead.org>
 *
 *//opt/src/include/linux/mtd/bbm.hbbmonenand_default_bbtonenand_scan_bbtnand_bbt_descr *bbm_infonand_bbt_descrbadblock_patternisbad_bbtbbtoptionsbadblockposbbt_erase_shiftpatternreserved_block_codemaxblocksuint8_t[1]unsigned char[1]CONFIG_SYS_NAND_MAX_CHIPSveroffsoffsONENAND_BBT_READ_FATAL_ERRORONENAND_BBT_READ_ECC_ERRORONENAND_BBT_READ_ERRORONENAND_BADBLOCK_POSNAND_LARGE_BADBLOCK_POSNAND_SMALL_BADBLOCK_POSNAND_BBT_SCAN_MAXBLOCKSNAND_BBT_DYNAMICSTRUCTNAND_BBT_NO_OOB_BBMNAND_BBT_NO_OOBNAND_BBT_USE_FLASHNAND_BBT_SCANLASTPAGENAND_BBT_SCAN2NDPAGENAND_BBT_SAVECONTENTNAND_BBT_WRITENAND_BBT_CREATE_EMPTYNAND_BBT_CREATENAND_BBT_VERSIONNAND_BBT_PERCHIPNAND_BBT_ABSPAGENAND_BBT_LASTBLOCKNAND_BBT_8BITNAND_BBT_4BITNAND_BBT_2BITNAND_BBT_1BITNAND_BBT_NRBITS_MSK0x0000000F__LINUX_MTD_BBM_H/* __LINUX_MTD_BBM_H *//* OneNAND BBT interface *//* TODO Add more NAND specific fileds *//**
 * struct bbm_info - [GENERIC] Bad Block Table data structure
 * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
 * @badblockpos:	[INTERN] position of the bad block marker in the oob area
 * @options:		options for this descriptor
 * @bbt:		[INTERN] bad block table pointer
 * @isbad_bbt:		function to determine if a block is bad
 * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for
 *			initial bad block scan
 * @priv:		[OPTIONAL] pointer to private bbm date
 *//*
 * Bad block scanning errors
 *//*
 * Constants for oob configuration
 *//* The maximum number of blocks to scan for a bbt *//*
 * Flag set by nand_create_default_bbt_descr(), marking that the nand_bbt_descr
 * was allocated dynamicaly and must be freed in nand_release(). Has no meaning
 * in nand_chip.bbt_options.
 *//*
 * Do not write new bad block markers to OOB; useful, e.g., when ECC covers
 * entire spare area. Must be used with NAND_BBT_USE_FLASH.
 *//*
 * Do not store flash based bad block table marker in the OOB area; store it
 * in-band.
 *//*
 * Use a flash based bad block table. By default, OOB identifier is saved in
 * OOB area. This option is passed to the default bad block table function.
 *//* Search good / bad pattern on the last page of the eraseblock *//* Search good / bad pattern on the first and the second page *//* Read and write back block contents when writing bbt *//* Write bbt if neccecary *//*
 * Create an empty BBT with no vendor information. Vendor's information may be
 * unavailable, for example, if the NAND controller has a different data and OOB
 * layout or if this information is already purged. Must be used in conjunction
 * with NAND_BBT_CREATE.
 *//* Create a bbt if none exists *//* bbt has a version counter at offset veroffs *//* bbt is stored per chip on multichip devices *//* The bbt is at the given page, else we must scan for the bbt *//* The bad block table is in the last good block of the device *//* The number of bits used per block in the bbt on the device *//* Options for the bad block table descriptors *//**
 * struct nand_bbt_descr - bad block table descriptor
 * @options:	options for this descriptor
 * @pages:	the page(s) where we find the bbt, used with option BBT_ABSPAGE
 *		when bbt is searched, then we store the found bbts pages here.
 *		Its an array and supports up to 8 chips now
 * @offs:	offset of the pattern in the oob area of the page
 * @veroffs:	offset of the bbt version counter in the oob are of the page
 * @version:	version read from the bbt page during scan
 * @len:	length of the pattern, if 0 no pattern check is performed
 * @maxblocks:	maximum number of blocks to search for a bbt. This number of
 *		blocks is reserved at the end of the device where the tables are
 *		written.
 * @reserved_block_code: if non-0, this pattern denotes a reserved (rather than
 *              bad) block in the stored bbt
 * @pattern:	pattern to identify bad block table or factory marked good /
 *		bad blocks, can be NULL, if len = 0
 *
 * Descriptor for the bad block table marker and the descriptor for the
 * pattern which identifies good and bad blocks. The assumption is made
 * that the pattern and the version count are always located in the oob area
 * of the first block.
 *//* The maximum number of NAND chips in an array *//*
 *  linux/include/linux/mtd/bbm.h
 *
 *  NAND family Bad Block Management (BBM) header file
 *    - Bad Block Table (BBT) implementation
 *
 *  Copyright  2005 Samsung Electronics
 *  Kyungmin Park <kyungmin.park@samsung.com>
 *
 *  Copyright  2000-2005
 *  Thomas Gleixner <tglx@linuxtronix.de>
 *
 *//opt/src/include/linux/mtd/rawnand.hrawnandnand_write_data_opnand_chip *nand_read_data_opnand_change_write_column_opnand_prog_page_opnand_prog_page_end_opnand_prog_page_begin_opnand_read_oob_opnand_change_read_column_opnand_read_page_opnand_erase_opnand_exit_status_opnand_status_opnand_readid_opnand_reset_opnand_resetnand_maximize_eccconst nand_ecc_capsconst nand_ecc_caps *nand_ecc_caps *nand_match_ecc_reqnand_check_ecc_capsnand_check_erased_ecc_chunkconst nand_data_interfaceconst nand_data_interface *nand_data_interface *nand_get_default_data_interfaceconst nand_sdr_timingsconst nand_sdr_timings *nand_sdr_timings *onfi_async_timing_mode_to_sdr_timingsnand_read_bytenand_read_buf16nand_read_bufnand_write_buf16nand_write_bufjedec_featurechip->jedec_params.featuresnand_opcode_8bitsNAND_CMD_READIDNAND_CMD_PARAMNAND_CMD_GET_FEATURESNAND_CMD_SET_FEATURESnand_is_slconfi_init_data_interfaceonfi_get_sync_timing_modeONFI_TIMING_MODE_UNKNOWNonfi_get_async_timing_modeonfi_featurenand_do_readnand_erase_nandnand_isbad_bbtnand_isreserved_bbtnand_markbad_bbtnand_default_bbtnand_set_controller_datanand_get_controller_datanand_to_mtdmtd_to_nandstruct nand_chipcontainer_of(mtd, struct nand_chip, mtd)nand_get_flash_nodenand_set_flash_nodenand_get_sdr_timingsNAND_SDR_IFACEnand_standard_page_accessorsnand_ecc_ctrl *NAND_ECC_CUSTOM_PAGE_ACCESSnand_hw_control_initnand_hw_control *&nfc->lockspin_lock_init(&nfc->lock)&nfc->wqinit_waitqueue_head(&nfc->wq)nand_wait_readynand_releasenand_scan_tailnand_scan_identnand_flash_dev *nand_scannand_get_flash_typeplatform_nand_dataplatform_nand_ctrlplatform_deviceplatform_nand_chipnand_manufacturersnand_flash_devnand_ecc_capsnand_ecc_step_infonand_hw_controlnand_chipnand_buffersnand_ecc_ctrlnand_data_interfacenand_sdr_timingsnand_data_interface_typenand_jedec_paramsjedec_ecc_infonand_onfi_vendor_micrononfi_ext_param_pageonfi_ext_sectiononfi_ext_ecc_infonand_onfi_paramsnand_ecc_algoNAND_ECC_UNKNOWNNAND_ECC_HAMMINGNAND_ECC_BCHnand_ecc_modes_tNAND_ECC_NONENAND_ECC_SOFTNAND_ECC_HWNAND_ECC_HW_SYNDROMENAND_ECC_HW_OOB_FIRSTNAND_ECC_SOFT_BCHread_byteread_bufwrite_bufcmd_ctrlselect_chipdev_readyhwcontrolplatform_device *bbt_optionschip_delaynr_partitionschip_offsetnr_chipsonfi_timing_mode_defaultid_lenpagesizestep_dsstrength_dsNAND_MAX_ID_LENmfr_idcalc_ecc_bytesnstepinfosconst nand_ecc_step_infoconst nand_ecc_step_info *nand_ecc_step_info *stepinfosnstrengthsstrengthsstepsizebbt_mdbbt_tdbuf_alignnand_buffers *buffersuint8_t[18048]unsigned char[18048]NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE16384 + 1664ALIGN(NAND_MAX_PAGESIZE + NAND_MAX_OOBSIZE,
			      ARCH_DMA_MINALIGN)166418048(16384 + 1664)(typeof(16384 + 1664))(16)-118063-16uint8_t[1664]unsigned char[1664]NAND_MAX_OOBSIZEALIGN(NAND_MAX_OOBSIZE, ARCH_DMA_MINALIGN)(1664)(typeof(1664))(16)-11679ecccode<linux/mtd/bbm.h><linux/mtd/flashchip.h><linux/mtd/mtd.h>nfcecccalcwrite_oobread_oobread_oob_rawwrite_oob_rawwrite_pagewrite_subpageread_subpageread_pagewrite_page_rawread_page_rawcorrectcalculatehwctlpostpadprepadstrengthtotalstepsalgocontrolleroob_poiread_retriesdata_interfacejedec_paramsonfi_paramsjedec_versiononfi_versionbadblockbitsecc_step_dsecc_strength_dsbits_per_cellsubpagesizepagebuf_bitflipspagebufpagemasknumchipschip_shiftphys_erase_shiftpage_shiftsetup_data_interfacetimingssdrtWW_mintWP_mintWHR_mintWH_mintWC_mintWB_maxtRST_maxtRR_mintRP_mintRLOH_mintRHZ_maxtRHW_mintRHOH_mintREH_mintREA_maxtRC_mintITC_maxtIR_mintFEAT_maxtDS_mintDH_mintCS_mintCOH_mintCLS_mintCLR_mintCLH_mintCHZ_maxtCH_mintCEH_mintCEA_maxtAR_mintALS_mintADL_mintALH_mintR_maxtPROG_maxtCCS_mintBERS_maxsetup_read_retryonfi_get_featuresonfi_set_featuresscan_bbtwaitfunccmdfuncblock_markbadblock_badwrite_byteread_wordflash_nodeIO_ADDR_WIO_ADDR_Ru8[88]unsigned char[88]reserved7vendor_rev_numu8[148]unsigned char[148]reserved6u8[29]unsigned char[29]reserved5jedec_ecc_info[4]ecc_infoguaranteed_block_enduranceguaranteed_good_blocksu8[36]unsigned char[36]reserved4t_adldriver_strength_supportclk_pin_capacitance_typinput_pin_capacitance_typio_pin_capacitance_typt_ccst_r_multi_planet_rt_berst_progsync_ddr_featurestoggle_ddr_featuresasync_sdr_featuressync_ddr_speed_gradetoggle_ddr_speed_gradeasync_sdr_speed_gradeu8[38]unsigned char[38]reserved3multi_plane_op_attrmulti_plane_addrprograms_per_pageaddr_cycleslun_countblocks_per_lunpages_per_blocku8[6]reserved2spare_bytes_per_pagebyte_per_pageu8[10]unsigned char[10]jedec_idmodelmanufactureru8[18]unsigned char[18]num_of_param_pagessec_cmdopt_cmdsigu8[2]block_endurancebb_per_luncodeword_sizeecc_bitsparam_revisionu8[72]unsigned char[72]read_retry_optionsotp_feat_addrotp_num_pagesotp_data_prot_addrotp_page_startotp_moderb_pulldown_strength_num_settingsrb_pulldown_strength_feat_addrrb_pulldown_strengthdq_imped_feat_addrdq_imped_num_settingsdq_impedread_unique_idread_cachetwo_plane_readonfi_ext_section[8]ONFI_EXT_SECTION_MAXvendor_revisionu8[8]t_int_rinput_pin_capacitance_maxsrc_ssync_featuressrc_sync_timing_modeprogram_cache_timing_modeasync_timing_modeio_pin_capacitance_maxu8[13]interleaved_opsinterleaved_bitsppage_attrspare_bytes_per_ppagedata_bytes_per_ppagedate_codeu8[17]unsigned char[17]ext_param_page_lengthnand_manufacturers[]nand_flash_dev[]NAND_ECC_STEP(type)((type)->ecc.step_ds)NAND_ECC_STRENGTH(type)((type)->ecc.strength_ds)NAND_ECC_INFO(_strength,_step){ .strength_ds = (_strength), .step_ds = (_step) }EXTENDED_ID_NAND(nm,devid,chipsz,opts){ .name = (nm), {{ .dev_id = (devid) }}, .chipsize = (chipsz), .options = (opts) }LEGACY_ID_NAND(nm,devid,chipsz,erasesz,opts){ .name = (nm), {{ .dev_id = (devid) }}, .pagesize = 512, .chipsize = (chipsz), .erasesize = (erasesz), .options = (opts) }NAND_MFR_ATO0x9bNAND_MFR_INTEL0x89NAND_MFR_SANDISK0x45NAND_MFR_EONNAND_MFR_MACRONIX0xc2NAND_MFR_AMDNAND_MFR_MICRONNAND_MFR_HYNIX0xadNAND_MFR_STMICRONAND_MFR_RENESASNAND_MFR_NATIONAL0x8fNAND_MFR_FUJITSUNAND_MFR_SAMSUNGNAND_MFR_TOSHIBANAND_ECC_CAPS_SINGLE(__name,__calc,__step,__VA_ARGS__...)static const int __name ## _strengths[] = { __VA_ARGS__ }; static const struct nand_ecc_step_info __name ## _stepinfo = { .stepsize = __step, .strengths = __name ## _strengths, .nstrengths = ARRAY_SIZE(__name ## _strengths), }; static const struct nand_ecc_caps __name = { .stepinfos = &__name ## _stepinfo, .nstepinfos = 1, .calc_ecc_bytes = __calc, }JEDEC_FEATURE_16_BIT_BUSONFI_SECTION_TYPE_2ONFI_SECTION_TYPE_1ONFI_SECTION_TYPE_0ONFI_CRC_BASE0x4F4EONFI_OPT_CMD_SET_GET_FEATURESONFI_SUBFEATURE_PARAM_LENONFI_FEATURE_ADDR_READ_RETRYONFI_FEATURE_ADDR_TIMING_MODEONFI_TIMING_MODE_5ONFI_TIMING_MODE_4ONFI_TIMING_MODE_3ONFI_TIMING_MODE_2ONFI_TIMING_MODE_1ONFI_TIMING_MODE_0ONFI_FEATURE_EXT_PARAM_PAGEONFI_FEATURE_16_BIT_BUSNAND_CI_CELLTYPE_SHIFTNAND_CI_CELLTYPE_MSKNAND_CI_CHIPNR_MSKNAND_CONTROLLER_ALLOCNAND_BBT_SCANNEDNAND_USE_BOUNCE_BUFFERNAND_BUSWIDTH_AUTONAND_SCAN_SILENT_NODEVNAND_OWN_BUFFERSNAND_SKIP_BBTSCANNAND_HAS_SUBPAGE_WRITE(chip)!((chip)->options & NAND_NO_SUBPAGE_WRITE)NAND_HAS_SUBPAGE_READ(chip)((chip->options & NAND_SUBPAGE_READ))NAND_HAS_CACHEPROG(chip)((chip->options & NAND_CACHEPRG))NAND_SAMSUNG_LP_OPTIONSNAND_CACHEPRGNAND_ROW_ADDR_3NAND_NEED_SCRAMBLINGNAND_SUBPAGE_READNAND_ROMNAND_BROKEN_XDNAND_NO_SUBPAGE_WRITENAND_NEED_READRDYNAND_COPYBACKNAND_NO_PADDINGNAND_BUSWIDTH_16NAND_GET_DEVICENAND_ECC_MAXIMIZENAND_ECC_GENERIC_ERASED_CHECKNAND_ECC_READSYNNAND_ECC_WRITENAND_ECC_READNAND_DATA_IFACE_CHECK_ONLYNAND_STATUS_WPNAND_STATUS_READYNAND_STATUS_TRUE_READYNAND_STATUS_FAIL_N1NAND_STATUS_FAILNAND_CMD_NONENAND_CMD_STATUS_CLEARNAND_CMD_STATUS_RESETNAND_CMD_STATUS_ERROR30x76NAND_CMD_STATUS_ERROR20x75NAND_CMD_STATUS_ERROR10x74NAND_CMD_STATUS_ERROR00x73NAND_CMD_STATUS_ERROR0x72NAND_CMD_STATUS_MULTI0x71NAND_CMD_DEPLETE2NAND_CMD_DEPLETE1NAND_CMD_CACHEDPROGNAND_CMD_RNDOUTSTARTNAND_CMD_READSTARTNAND_CMD_UNLOCK2NAND_CMD_UNLOCK1NAND_CMD_LOCK0x2aNAND_CMD_RESET0xef0xeeNAND_CMD_ERASE20xd0NAND_CMD_RNDIN0x85NAND_CMD_SEQINNAND_CMD_STATUSNAND_CMD_ERASE1NAND_CMD_READOOBNAND_CMD_PAGEPROGNAND_CMD_RNDOUTNAND_CMD_READ1NAND_CMD_READ0NAND_CTRL_CHANGENAND_CTRL_ALE(NAND_NCE | NAND_ALE)NAND_CTRL_CLE(NAND_NCE | NAND_CLE)NAND_ALENAND_CLENAND_NCENAND_MAX_PAGESIZE__LINUX_MTD_RAWNAND_HCONFIG_SYS_NAND_ONFI_DETECTIONnand_manuf_idsnand_flash_ids/* __LINUX_MTD_RAWNAND_H *//* NAND operation helpers *//* Reset and initialize a NAND device *//* get data interface from ONFI timing mode 0, used after reset. *//* get timing characteristics from ONFI timing mode. *//* Standard NAND functions from nand_base.c *//* return the supported JEDEC features. *//**
 * Check if the opcode's address should be sent only on the lower 8 bits
 * @command: opcode to check
 *//*
 * Check if it is a SLC nand.
 * The !nand_is_slc() can be used to check the MLC/TLC nand chips.
 * We do not distinguish the MLC and TLC now.
 *//* return the supported synchronous timing mode. *//* return the supported asynchronous timing mode. *//* return the supported features. *//**
 * struct platform_nand_data - container structure for platform-specific data
 * @chip:		chip level chip structure
 * @ctrl:		controller level device structure
 *//**
 * struct platform_nand_ctrl - controller level device structure
 * @probe:		platform specific function to probe/setup hardware
 * @remove:		platform specific function to remove/teardown hardware
 * @hwcontrol:		platform specific hardware control structure
 * @dev_ready:		platform specific function to read ready/busy pin
 * @select_chip:	platform specific chip select function
 * @cmd_ctrl:		platform specific function for controlling
 *			ALE/CLE/nCE. Also used to write command and address
 * @write_buf:		platform specific function for write buffer
 * @read_buf:		platform specific function for read buffer
 * @read_byte:		platform specific function to read one byte from chip
 * @priv:		private data to transport driver specific settings
 *
 * All fields are optional and depend on the hardware driver requirements
 *//* Keep gcc happy *//**
 * struct platform_nand_chip - chip level device structure
 * @nr_chips:		max. number of chips to scan for
 * @chip_offset:	chip number offset
 * @nr_partitions:	number of partitions pointed to by partitions (or zero)
 * @partitions:		mtd partition list
 * @chip_delay:		R/B delay value in us
 * @options:		Option flags, e.g. 16bit buswidth
 * @bbt_options:	BBT option flags, e.g. NAND_BBT_USE_FLASH
 * @part_probe_types:	NULL-terminated array of probe types
 *//*
* Constants for oob configuration
*//**
 * struct nand_manufacturers - NAND Flash Manufacturer ID Structure
 * @name:	Manufacturer name
 * @id:		manufacturer ID code of device.
*//**
 * struct nand_flash_dev - NAND Flash Device ID Structure
 * @name: a human-readable name of the NAND chip
 * @dev_id: the device ID (the second byte of the full chip ID array)
 * @mfr_id: manufecturer ID part of the full chip ID array (refers the same
 *          memory address as @id[0])
 * @dev_id: device ID part of the full chip ID array (refers the same memory
 *          address as @id[1])
 * @id: full device ID array
 * @pagesize: size of the NAND page in bytes; if 0, then the real page size (as
 *            well as the eraseblock size) is determined from the extended NAND
 *            chip ID array)
 * @chipsize: total chip size in MiB
 * @erasesize: eraseblock size in bytes (determined from the extended ID if 0)
 * @options: stores various chip bit options
 * @id_len: The valid length of the @id.
 * @oobsize: OOB size
 * @ecc: ECC correctability and step information from the datasheet.
 * @ecc.strength_ds: The ECC correctability from the datasheet, same as the
 *                   @ecc_strength_ds in nand_chip{}.
 * @ecc.step_ds: The ECC step required by the @ecc.strength_ds, same as the
 *               @ecc_step_ds in nand_chip{}, also from the datasheet.
 *               For example, the "4bit ECC for each 512Byte" can be set with
 *               NAND_ECC_INFO(4, 512).
 * @onfi_timing_mode_default: the default ONFI timing mode entered after a NAND
 *			      reset. Should be deduced from timings described
 *			      in the datasheet.
 *
 *//*
 * A helper for defining newer chips which report their page size and
 * eraseblock size via the extended ID bytes.
 *
 * The real difference between LEGACY_ID_NAND and EXTENDED_ID_NAND is that with
 * EXTENDED_ID_NAND, manufacturers overloaded the same device ID so that the
 * device ID now only represented a particular total chip size (and voltage,
 * buswidth), and the page size, eraseblock size, and OOB size could vary while
 * using the same device ID.
 *//*
 * A helper for defining older NAND chips where the second ID byte fully
 * defined the chip, including the geometry (chip size, eraseblock size, page
 * size). All these chips have 512 bytes NAND page size.
 *//* The maximum expected count of bytes in the NAND ID sequence *//*
 * NAND Flash Manufacturer ID Codes
 *//**
 * struct nand_chip - NAND Private Flash Chip Data
 * @mtd:		MTD device registered to the MTD framework
 * @IO_ADDR_R:		[BOARDSPECIFIC] address to read the 8 I/O lines of the
 *			flash device
 * @IO_ADDR_W:		[BOARDSPECIFIC] address to write the 8 I/O lines of the
 *			flash device.
 * @flash_node:		[BOARDSPECIFIC] device node describing this instance
 * @read_byte:		[REPLACEABLE] read one byte from the chip
 * @read_word:		[REPLACEABLE] read one word from the chip
 * @write_byte:		[REPLACEABLE] write a single byte to the chip on the
 *			low 8 I/O lines
 * @write_buf:		[REPLACEABLE] write data from the buffer to the chip
 * @read_buf:		[REPLACEABLE] read data from the chip into the buffer
 * @select_chip:	[REPLACEABLE] select chip nr
 * @block_bad:		[REPLACEABLE] check if a block is bad, using OOB markers
 * @block_markbad:	[REPLACEABLE] mark a block bad
 * @cmd_ctrl:		[BOARDSPECIFIC] hardwarespecific function for controlling
 *			ALE/CLE/nCE. Also used to write command and address
 * @dev_ready:		[BOARDSPECIFIC] hardwarespecific function for accessing
 *			device ready/busy line. If set to NULL no access to
 *			ready/busy is available and the ready/busy information
 *			is read from the chip status register.
 * @cmdfunc:		[REPLACEABLE] hardwarespecific function for writing
 *			commands to the chip.
 * @waitfunc:		[REPLACEABLE] hardwarespecific function for wait on
 *			ready.
 * @setup_read_retry:	[FLASHSPECIFIC] flash (vendor) specific function for
 *			setting the read-retry mode. Mostly needed for MLC NAND.
 * @ecc:		[BOARDSPECIFIC] ECC control structure
 * @buffers:		buffer structure for read/write
 * @buf_align:		minimum buffer alignment required by a platform
 * @hwcontrol:		platform-specific hardware control structure
 * @erase:		[REPLACEABLE] erase function
 * @scan_bbt:		[REPLACEABLE] function to scan bad block table
 * @chip_delay:		[BOARDSPECIFIC] chip dependent delay for transferring
 *			data from array to read regs (tR).
 * @state:		[INTERN] the current state of the NAND device
 * @oob_poi:		"poison value buffer," used for laying out OOB data
 *			before writing
 * @page_shift:		[INTERN] number of address bits in a page (column
 *			address bits).
 * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
 * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
 * @chip_shift:		[INTERN] number of address bits in one chip
 * @options:		[BOARDSPECIFIC] various chip options. They can partly
 *			be set to inform nand_scan about special functionality.
 *			See the defines for further explanation.
 * @bbt_options:	[INTERN] bad block specific options. All options used
 *			here must come from bbm.h. By default, these options
 *			will be copied to the appropriate nand_bbt_descr's.
 * @badblockpos:	[INTERN] position of the bad block marker in the oob
 *			area.
 * @badblockbits:	[INTERN] minimum number of set bits in a good block's
 *			bad block marker position; i.e., BBM == 11110111b is
 *			not bad when badblockbits == 7
 * @bits_per_cell:	[INTERN] number of bits per cell. i.e., 1 means SLC.
 * @ecc_strength_ds:	[INTERN] ECC correctability from the datasheet.
 *			Minimum amount of bit errors per @ecc_step_ds guaranteed
 *			to be correctable. If unknown, set to zero.
 * @ecc_step_ds:	[INTERN] ECC step required by the @ecc_strength_ds,
 *                      also from the datasheet. It is the recommended ECC step
 *			size, if known; if unknown, set to zero.
 * @onfi_timing_mode_default: [INTERN] default ONFI timing mode. This field is
 *			      set to the actually used ONFI mode if the chip is
 *			      ONFI compliant or deduced from the datasheet if
 *			      the NAND chip is not ONFI compliant.
 * @numchips:		[INTERN] number of physical chips
 * @chipsize:		[INTERN] the size of one chip for multichip arrays
 * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
 * @pagebuf:		[INTERN] holds the pagenumber which is currently in
 *			data_buf.
 * @pagebuf_bitflips:	[INTERN] holds the bitflip count for the page which is
 *			currently in data_buf.
 * @subpagesize:	[INTERN] holds the subpagesize
 * @onfi_version:	[INTERN] holds the chip ONFI version (BCD encoded),
 *			non 0 if ONFI supported.
 * @jedec_version:	[INTERN] holds the chip JEDEC version (BCD encoded),
 *			non 0 if JEDEC supported.
 * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is
 *			supported, 0 otherwise.
 * @jedec_params:	[INTERN] holds the JEDEC parameter page when JEDEC is
 *			supported, 0 otherwise.
 * @read_retries:	[INTERN] the number of read retry modes supported
 * @onfi_set_features:	[REPLACEABLE] set the features for ONFI nand
 * @onfi_get_features:	[REPLACEABLE] get the features for ONFI nand
 * @setup_data_interface: [OPTIONAL] setup the data interface and timing. If
 *			  chipnr is set to %NAND_DATA_IFACE_CHECK_ONLY this
 *			  means the configuration should not be applied but
 *			  only checked.
 * @bbt:		[INTERN] bad block table pointer
 * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash
 *			lookup.
 * @bbt_md:		[REPLACEABLE] bad block table mirror descriptor
 * @badblock_pattern:	[REPLACEABLE] bad block scan pattern used for initial
 *			bad block scan.
 * @controller:		[REPLACEABLE] a pointer to a hardware controller
 *			structure which is shared among multiple independent
 *			devices.
 * @priv:		[OPTIONAL] pointer to private chip data
 * @write_page:		[REPLACEABLE] High-level page write function
 *//**
 * nand_get_sdr_timings - get SDR timing from data interface
 * @conf:	The data interface
 *//**
 * struct nand_data_interface - NAND interface timing
 * @type:	type of the timing
 * @timings:	The timing, type according to @type
 *//**
 * enum nand_data_interface_type - NAND interface timing type
 * @NAND_SDR_IFACE:	Single Data Rate interface
 *//**
 * struct nand_sdr_timings - SDR NAND chip timings
 *
 * This struct defines the timing requirements of a SDR NAND chip.
 * These information can be found in every NAND datasheets and the timings
 * meaning are described in the ONFI specifications:
 * www.onfi.org/~/media/ONFI/specs/onfi_3_1_spec.pdf (chapter 4.15 Timing
 * Parameters)
 *
 * All these timings are expressed in picoseconds.
 *
 * @tBERS_max: Block erase time
 * @tCCS_min: Change column setup time
 * @tPROG_max: Page program time
 * @tR_max: Page read time
 * @tALH_min: ALE hold time
 * @tADL_min: ALE to data loading time
 * @tALS_min: ALE setup time
 * @tAR_min: ALE to RE# delay
 * @tCEA_max: CE# access time
 * @tCEH_min: CE# high hold time
 * @tCH_min:  CE# hold time
 * @tCHZ_max: CE# high to output hi-Z
 * @tCLH_min: CLE hold time
 * @tCLR_min: CLE to RE# delay
 * @tCLS_min: CLE setup time
 * @tCOH_min: CE# high to output hold
 * @tCS_min: CE# setup time
 * @tDH_min: Data hold time
 * @tDS_min: Data setup time
 * @tFEAT_max: Busy time for Set Features and Get Features
 * @tIR_min: Output hi-Z to RE# low
 * @tITC_max: Interface and Timing Mode Change time
 * @tRC_min: RE# cycle time
 * @tREA_max: RE# access time
 * @tREH_min: RE# high hold time
 * @tRHOH_min: RE# high to output hold
 * @tRHW_min: RE# high to WE# low
 * @tRHZ_max: RE# high to output hi-Z
 * @tRLOH_min: RE# low to output hold
 * @tRP_min: RE# pulse width
 * @tRR_min: Ready to RE# low (data only)
 * @tRST_max: Device reset time, measured from the falling edge of R/B# to the
 *	      rising edge of R/B#.
 * @tWB_max: WE# high to SR[6] low
 * @tWC_min: WE# cycle time
 * @tWH_min: WE# high hold time
 * @tWHR_min: WE# high to RE# low
 * @tWP_min: WE# pulse width
 * @tWW_min: WP# transition to WE# low
 *//**
 * struct nand_buffers - buffer structure for read/write
 * @ecccalc:	buffer pointer for calculated ECC, size is oobsize.
 * @ecccode:	buffer pointer for ECC read from flash, size is oobsize.
 * @databuf:	buffer pointer for data, size is (page size + oobsize).
 *
 * Do not change the order of buffers. databuf and oobrbuf must be in
 * consecutive order.
 *//**
 * struct nand_ecc_ctrl - Control structure for ECC
 * @mode:	ECC mode
 * @algo:	ECC algorithm
 * @steps:	number of ECC steps per page
 * @size:	data bytes per ECC step
 * @bytes:	ECC bytes per step
 * @strength:	max number of correctible bits per ECC step
 * @total:	total number of ECC bytes per page
 * @prepad:	padding information for syndrome based ECC generators
 * @postpad:	padding information for syndrome based ECC generators
 * @options:	ECC specific options (see NAND_ECC_XXX flags defined above)
 * @layout:	ECC layout control struct pointer
 * @priv:	pointer to private ECC control data
 * @hwctl:	function to control hardware ECC generator. Must only
 *		be provided if an hardware ECC is available
 * @calculate:	function for ECC calculation or readback from ECC hardware
 * @correct:	function for ECC correction, matching to ECC generator (sw/hw).
 *		Should return a positive number representing the number of
 *		corrected bitflips, -EBADMSG if the number of bitflips exceed
 *		ECC strength, or any other error code if the error is not
 *		directly related to correction.
 *		If -EBADMSG is returned the input buffers should be left
 *		untouched.
 * @read_page_raw:	function to read a raw page without ECC. This function
 *			should hide the specific layout used by the ECC
 *			controller and always return contiguous in-band and
 *			out-of-band data even if they're not stored
 *			contiguously on the NAND chip (e.g.
 *			NAND_ECC_HW_SYNDROME interleaves in-band and
 *			out-of-band data).
 * @write_page_raw:	function to write a raw page without ECC. This function
 *			should hide the specific layout used by the ECC
 *			controller and consider the passed data as contiguous
 *			in-band and out-of-band data. ECC controller is
 *			responsible for doing the appropriate transformations
 *			to adapt to its specific layout (e.g.
 *			NAND_ECC_HW_SYNDROME interleaves in-band and
 *			out-of-band data).
 * @read_page:	function to read a page according to the ECC generator
 *		requirements; returns maximum number of bitflips corrected in
 *		any single ECC step, 0 if bitflips uncorrectable, -EIO hw error
 * @read_subpage:	function to read parts of the page covered by ECC;
 *			returns same as read_page()
 * @write_subpage:	function to write parts of the page covered by ECC.
 * @write_page:	function to write a page according to the ECC generator
 *		requirements.
 * @write_oob_raw:	function to write chip OOB data without ECC
 * @read_oob_raw:	function to read chip OOB data without ECC
 * @read_oob:	function to read chip OOB data
 * @write_oob:	function to write chip OOB data
 *//* a shorthand to generate struct nand_ecc_caps with only one ECC stepsize *//**
 * struct nand_ecc_caps - capability of ECC engine
 * @stepinfos: array of ECC step information
 * @nstepinfos: number of ECC step information
 * @calc_ecc_bytes: driver's hook to calculate ECC bytes per step
 *//**
 * struct nand_ecc_step_info - ECC step information of ECC engine
 * @stepsize: data bytes per ECC step
 * @strengths: array of supported strengths
 * @nstrengths: number of supported strengths
 *//**
 * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
 * @lock:               protection lock
 * @active:		the mtd device which holds the controller currently
 * @wq:			wait queue to sleep on if a NAND operation is in
 *			progress used instead of the per chip wait queue
 *			when a hw controller is available.
 *//* CRC for Parameter Page *//* vendor *//* reserved *//* ECC and endurance block *//* electrical parameter block *//* memory organization block *//* manufacturer information block *//* 'J' 'E' 'S' 'D'  *//* rev info and features block *//* JEDEC features *//*
	 * The actual size of the Extended Parameter Page is in
	 * @ext_param_page_length of nand_onfi_params{}.
	 * The following are the variable length sections.
	 * So we do not add any fields below. Please see the ONFI spec.
	 *//* 'E' 'P' 'P' 'S' *//* Extended Parameter Page Definition (since ONFI 2.1) *//* for ECC information. *//* for additional sections. *//* Unused section. *//* Extended ECC information Block Definition (since ONFI 2.1) *//* since ONFI 2.1 *//* 'O' 'N' 'F' 'I'  *//* ONFI optional commands SET/GET FEATURES supported? *//* ONFI subfeature parameters length *//* Vendor-specific feature address (Micron) *//* ONFI feature address *//* ONFI timing mode, used in both asynchronous and synchronous mode *//* ONFI features *//* Cell info constants *//* Nand scan has allocated controller struct *//* bbt has already been read *//* Options set by nand scan *//*
 * This option could be defined by controller drivers to protect against
 * kmap'ed, vmalloc'ed highmem buffers being passed from upper layers
 *//*
 * Autodetect nand buswidth with readid/onfi.
 * This suppose the driver will configure the hardware in 8 bits mode
 * when calling nand_scan_ident, and update its configuration
 * before calling nand_scan_tail.
 *//* Chip may not exist, so silence any errors in scan *//*
 * This option is defined if the board driver allocates its own buffers
 * (e.g. because it needs them DMA-coherent).
 *//* This option skips the bbt scan during initialization. *//* Non chip related options *//* Macros to identify the above *//* Options valid for Samsung large page devices *//* Device needs 3rd row address cycle *//*
 * Some MLC NANDs need data scrambling to limit bitflips caused by repeated
 * patterns.
 *//* Device supports subpage reads *//* Device behaves just like nand, but is readonly *//* Device is one of 'new' xD cards that expose fake nand command set *//* Chip does not allow subpage writes *//*
 * Chip requires ready check on read (for auto-incremented sequential read).
 * True only for small page devices; large page devices do not support
 * autoincrement.
 *//* Chip has copy back function *//* Chip has cache program function *//* Device supports partial programming without padding *//* Buswidth is 16 bit *//*
 * Option constants for bizarre disfunctionality and real
 * features.
 *//* Bit mask for flags passed to do_nand_read_ecc *//*
 * If your controller already sends the required NAND commands when
 * reading or writing a page, then the framework is not supposed to
 * send READ0 and SEQIN/PAGEPROG respectively.
 *//*
 * Enable generic NAND 'page erased' check. This check is only done when
 * ecc.correct() returns -EBADMSG.
 * Set this flag if your implementation does not fix bitflips in erased
 * pages and you want to rely on the default implementation.
 *//* Enable Hardware ECC before syndrome is read back from flash *//* Reset Hardware ECC for write *//* Reset Hardware ECC for read *//*
 * Constants for Hardware ECC
 *//*
 * Constants for ECC_MODES
 *//* Status bits *//* multi-bank error status (banks 0-3) *//*
 * Note: the command for NAND_CMD_DEPLETE1 is really 0x00 but
 *       there is no way to distinguish that from NAND_CMD_READ0
 *       until the remaining sequence of commands has been completed
 *       so add a high order bit and mask it off in the command.
 *//* Extended commands for AG-AND device *//* Extended commands for large page devices *//*
 * Standard NAND flash commands
 *//* Select the address latch by setting ALE to high *//* Select the command latch by setting CLE to high *//* Select the chip by setting nCE to low *//*
 * Constants for hardware specific CLE/ALE/NCE function
 *
 * These are bits which can be or'ed to set/clear multiple
 * bits in one go.
 *//*
 * This constant declares the max. oobsize / page, which
 * is supported now. If you add a chip with bigger oobsize/page
 * adjust this accordingly.
 *//* Internal helper for board drivers which need to override command function *//* Free resources held by the NAND device *//*
 * Separate phases of nand_scan(), allowing board driver to intervene
 * and override command or ECC setup according to flash type.
 *//* Scan and identify a NAND device *//* Get the flash and manufacturer id and lookup if the type is supported. *//*
 *  Copyright  2000-2010 David Woodhouse <dwmw2@infradead.org>
 *                        Steven J. Hill <sjhill@realitydiluted.com>
 *		          Thomas Gleixner <tglx@linutronix.de>
 *
 * Info:
 *	Contains standard defines and IDs for NAND flash devices
 *
 * Changelog:
 *	See git changelog.
 */force_8bitoffset_in_pagepageeraseblockchipnrdatalenecclenextraoobextraooblenthresholdtiming_modeallowbbtmax_chipsmaf_id/opt/src/include/nand.hnandget_nand_dev_by_indexsunxi_nand_initspl_nand_erase_onenand_bootnand_deselectnand_spl_read_blocknand_spl_load_imagenand_get_lock_statusnand_unlocknand_locknand_verifynand_verify_page_oobnand_torturenand_erase_optsconst nand_erase_options_tconst nand_erase_options_t *nand_erase_options *nand_write_skip_badnand_read_skip_badnand_erasenand_block_isbadnand_writenand_readboard_nand_initnand_mtd_to_devnumnand_sizenand_initnand_erase_options_tnand_erase_optionsmtd_oob_ops_tlimspreadjffs2quietNAND_LOCK_STATUS_UNLOCKNAND_LOCK_STATUS_TIGHTWITH_WR_VERIFYWITH_DROP_FFS_NAND_H_defined(CONFIG_NAND_FSL_ELBC) || defined(CONFIG_NAND_FSL_IFC)defined(CONFIG_NAND_FSL_ELBC) || defined(CONFIG_NAND_ATMEL)\CONFIG_SYS_NAND_SELF_INITCONFIG_SYS_NAND_SELECT_DEVICECONFIG_ENV_OFFSET_OOBnand_curr_device/* _NAND_H_ *//*
 * get_nand_dev_by_index - Get the nand info based in index.
 *
 * @dev - index to the nand device.
 *
 * returns pointer to the nand device info structure or NULL on failure.
 *//* platform specific init functions *//*"ENV0" in little-endian -- offset is
					stored as byte number *//*"EVB0" in little-endian -- offset is stored
				    as block number*//* verify data was written correctly *//* drop trailing all-0xff pages *//* maximum size that actual may be in order to not exceed the buf *//* Don't include skipped bad blocks in size to be erased *//* if true, really clean NAND by erasing
				 * bad blocks (UNSAFE) *//* if true: format for jffs2 usage
				 * (write appropriate cleanmarker blocks) *//* don't display progress messages *//* first address in NAND to erase *//* number of bytes to erase *//*****************************************************************************
 * declarations from nand_util.c
 ****************************************************************************//*
 * All boards using a given driver must convert to self-init
 * at the same time, so do it here.  When all drivers are
 * converted, this will go away.
 *//*
 * (C) Copyright 2005
 * 2N Telekomunikace, a.s. <www.2n.cz>
 * Ladislav Michl <michl@2n.cz>
 */<linux/mtd/rawnand.h>allexcepttightoptsactual/opt/src/include/linux/ctype.hctype__toupperislower(c)'a''A''a'-'A'__tolowerisupper(c)-32'A'-'a'toupper(c)__toupper(c)tolower(c)__tolower(c)toascii(c)(((unsigned char)(c))&0x7f)isascii(c)(((unsigned char)(c))<=0x7f)isblank(c)(c == ' ' || c == '\t')isxdigit(c)((__ismask(c)&(_D|_X)) != 0)((__ismask(c)&(_U)) != 0)isspace(c)((__ismask(c)&(_S)) != 0)ispunct(c)((__ismask(c)&(_P)) != 0)isprint(c)((__ismask(c)&(_P|_U|_L|_D|_SP)) != 0)((__ismask(c)&(_L)) != 0)isgraph(c)((__ismask(c)&(_P|_U|_L|_D)) != 0)isdigit(c)((__ismask(c)&(_D)) != 0)iscntrl(c)((__ismask(c)&(_C)) != 0)isalpha(c)((__ismask(c)&(_U|_L)) != 0)isalnum(c)((__ismask(c)&(_U|_L|_D)) != 0)__ismask(x)(_ctype[(int)(unsigned char)(x)])_SP_X_S_P_C_D_L_U_LINUX_CTYPE_H_ctype/*
 * Rather than doubling the size of the _ctype lookup table to hold a 'blank'
 * flag, just check for space or tab.
 *//* hard space (0x20) *//* hex digit *//* white space (space/lf/tab) *//* punct *//* cntrl *//* digit *//* lower *//* upper *//*
 * NOTE! This ctype does not handle EOF like the standard C
 * library is required to.
 *//opt/src/include/u-boot/zlib.hzlibgzfreegzallocinflateInit2_adler32const Bytefconst Bytef *inflateResetinflateEndinflateinflateInit_deflateCopydeflateBounddeflateTunedeflateParamsdeflatePrimedeflateSetHeaderdeflateSetDictionarydeflateResetdeflateInit2_deflateEnddeflateInit_deflategz_header *gz_header_s *gz_headerpgz_headergz_header_sz_stream *z_stream_s *z_streampz_streamz_stream_sinternal_stateBytef *cb_funcfree_funcalloc_funcvoidpvoidpfvoidpcuLongfuIntfintfcharfBytefuLonguIntBytehcrccomm_maxcommentname_maxextra_maxextra_lenextraxflagsadleroutcbdata_typeopaquezfreezallocinternal_state *total_outavail_outnext_outtotal_inavail_innext_ininflateInit2(strm,windowBits)inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))inflateInit(strm)inflateInit_((strm), ZLIB_VERSION, sizeof(z_stream))Z_NULL(void *)0Z_DEFLATEDZ_UNKNOWNZ_ASCIIZ_TEXTZ_BINARYZ_DEFAULT_STRATEGYZ_FIXEDZ_RLEZ_HUFFMAN_ONLYZ_FILTEREDZ_DEFAULT_COMPRESSIONZ_BEST_COMPRESSIONZ_BEST_SPEEDZ_NO_COMPRESSIONZ_VERSION_ERROR(-6)Z_BUF_ERROR(-5)Z_MEM_ERROR(-4)Z_DATA_ERRORZ_STREAM_ERRORZ_ERRNOZ_NEED_DICTZ_STREAM_ENDZ_OKZ_BLOCKZ_FINISHZ_FULL_FLUSHZ_SYNC_FLUSHZ_PARTIAL_FLUSHZ_NO_FLUSHz_off_tFARZEXPORTVAZEXPORTZEXTERNOF(args)MAX_WBITSMAX_MEM_LEVELSTDC99STDCZLIB_VERNUM0x1230ZLIB_VERSION"1.2.3"ZLIB_HZ_PREFIXdefined(__MSDOS__) && !defined(MSDOS)(defined(OS_2) || defined(__OS2__)) && !defined(OS2)defined(_WINDOWS) && !defined(WINDOWS)defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)(defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)!defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)SYS16BITMSDOS__STDC_VERSION__ >= 199901L!defined(STDC) && (defined(__STDC__) || defined(__cplusplus))!defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))!defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))!defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))defined(__OS400__) && !defined(STDC)defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)MAXSEG_64KOFdefined(M_I86SM) || defined(M_I86MM)(defined(__SMALL__) || defined(__MEDIUM__))defined(WINDOWS) || defined(WIN32)ZLIB_DLLdefined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))ZLIB_INTERNALZLIB_WINAPIdefined (__BEOS__)!defined(__MACTYPES__)SMALL_MEDIUMVMSdefined(__OS400__)defined(__MVS__)!defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)(z_streamp strm, int windowBits, const char *version, int stream_size)(uInt crc, const Bytef *buf, uInt len)(uLong adler, const Bytef *buf, uInt len)(z_streamp strm)(z_streamp strm, int flush)(z_streamp strm, const char *version, int stream_size)(z_streamp dest, z_streamp source)(z_streamp strm, uLong sourceLen)(z_streamp strm, int good_length, int max_lazy, int nice_length, int max_chain)(z_streamp strm, int level, int strategy)(z_streamp strm, int bits, int value)(z_streamp strm, gz_headerp head)(z_streamp strm, const Bytef *dictionary, uInt dictLength)(z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)(z_streamp strm, int level, const char *version, int stream_size)(Bytef *buf, uInt len)(voidpf opaque, voidpf address, uInt size)(voidpf opaque, uInt items, uInt size)/* ZLIB_H *//* hack for buggy compilers *//*
     Update a running CRC-32 with the bytes buf[0..len-1] and return the
   updated CRC-32. If buf is NULL, this function returns the required initial
   value for the for the crc. Pre- and post-conditioning (one's complement) is
   performed within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*//*
     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.
*//*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*//*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level and memory usage,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*//* utility functions *//* Advanced functions *//*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*//*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce
  some output latency (reading input without producing any output) except when
  forced to flush.

  The detailed semantics are as follows. inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
  Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
  output as possible to the output buffer. Z_BLOCK requests that inflate() stop
  if and when it gets to the next deflate block boundary. When decoding the
  zlib or gzip format, this will cause inflate() to return immediately after
  the header and before the first block. When doing a raw inflate, inflate()
  will go ahead and process the first block, and will return when it gets to
  the end of that block, or when it runs out of data.

    The Z_BLOCK option assists in appending to or combining deflate streams.
  Also to assist in this, on return inflate() will set strm->data_type to the
  number of unused bits in the last byte taken from strm->next_in, plus 64
  if inflate() is currently decoding the last block in the deflate stream,
  plus 128 if inflate() returned immediately after decoding an end-of-block
  code or decoding the complete header up to just before the first byte of the
  deflate stream. The end-of-block will not be indicated until all of the
  uncompressed data from that block has been written to strm->next_out.  The
  number of unused bits may in general be greater than seven, except when
  bit 7 of data_type is set, in which case the number of unused bits will be
  less than eight.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster approach
  may be used for the single inflate() call.

     In this implementation, inflate() always flushes as much output as
  possible to the output buffer, and always uses the faster approach on the
  first call. So the only effect of the flush parameter in this implementation
  is on the return value of inflate(), as noted below, or when it returns early
  because Z_BLOCK is used.

     If a preset dictionary is needed after this call (see inflateSetDictionary
  below), inflate sets strm->adler to the adler32 checksum of the dictionary
  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
  strm->adler to the adler32 checksum of all output produced so far (that is,
  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
  below. At the end of the stream, inflate() checks that its computed adler32
  checksum is equal to that saved by the compressor and returns Z_STREAM_END
  only if the checksum is correct.

    inflate() will decompress and check either zlib-wrapped or gzip-wrapped
  deflate data.  The header type is detected automatically.  Any information
  contained in the gzip header is not retained, so applications that need that
  information should instead use raw inflate, see inflateInit2() below, or
  inflateBack() and perform their own processing of the gzip header and
  trailer.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect check
  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
  if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
  output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
  inflate() can be called again with more input and more output space to
  continue decompressing. If Z_DATA_ERROR is returned, the application may then
  call inflateSync() to look for a good compression block if a partial recovery
  of the data is desired.
*//* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
   *//* basic functions *//* for initializing zalloc, zfree, opaque *//* The deflate compression method (the only one supported in this version) *//* Possible values of the data_type field (though see inflate()) *//* for compatibility with 1.2.2 and earlier *//* compression strategy; see deflateInit2() below for details *//* compression levels *//* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 *//* Allowed flush values; see deflate() and inflate() below for details *//* will be removed, use Z_SYNC_FLUSH instead *//* constants *//* true when done reading gzip header (not used
			when writing a gzip file) *//* true if there was or will be a header crc *//* space at comment (only when reading header) *//* pointer to zero-terminated comment or Z_NULL *//* space at name (only when reading header) *//* pointer to zero-terminated file name or Z_NULL *//* space at extra (only when reading header) *//* extra field length (valid if extra != Z_NULL) *//* pointer to extra field or Z_NULL if none *//* operating system *//* extra flags (not used when writing a gzip file) *//* modification time *//* true if compressed data believed to be text *//*
     gzip header information passed to and from zlib routines.  See RFC 1952
  for more details on the meanings of these fields.
*//* reserved for future use *//* adler32 value of the uncompressed data *//* called regularly just before blocks of output *//* best guess about the data type:
					binary or text *//* private data object passed to zalloc and zfree *//* used to free the internal state *//* used to allocate the internal state *//* not visible by applications *//* last error message, NULL if no error *//* total nb of bytes output so far *//* remaining free space at next_out *//* next output byte should be put there *//* total nb of input bytes read so far *//* number of bytes available at next_in *//* next input byte *//*
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms will be added later and will have the same
  stream interface.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The compressed data format used by default by the in-memory functions is
  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
  around a deflate stream, which is itself documented in RFC 1951.

     The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio using the functions that start
  with "gz".  The gzip format is different from the zlib format.  gzip is a
  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.

     This library can optionally read and write gzip streams in memory as well.

     The zlib format was designed to be compact and fast for use in memory
  and on communications channels.  The gzip format was designed for single-
  file compression on file systems, has a larger header than zlib to maintain
  directory information, and uses a different, slower check method than zlib.

     The library does not install any signal handler. The decoder checks
  the consistency of the compressed data, so the library should never
  crash even in case of corrupted input.
*//* End of new zconf.h *//* MVS linker does not support external names larger than 8 bytes *//* Set file pointer to EOF plus "offset" *//* for off_t *//* Borland C/C++ and some old MSC versions ignore FAR inside typedef *//* 32 bits or more *//* 16 bits or more *//* For complete Windows compatibility, use WINAPI, not __stdcall. *//* No need for _export, use ZLIB.DEF instead. *//* If building or using zlib with the WINAPI/WINAPIV calling convention,
    * define ZLIB_WINAPI.
    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
    *//* ZLIB_DLL *//* If building or using zlib as a DLL, define ZLIB_DLL.
    * This is not mandatory, but it offers a little performance increase.
    *//* Turbo C small or medium model *//* MSC small or medium model *//* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 *//* function prototypes *//* Type declarations *//* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*//* 32K LZ77 window *//* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 *//* Maximum value for memLevel in deflateInit2 *//* Some Mac compilers merge all .h files incorrectly: *//* note: need a more gentle solution here *//* cannot use !defined(STDC) && !defined(const) on Mac *//* iSeries (formerly AS/400). *//*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 *//*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 *//* Begin of new zconf.h *//* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-2005 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 *//* included directly here *//* #include "zconf.h" *//* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.2.3, July 18th, 2005

  Copyright (C) 1995-2005 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*//*
  * ==FILEVERSION 960122==
  *
  * This marker is used by the Linux installation script to determine
  * whether an up-to-date version of this file is already installed.
  *//*
 * This file is derived from zlib.h and zconf.h from the zlib-1.2.3
 * distribution by Jean-loup Gailly and Mark Adler, with some additions
 * by Paul Mackerras to aid in implementing Deflate compression and
 * decompression for PPP packets.
 *//opt/src/include/u-bootu-bootstrmwindowBitsstream_sizesourceLengood_lengthmax_lazynice_lengthmax_chainstrategydictionarydictLengthmethodmemLevel/opt/src/cmd/bootm.cimage_info
## Checking Image at %08lx ...
"\n## Checking Image at %08lx ...\n"IMAGE_FORMAT_ANDROID   Android image found
"   Android image found\n"const andr_img_hdrconst andr_img_hdr *andr_img_hdr *IMAGE_FORMAT_FIT   FIT image found
"   FIT image found\n"Bad FIT image format!
"Bad FIT image format!\n"Bad hash in FIT image!
"Bad hash in FIT image!\n"Unknown image format!
"Unknown image format!\n"do_iminfodo_bootdbootcmd"bootcmd"bootm_maybe_autostartepautostart"autostart"yes"yes"local_argsAutomatic boot of image at addr 0x%08lX ...
"Automatic boot of image at addr 0x%08lX ...\n"do_bootm'#'BOOTM_STATE_STARTBOOTM_STATE_FINDOSBOOTM_STATE_START |
		BOOTM_STATE_FINDOSBOOTM_STATE_FINDOTHERBOOTM_STATE_START |
		BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHERBOOTM_STATE_LOADOSBOOTM_STATE_START |
		BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |
		BOOTM_STATE_LOADOSBOOTM_STATE_OS_PREPBOOTM_STATE_START |
		BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |
		BOOTM_STATE_LOADOS |
#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH
		BOOTM_STATE_RAMDISK |
#endif
#if defined(CONFIG_PPC) || defined(CONFIG_MIPS)
		BOOTM_STATE_OS_CMDLINE |
#endif
		BOOTM_STATE_OS_PREP783BOOTM_STATE_START |
		BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |
		BOOTM_STATE_LOADOS |
#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH
		BOOTM_STATE_RAMDISK |
#endif
#if defined(CONFIG_PPC) || defined(CONFIG_MIPS)
		BOOTM_STATE_OS_CMDLINE |
#endif
		BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO1807BOOTM_STATE_START |
		BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |
		BOOTM_STATE_LOADOS |
#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH
		BOOTM_STATE_RAMDISK |
#endif
#if defined(CONFIG_PPC) || defined(CONFIG_MIPS)
		BOOTM_STATE_OS_CMDLINE |
#endif
		BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |
		BOOTM_STATE_OS_GOdo_bootm_subcommandcmd_tbl_t[8]cmd_tbl_s[8]cmd_bootm_sub448ARRAY_SIZE(cmd_bootm_sub)BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHERTrying to execute a command out of order
"Trying to execute a command out of order\n"char[42]iminfo"print header information for application image""addr [addr ...]\n" "    - print header information for application image starting at\n" "      address 'addr' in memory; this includes verification of the\n" "      image contents (magic number, header and payload checksums)"U_BOOT_CMD(
	iminfo,	CONFIG_SYS_MAXARGS,	1,	do_iminfo,
	"print header information for application image",
	"addr [addr ...]\n"
	"    - print header information for application image starting at\n"
	"      address 'addr' in memory; this includes verification of the\n"
	"      image contents (magic number, header and payload checksums)"
)print header information for application imagechar[47]addr [addr ...]
    - print header information for application image starting at
      address 'addr' in memory; this includes verification of the
      image contents (magic number, header and payload checksums)"addr [addr ...]\n"
	"    - print header information for application image starting at\n"
	"      address 'addr' in memory; this includes verification of the\n"
	"      image contents (magic number, header and payload checksums)"char[213]<u-boot/zlib.h><linux/ctype.h><nand.h><environment.h><bootm.h>_u_boot_list_2_cmd_2_iminfo.u_boot_list_2_cmd_2_iminfobootd"boot default, i.e., run 'bootcmd'"boot default, i.e., run 'bootcmd'U_BOOT_CMD(
	bootd, 1,	1,	do_bootd,
	"boot default, i.e., run 'bootcmd'",
	""
)_u_boot_list_2_cmd_2_bootd.u_boot_list_2_cmd_2_bootdU_BOOT_CMD(
	boot,	1,	1,	do_bootd,
	"boot default, i.e., run 'bootcmd'",
	""
)_u_boot_list_2_cmd_2_boot.u_boot_list_2_cmd_2_boot"boot application image from memory"bootm_help_textU_BOOT_CMD(
	bootm,	CONFIG_SYS_MAXARGS,	1,	do_bootm,
	"boot application image from memory", bootm_help_text
)boot application image from memorychar[1171]_u_boot_list_2_cmd_2_bootm.u_boot_list_2_cmd_2_bootm[addr [arg ...]]
    - boot application image stored in memory
	passing arguments 'arg ...'; when booting a Linux kernel,
	'arg' can be the address of an initrd image
	When booting a Linux kernel which requires a flat device-tree
	a third argument is required which is the address of the
	device-tree blob. To boot that kernel without an initrd image,
	use a '-' for the second argument. If you do not pass a third
	a bd_info struct will be passed instead
	
For the new multi component uImage format (FIT) addresses
	must be extended to include component or configuration unit name:
	addr:<subimg_uname> - direct component image specification
	addr#<conf_uname>   - configuration specification
	Use iminfo command to get the list of existing component
	images and configurations.

Sub-commands to do part of the bootm sequence.  The sub-commands must be
issued in the order below (it's ok to not issue all sub-commands):
	start [addr [arg ...]]
	loados  - load OS image
	fdt     - relocate flat device tree
	cmdline - OS specific command line processing/setup
	bdt     - OS specific bd_t processing
	prep    - OS specific prep before relocation or go
	go      - start OS(void *)BOOTM_STATE_START(void *)(0x00000001)loados(void *)BOOTM_STATE_LOADOS(void *)(0x00000008)(void *)BOOTM_STATE_FDT(void *)(0x00000020)(void *)BOOTM_STATE_OS_CMDLINE(void *)(0x00000040)bdt(void *)BOOTM_STATE_OS_BD_T(void *)(0x00000080)prep(void *)BOOTM_STATE_OS_PREP(void *)(0x00000100)fake(void *)BOOTM_STATE_OS_FAKE_GO(void *)(0x00000200)(void *)BOOTM_STATE_OS_GO(void *)(0x00000400)U_BOOT_CMD_MKENT(start, 0, 1, (void *)BOOTM_STATE_START, "", "")(void *)BOOTM_STATE_START, "", "")U_BOOT_CMD_MKENT(loados, 0, 1, (void *)BOOTM_STATE_LOADOS, "", "")(void *)BOOTM_STATE_LOADOS, "", "")U_BOOT_CMD_MKENT(fdt, 0, 1, (void *)BOOTM_STATE_FDT, "", "")(void *)BOOTM_STATE_FDT, "", "")U_BOOT_CMD_MKENT(cmdline, 0, 1, (void *)BOOTM_STATE_OS_CMDLINE, "", "")(void *)BOOTM_STATE_OS_CMDLINE, "", "")U_BOOT_CMD_MKENT(bdt, 0, 1, (void *)BOOTM_STATE_OS_BD_T, "", "")(void *)BOOTM_STATE_OS_BD_T, "", "")U_BOOT_CMD_MKENT(prep, 0, 1, (void *)BOOTM_STATE_OS_PREP, "", "")(void *)BOOTM_STATE_OS_PREP, "", "")U_BOOT_CMD_MKENT(fake, 0, 1, (void *)BOOTM_STATE_OS_FAKE_GO, "", "")(void *)BOOTM_STATE_OS_FAKE_GO, "", "")U_BOOT_CMD_MKENT(go, 0, 1, (void *)BOOTM_STATE_OS_GO, "", "")(void *)BOOTM_STATE_OS_GO, "", "")defined(CONFIG_CMD_IMI)defined(CONFIG_CMD_IMLS)defined(CONFIG_CMD_IMLS) || defined(CONFIG_CMD_IMLS_NAND)CONFIG_SYS_BOOT_RAMDISK_HIGHCONFIG_OF_LIBFDTdefined(CONFIG_PPC) || defined(CONFIG_MIPS)defined(CONFIG_OF_LIBFDT)defined(CONFIG_FIT)defined(CONFIG_SYS_BOOT_RAMDISK_HIGH)defined(CONFIG_TRACE)defined(CONFIG_CMD_BOOTD)defined(CONFIG_LEGACY_IMAGE_FORMAT)defined(CONFIG_ANDROID_BOOT_IMAGE)defined(CONFIG_CMD_IMLS_NAND)/*******************************************************************//* imls - list all images found in flash *//* iminfo - print header info for a requested image *//* keep old command name "bootd" for backward compatibility *//* bootd - boot default image *//* endp pointing to NULL means that argv[0] was just a
		 * valid number, pass it along to the normal bootm processing
		 *
		 * If endp is ':' or '#' assume a FIT identifier so pass
		 * along for normal processing.
		 *
		 * Right now we assume the first arg should never be '-'
		 *//* determine if we have a sub command *//* relocate names of sub-command table *//* bootm - boot application image from image in memory *//* Unrecognized command *//* we overload the cmd field with our state machine info instead of a
 * function pointer *//* info for FLASH chips *//opt/src/cmd/bootstage.cdo_boostagecmd_tbl_t[3]cmd_tbl_s[3]cmd_bootstage_subARRAY_SIZE(cmd_bootstage_sub)do_bootstage_stash-1ULNo bootstage stash area defined
"No bootstage stash area defined\n"stash"stash"get_base_sizeCONFIG_BOOTSTAGE_STASH_ADDR16534CONFIG_BOOTSTAGE_STASH_SIZEdo_bootstage_report"Boot stage command"" - check boot progress and timing\n" "report                      - Print a report\n" "stash [<start> [<size>]]    - Stash data into memory\n" "unstash [<start> [<size>]]  - Unstash data from memory"Boot stage command - check boot progress and timing
report                      - Print a report
stash [<start> [<size>]]    - Stash data into memory
unstash [<start> [<size>]]  - Unstash data from memory" - check boot progress and timing\n"
	"report                      - Print a report\n"
	"stash [<start> [<size>]]    - Stash data into memory\n"
	"unstash [<start> [<size>]]  - Unstash data from memory"char[187]U_BOOT_CMD(bootstage, 4, 1, do_boostage,
	"Boot stage command",
	" - check boot progress and timing\n"
	"report                      - Print a report\n"
	"stash [<start> [<size>]]    - Stash data into memory\n"
	"unstash [<start> [<size>]]  - Unstash data from memory"
)_u_boot_list_2_cmd_2_bootstage.u_boot_list_2_cmd_2_bootstagereportunstashU_BOOT_CMD_MKENT(report, 2, 1, do_bootstage_report, "", "")U_BOOT_CMD_MKENT(stash, 4, 0, do_bootstage_stash, "", "")U_BOOT_CMD_MKENT(unstash, 4, 0, do_bootstage_stash, "", "")/* Strip off leading 'bootstage' command argument *//*
 * Process a bootstage sub-command
 *//*
 * Copyright (c) 2012, Google Inc. All rights reserved.
 *//opt/src/cmd/bootz.cbootzdo_bootzIH_OS_LINUX768BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO1792BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |
			      BOOTM_STATE_OS_GObootz_start"*  kernel: default image load address = 0x%08lx\n"debug("*  kernel: default image load address = 0x%08lx\n",
				load_addr)cmd/bootz.c*  kernel: default image load address = 0x%08lx
"*  kernel: cmdline image address = 0x%08lx\n"images->epdebug("*  kernel: cmdline image address = 0x%08lx\n",
			images->ep)*  kernel: cmdline image address = 0x%08lx
Your platform's zImage format isn't supported yet!
"Your platform's zImage format isn't supported yet!\n""boot Linux zImage image from memory"bootz_help_textU_BOOT_CMD(
	bootz,	CONFIG_SYS_MAXARGS,	1,	do_bootz,
	"boot Linux zImage image from memory", bootz_help_text
)boot Linux zImage image from memorychar[520]_u_boot_list_2_cmd_2_bootz.u_boot_list_2_cmd_2_bootz[addr [initrd[:size]] [fdt]]
    - boot Linux zImage stored in memory
	The argument 'initrd' is optional and specifies the address
	of the initrd in memory. The optional argument ':size' allows
	specifying the size of RAW initrd.
	When booting a Linux kernel which requires a flat device-tree
	a third argument is required which is the address of the
	device-tree blob. To boot that kernel without an initrd image,
	use a '-' for the second argument. If you do not pass a third
	a bd_info struct will be passed instead
/*
	 * We are doing the BOOTM_STATE_LOADOS state ourselves, so must
	 * disable interrupts ourselves
	 *//* Consume 'bootz' *//*
	 * Handle the BOOTM_STATE_FINDOTHER state ourselves as we do not
	 * have a header that provide this informaiton.
	 *//* Setup Linux kernel zImage entry point *//*
 * zImage booting support
 *//* Please define bootz_setup() for your platform */<lmb.h>/opt/src/include/btrfs.hbtrfsbtrfs_list_subvolsbtrfs_uuidbtrfs_closebtrfs_readbtrfs_sizebtrfs_existsbtrfs_lsbtrfs_probe__U_BOOT_BTRFS_H__/* __U_BOOT_BTRFS_H__ *//*
 * BTRFS filesystem implementation for U-Boot
 *
 * 2017 Marek Behun, CZ.NIC, marek.behun@nic.cz
 *//opt/src/include/fs.hfsdo_fs_typedo_fs_uuiddo_lndo_mkdirdo_rmdo_savefile_existsdo_lsdo_loaddo_sizefs_mkdirfs_unlinkfs_closedirfs_dir_stream *fs_dirent *fs_readdirfs_opendirfs_writefs_readfs_sizefs_existsfs_lsfs_get_type_namefs_set_blk_dev_with_partfs_set_blk_devfs_dir_streamfs_direntFS_DT_LNKFS_DT_REGFS_DT_DIRFS_TYPE_BTRFSFS_TYPE_UBIFSFS_TYPE_SANDBOXFS_TYPE_EXTFS_TYPE_FATFS_TYPE_ANY_FS_H/* _FS_H *//*
 * Determine the type of the specified filesystem and print it. Optionally it is
 * possible to store the type directly in env.
 *//*
 * Determine the UUID of the specified filesystem and print it. Optionally it is
 * possible to store the UUID directly in env.
 *//*
 * Common implementation for various filesystem commands, optionally limited
 * to a specific filesystem type via the fstype parameter.
 *//*
 * fs_mkdir - Create a directory
 *
 * @filename: Name of directory to create
 * @return 0 on success, -1 on error conditions
 *//*
 * fs_unlink - delete a file or directory
 *
 * If a given name is a directory, it will be deleted only if it's empty
 *
 * @filename: Name of file or directory to delete
 * @return 0 on success, -1 on error conditions
 *//*
 * fs_closedir - close a directory stream
 *
 * @dirs: the directory stream
 *//*
 * fs_readdir - Read the next directory entry in the directory stream.
 *
 * Works in an analogous way to posix readdir().  The previously returned
 * directory entry is no longer valid after calling fs_readdir() again.
 * After fs_closedir() is called, the returned directory entry is no
 * longer valid.
 *
 * @dirs: the directory stream
 * @return the next directory entry (only valid until next fs_readdir() or
 *    fs_closedir() call, do not attempt to free()) or NULL if the end of
 *    the directory is reached.
 *//*
 * fs_opendir - Open a directory
 *
 * @filename: the path to directory to open
 * @return a pointer to the directory stream or NULL on error and errno
 *    set appropriately
 *//* private to fs. layer: *//* Note: fs_dir_stream should be treated as opaque to the user of fs layer *//* size in bytes *//* one of FS_DT_x (not a mask) *//*
 * A directory entry, returned by fs_readdir().  Returns information
 * about the file/directory at the current directory entry position.
 *//* symbolic link *//* regular file *//* directory *//*
 * Directory entry types, matches the subset of DT_x in posix readdir()
 * which apply to u-boot.
 *//**
 * fs_write() - write file to the partition previously set by fs_set_blk_dev()
 *
 * Note that not all filesystem drivers support offset != 0.
 *
 * @filename:	full path of the file to write to
 * @addr:	address of the buffer to read from
 * @offset:	offset in the file from where to start writing
 * @len:	the number of bytes to write
 * @actwrite:	returns the actual number of bytes written
 * Return:	0 if OK with valid *actwrite, -1 on error conditions
 *//**
 * fs_read() - read file from the partition previously set by fs_set_blk_dev()
 *
 * Note that not all filesystem drivers support either or both of offset != 0
 * and len != 0.
 *
 * @filename:	full path of the file to read from
 * @addr:	address of the buffer to write to
 * @offset:	offset in the file from where to start reading
 * @len:	the number of bytes to read. Use 0 to read entire file.
 * @actread:	returns the actual number of bytes read
 * Return:	0 if OK with valid *actread, -1 on error conditions
 *//*
 * fs_size - Determine a file's size
 *
 * @filename: Name of the file
 * @size: Size of file
 * @return 0 if ok with valid *size, negative on error
 *//*
 * Determine whether a file exists
 *
 * Returns 1 if the file exists, 0 if it doesn't exist.
 *//*
 * Print the list of files on the partition previously set by fs_set_blk_dev(),
 * in directory "dirname".
 *
 * Returns 0 on success. Returns non-zero on error.
 *//**
 * fs_get_type_name() - Get type of current filesystem
 *
 * Return: Pointer to filesystem name
 *
 * Returns a string describing the current filesystem, or the sentinel
 * "unsupported" for any unrecognised filesystem.
 *//*
 * fs_set_blk_dev_with_part - Set current block device + partition
 *
 * Similar to fs_set_blk_dev(), but useful for cases where you already
 * know the blk_desc and part number.
 *
 * Returns 0 on success.
 * Returns non-zero if invalid partition or error accessing the disk.
 *//*
 * Tell the fs layer which block device an partition to use for future
 * commands. This also internally identifies the filesystem that is present
 * within the partition. The identification process may be limited to a
 * specific filesystem type by passing FS_* in the fstype parameter.
 *
 * Returns 0 on success.
 * Returns non-zero if there is an error accessing the disk or partition, or
 * no known filesystem type could be recognized on it.
 *//*
 * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 */fstypedev_typedev_partfilenamedirsactwriteactreaddev_part_str/opt/src/cmd/btrfs.cdo_btrsubvolbtrsubvol"list subvolumes of a BTRFS filesystem""<interface> <dev[:part]>\n" "     - List subvolumes of a BTRFS filesystem."list subvolumes of a BTRFS filesystem<interface> <dev[:part]>
     - List subvolumes of a BTRFS filesystem."<interface> <dev[:part]>\n"
	"     - List subvolumes of a BTRFS filesystem."char[71]U_BOOT_CMD(btrsubvol, 3, 1, do_btrsubvol,
	"list subvolumes of a BTRFS filesystem",
	"<interface> <dev[:part]>\n"
	"     - List subvolumes of a BTRFS filesystem."
)_u_boot_list_2_cmd_2_btrsubvol.u_boot_list_2_cmd_2_btrsubvol/*
 * 2017 by Marek Behun <marek.behun@nic.cz>
 */<fs.h><btrfs.h>/opt/src/include/cbfs.hcbfsfile_cbfs_readconst cbfs_cachenodeconst cbfs_cachenode *cbfs_cachenode *file_cbfs_typefile_cbfs_sizefile_cbfs_namefile_cbfs_find_uncachedfile_cbfs_findfile_cbfs_get_nextconst cbfs_cachenode **cbfs_cachenode **file_cbfs_get_firstconst cbfs_headerconst cbfs_header *cbfs_header *file_cbfs_get_headerfile_cbfs_initfile_cbfs_errorcbfs_cachenodecbfs_fileheadercbfs_headerCBFS_HEADER_MAGIC13307909790x4f524243cbfs_filetypeCBFS_TYPE_BOOTBLOCKCBFS_TYPE_CBFSHEADERCBFS_TYPE_STAGECBFS_TYPE_PAYLOADCBFS_TYPE_FITCBFS_TYPE_OPTIONROMCBFS_TYPE_BOOTSPLASHCBFS_TYPE_RAWCBFS_TYPE_VSACBFS_TYPE_MBICBFS_TYPE_MICROCODECBFS_TYPE_FSPCBFS_TYPE_MRCCBFS_TYPE_MMACBFS_TYPE_EFI0x63CBFS_TYPE_STRUCTCBFS_TYPE_CMOS_DEFAULT0xaaCBFS_TYPE_SPD0xabCBFS_TYPE_MRC_CACHE0xacCBFS_TYPE_CMOS_LAYOUT4260x01aacbfs_resultCBFS_SUCCESSCBFS_NOT_INITIALIZEDCBFS_BAD_HEADERCBFS_BAD_FILECBFS_FILE_NOT_FOUNDattributes_offsetname_lengthdata_lengthu32[2]boot_block_sizerom_size__CBFS_Hfile_cbfs_result/* __CBFS_H *//**
 * file_cbfs_read() - Read a file from CBFS into RAM
 *
 * @file:		A handle to the file to read.
 * @buffer:		Where to read it into memory.
 * @maxsize:		Maximum number of bytes to read
 *
 * @return If positive or zero, the number of characters read. If negative, an
 *	   error occurred.
 *//**
 * file_cbfs_type() - Get the type of a file in CBFS.
 *
 * @file:		The handle to the file.
 *
 * @return The type of the file, zero on error.
 *//**
 * file_cbfs_size() - Get the size of a file in CBFS.
 *
 * @file:		The handle to the file.
 *
 * @return The size of the file, zero on error.
 *//**
 * file_cbfs_name() - Get the name of a file in CBFS.
 *
 * @file:		The handle to the file.
 *
 * @return The name of the file, NULL on error.
 *//**
 * file_cbfs_find_uncached() - Find a file with a particular name in CBFS
 * without using the heap.
 *
 * @end_of_rom:		Points to the end of the ROM the CBFS should be read
 *                      from.
 * @name:		The name to search for.
 *
 * @return A handle to the file, or NULL on error.
 *//***************************************************************************//* All of the functions below can be used without first initializing CBFS. *//**
 * file_cbfs_find() - Find a file with a particular name in CBFS.
 *
 * @name:		The name to search for.
 *
 * @return A handle to the file, or NULL on error.
 *//**
 * file_cbfs_get_next() - Get a handle to the file after this one in CBFS.
 *
 * @file:		A pointer to the handle to advance.
 *//**
 * file_cbfs_get_first() - Get a handle for the first file in CBFS.
 *
 * @return A handle for the first file in CBFS, NULL on error.
 *//**
 * file_cbfs_get_header() - Get the header structure for the current CBFS.
 *
 * @return A pointer to the constant structure, or NULL if there is none.
 *//**
 * file_cbfs_init() - Initialize the CBFS driver and load metadata into RAM.
 *
 * @end_of_rom: Points to the end of the ROM the CBFS should be read
 *                      from.
 *//**
 * file_cbfs_error() - Return a string describing the most recent error
 * condition.
 *
 * @return A pointer to the constant string.
 *//* offset to struct cbfs_file_attribute or 0 *//**
 * struct cbfs_header - header at the start of a CBFS region
 *
 * All fields use big-endian format.
 *
 * @magic: Magic number (CBFS_HEADER_MAGIC)
 *//*
 * Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
 */<compiler.h>end_of_rom/opt/src/cmd/cbfs.cdo_cbfs_fsinfo%s.
"%s.\n"CBFS version: %#x
"CBFS version: %#x\n"ROM size: %#x
"ROM size: %#x\n"Boot block size: %#x
"Boot block size: %#x\n"CBFS size: %#x
"CBFS size: %#x\n"Alignment: %d
"Alignment: %d\n"Offset: %#x
"Offset: %#x\n"do_cbfs_ls     size              type  name
"     size              type  name\n"------------------------------------------
"------------------------------------------\n"type_name %8d" %8d"bootblock"bootblock"cbfs header"cbfs header"stage"stage""payload""fit"option rom"option rom"boot splash"boot splash"vsa"vsa"mbi"mbi"microcode"microcode"fsp"fsp"mrc"mrc"mma"mma""efi"struct"struct"cmos default"cmos default"spd"spd"mrc cache"mrc cache"cmos layout"cmos layout""null"  %16s"  %16s"  %16d"  %16d"(empty)"(empty)"files
%d file(s)

"\n%d file(s)\n\n"do_cbfs_fsloadusage: cbfsload <addr> <filename> [bytes]
"usage: cbfsload <addr> <filename> [bytes]\n"%s: %s
"%s: %s\n"reading %s
"reading %s\n"<cbfs.h>
%ld bytes read
"\n%ld bytes read\n"do_cbfs_initusage: cbfsls [end of rom]>
"usage: cbfsls [end of rom]>\n"0xffffffff
** Invalid end of ROM **
"\n** Invalid end of ROM **\n"cbfsinfo"print information about filesystem""    - print information about the cbfs filesystem\n"print information about filesystem    - print information about the cbfs filesystem
U_BOOT_CMD(
	cbfsinfo,	1,	1,	do_cbfs_fsinfo,
	"print information about filesystem",
	"    - print information about the cbfs filesystem\n"
)_u_boot_list_2_cmd_2_cbfsinfo.u_boot_list_2_cmd_2_cbfsinfocbfsls"list files""    - list the files in the cbfs\n"list files    - list the files in the cbfs
U_BOOT_CMD(
	cbfsls,	1,	1,	do_cbfs_ls,
	"list files",
	"    - list the files in the cbfs\n"
)_u_boot_list_2_cmd_2_cbfsls.u_boot_list_2_cmd_2_cbfslscbfsload"load binary file from a cbfs filesystem""<addr> <filename> [bytes]\n" "    - load binary file 'filename' from the cbfs to address 'addr'\n"load binary file from a cbfs filesystem<addr> <filename> [bytes]
    - load binary file 'filename' from the cbfs to address 'addr'
"<addr> <filename> [bytes]\n"
	"    - load binary file 'filename' from the cbfs to address 'addr'\n"char[93]U_BOOT_CMD(
	cbfsload,	4,	0,	do_cbfs_fsload,
	"load binary file from a cbfs filesystem",
	"<addr> <filename> [bytes]\n"
	"    - load binary file 'filename' from the cbfs to address 'addr'\n"
)_u_boot_list_2_cmd_2_cbfsload.u_boot_list_2_cmd_2_cbfsloadcbfsinit"initialize the cbfs driver""[end of rom]\n" "    - Initialize the cbfs driver. The optional 'end of rom'\n" "      parameter specifies where the end of the ROM is that the\n" "      CBFS is in. It defaults to 0xFFFFFFFF\n"initialize the cbfs driver[end of rom]
    - Initialize the cbfs driver. The optional 'end of rom'
      parameter specifies where the end of the ROM is that the
      CBFS is in. It defaults to 0xFFFFFFFF
"[end of rom]\n"
	"    - Initialize the cbfs driver. The optional 'end of rom'\n"
	"      parameter specifies where the end of the ROM is that the\n"
	"      CBFS is in. It defaults to 0xFFFFFFFF\n"char[181]U_BOOT_CMD(
	cbfsinit,	2,	0,	do_cbfs_init,
	"initialize the cbfs driver",
	"[end of rom]\n"
	"    - Initialize the cbfs driver. The optional 'end of rom'\n"
	"      parameter specifies where the end of the ROM is that the\n"
	"      CBFS is in. It defaults to 0xFFFFFFFF\n"
)_u_boot_list_2_cmd_2_cbfsinit.u_boot_list_2_cmd_2_cbfsinit/* parse offset and count *//*
 * CBFS commands
 *//opt/src/cmd/config_data_gz.hconfig_data_gzconst char[]     <r8JMS>U J8HIjl%? ) @gfoOmsc;&$/	y'WDd>}s6x?w?<;"O&Ng.7~RByy~/#+61-\<T3l~xrE|S*LD1I%uDiANY~=wh~D:$yu=QQ$KV&q,aLjYWDj(c#_qg
t{{l/~U>G#h9 A	jd>@k!eV{"JV\jD@ZZ`IL*^*&UY.D3I!k0W<-`(69\KOHzM+V-%t<[&tcig[*{r2"k`(R\(`-xyBt]Q.#-Z*NcE%@2?r)7l6p:tb1 L$$Qs(C"ZUBAeNJ m$mlTD)RXFHI=eKBo.HZK<Dd4e\T]Njr"|Dkc+C{NBu-?._"OD, '4eb($/J*/, ||kDtry>|ii39N[8%xHIF#5^{J1 cM,\PAzd $s7zxb2(Bv\5	P 2i=<He,>7Eu-PS_-mk0Uc<kx]ZdC:y&+9QGU0!V_*xPm}azVmm!:66%\XX`4Cj'Ea0chhaM?~X6. 
MOa#6&|^`	0)!dn\GLkI6:1U[=M2e$VzD-BL8*KMQ8
4Qul	nj
=	vQzsdfo`j`_N!XLoXNY)52)Q4_sWl?~N^_^^W{$'zy{zSX2) DLErUJ<kP-)k&0yb{zdvw[k
"	iv[8w )|&RV2bbgfrX50)6zz+Bf K_2V[K%vWrgG[Ff>H9e.(E`eC!%{04A{*	bA,L XQ/[V=Rr!n\M$L"9tD4-zg^0* f TdEO Bxe-pJ4"fIRtkj:Nlt84gK"9lnCp
H;u`3N6)h]YQ!IZu[[
=Z9(MRq
7 l`">6N/&w^P @pMQq W{cG:Ns	D;j!	slr1P	;rn* <`P.p7jk 63/ !aa#|1wJQ(YH	:0fMbj)6L:aiMq6"AVK4w%X	!W_a%D8%N9]nYc#vr^H*la`,$[sY!M_qetE%]SoZ@C&b#EFsVMav=N4%S8	EDnCnZ+g6!p>\'VU-Ssiy2h<@%6<qH23J;IT>\M~t\)'jekJ}(=PPa;\F&S*!%|3hHC VuP6*$w%l*a	ZK>y}O;,PV,Bh0qqze'cA)_-VmWOWL
5f| @8{w8AejF{SHJ !0-R"<;0Q 9m 5Iu*mqXuHM6J`xd\:gJ'g#,8I1*%3uc=aWX?_ : $Z*|`%!$f9q".g8!}DQBxGaq^:E=O)I<v|;{ZcO	t4P;c!Sc3!9	4?fkNH3!h88gy;<uZ3Yb!8ySc0qM,u4pV<4Ca&+gs,$Dy^x%!{%;TY3sx/ukb6t4>Oh<)YTzCtOfu((TxUkf6}i^].YjkLAUI0)pr6M; 9[q=%1SEx	$\5]yKI'xZ`n'QiDfk~l)"fskV1:7ffmIgfs]iXiQm|pwT`?PpOf4{|?[{|aAMhVjX6y|o4|:"`NfDA>6SGMib Z<"O 9Uz	8nwtWETY4#Vw&;|y;jq5,5i(du<yj'K|h"I"c[1]LF[pnD2eDoH htEjd!=J^[2*oxEE :A|x2$>plP2pBW[|;2fG$2{Z]i7d$sHe1Yl</at$oX~Dr&sfM!O
z6pMc|8YP->.*hc
G	mnccu,%%sPl	Uo#04|;|ZX(#R/gt^]m gT}LwFW,V;~tqil	 k8eu`}o!+73WoFZ)@S*PQXnuQ|tV=o"l""UIS_C9>o[ua]rzob-}7_7l,=PCeD WdJRVrvhuF33}{]nsxm9
I~MS`sVHTdM,o=xG2j.3 >!b6`D(!xr6Jb#b	fx|
GEi_%k\$ vzk:_\zPK'1wA?zl~|RnIkZJjxD0ej@_~5}4'zkcfk<jSpek[HXM#tRd)To	w]/QoLoZO5;};;:/>y 1` 69"*!NP7 9 58^Tev6<PFRNG 4c~7 B))wk:|In^O9f4t>Lak_WyJ0./x}%@5:YU$t-fvz/7W.]9zoD\q7f(fn>&Eo0*s$a7\O"|KD.D$_f<`< _JE M}g)ug46j"yI\1Y ^hPP:	xV@kqka<IvT,e<S ^A$9+9_M^zoY%GjN6	|P!G]A_`IcLp`gXa#9n>Pxco r }$")K\`he.fgK?NelWp!9T"^W@d]Bm> 	.[U9CWB	
#gHt|+t		dKkwYj/j&raZ8%;M9=il N[&%
n<L% ao<?!Q(1ab@`wuz[Xsu`t?_
lYbtlJnr4?/dpIza7$Y7>1	=TFl]VKSe N=`jE2L]"><A
x>hJ(WIcrGi0bq~i1G|l`"I_gW4	/...q&Ic\]]..7nbd_M5#mnVWKf:05?"[\]^#2R` iF12S
O?9dZ^z%,X8'#Y4>mCS+ R.cn,@;'?ze*P7v-m@=
Xrd="5zUb'!m6	);CJ_CDO-#9g4F(/dMllxj29>]m%:ae#|/.4mS!>R=>#>	veHdw)K4S2I$/,^cs|~7}V\;0,% @Xe`+p&XGW	zX-vE`:Hq[.)%Q0ou@2W!]Ri,\maOA
g.4t*i\dw
_:e\_RQ2inA,$qL=n}5^&(,Z`luTUCBljJ4M?]a`V?sJiyVE?Igl2Pv;>7`Ftu&+_'TuV;7*HYwk$:{++<vy-QOWcd<~n{N\
"aq p('[[y0Wr?(
=mb"y/47'&qROZ(H`%R<m}!y|@B%@q'sWH(z0=_!&%\mL{ 1AyAFOhJ{;<	iwwj)][@TUa)c|djS qBd?f"xuqvH[Doic+LPxVE6 kIy< )_=R<\4p]Z,bCV&(Z&}iA11vRx/V69P\ d-(aU[)1D5=b|o@PV"5bAG?}x	fUtj5QJyd`hH@+{db 9@s$[T<|sQoq
FX zU:bqT'	6~yT-W;?V)"/OL?/B,P;K&Ou,ZX7Bq/)_>A)9j(\3MY!nT$D+k=4iX7a!E*_H]97Ofq"*6mk;B[V#YN#}kO`6/dM	?F&S?{$&@<xd5DM7TNF	`B$E1?`q<b,	tF9df1czJ2aa=uf@pw:Iit
I)s u'd-|0f#GPr}x 	1S^,d]#Bp|m6YQyeX eH4'x=VY;29#>n^!hu$6C[|hldUcxt:1redk^3VND KP~Q(|P'a+t{Q+B7#R~lnObE03^D'zboF
nH1)jZ^i!qr"EiDJ{.2&,m5KmYlLUKS\HD&z>hSS(\*h!*ZE[QLzBt:,35d#?ul #)h#)rL\JnbJwf|`sIb#Fq{8N]gWU2(4HNmeY'`+e^ZK*]SgPrt]-e3OwI2T$br>GMwA*qwc>o\"K(LBj2^'@#|^%Rr YI8tzYC!4J-GfOX.C5d?j#C	Zr{w={7o3R&A>DP#F`lV2||W@u  char[8031]data_gz/opt/src/cmd/config_data_size.hconfig_data_size33141/opt/src/cmd/config.cdo_config33142data_size + 1const char[8031]failed to uncompress .config data
"failed to uncompress .config data\n""print .config"print .configU_BOOT_CMD(
	config, 1, 1, do_config,
	"print .config",
	""
)_u_boot_list_2_cmd_2_config.u_boot_list_2_cmd_2_config/*
 * Copyright (C) 2017 Masahiro Yamada <yamada.masahiro@socionext.com>
 */"config_data_size.h""config_data_gz.h"/opt/src/cmd/console.cconsoledo_coninfoList of available devices:
"List of available devices:\n"struct stdio_devlist_entry(pos, struct stdio_dev, list)%-8s %08x %c%c "%-8s %08x %c%c "'I''.''O'_do_coninfoconinfo"print console devices and information"print console devices and informationU_BOOT_CMD(
	coninfo,	3,	1,	do_coninfo,
	"print console devices and information",
	""
)_u_boot_list_2_cmd_2_coninfo.u_boot_list_2_cmd_2_coninfo/***************************************************//* Scan for valid output and input devices *//*
 * (C) Copyright 2000
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *//opt/src/include/cpu.hcpu_probe_allcpu_get_vendorcpu_get_countcpu_get_infocpu_info *cpu_get_desccpu_opscpu_infoCPU_FEAT_L1_CACHECPU_FEAT_MMUCPU_FEAT_UCODECPU_FEAT_DEVICE_IDCPU_FEAT_COUNTcpu_platdataget_vendorget_desccpu_freqtimebase_frequcode_versioncpu_idcpu_get_ops(dev)((struct cpu_ops *)(dev)->driver->ops)__CPU_H/**
 * cpu_probe_all() - Probe all available CPUs
 *
 * Return: 0 if OK, -ve on error
 *//**
 * cpu_get_vendor() - Get vendor name of a CPU
 * @dev:	Device to check (UCLASS_CPU)
 * @buf:	Buffer to place string
 * @size:	Size of string space
 *
 * Return: 0 if OK, -ENOSPC if buffer is too small, other -ve on error
 *//**
 * cpu_get_count() - Get number of CPUs
 * @dev:	Device to check (UCLASS_CPU)
 *
 * Return: CPU count if OK, -ve on error
 *//**
 * cpu_get_info() - Get information about a CPU
 * @dev:	Device to check (UCLASS_CPU)
 * @info:	Returns CPU info
 *
 * Return: 0 if OK, -ve on error
 *//**
 * cpu_get_desc() - Get a description string for a CPU
 * @dev:	Device to check (UCLASS_CPU)
 * @buf:	Buffer to place string
 * @size:	Size of string space
 *
 * Return: 0 if OK, -ENOSPC if buffer is too small, other -ve on error
 *//**
	 * get_vendor() - Get vendor name of a CPU
	 *
	 * @dev:	Device to check (UCLASS_CPU)
	 * @buf:	Buffer to place string
	 * @size:	Size of string space
	 * @return 0 if OK, -ENOSPC if buffer is too small, other -ve on error
	 *//**
	 * get_count() - Get number of CPUs
	 *
	 * @dev:	Device to check (UCLASS_CPU)
	 * @return CPU count if OK, -ve on error
	 *//**
	 * get_info() - Get information about a CPU
	 *
	 * @dev:	Device to check (UCLASS_CPU)
	 * @info:	Returns CPU info
	 * @return 0 if OK, -ve on error
	 *//**
	 * get_desc() - Get a description string for a CPU
	 *
	 * @dev:	Device to check (UCLASS_CPU)
	 * @buf:	Buffer to place string
	 * @size:	Size of string space
	 * @return 0 if OK, -ENOSPC if buffer is too small, other -ve on error
	 *//**
 * struct cpu_info - Information about a CPU
 *
 * @cpu_freq:	Current CPU frequency in Hz
 * @features:	Flags for supported CPU features
 *//* Provides a device ID *//* Requires/uses microcode *//* Supports virtual memory *//* Supports level 1 cache *//* CPU features - mostly just a placeholder for now *//**
 * struct cpu_platdata - platform data for a CPU
 * @cpu_id:	   Platform-specific way of identifying the CPU.
 * @ucode_version: Microcode version, if CPU_FEAT_UCODE is set
 * @device_id:     Driver-defined device identifier
 * @family:        DMTF CPU Family identifier
 * @id:            DMTF CPU Processor identifier
 * @timebase_freq: the current frequency at which the cpu timer timebase
 *		   registers are updated (in Hz)
 *
 * This can be accessed with dev_get_parent_platdata() for any UCLASS_CPU
 * device.
 *//opt/src/cmd/cpu.cdo_cpucmd_cpu_subARRAY_SIZE(cmd_cpu_sub)do_cpu_detaildo_cpu_listprint_cpu_listcpu_platdata *platsizeof(buf)%3d: %-10s %s
"%3d: %-10s %s\n"<no description>"<no description>"	(no detail available"\t(no detail available": err=%d": err=%d"	ID = %d, freq = "\tID = %d, freq = ": ": "1 << CPU_FEAT_UCODE(1 << CPU_FEAT_UCODE)	Microcode version %#x
"\tMicrocode version %#x\n"1 << CPU_FEAT_DEVICE_ID(1 << CPU_FEAT_DEVICE_ID)	Device ID %#lx
"\tDevice ID %#lx\n"UCLASS_CPU"display information about CPUs""list	- list available CPUs\n" "cpu detail	- show CPU detail"display information about CPUslist	- list available CPUs
cpu detail	- show CPU detail"list	- list available CPUs\n"
	"cpu detail	- show CPU detail"U_BOOT_CMD(
	cpu, 2, 1, do_cpu,
	"display information about CPUs",
	"list	- list available CPUs\n"
	"cpu detail	- show CPU detail"
)_u_boot_list_2_cmd_2_cpu.u_boot_list_2_cmd_2_cpudetailU_BOOT_CMD_MKENT(list, 2, 1, do_cpu_list, "", "")U_BOOT_CMD_MKENT(detail, 4, 0, do_cpu_detail, "", "")L1 cache"L1 cache"MMU"MMU"Microcode"Microcode"Device ID"Device ID"cpu_feature_name/* Strip off leading 'cpu' command argument *//*
 * Process a cpu sub-command
 *//*
 * Copyright (c) 2015 Google, Inc
 * Written by Simon Glass <sjg@chromium.org>
 * Copyright (c) 2017 lvaro Fernndez Rojas <noltari@gmail.com>
 */<cpu.h>/opt/src/include/cramfs/cramfs_fs.hcramfs_fscramfs_uncompress_exitcramfs_uncompress_initcramfs_uncompress_blockcramfs_supercramfs_infocramfs_inodefsidfutureeditionnamelenCRAMFS_SET_NAMELEN(x,y)((x)->namelen = (y))CRAMFS_SET_OFFSET(x,y)((x)->offset = (y))CRAMFS_GET_OFFSET(x)((x)->offset)CRAMFS_GET_NAMELEN(x)((x)->namelen)CRAMFS_32(x)CRAMFS_24(x)CRAMFS_16(x)CRAMFS_SUPPORTED_FLAGS( 0x000000ff | CRAMFS_FLAG_HOLES | CRAMFS_FLAG_WRONG_SIGNATURE | CRAMFS_FLAG_SHIFTED_ROOT_OFFSET )CRAMFS_FLAG_SHIFTED_ROOT_OFFSETCRAMFS_FLAG_WRONG_SIGNATURECRAMFS_FLAG_HOLESCRAMFS_FLAG_SORTED_DIRSCRAMFS_FLAG_FSID_VERSION_2CRAMFS_MAXPATHLEN(((1 << CRAMFS_NAMELEN_WIDTH) - 1) << 2)CRAMFS_OFFSET_WIDTHCRAMFS_NAMELEN_WIDTHCRAMFS_GID_WIDTHCRAMFS_SIZE_WIDTHCRAMFS_UID_WIDTHCRAMFS_MODE_WIDTHCRAMFS_SIGNATURE"Compressed ROMFS"CRAMFS_MAGIC0x28cd3d45__CRAMFS_H/* __CRAMFS_H *//* Uncompression interfaces to the underlying zlib *//*
 * Valid values in super.flags.	 Currently we refuse to mount
 * if (flags & ~CRAMFS_SUPPORTED_FLAGS).  Maybe that should be
 * changed to test super.future instead.
 *//* shifted root fs *//* support for holes *//* sorted dirs *//* fsid version #2 *//*
 * Feature flags
 *
 * 0x00000000 - 0x000000ff: features that work for all past kernels
 * 0x00000100 - 0xffffffff: features that don't work for past kernels
 *//* root inode data *//* user-defined name *//* unique filesystem info *//* "Compressed ROMFS" *//* feature flags *//* length in bytes *//* 0x28cd3d45 - random number *//*
 * Superblock information at the beginning of the FS.
 *//* OFFSET: For symlinks and non-empty regular files, this
	   contains the offset (divided by 4) of the file data in
	   compressed form (starting with an array of block pointers;
	   see README).	 For non-empty directories it is the offset
	   (divided by 4) of the inode of the first file in that
	   directory.  For anything else, offset is zero. *//* NAMELEN is the length of the file name, divided by 4 and
	   rounded up.	(cramfs doesn't support hard links.) *//* SIZE for device files is i_rdev *//*
 * Reasonably terse representation of the inode data.
 *//*
 * Since inode.namelen is a unsigned 6-bit number, the maximum cramfs
 * path length is 63 << 2 = 252.
 *//*
 * Width of various bitfields in struct cramfs_inode.
 * Primarily used to generate warnings in mkcramfs.
 *//* some random number *//opt/src/include/cramfscramfs/opt/src/cmd/cramfs.cdo_cramfs_lscramfsaddr"cramfsaddr"MTD_DEV_TYPE_NORmtdids *mtd_device *OFFSET_ADJUSTMENT"/"part_info *do_cramfs_loadbootfile"bootfile"uImage"uImage"offset_virt### CRAMFS load complete: %d bytes loaded to 0x%lx
"### CRAMFS load complete: %d bytes loaded to 0x%lx\n"### CRAMFS LOAD ERROR<%x> for %s!
"### CRAMFS LOAD ERROR<%x> for %s!\n"cramfs_lscramfs_loadcramfs_checkmkmodestr6144024576'f'4096049152'?'/opt/src/include/jffs2/jffs2.h/opt/src/include/jffs2/load_kernel.h/opt/src/include/linux/stat.h<linux/stat.h><cramfs/cramfs_fs.h><jffs2/load_kernel.h><jffs2/jffs2.h>'S''T'xwr"xwr"cramfsls"list files in a directory (default /)""[ directory ]\n" "    - list files in a directory.\n"list files in a directory (default /)[ directory ]
    - list files in a directory.
"[ directory ]\n"
	"    - list files in a directory.\n"U_BOOT_CMD(
	cramfsls,	2,	1,	do_cramfs_ls,
	"list files in a directory (default /)",
	"[ directory ]\n"
	"    - list files in a directory.\n"
)_u_boot_list_2_cmd_2_cramfsls.u_boot_list_2_cmd_2_cramfslscramfsload"load binary file from a filesystem image""[ off ] [ filename ]\n" "    - load binary file from address 'cramfsaddr'\n" "      with offset 'off'\n"load binary file from a filesystem image[ off ] [ filename ]
    - load binary file from address 'cramfsaddr'
      with offset 'off'
"[ off ] [ filename ]\n"
	"    - load binary file from address 'cramfsaddr'\n"
	"      with offset 'off'\n"U_BOOT_CMD(
	cramfsload,	3,	0,	do_cramfs_load,
	"load binary file from a filesystem image",
	"[ off ] [ filename ]\n"
	"    - load binary file from address 'cramfsaddr'\n"
	"      with offset 'off'\n"
)_u_boot_list_2_cmd_2_cramfsload.u_boot_list_2_cmd_2_cramfsloadDEBUGF(fmt,args...)DEBUG_CRAMFSCONFIG_MTD_NOR_FLASHCONFIG_FS_JFFS2/* command line only *//* fake the address offset *//* fake the device type *//* cramfs_* only supports NOR flash chips *//* hack! *//**
 * Routine implementing u-boot ls command which lists content of a given
 * directory at location 'cramfsaddr'.
 * cramfsaddr is an evironment variable.
 *
 * @param cmdtp command internal data
 * @param flag command flag
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 *//* pre-set Boot file name *//**
 * Routine implementing fsload u-boot command. This routine tries to load
 * a requested file from cramfs filesystem at location 'cramfsaddr'.
 * cramfsaddr is an evironment variable.
 *
 * @param cmdtp command internal data
 * @param flag command flag
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 *//* U-Boot commands				   *//* CONFIG_FS_JFFS2 *//* enable/disable debugging messages *//*
 * CRAMFS support
 *//*
 *
 * based on: cmd_jffs2.c
 *
 * 	Add support for a CRAMFS located in RAM
 */loadoffset/opt/src/cmd/cros_ec.cdo_cros_ec"init"Could not init cros_ec device (err %d)
"Could not init cros_ec device (err %d)\n"Cannot get cros-ec device (err=%d)
"Cannot get cros-ec device (err=%d)\n""id"char[257]sizeof(id)"%s: Could not read KBC ID\n"debug("%s: Could not read KBC ID\n", __func__)cmd/cros_ec.c%s: Could not read KBC ID
%s
"%s\n""info""%s: Could not read KBC info\n"debug("%s: Could not read KBC info\n", __func__)%s: Could not read KBC info
rows     = %u
"rows     = %u\n"cols     = %u
"cols     = %u\n"curimage"curimage""%s: Could not read KBC image\n"debug("%s: Could not read KBC image\n", __func__)%s: Could not read KBC image
%d
"%d\n""hash"4294967293"%s: Could not read KBC hash\n"debug("%s: Could not read KBC hash\n", __func__)%s: Could not read KBC hash
type:    SHA-256
"type:    SHA-256\n"type:    %d
"type:    %d\n"offset:  0x%08x
"offset:  0x%08x\n"size:    0x%08x
"size:    0x%08x\n"digest:  "digest:  "%02x"%02x"reboot"reboot"cold"cold""%s: Could not reboot KBC\n"debug("%s: Could not reboot KBC\n", __func__)%s: Could not reboot KBC
"events""%s: Could not read host events\n"debug("%s: Could not read host events\n", __func__)%s: Could not read host events
0x%08x
"0x%08x\n"clrevents"clrevents"0x7fffffff"%s: Could not clear host events\n"debug("%s: Could not clear host events\n", __func__)%s: Could not clear host events
"erase""%s: Could not read region info\n"debug("%s: Could not read region info\n", __func__)%s: Could not read region info
"%s: Could not erase region\n"debug("%s: Could not erase region\n",
				      __func__)%s: Could not erase region
regioninfo"regioninfo"Region: %s
"Region: %s\n"RO"RO"RW"RW"Offset: %x
"Offset: %x\n"Size:   %x
"Size:   %x\n"flashinfo"flashinfo"Flash size:         %u
"Flash size:         %u\n"Write block size:   %u
"Write block size:   %u\n"Erase block size:   %u
"Erase block size:   %u\n"vbnvcontext"vbnvcontext"vbnv_block: "vbnv_block: ""%s: Could not %s VbNvContext\n"__func__, argc <= 2 ? "read" : "write"debug("%s: Could not %s VbNvContext\n", __func__,
			      argc <= 2 ?  "read" : "write")%s: Could not %s VbNvContext
"test"Test failed with error %d
"Test failed with error %d\n"Test passed
"Test passed\n""version"build_stringRO version:    %1.*s
"RO version:    %1.*s\n"(int)sizeof(p->version_string_ro)RW version:    %1.*s
"RW version:    %1.*s\n"(int)sizeof(p->version_string_rw)Firmware copy: %s
"Firmware copy: %s\n"const char *const[3]ec_current_image_nameARRAY_SIZE(ec_current_image_name)?"?"Build info:    %s
"Build info:    %s\n"ldo"ldo"LDO%d: %s
"LDO%d: %s\n""on""off""%s: Could not access LDO%d\n"__func__, indexdebug("%s: Could not access LDO%d\n", __func__, index)349%s: Could not access LDO%d
Error: CROS-EC command failed (error %d)
"Error: CROS-EC command failed (error %d)\n"do_read_writeregion_size"%s: Could not %s region\n"__func__, is_write ? "write" : "read"debug("%s: Could not %s region\n", __func__,
		      is_write ? "write" : "read")%s: Could not %s region
cros_ec_decode_regionrw"rw"ro"ro""%s: Invalid region '%s'\n"__func__, *argvdebug("%s: Invalid region '%s'\n", __func__, *argv)const char[22]%s: Invalid region '%s'
"%s: Missing region parameter\n"debug("%s: Missing region parameter\n", __func__)%s: Missing region parameter
crosec"CROS-EC utility command""init                Re-init CROS-EC (done on startup automatically)\n" "crosec id                  Read CROS-EC ID\n" "crosec info                Read CROS-EC info\n" "crosec curimage            Read CROS-EC current image\n" "crosec hash                Read CROS-EC hash\n" "crosec reboot [rw | ro | cold]  Reboot CROS-EC\n" "crosec events              Read CROS-EC host events\n" "crosec clrevents [mask]    Clear CROS-EC host events\n" "crosec regioninfo <ro|rw>  Read image info\n" "crosec flashinfo           Read flash info\n" "crosec erase <ro|rw>       Erase EC image\n" "crosec read <ro|rw> <addr> [<size>]   Read EC image\n" "crosec write <ro|rw> <addr> [<size>]  Write EC image\n" "crosec vbnvcontext [hexstring]        Read [write] VbNvContext from EC\n" "crosec ldo <idx> [<state>] Switch/Read LDO state\n" "crosec test                run tests on cros_ec\n" "crosec version             Read CROS-EC version"CROS-EC utility commandinit                Re-init CROS-EC (done on startup automatically)
crosec id                  Read CROS-EC ID
crosec info                Read CROS-EC info
crosec curimage            Read CROS-EC current image
crosec hash                Read CROS-EC hash
crosec reboot [rw | ro | cold]  Reboot CROS-EC
crosec events              Read CROS-EC host events
crosec clrevents [mask]    Clear CROS-EC host events
crosec regioninfo <ro|rw>  Read image info
crosec flashinfo           Read flash info
crosec erase <ro|rw>       Erase EC image
crosec read <ro|rw> <addr> [<size>]   Read EC image
crosec write <ro|rw> <addr> [<size>]  Write EC image
crosec vbnvcontext [hexstring]        Read [write] VbNvContext from EC
crosec ldo <idx> [<state>] Switch/Read LDO state
crosec test                run tests on cros_ec
crosec version             Read CROS-EC version"init                Re-init CROS-EC (done on startup automatically)\n"
	"crosec id                  Read CROS-EC ID\n"
	"crosec info                Read CROS-EC info\n"
	"crosec curimage            Read CROS-EC current image\n"
	"crosec hash                Read CROS-EC hash\n"
	"crosec reboot [rw | ro | cold]  Reboot CROS-EC\n"
	"crosec events              Read CROS-EC host events\n"
	"crosec clrevents [mask]    Clear CROS-EC host events\n"
	"crosec regioninfo <ro|rw>  Read image info\n"
	"crosec flashinfo           Read flash info\n"
	"crosec erase <ro|rw>       Erase EC image\n"
	"crosec read <ro|rw> <addr> [<size>]   Read EC image\n"
	"crosec write <ro|rw> <addr> [<size>]  Write EC image\n"
	"crosec vbnvcontext [hexstring]        Read [write] VbNvContext from EC\n"
	"crosec ldo <idx> [<state>] Switch/Read LDO state\n"
	"crosec test                run tests on cros_ec\n"
	"crosec version             Read CROS-EC version"char[856]U_BOOT_CMD(
	crosec,	6,	1,	do_cros_ec,
	"CROS-EC utility command",
	"init                Re-init CROS-EC (done on startup automatically)\n"
	"crosec id                  Read CROS-EC ID\n"
	"crosec info                Read CROS-EC info\n"
	"crosec curimage            Read CROS-EC current image\n"
	"crosec hash                Read CROS-EC hash\n"
	"crosec reboot [rw | ro | cold]  Reboot CROS-EC\n"
	"crosec events              Read CROS-EC host events\n"
	"crosec clrevents [mask]    Clear CROS-EC host events\n"
	"crosec regioninfo <ro|rw>  Read image info\n"
	"crosec flashinfo           Read flash info\n"
	"crosec erase <ro|rw>       Erase EC image\n"
	"crosec read <ro|rw> <addr> [<size>]   Read EC image\n"
	"crosec write <ro|rw> <addr> [<size>]  Write EC image\n"
	"crosec vbnvcontext [hexstring]        Read [write] VbNvContext from EC\n"
	"crosec ldo <idx> [<state>] Switch/Read LDO state\n"
	"crosec test                run tests on cros_ec\n"
	"crosec version             Read CROS-EC version"
)_u_boot_list_2_cmd_2_crosec.u_boot_list_2_cmd_2_crosec"unknown"/* Print versions *//*
			 * TODO(clchiou): Move this to a utility function as
			 * cmd_spi might want to call it.
			 *//* Remove any existing device *//**
 * Perform a flash read or write command
 *
 * @param dev		CROS-EC device to read/write
 * @param is_write	1 do to a write, 0 to do a read
 * @param argc		Number of arguments
 * @param argv		Arguments (2 is region, 3 is address)
 * @return 0 for ok, 1 for a usage error or -ve for ec command error
 *	(negative EC_RES_...)
 *//**
 * Decode a flash region parameter
 *
 * @param argc Number of params remaining
 * @param argv List of remaining parameters
 * @return flash region (EC_FLASH_REGION_...) or -1 on error
 *//* Note: depends on enum ec_current_image *//*
 * Chromium OS cros_ec driver
 *
 * Copyright (c) 2016 The Chromium OS Authors.
 * Copyright (c) 2016 National Instruments Corp
 */is_write/opt/src/include/bcd.hbcdbin2bcdbcd2bin_BCD_H/* _BCD_H *//* inline functions to translate to/from binary and binary-coded decimal
 * (frequently found in RTC chips).
 *//* Permission is hereby granted to copy, modify and redistribute this code
 * in terms of the GNU Library General Public License, Version 2 or later,
 * at your option.
 *//opt/src/include/rtc.hrtcrtc_month_daysrtc_mktimeconst rtc_timeconst rtc_time *rtc_to_tmrtc_calc_weekdayis_leap_year400rtc_write32rtc_read32rtc_write16rtc_read16rtc_write8rtc_read8dm_rtc_resetdm_rtc_setdm_rtc_getrtc_opswrite8read8rtc_get_ops(dev)((struct rtc_ops *)(dev)->driver->ops)_RTC_H_CONFIG_DM_RTC/* _RTC_H_ *//**
 * rtc_month_days() - The number of days in the month
 *
 * @month:	month (January = 0)
 * @year:	year (4 digits)
 *//**
 * rtc_mktime() - Convert a broken-out time into a time_t value
 *
 * The following fields need to be valid for this function to work:
 *	tm_sec, tm_min, tm_hour, tm_mday, tm_mon, tm_year
 *
 * Note that tm_wday and tm_yday are ignored.
 *
 * @time:	Broken-out time to convert
 * @return corresponding time_t value, seconds since 1970-01-01 00:00:00
 *//**
 * rtc_to_tm() - Convert a time_t value into a broken-out time
 *
 * The following fields are set up by this function:
 *	tm_sec, tm_min, tm_hour, tm_mday, tm_mon, tm_year, tm_wday
 *
 * Note that tm_yday and tm_isdst are set to 0.
 *
 * @time_t:	Number of seconds since 1970-01-01 00:00:00
 * @time:	Place to put the broken-out time
 *//**
 * rtc_calc_weekday() - Work out the weekday from a time
 *
 * This only works for the Gregorian calendar - i.e. after 1752 (in the UK).
 * It sets time->tm_wdaay to the correct day of the week.
 *
 * @time:	Time to inspect. tm_wday is updated
 * @return 0 if OK, -EINVAL if the weekday could not be determined
 *//**
 * is_leap_year - Check if year is a leap year
 *
 * @year	Year
 * @return	1 if leap year
 *//* CONFIG_DM_RTC *//**
 * rtc_init() - Set up the real time clock ready for use
 *//**
 * rtc_write32() - Write a 32-bit value to the RTC
 *
 * @reg:	Register to start writing to
 * @value:	Value to write
 *//**
 * rtc_read32() - Read a 32-bit value from the RTC
 *
 * @reg:	Offset to start reading from
 * @return value read
 *//**
 * rtc_write8() - Write an 8-bit register
 *
 * @reg:	Register to write
 * @value:	Value to write
 *//**
 * rtc_read8() - Read an 8-bit register
 *
 * @reg:	Register to read
 * @return value read
 *//**
 * rtc_write32() - Write a 32-bit value to the RTC
 *
 * @dev:	Device to write to
 * @reg:	Register to start writing to
 * @value:	Value to write
 * @return 0 if OK, -ve on error
 *//**
 * rtc_read32() - Read a 32-bit value from the RTC
 *
 * @dev:	Device to read from
 * @reg:	Offset to start reading from
 * @valuep:	Place to put the value that is read
 * @return 0 if OK, -ve on error
 *//**
 * rtc_write16() - Write a 16-bit value to the RTC
 *
 * @dev:	Device to write to
 * @reg:	Register to start writing to
 * @value:	Value to write
 * @return 0 if OK, -ve on error
 *//**
 * rtc_read16() - Read a 16-bit value from the RTC
 *
 * @dev:	Device to read from
 * @reg:	Offset to start reading from
 * @valuep:	Place to put the value that is read
 * @return 0 if OK, -ve on error
 *//**
 * rtc_write8() - Write an 8-bit register
 *
 * @dev:	Device to write to
 * @reg:	Register to write
 * @value:	Value to write
 * @return 0 if OK, -ve on error
 *//**
 * rtc_read8() - Read an 8-bit register
 *
 * @dev:	Device to read from
 * @reg:	Register to read
 * @return value read, or -ve on error
 *//**
 * dm_rtc_reset() - reset the RTC to a known-good state
 *
 * If the RTC appears to be broken (e.g. it is not counting up in seconds)
 * it may need to be reset to a known good state. This function achieves this.
 * After resetting the RTC the time should then be set to a known value by
 * the caller.
 *
 * @dev:	Device to read from
 * @return 0 if OK, -ve on error
 *//**
 * dm_rtc_set() - Write a time to an RTC
 *
 * @dev:	Device to read from
 * @time:	Time to write into the RTC
 * @return 0 if OK, -ve on error
 *//**
 * dm_rtc_get() - Read the time from an RTC
 *
 * @dev:	Device to read from
 * @time:	Place to put the current time
 * @return 0 if OK, -ve on error
 *//* Access the operations for an RTC device *//**
	* write8() - Write an 8-bit register
	*
	* @dev:		Device to write to
	* @reg:		Register to write
	* @value:	Value to write
	* @return 0 if OK, -ve on error
	*//**
	 * read8() - Read an 8-bit register
	 *
	 * @dev:	Device to read from
	 * @reg:	Register to read
	 * @return value read, or -ve on error
	 *//**
	 * reset() - reset the RTC to a known-good state
	 *
	 * This function resets the RTC to a known-good state. The time may
	 * be unset by this method, so should be set after this method is
	 * called.
	 *
	 * @dev:	Device to read from
	 * @return 0 if OK, -ve on error
	 *//**
	 * set() - set the current time
	 *
	 * Sets the time in the RTC device. The driver can expect every
	 * field to be set correctly.
	 *
	 * @dev:	Device to read from
	 * @time:	Time to write
	 *//**
	 * get() - get the current time
	 *
	 * Returns the current time read from the RTC device. The driver
	 * is responsible for setting up every field in the structure.
	 *
	 * @dev:	Device to read from
	 * @time:	Place to put the time that is read
	 *//* bcd<->bin functions are needed by almost all the RTC drivers, let's include
 * it there instead of in evey single driver *//*
 * Generic RTC interface.
 */<bcd.h>time_t/opt/src/include/i2c.hi2ci2c_emul_get_devicei2c_emul_findi2c_dump_msgsi2c_chip_ofdata_to_platdatadm_i2c_chip *i2c_get_chip_for_busnumi2c_get_chipi2c_deblocki2c_get_chip_offset_leni2c_set_chip_offset_leni2c_get_chip_flagsi2c_set_chip_flagsdm_i2c_get_bus_speeddm_i2c_set_bus_speeddm_i2c_xferdm_i2c_reg_writedm_i2c_reg_readdm_i2c_probedm_i2c_writedm_i2c_readi2c_mux_opsdm_i2c_opsi2c_msg_listdm_i2c_msg_flagsI2C_M_TENI2C_M_RDI2C_M_STOPI2C_M_NOSTARTI2C_M_REV_DIR_ADDRI2C_M_IGNORE_NAKI2C_M_NO_RD_ACKI2C_M_RECV_LENdm_i2c_busdm_i2c_chipdm_i2c_chip_flagsDM_I2C_CHIP_10BITDM_I2C_CHIP_RD_ADDRESSDM_I2C_CHIP_WR_ADDRESSdeselectdeblockget_bus_speedset_bus_speedprobe_chipxfermsgsmax_transaction_bytesspeed_hzchip_addri2c_mux_get_ops(dev)((struct i2c_mux_ops *)(dev)->driver->ops)i2c_get_ops(dev)((struct dm_i2c_ops *)(dev)->driver->ops)_I2C_H_CONFIG_SANDBOXCONFIG_DM_I2C!defined(CONFIG_SYS_I2C_MAX_HOPS)!defined(CONFIG_SYS_RTC_BUS_NUM)!defined(CONFIG_SYS_SPD_BUS_NUM)CONFIG_SYS_I2C_DIRECT_BUSI2C_SOFT_DECLARATIONS(defined(CONFIG_AT91RM9200) || \CONFIG_SYS_I2C_SLAVECONFIG_SYS_I2C_EARLY_INITCONFIG_SYS_I2Cdefined(CONFIG_SYS_I2C) || defined(CONFIG_I2C_MULTI_BUS)!defined(CONFIG_SYS_MAX_I2C_BUS)/* _I2C_H_ *//* !CONFIG_DM_I2C *//**
 * Reset the I2C bus represented by the given a FDT I2C node.
 *
 * @param blob  Device tree blbo
 * @param node  FDT I2C node to find
 * @return 0 if port was reset, -1 if not found
 *//**
 * Find the I2C bus number by given a FDT I2C node.
 *
 * @param blob  Device tree blbo
 * @param node  FDT I2C node to find
 * @return the number of I2C bus (zero based), or -1 on error
 *//**
 * Get FDT values for i2c bus.
 *
 * @param blob  Device tree blbo
 * @return the number of I2C bus
 *//* Multi I2C definitions *//* NOTE: These two functions MUST be always_inline to avoid code growth! *//*
 * only for backwardcompatibility, should go away if we switched
 * completely to new multibus support.
 *//* CONFIG_SYS_I2C *//*
 * i2c_get_bus_speed:
 *
 *  Returns speed of currently active I2C bus in Hz
 *//*
 * i2c_set_bus_speed:
 *
 *  Change the speed of the active I2C bus
 *
 *	speed - bus speed in Hz
 *
 *	Returns: 0 on success, not 0 on failure
 *
 *//*
 * i2c_get_bus_num:
 *
 *  Returns index of currently active I2C bus.  Zero-based.
 *//*
 * i2c_set_bus_num:
 *
 *  Change the active I2C bus.  Subsequent read/write calls will
 *  go to this one.
 *
 *	bus - bus index, zero based
 *
 *	Returns: 0 on success, not 0 on failure
 *
 *//*
 * Functions for setting the current I2C bus and its speed
 *//*
 * Utility routines to read/write registers.
 *//*
 * Read/Write interface:
 *   chip:    I2C chip address, range 0..127
 *   addr:    Memory (register) address within the chip
 *   alen:    Number of bytes to use for addr (typically 1, 2 for larger
 *              memories, 0 for register type devices with only one
 *              register)
 *   buffer:  Where to read/write the data
 *   len:     How many bytes to read/write
 *
 *   Returns: 0 on success, not 0 on failure
 *//*
 * Probe the given I2C chip address.  Returns 0 if a chip responded,
 * not 0 on failure.
 *//*
 * i2c_set_bus_speed:
 *
 *  Change the speed of the active I2C bus
 *
 *	speed - bus speed in Hz
 *
 *	Returns: new bus speed
 *
 *//*
 * i2c_init_all():
 *
 * Initializes all I2C adapters in the system. All i2c_adap structures must
 * be initialized beforehead with function pointers and data, including
 * speed and slaveaddr. Returns 0 on success, non-0 on failure.
 *//*
 * Initialization, must be called once on start up, may be called
 * repeatedly to change the speed and slave addresses.
 *//*
 * Many boards/controllers/drivers don't support an I2C slave interface so
 * provide a default slave address for them for use in common code.  A real
 * value for CONFIG_SYS_I2C_SLAVE should be defined for any board which does
 * support a slave interface.
 *//* define the I2C bus number for RTC and DTT if not already done *//* we use i2c muxes *//* no muxes used bus = i2c adapters *//* maximum tx/rx buffer length *//*
 * Configuration items.
 *//*
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 *
 * The implementation MUST NOT use static or global variables if the
 * I2C routines are used to read SDRAM configuration information
 * because this is done before the memories are initialized. Limited
 * use of stack-based variables are OK (the initial stack size is
 * limited).
 *
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
 *//**
 * i2c_emul_get_device() - Find the device being emulated
 *
 * Given an emulator this returns the associated device
 *
 * @emul: Emulator for the device
 * @return device that @emul is emulating
 *//**
 * i2c_emul_find() - Find an emulator for an i2c sandbox device
 *
 * This looks at the device's 'emul' phandle
 *
 * @dev: Device to find an emulator for
 * @emulp: Returns the associated emulator, if found *
 * @return 0 if OK, -ENOENT or -ENODEV if not found
 *//**
 * i2c_dump_msgs() - Dump a list of I2C messages
 *
 * This may be useful for debugging.
 *
 * @msg:	Message list to dump
 * @nmsgs:	Number of messages
 *//**
 * i2c_chip_ofdata_to_platdata() - Decode standard I2C platform data
 *
 * This decodes the chip address from a device tree node and puts it into
 * its dm_i2c_chip structure. This should be called in your driver's
 * ofdata_to_platdata() method.
 *
 * @blob:	Device tree blob
 * @node:	Node offset to read from
 * @spi:	Place to put the decoded information
 *//**
 * i2c_get_chip_for_busnum() - get a device to use to access a chip on
 *			       a bus number
 *
 * This returns the device for the given chip address on a particular bus
 * number.
 *
 * @busnum:	Bus number to examine
 * @chip_addr:	Chip address for the new device
 * @offset_len:	Length of a register offset in bytes (normally 1)
 * @devp:	Returns pointer to new device if found or -ENODEV if not
 *		found
 *//**
 * i2c_get_chip() - get a device to use to access a chip on a bus
 *
 * This returns the device for the given chip address. The device can then
 * be used with calls to i2c_read(), i2c_write(), i2c_probe(), etc.
 *
 * @bus:	Bus to examine
 * @chip_addr:	Chip address for the new device
 * @offset_len:	Length of a register offset in bytes (normally 1)
 * @devp:	Returns pointer to new device if found or -ENODEV if not
 *		found
 *//**
	 * deselect() - select one of of I2C buses attached to a mux
	 *
	 * This is used to deselect the currently selected I2C bus.
	 *
	 * @mux:	Mux device
	 * @bus:	I2C bus to deselect
	 * @channel:	Channel number correponding to the bus to deselect
	 * @return 0 if OK, -ve on error
	 *//**
	 * select() - select one of of I2C buses attached to a mux
	 *
	 * This will be called when there is no bus currently selected by the
	 * mux. This method does not need to deselect the old bus since
	 * deselect() will be already have been called if necessary.
	 *
	 * @mux:	Mux device
	 * @bus:	I2C bus to select
	 * @channel:	Channel number correponding to the bus to select
	 * @return 0 if OK, -ve on error
	 *//**
 * struct i2c_mux_ops - operations for an I2C mux
 *
 * The current mux state is expected to be stored in the mux itself since
 * it is the only thing that knows how to make things work. The mux can
 * record the current state and then avoid switching unless it is necessary.
 * So select() can be skipped if the mux is already in the correct state.
 * Also deselect() can be made a nop if required.
 *//**
	 * deblock() - recover a bus that is in an unknown state
	 *
	 * I2C is a synchronous protocol and resets of the processor in the
	 * middle of an access can block the I2C Bus until a powerdown of
	 * the full unit is done. This is because slaves can be stuck
	 * waiting for addition bus transitions for a transaction that will
	 * never complete. Resetting the I2C master does not help. The only
	 * way is to force the bus through a series of transitions to make
	 * sure that all slaves are done with the transaction. This method
	 * performs this 'deblocking' if support by the driver.
	 *
	 * This method is optional.
	 *//**
	 * set_flags() - set the flags for a chip (optional)
	 *
	 * This is generally implemented by the uclass, but drivers can
	 * check the value to ensure that unsupported options are not used.
	 * This method is optional. If provided, this method will always be
	 * called when the flags change.
	 *
	 * @dev:	Chip to adjust
	 * @flags:	New flags value
	 * @return 0 if OK, -EINVAL if value is unsupported
	 *//**
	 * get_bus_speed() - get the speed of a bus (optional)
	 *
	 * Normally this can be provided by the uclass, but if you want your
	 * driver to check the bus speed by looking at the hardware, you can
	 * implement that here. This method is optional. This method would
	 * normally be expected to return dev_get_uclass_priv(bus)->speed_hz.
	 *
	 * @bus:	Bus to check
	 * @return speed of selected I2C bus in Hz, -ve on error
	 *//**
	 * set_bus_speed() - set the speed of a bus (optional)
	 *
	 * The bus speed value will be updated by the uclass if this function
	 * does not return an error. This method is optional - if it is not
	 * provided then the driver can read the speed from
	 * dev_get_uclass_priv(bus)->speed_hz
	 *
	 * @bus:	Bus to adjust
	 * @speed:	Requested speed in Hz
	 * @return 0 if OK, -EINVAL for invalid values
	 *//**
	 * probe_chip() - probe for the presense of a chip address
	 *
	 * This function is optional. If omitted, the uclass will send a zero
	 * length message instead.
	 *
	 * @bus:	Bus to probe
	 * @chip_addr:	Chip address to probe
	 * @chip_flags:	Probe flags (enum dm_i2c_chip_flags)
	 * @return 0 if chip was found, -EREMOTEIO if not, -ENOSYS to fall back
	 * to default probem other -ve value on error
	 *//**
	 * xfer() - transfer a list of I2C messages
	 *
	 * @bus:	Bus to read from
	 * @msg:	List of messages to transfer
	 * @nmsgs:	Number of messages in the list
	 * @return 0 if OK, -EREMOTEIO if the slave did not ACK a byte,
	 *	-ECOMM if the speed cannot be supported, -EPROTO if the chip
	 *	flags cannot be supported, other -ve value on some other error
	 *//**
 * struct dm_i2c_ops - driver operations for I2C uclass
 *
 * Drivers should support these operations unless otherwise noted. These
 * operations are intended to be used by uclass code, not directly from
 * other code.
 *//**
 * i2c_deblock() - recover a bus that is in an unknown state
 *
 * See the deblock() method in 'struct dm_i2c_ops' for full information
 *
 * @bus:	Bus to recover
 * @return 0 if OK, -ve on error
 *//**
 * i2c_get_offset_len() - get the offset length for a chip
 *
 * @return:	Current offset length value (typically 1 or 2)
 *//**
 * i2c_set_offset_len() - set the offset length for a chip
 *
 * The offset used to access a chip may be up to 4 bytes long. Typically it
 * is only 1 byte, which is enough for chips with 256 bytes of memory or
 * registers. The default value is 1, but you can call this function to
 * change it.
 *
 * @offset_len:	New offset length value (typically 1 or 2)
 *//**
 * i2c_get_chip_flags() - get flags for a chip
 *
 * @dev:	Chip to check
 * @flagsp:	Place to put flags
 * @return 0 if OK, other -ve value on error
 *//**
 * i2c_set_chip_flags() - set flags for a chip
 *
 * Typically addresses are 7 bits, but for 10-bit addresses you should set
 * flags to DM_I2C_CHIP_10BIT. All accesses will then use 10-bit addressing.
 *
 * @dev:	Chip to adjust
 * @flags:	New flags
 * @return 0 if OK, -EINVAL if value is unsupported, other -ve value on error
 *//**
 * dm_i2c_get_bus_speed() - get the speed of a bus
 *
 * @bus:	Bus to check
 * @return speed of selected I2C bus in Hz, -ve on error
 *//**
 * dm_i2c_set_bus_speed() - set the speed of a bus
 *
 * @bus:	Bus to adjust
 * @speed:	Requested speed in Hz
 * @return 0 if OK, -EINVAL for invalid values
 *//**
 * dm_i2c_xfer() - Transfer messages over I2C
 *
 * This transfers a raw message. It is best to use dm_i2c_reg_read/write()
 * instead.
 *
 * @dev:	Device to use for transfer
 * @msg:	List of messages to transfer
 * @nmsgs:	Number of messages to transfer
 * @return 0 on success, -ve on error
 *//**
 * dm_i2c_reg_write() - Write a value to an I2C register
 *
 * This writes a single value to the given address in an I2C chip
 *
 * @dev:	Device to use for transfer
 * @addr:	Address to write to
 * @val:	Value to write (normally a byte)
 * @return 0 on success, -ve on error
 *//**
 * dm_i2c_reg_read() - Read a value from an I2C register
 *
 * This reads a single value from the given address in an I2C chip
 *
 * @dev:	Device to use for transfer
 * @addr:	Address to read from
 * @return value read, or -ve on error
 *//**
 * dm_i2c_probe() - probe a particular chip address
 *
 * This can be useful to check for the existence of a chip on the bus.
 * It is typically implemented by writing the chip address to the bus
 * and checking that the chip replies with an ACK.
 *
 * @bus:	Bus to probe
 * @chip_addr:	7-bit address to probe (10-bit and others are not supported)
 * @chip_flags:	Flags for the probe (see enum dm_i2c_chip_flags)
 * @devp:	Returns the device found, or NULL if none
 * @return 0 if a chip was found at that address, -ve if not
 *//**
 * dm_i2c_write() - write bytes to an I2C chip
 *
 * See notes for dm_i2c_read() above.
 *
 * @dev:	Chip to write to
 * @offset:	Offset within chip to start writing
 * @buffer:	Buffer containing data to write
 * @len:	Number of bytes to write
 *
 * @return 0 on success, -ve on failure
 *//**
 * dm_i2c_read() - read bytes from an I2C chip
 *
 * To obtain an I2C device (called a 'chip') given the I2C bus address you
 * can use i2c_get_chip(). To obtain a bus by bus number use
 * uclass_get_device_by_seq(UCLASS_I2C, <bus number>).
 *
 * To set the address length of a devce use i2c_set_addr_len(). It
 * defaults to 1.
 *
 * @dev:	Chip to read from
 * @offset:	Offset within chip to start reading
 * @buffer:	Place to put data
 * @len:	Number of bytes to read
 *
 * @return 0 on success, -ve on failure
 *//**
 * struct i2c_msg_list - a list of I2C messages
 *
 * This is called i2c_rdwr_ioctl_data in Linux but the name does not seem
 * appropriate in U-Boot.
 *
 * @msg:	Pointer to i2c_msg array
 * @nmsgs:	Number of elements in the array
 *//**
 * struct i2c_msg - an I2C message
 *
 * @addr:	Slave address
 * @flags:	Flags (see enum dm_i2c_msg_flags)
 * @len:	Length of buffer in bytes, may be 0 for a probe
 * @buf:	Buffer to send/receive, or NULL if no data
 *//* length is first received byte *//* skip the Ack bit on reads *//* continue after NAK *//* invert polarity of R/W bit *//* no start before this message *//* send stop after this message *//* read data, from slave to master *//* ten-bit chip address *//*
 * Not all of these flags are implemented in the U-Boot API
 *//**
 * struct dm_i2c_bus- information about an i2c bus
 *
 * An I2C bus contains 0 or more chips on it, each at its own address. The
 * bus can operate at different speeds (measured in Hz, typically 100KHz
 * or 400KHz).
 *
 * To obtain this structure, use dev_get_uclass_priv(bus) where bus is the
 * I2C bus udevice.
 *
 * @speed_hz: Bus speed in hertz (typically 100000)
 * @max_transaction_bytes: Maximal size of single I2C transfer
 *//**
 * struct dm_i2c_chip - information about an i2c chip
 *
 * An I2C chip is a device on the I2C bus. It sits at a particular address
 * and normally supports 7-bit or 10-bit addressing.
 *
 * To obtain this structure, use dev_get_parent_platdata(dev) where dev is
 * the chip to examine.
 *
 * @chip_addr:	Chip address on bus
 * @offset_len: Length of offset in bytes. A single byte offset can
 *		represent up to 256 bytes. A value larger than 1 may be
 *		needed for larger devices.
 * @flags:	Flags for this chip (dm_i2c_chip_flags)
 * @emul: Emulator for this chip address (only used for emulation)
 *//* Send address for each write byte *//* Send address for each read byte *//* Use 10-bit addressing *//*
 * For now there are essentially two parts to this file - driver model
 * here at the top, and the older code below (with CONFIG_SYS_I2C being
 * most recent). The plan is to migrate everything to driver model.
 * The driver model structures and API are separate as they are different
 * enough as to be incompatible for compilation purposes.
 *//*
 * Copyright (C) 2009 Sergey Kubushyn <ksi@koi8.net>
 * Copyright (C) 2009 - 2013 Heiko Schocher <hs@denx.de>
 * Changes for multibus/multiadapter I2C support.
 *
 * (C) Copyright 2001
 * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com.
 *
 * The original I2C interface was
 *   (C) 2000 by Paolo Scaffardi (arsenio@tin.it)
 *   AIRVENT SAM s.p.a - RIMINI(ITALY)
 * but has been changed substantially.
 */flagspspeedchip_flags/opt/src/cmd/date.cmk_dateseccenturycnvrt2'9'do_dateUCLASS_RTCCannot find RTC: err=%d
"Cannot find RTC: err=%d\n""reset"Reset RTC...
"Reset RTC...\n"## Failed to set date after RTC reset
"## Failed to set date after RTC reset\n"## Bad date format
"## Bad date format\n"## Set date failed: err=%d
"## Set date failed: err=%d\n"## Get date failed
"## Get date failed\n"Date: %4d-%02d-%02d (%sday)    Time: %2d:%02d:%02d
"Date: %4d-%02d-%02d (%sday)    Time: %2d:%02d:%02d\n"unknown "unknown "const char *const[7]char *[7]weekdays[tm.tm_wday]old_bus"get/set/reset date & time""[MMDDhhmm[[CC]YY][.ss]]\ndate reset\n" "  - without arguments: print date & time\n" "  - with numeric argument: set the system date & time\n" "  - with 'reset' argument: reset the RTC"<i2c.h><rtc.h>datestrvalpget/set/reset date & time[MMDDhhmm[[CC]YY][.ss]]
date reset
  - without arguments: print date & time
  - with numeric argument: set the system date & time
  - with 'reset' argument: reset the RTC"[MMDDhhmm[[CC]YY][.ss]]\ndate reset\n"
	"  - without arguments: print date & time\n"
	"  - with numeric argument: set the system date & time\n"
	"  - with 'reset' argument: reset the RTC"char[171]U_BOOT_CMD(
	date,	2,	1,	do_date,
	"get/set/reset date & time",
	"[MMDDhhmm[[CC]YY][.ss]]\ndate reset\n"
	"  - without arguments: print date & time\n"
	"  - with numeric argument: set the system date & time\n"
	"  - with 'reset' argument: reset the RTC"
)_u_boot_list_2_cmd_2_date.u_boot_list_2_cmd_2_date2000default_tmSun"Sun"Mon"Mon"Tues"Tues"Wednes"Wednes"Thurs"Thurs"Fri"Fri"Satur"Satur"weekdaysRELOC(a)!defined(CONFIG_DM_RTC)/* calculate day of week *//* MMDDhhmmCCYY	*//* fall thru *//* MMDDhhmmYY	*//* MMDDhhmm	*//* Set seconds *//*
 * Convert date string: MMDDhhmm[[CC]YY][.ss]
 *
 * Some basic checking for valid values is done, but this will not catch
 * all possible error conditions.
 *//*
 * simple conversion of two-digit string with error checking
 *//* switch back to original I2C bus *//* get date & time *//* FALL TROUGH *//* and write to RTC *//* insert new date & time *//* initialize tm with current time *//* set date & time *//* switch to correct I2C bus *//*
 * RTC, Date & Time support: get and set date & time
 *//opt/src/include/dm-demo.hdm-demodemo_parse_dtdemo_listdemo_get_lightdemo_set_lightdemo_statusdemo_hellodemo_opsdm_demo_pdataget_lightset_lighthellodefault_charsidescolour__DM_DEMO_H/**
 * struct dm_demo_pdata - configuration data for demo instance
 *
 * @colour: Color of the demo
 * @sides: Numbers of sides
 * @default_char: Default ASCII character to output (65 = 'A')
 */light/opt/src/cmd/demo.cdo_demodemo_cmddemo_commandsARRAY_SIZE(demo_commands)UCLASS_DEMOdo_demo_listDemo uclass entries:
"Demo uclass entries:\n"entry %d - instance %08x, ops %08x, platdata %08x
"entry %d - instance %08x, ops %08x, platdata %08x\n"do_demo_lightLight: %x
"Light: %x\n"do_demo_statusStatus: %d
"Status: %d\n"do_demo_hello"Driver model (dm) demo operations""list                     List available demo devices\n" "demo hello <num> [<char>]     Say hello\n" "demo light [<num>]            Set or get the lights\n" "demo status <num>             Get demo device status\n" "demo list                     List available demo devices"Driver model (dm) demo operationslist                     List available demo devices
demo hello <num> [<char>]     Say hello
demo light [<num>]            Set or get the lights
demo status <num>             Get demo device status
demo list                     List available demo devices"list                     List available demo devices\n"
	"demo hello <num> [<char>]     Say hello\n"
	"demo light [<num>]            Set or get the lights\n"
	"demo status <num>             Get demo device status\n"
	"demo list                     List available demo devices"U_BOOT_CMD(
	demo,   4,      1,      do_demo,
	"Driver model (dm) demo operations",
	"list                     List available demo devices\n"
	"demo hello <num> [<char>]     Say hello\n"
	"demo light [<num>]            Set or get the lights\n"
	"demo status <num>             Get demo device status\n"
	"demo list                     List available demo devices"
)_u_boot_list_2_cmd_2_demo.u_boot_list_2_cmd_2_demoU_BOOT_CMD_MKENT(list, 0, 1, do_demo_list, "", "")U_BOOT_CMD_MKENT(hello, 2, 1, do_demo_hello, "", "")U_BOOT_CMD_MKENT(light, 2, 1, do_demo_light, "", "")<dm-demo.h>U_BOOT_CMD_MKENT(status, 1, 1, do_demo_status, "", "")demo_dev/opt/src/cmd/disk.cdiskcommon_diskbootBOOTSTAGE_ID_IDE_STARTBOOTSTAGE_ID_IDE_ADDRCONFIG_SYS_LOAD_ADDRBOOTSTAGE_ID_IDE_BOOT_DEVICEBOOTSTAGE_ID_IDE_TYPE
Loading from %s device %d, partition %d: Name: %.32s  Type: %.32s
"\nLoading from %s device %d, partition %d: "
	       "Name: %.32s  Type: %.32s\n"uchar[32]"First Block: " LBAFU ",  # of blocks: " LBAFU ", Block Size: %ld\n""First Block: " "%" "l" "u" ",  # of blocks: " "%" "l" "u" ", Block Size: %ld\n"info.start, info.size, info.blkszdebug("First Block: " LBAFU ",  # of blocks: " LBAFU
	      ", Block Size: %ld\n",
	      info.start, info.size, info.blksz)cmd/disk.cFirst Block: %lu,  # of blocks: %lu, Block Size: %ld
"First Block: " LBAFU ",  # of blocks: " LBAFU
	      ", Block Size: %ld\n"char[54]** Read error on %d:%d
"** Read error on %d:%d\n"BOOTSTAGE_ID_IDE_PART_READfit_hdrFit image detected...
"Fit image detected...\n"BOOTSTAGE_ID_IDE_FORMAT** Unknown image type
"** Unknown image type\n"FITCONFIG_VAL(FIT)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_FITCONFIG_FITCONFIG_VAL(FIT_MODULE)CONFIG_FIT_MODULEFIT_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_FIT_MODULE__ARG_PLACEHOLDER_CONFIG_FIT_MODULE__ARG_PLACEHOLDER_CONFIG_FIT_MODULE 1BOOTSTAGE_ID_IDE_READBOOTSTAGE_ID_IDE_FIT_READ** Bad FIT image format
"** Bad FIT image format\n"BOOTSTAGE_ID_IDE_FIT_READ_OKCONFIG_IS_ENABLED(FIT)/* Loading ok, update default load address *//* This cannot be done earlier,
	 * we need complete FIT image in RAM first *//*
 * (C) Copyright 2000-2011
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *//opt/src/include/dm/util.hutildm_ofnode_pre_relocdm_dump_devresdm_dump_uclassdm_dump_alllist_count_itemsdm_warn__DM_UTIL_HCONFIG_DM_WARN/**
 * Check if an of node should be or was bound before relocation.
 *
 * Devicetree nodes can be marked as needed to be bound
 * in the loader stages via special devicetree properties.
 *
 * Before relocation this function can be used to check if nodes
 * are required in either SPL or TPL stages.
 *
 * After relocation and jumping into the real U-Boot binary
 * it is possible to determine if a node was bound in one of
 * SPL/TPL stages.
 *
 * There are 4 settings currently in use
 * - u-boot,dm-pre-proper: U-Boot proper pre-relocation only
 * - u-boot,dm-pre-reloc: legacy and indicates any of TPL or SPL
 *   Existing platforms only use it to indicate nodes needed in
 *   SPL. Should probably be replaced by u-boot,dm-spl for
 *   existing platforms.
 * - u-boot,dm-spl: SPL and U-Boot pre-relocation
 * - u-boot,dm-tpl: TPL and U-Boot pre-relocation
 * @node: of node
 *
 * Returns true if node is needed in SPL/TL, false otherwise.
 *//* Dump out a list of device resources *//* Dump out a list of uclasses and their devices *//* Dump out a tree of all devices *//**
 * list_count_items() - Count number of items in a list
 *
 * @param head:		Head of list
 * @return number of items, or 0 if empty
 *//opt/src/cmd/dm.cdo_dmtest_cmdtest_commandsARRAY_SIZE(test_commands)dm_relocdo_dm_dump_devresdo_dm_dump_uclassdo_dm_dump_all"Driver model low level access""tree          Dump driver model tree ('*' = activated)\n" "dm uclass        Dump list of instances for each uclass\n" "dm devres        Dump list of device resources for each device"Driver model low level accesstree          Dump driver model tree ('*' = activated)
dm uclass        Dump list of instances for each uclass
dm devres        Dump list of device resources for each device"tree          Dump driver model tree ('*' = activated)\n"
	"dm uclass        Dump list of instances for each uclass\n"
	"dm devres        Dump list of device resources for each device"char[174]U_BOOT_CMD(
	dm,	3,	1,	do_dm,
	"Driver model low level access",
	"tree          Dump driver model tree ('*' = activated)\n"
	"dm uclass        Dump list of instances for each uclass\n"
	"dm devres        Dump list of device resources for each device"
)_u_boot_list_2_cmd_2_dm.u_boot_list_2_cmd_2_dmtreedevresU_BOOT_CMD_MKENT(tree, 0, 1, do_dm_dump_all, "", "")U_BOOT_CMD_MKENT(uclass, 1, 1, do_dm_dump_uclass, "", "")U_BOOT_CMD_MKENT(devres, 1, 1, do_dm_dump_devres, "", "")/*
 * Copyright (c) 2013 Google, Inc
 *
 * (C) Copyright 2012
 * Marek Vasut <marex@denx.de>
 */<dm/util.h>/opt/src/cmd/echo.cechodo_echonls' '\c"\\c"prenlsputnl'\\'"echo args to console""[args..]\n" "    - echo args to console; \\c suppresses newline"U_BOOT_CMD(
	echo,	CONFIG_SYS_MAXARGS,	1,	do_echo,
	"echo args to console",
	"[args..]\n"
	"    - echo args to console; \\c suppresses newline"
)echo args to console[args..]
    - echo args to console; \c suppresses newline"[args..]\n"
	"    - echo args to console; \\c suppresses newline"_u_boot_list_2_cmd_2_echo.u_boot_list_2_cmd_2_echo/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 *//* new-line suppression *//*
 * Copyright 2000-2009
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *//opt/src/include/ethsw.hethswethsw_command_funcethsw_command_defethsw_keyword_opt_idethsw_id_port_noethsw_id_countethsw_id_count + 1ethsw_id_vlan_noethsw_id_pvid_noethsw_id_add_del_noethsw_id_add_del_macethsw_id_aggr_noethsw_id_count_allethsw_keyword_idethsw_id_key_endethsw_id_helpethsw_id_showethsw_id_portethsw_id_enableethsw_id_disableethsw_id_statisticsethsw_id_clearethsw_id_learningethsw_id_autoethsw_id_vlanethsw_id_fdbethsw_id_addethsw_id_delethsw_id_flushethsw_id_pvidethsw_id_untaggedethsw_id_allethsw_id_noneethsw_id_egressethsw_id_tagethsw_id_classifiedethsw_id_sharedethsw_id_privateethsw_id_ingressethsw_id_filteringethsw_id_aggrethsw_command_def *port_aggr_setport_aggr_showport_ingr_filt_setport_ingr_filt_showvlan_learn_setvlan_learn_showport_egr_vlan_setport_egr_vlan_showport_untag_setport_untag_showvlan_setvlan_showpvid_setpvid_showfdb_entry_delfdb_entry_addfdb_flushfdb_showport_learn_showport_learnport_stats_clearport_statsport_showport_disableport_enableethsw_namecmd_functionuchar[6]aggr_grpcmd_keywords_nrint[20]ETHSW_MAX_CMD_PARAMScmd_to_keywordsETHSW_CMD_AGGR_GRP_NONEETHSW_CMD_VLAN_ALLETHSW_CMD_PORT_ALL_CMD_ETHSW_H_ethsw_define_functionsconst ethsw_command_funcconst ethsw_command_func *ethsw_command_func */* _CMD_ETHSW_H_ *//* Structure to be created and initialized by an Ethernet Switch driver *//* keep last *//* IDs used to track keywords in a command *//*
 * Copyright 2015 Freescale Semiconductor, Inc.
 *
 * Ethernet Switch commands
 */cmd_func/opt/src/cmd/ethsw.cdo_ethswparsed_cmdcommand_def_initsizeof(parsed_cmd->ethaddr)keywords_findjkeyword_def[26]keyword_def *argc_valconst ethsw_command_defconst ethsw_command_def *Command not available for: %s
"Command not available for: %s\n"cmd_keywords_checkkeywords_to_function[51]ethsw_cmd_def4896ARRAY_SIZE(ethsw_cmd_def)keywords_to_function *keyw_matchedcmd_keyw_pcmd_keyw_def_pethsw_keyword_id[20]ethsw_keyword_id *cmd_keywords_opt_checkargc_val_maxkeywords_optional[3]cmd_opt_defARRAY_SIZE(cmd_opt_def)keywords_optional *keyw_opt_matchedcmd_keyw_opt_p<ethsw.h>keyword_match_aggrkeyword_match_mac_addrInvalid MAC address: %s
"Invalid MAC address: %s\n"keyword_match_pvidkeyword_match_vlanauxkeyword_match_portkeyword_match_genaux_pcmd_func_auxethsw_port_aggr_help_key_funcethsw [port <port_no>] aggr { [help] | show | <lag_group_no> } - get/set LAG group for a port
ETHSW_PORT_AGGR_HELP"\n"ethsw_ingr_fltr_help_key_funcethsw [port <port_no>] ingress filtering { [help] | show | enable | disable } - enable/disable VLAN ingress filtering on port
ETHSW_PORT_INGR_FLTR_HELP"\n"char[127]ethsw_vlan_learn_help_key_funcethsw vlan fdb { [help] | show | shared | private } - make VLAN learning shared or private
ETHSW_VLAN_FDB_HELP"\n"char[92]ethsw_egr_tag_help_key_funcethsw [port <port_no>] egress tag { [help] | show | pvid | classified } - Configure VID source for egress tag. Tag's VID could be the frame's classified VID or the PVID of the port
ETHSW_EGR_VLAN_TAG_HELP"\n"char[182]ethsw_port_untag_help_key_funcethsw [port <port_no>] untagged { [help] | show | all | none | pvid }  - set egress tagging mode for a port
ETHSW_PORT_UNTAG_HELP"\n"char[109]ethsw_vlan_help_key_funcethsw [port <port_no>] vlan { [help] | show | add <vid> | del <vid> } - add a VLAN to a port (VLAN members)
ETHSW_VLAN_HELP"\n"ethsw_pvid_help_key_funcethsw [port <port_no>] pvid { [help] | show | <pvid> } - set/show PVID (ingress and egress VLAN tagging) for a port
ETHSW_PVID_HELP"\n"char[117]ethsw_fdb_help_key_funcethsw [port <port_no>] [vlan <vid>] fdb { [help] | show | flush | { add | del } <mac> } - Add/delete a mac entry in FDB; use show to see FDB entries; if vlan <vid> is missing, VID 1 will be used
ETHSW_FDB_HELP"\n"char[196]key_idargc_nrethsw_learn_help_key_funcethsw [port <port_no>] learning { [help] | show | auto | disable } - enable/disable/show learning configuration on a port
ETHSW_LEARN_HELP"\n"char[123]ethsw_port_stats_help_key_funcethsw [port <port_no>] statistics { [help] | [clear] } - show an l2 switch port's statistics
ETHSW_PORT_STATS_HELP"\n"char[94]keyword_defkeywords_optionalkeywords_to_functionkeyword_namecmd_keywordkeyword_functioncmd_func_offset"Ethernet l2 switch commands"ETHSW_PORT_CONF_HELP"\n" ETHSW_PORT_STATS_HELP"\n" ETHSW_LEARN_HELP"\n" ETHSW_FDB_HELP"\n" ETHSW_PVID_HELP"\n" ETHSW_VLAN_HELP"\n" ETHSW_PORT_UNTAG_HELP"\n" ETHSW_EGR_VLAN_TAG_HELP"\n" ETHSW_VLAN_FDB_HELP"\n" ETHSW_PORT_INGR_FLTR_HELP"\n" ETHSW_PORT_AGGR_HELP"\n""[port <port_no>] { enable | disable | show } " "- enable/disable a port; show a port's configuration""\n" "ethsw [port <port_no>] statistics " "{ [help] | [clear] } - show an l2 switch port's statistics""\n" "ethsw [port <port_no>] learning " "{ [help] | show | auto | disable } " "- enable/disable/show learning configuration on a port""\n" "ethsw [port <port_no>] [vlan <vid>] fdb " "{ [help] | show | flush | { add | del } <mac> } " "- Add/delete a mac entry in FDB; use show to see FDB entries; " "if vlan <vid> is missing, VID 1 will be used""\n" "ethsw [port <port_no>] " "pvid { [help] | show | <pvid> } " "- set/show PVID (ingress and egress VLAN tagging) for a port""\n" "ethsw [port <port_no>] vlan " "{ [help] | show | add <vid> | del <vid> } " "- add a VLAN to a port (VLAN members)""\n" "ethsw [port <port_no>] untagged " "{ [help] | show | all | none | pvid } " " - set egress tagging mode for a port""\n" "ethsw [port <port_no>] egress tag " "{ [help] | show | pvid | classified } " "- Configure VID source for egress tag. " "Tag's VID could be the frame's classified VID or the PVID of the port""\n" "ethsw vlan fdb " "{ [help] | show | shared | private } " "- make VLAN learning shared or private""\n" "ethsw [port <port_no>] ingress filtering" " { [help] | show | enable | disable } " "- enable/disable VLAN ingress filtering on port""\n" "ethsw [port <port_no>] aggr" " { [help] | show | <lag_group_no> } " "- get/set LAG group for a port""\n"U_BOOT_CMD(ethsw, ETHSW_MAX_CMD_PARAMS, 0, do_ethsw,
	   "Ethernet l2 switch commands",
	   ETHSW_PORT_CONF_HELP"\n"
	   ETHSW_PORT_STATS_HELP"\n"
	   ETHSW_LEARN_HELP"\n"
	   ETHSW_FDB_HELP"\n"
	   ETHSW_PVID_HELP"\n"
	   ETHSW_VLAN_HELP"\n"
	   ETHSW_PORT_UNTAG_HELP"\n"
	   ETHSW_EGR_VLAN_TAG_HELP"\n"
	   ETHSW_VLAN_FDB_HELP"\n"
	   ETHSW_PORT_INGR_FLTR_HELP"\n"
	   ETHSW_PORT_AGGR_HELP"\n"
)Ethernet l2 switch commands[port <port_no>] { enable | disable | show } - enable/disable a port; show a port's configuration
ethsw [port <port_no>] statistics { [help] | [clear] } - show an l2 switch port's statistics
ethsw [port <port_no>] learning { [help] | show | auto | disable } - enable/disable/show learning configuration on a port
ethsw [port <port_no>] [vlan <vid>] fdb { [help] | show | flush | { add | del } <mac> } - Add/delete a mac entry in FDB; use show to see FDB entries; if vlan <vid> is missing, VID 1 will be used
ethsw [port <port_no>] pvid { [help] | show | <pvid> } - set/show PVID (ingress and egress VLAN tagging) for a port
ethsw [port <port_no>] vlan { [help] | show | add <vid> | del <vid> } - add a VLAN to a port (VLAN members)
ethsw [port <port_no>] untagged { [help] | show | all | none | pvid }  - set egress tagging mode for a port
ethsw [port <port_no>] egress tag { [help] | show | pvid | classified } - Configure VID source for egress tag. Tag's VID could be the frame's classified VID or the PVID of the port
ethsw vlan fdb { [help] | show | shared | private } - make VLAN learning shared or private
ethsw [port <port_no>] ingress filtering { [help] | show | enable | disable } - enable/disable VLAN ingress filtering on port
ethsw [port <port_no>] aggr { [help] | show | <lag_group_no> } - get/set LAG group for a port
U_BOOT_CMD(ethsw, ETHSW_MAX_CMD_PARAMS, 0, do_ethsw,
	   "Ethernet l2 switch commands",
	   ETHSW_PORT_CONF_HELP"\n"
	   ETHSW_PORT_STATS_HELP"\n"
	   ETHSW_LEARN_HELP"\n"
	   ETHSW_FDB_HELP"\n"
	   ETHSW_PVID_HELP"\n"
	   ETHSW_VLAN_HELP"\n"
	   ETHSW_PORT_UNTAG_HELP"\n"
	   ETHSW_EGR_VLAN_TAG_HELP"\n"
	   ETHSW_VLAN_FDB_HELP"\n"
	   ETHSW_PORT_INGR_FLTR_HELP"\n"
	   ETHSW_PORT_AGGR_HELP"\n"char[1333]_u_boot_list_2_cmd_2_ethsw.u_boot_list_2_cmd_2_ethswkeyword_def[]"show""port""enable""disable""statistics"clear"clear"learning"learning""auto"vlan"vlan"fdb"fdb""add"del"del""flush"pvid"pvid"untagged"untagged"all"all"none"none"egress"egress""tag"classified"classified"shared"shared""private"ingress"ingress"filtering"filtering"aggr"aggr"keywordkeywords_optional[]keywords_to_function[]struct ethsw_command_funcoffsetof(struct ethsw_command_func,
						    port_enable)offsetof(struct ethsw_command_func,
						    port_disable)offsetof(struct ethsw_command_func,
						    port_show)offsetof(struct ethsw_command_func,
						    port_stats)offsetof(struct ethsw_command_func,
						    port_stats_clear)offsetof(struct ethsw_command_func,
						    port_learn_show)offsetof(struct ethsw_command_func,
						    port_learn)offsetof(struct ethsw_command_func,
						    fdb_show)offsetof(struct ethsw_command_func,
						    fdb_flush)offsetof(struct ethsw_command_func,
						    fdb_entry_add)offsetof(struct ethsw_command_func,
						    fdb_entry_del)offsetof(struct ethsw_command_func,
						    pvid_show)offsetof(struct ethsw_command_func,
						    pvid_set)offsetof(struct ethsw_command_func,
						    vlan_show)offsetof(struct ethsw_command_func,
						    vlan_set)offsetof(struct ethsw_command_func,
						    port_untag_show)offsetof(struct ethsw_command_func,
						    port_untag_set)offsetof(struct ethsw_command_func,
						    port_egr_vlan_show)offsetof(struct ethsw_command_func,
						    port_egr_vlan_set)offsetof(struct ethsw_command_func,
						    vlan_learn_show)offsetof(struct ethsw_command_func,
						    vlan_learn_set)offsetof(struct ethsw_command_func,
						    port_ingr_filt_show)offsetof(struct ethsw_command_func,
						    port_ingr_filt_set)offsetof(struct ethsw_command_func,
						    port_aggr_show)offsetof(struct ethsw_command_func,
						    port_aggr_set)ETHSW_PORT_CONF_HELP"[port <port_no>] { enable | disable | show } " "- enable/disable a port; show a port's configuration"ETHSW_PORT_AGGR_HELP"ethsw [port <port_no>] aggr" " { [help] | show | <lag_group_no> } " "- get/set LAG group for a port"ETHSW_PORT_INGR_FLTR_HELP"ethsw [port <port_no>] ingress filtering" " { [help] | show | enable | disable } " "- enable/disable VLAN ingress filtering on port"ETHSW_VLAN_FDB_HELP"ethsw vlan fdb " "{ [help] | show | shared | private } " "- make VLAN learning shared or private"ETHSW_EGR_VLAN_TAG_HELP"ethsw [port <port_no>] egress tag " "{ [help] | show | pvid | classified } " "- Configure VID source for egress tag. " "Tag's VID could be the frame's classified VID or the PVID of the port"ETHSW_PORT_UNTAG_HELP"ethsw [port <port_no>] untagged " "{ [help] | show | all | none | pvid } " " - set egress tagging mode for a port"ETHSW_VLAN_HELP"ethsw [port <port_no>] vlan " "{ [help] | show | add <vid> | del <vid> } " "- add a VLAN to a port (VLAN members)"ETHSW_PVID_HELP"ethsw [port <port_no>] " "pvid { [help] | show | <pvid> } " "- set/show PVID (ingress and egress VLAN tagging) for a port"ETHSW_FDB_HELP"ethsw [port <port_no>] [vlan <vid>] fdb " "{ [help] | show | flush | { add | del } <mac> } " "- Add/delete a mac entry in FDB; use show to see FDB entries; " "if vlan <vid> is missing, VID 1 will be used"ETHSW_LEARN_HELP"ethsw [port <port_no>] learning " "{ [help] | show | auto | disable } " "- enable/disable/show learning configuration on a port"ETHSW_PORT_STATS_HELP"ethsw [port <port_no>] statistics " "{ [help] | [clear] } - show an l2 switch port's statistics"/* function to interpret commands starting with "ethsw " *//* We initialize the MAC address with the Broadcast address *//* error if not all commands' parameters were matched *//*
	 * check the keywords and if a match is found,
	 * get the function to call
	 *//* get optional parameters first *//* if there is no keyword match for a word, the command is invalid *//* find all the keywords in the command *//*
		 * if all our command's keywords perfectly match an
		 * available command, then we get the function we need to call
		 * to configure the Ethernet Switch
		 *//*
		 * increase the number of keywords that
		 * matched with a command
		 *//*
	 * check if our command's keywords match the
	 * keywords of an available command
	 *//*
 * Finds the function to call based on keywords and
 * modifies *argc_va to skip them
 *//*
		 * if all our optional command's keywords perfectly match an
		 * optional pattern, then we can move to the next defined
		 * keywords in our command; remember the one that matched the
		 * greatest number of keywords
		 *//*
	 * check if our command's optional keywords match the optional
	 * keywords of an available command
	 *//* remember the best match *//* Finds optional keywords and modifies *argc_va to skip them *//* Function used to match the command's aggregation number *//* Function used to match the command's MAC address *//* Function used to match the command's pvid *//* Function used to match the command's vlan *//* Function used to match the command's port *//* Generic function used to match a keyword only by a string *//*
		 * get the pointer to the function send by the Ethernet Switch
		 * driver that corresponds to the proper ethsw command
		 *//*
 * Function used by an Ethernet Switch driver to set the functions
 * that must be called by the parser when an ethsw command is given
 *//*
 * Define properties for each keyword;
 * keep the order synced with enum ethsw_keyword_id
 *//opt/src/cmd/exit.cdo_exit"exit script"exit scriptU_BOOT_CMD(
	exit,	2,	1,	do_exit,
	"exit script",
	""
)_u_boot_list_2_cmd_2_exit.u_boot_list_2_cmd_2_exit/opt/src/cmd/ext2.cext2do_ext2lsext2load"load binary file from a Ext2 filesystem""<interface> [<dev[:part]> [addr [filename [bytes [pos]]]]]\n" "    - load binary file 'filename' from 'dev' on 'interface'\n" "      to address 'addr' from ext2 filesystem."load binary file from a Ext2 filesystem<interface> [<dev[:part]> [addr [filename [bytes [pos]]]]]
    - load binary file 'filename' from 'dev' on 'interface'
      to address 'addr' from ext2 filesystem."<interface> [<dev[:part]> [addr [filename [bytes [pos]]]]]\n"
	"    - load binary file 'filename' from 'dev' on 'interface'\n"
	"      to address 'addr' from ext2 filesystem."char[165]U_BOOT_CMD(
	ext2load,	6,	0,	do_ext2load,
	"load binary file from a Ext2 filesystem",
	"<interface> [<dev[:part]> [addr [filename [bytes [pos]]]]]\n"
	"    - load binary file 'filename' from 'dev' on 'interface'\n"
	"      to address 'addr' from ext2 filesystem."
)_u_boot_list_2_cmd_2_ext2load.u_boot_list_2_cmd_2_ext2loadext2ls"<interface> <dev[:part]> [directory]\n" "    - list files from 'dev' on 'interface' in a 'directory'"<interface> <dev[:part]> [directory]
    - list files from 'dev' on 'interface' in a 'directory'"<interface> <dev[:part]> [directory]\n"
	"    - list files from 'dev' on 'interface' in a 'directory'"char[97]U_BOOT_CMD(
	ext2ls,	4,	1,	do_ext2ls,
	"list files in a directory (default /)",
	"<interface> <dev[:part]> [directory]\n"
	"    - list files from 'dev' on 'interface' in a 'directory'"
)_u_boot_list_2_cmd_2_ext2ls.u_boot_list_2_cmd_2_ext2ls/******************************************************************************
 * Ext2fs boot command intepreter. Derived from diskboot
 *//*
 * Ext2fs support
 *//*
 * (C) Copyright 2011 - 2012 Samsung Electronics
 * EXT4 filesystem implementation in Uboot by
 * Uma Shankar <uma.shankar@samsung.com>
 * Manjunatha C Achar <a.manjunatha@samsung.com>

 * (C) Copyright 2004
 * esd gmbh <www.esd-electronics.com>
 * Reinhard Arlt <reinhard.arlt@esd-electronics.com>
 *
 * made from cmd_reiserfs by
 *
 * (C) Copyright 2003 - 2004
 * Sysgo Real-Time Solutions, AG <www.elinos.com>
 * Pavel Bartusek <pba@sysgo.com>
 *//opt/src/include/ext_common.hext_commonext2fs_nodeext2_dataext2_direntext2_inodedatablocksext2_block_groupext2_sblockinode_readinoinodeext2_data *diropenext2_inode *sblockfiletypedirentlen__le32[3]osd2fragment_addrsize_highaclosd1blockcntnlinksdtimemtimeatimechar[60]inline_datatriple_indir_blockdouble_indir_blockindir_block__le32[12]unsigned int[12]INDIRECT_BLOCKSdir_blocksbg_reservedbg_inode_id_csum_highbg_block_id_csum_highbg_exclude_bitmap_highbg_itable_unused_highused_dir_cnt_highfree_inodes_highfree_blocks_highinode_table_id_highinode_id_highblock_id_highbg_checksumbg_itable_unusedbg_inode_id_csumbg_block_id_csumbg_exclude_bitmapbg_flagsused_dir_cntfree_inodesfree_blocksinode_table_idinode_idblock_idchecksum_typelog2_groups_per_flexraid_stripe_widthmmp_blockmmp_intervalraid_stridewant_extra_inode_sizemin_extra_inode_sizereserved_blocks_hightotal_blocks_high__le32[17]unsigned int[17]journal_blocksmkfs_timefirst_meta_block_groupdefault_mount_optionsjournal_backup_typedefault_hash_version__le32[4]hash_seedlast_orphanjournal_devjournal_inodejournal_uuidreserved_gdt_blocksprealloc_dir_blocksprealloc_blockscompression_infolast_mounted_onvolume_nameunique_idfeature_ro_compatfeature_incompatfeature_compatibilityblock_group_numberinode_sizefirst_inodegid_reserveduid_reservedrevision_levelcreator_oscheckintervallastcheckminor_revision_levelerror_handlingfs_statemax_mnt_countmnt_countutimeinodes_per_groupfragments_per_groupblocks_per_grouplog2_fragment_sizelog2_block_sizefirst_data_blockreserved_blockstotal_blockstotal_inodesEXT2_MAX_BLOCK_SIZE(1 << EXT2_MAX_BLOCK_LOG_SIZE)EXT2_MIN_BLOCK_SIZE(1 << EXT2_MIN_BLOCK_LOG_SIZE)EXT2_MAX_BLOCK_LOG_SIZEEXT2_MIN_BLOCK_LOG_SIZESUCCESSEXT2_FT_DIRLOG2_BLOCK_SIZE(data)(le32_to_cpu (data->sblock.log2_block_size) + EXT2_MIN_BLOCK_LOG_SIZE)EXT2_BLOCK_SIZE(data)(1 << LOG2_BLOCK_SIZE(data))EXT2_ROOT_INOFILETYPE_INO_SYMLINKFILETYPE_INO_DIRECTORYFILETYPE_INO_REGFILETYPE_INO_MASKFILETYPE_SYMLINKFILETYPE_DIRECTORYFILETYPE_REGFILETYPE_UNKNOWNEXT2_MAX_SYMLINKCNTEXT2_PATH_MAXEXT2_MAGIC0xEF53LOG2_SECTOR_SIZESECTOR_SIZE__EXT_COMMON__do_ext4_writedo_ext4_lsdo_ext4_loadpart_offset/* Information about a "mounted" ext2 filesystem. *//* The header of an ext2 directory entry. *//* previously dir_acl, but never used *//* Blocks of either 512 or block_size bytes *//* The ext2 inode. *//* following fields only exist if descriptor size is 64 *//* crc16(s_uuid+group_num+group_desc)*//* Unused inodes count *//* Directories count *//* Free inodes count *//* Free blocks count *//* Inodes table block *//* Inodes bitmap block *//* Blocks bitmap block *//* The ext2 superblock.  *//* 65536 *//* 1024 *//* Macro-instructions used to manage several block sizes  *//* Log2 size of ext2 block in bytes.  *//* The size of an ext2 block in bytes.  *//* Root inode *//* Filetype information as used in inodes.  *//* Filetype used in directory entry.  *//* Maximum nesting of symlinks, used to prevent a loop.  *//* Maximum lenght of a pathname.  *//* Amount of indirect blocks in an inode.  *//* Magic value used to identify an ext2 filesystem.  *//*
 * (C) Copyright 2011 - 2012 Samsung Electronics
 * EXT4 filesystem implementation in Uboot by
 * Uma Shankar <uma.shankar@samsung.com>
 * Manjunatha C Achar <a.manjunatha@samsung.com>
 *
 * Data structures and headers for ext4 support have been taken from
 * ext2 ls load support in Uboot
 *
 * (C) Copyright 2004
 * esd gmbh <www.esd-electronics.com>
 * Reinhard Arlt <reinhard.arlt@esd-electronics.com>
 *
 * based on code from grub2 fs/ext2.c and fs/fshelp.c by
 * GRUB  --  GRand Unified Bootloader
 * Copyright (C) 2003, 2004  Free Software Foundation, Inc.
 *//opt/src/include/ext4fs.hext4fsext_cache_readext_block_cache *ext_cache_finiext_cache_initext4fs_uuidext4_read_superblockext4_read_fileext4fs_proberead_allocated_blockext4fs_set_blk_devext4fs_devreadext4fs_free_nodeext2fs_node *ext4fs_sizeext4fs_existsext4fs_lsext4fs_reinit_globalext4fs_closeext4fs_mountext4fs_readext4fs_openext_filesystem *get_fsext4fs_create_linkext4_write_fileext4fs_writeext4fs_filename_unlinkext4fs_deinitext4fs_initext_block_cacheext_filesystemext4_extent_headerext4_extent_idxext4_extentfirst_pass_ibmapcurr_inode_noinode_bmapsfirst_pass_bbmapcurr_blknoblk_bmapsgdtableext2_sblock *sbno_blk_pergdtno_blkgrpgdtable_blknogdsizesect_perblkinodesztotal_secteh_generationeh_deptheh_maxeh_entrieseh_magicei_unusedei_leaf_hiei_leaf_loei_blockee_start_loee_start_hiee_lenee_blockEXT4_BG_INODE_ZEROEDEXT4_BG_BLOCK_UNINITEXT4_BG_INODE_UNINITEXT4_INDIRECT_BLOCKSEXT4_FEATURE_INCOMPAT_64BITEXT4_FEATURE_INCOMPAT_EXTENTSEXT4_FEATURE_RO_COMPAT_METADATA_CSUMEXT4_FEATURE_RO_COMPAT_GDT_CSUMEXT4_EXT_MAGIC0xf30aEXT4_EXTENTS_FLEXT4_INDEX_FL__EXT4__defined(CONFIG_EXT4_WRITE)gindexgd_indexg_parent_inodeext4fs_fileext4fs_root/* Block Device Descriptor *//* Journal Related *//* Inode Bitmap Related *//* Block Bitmap Related *//* Block group descritpor table *//* Superblock *//* No of blocks required for bgdtable *//* Total block groups of partition *//* Group Descriptor Block Number *//* Group Descriptor size *//* Sectors per Block *//* Inode size of partition *//* Block size  of partition *//* Total Sector of partition *//* generation of the tree *//* has tree real underlying blocks? *//* capacity of store in entries *//* number of valid entries *//* probably will support different formats *//* Each block (leaves and indexes), even inode-stored has header. *//* high 16 bits of physical block *//* pointer to the physical block of the next *
				 * level. leaf or next index could be there *//* index covers logical blocks from 'block' *//*
 * This is index on-disk structure.
 * It's used at all the levels except the bottom.
 *//* low 32 bits of physical block *//* number of blocks covered by extent *//* first logical block extent covers *//*
 * This is the extent on-disk structure.
 * It's used at the bottom of the tree.
 *//*
 * ext4_inode has i_block array (60 bytes total).
 * The first 12 bytes store ext4_extent_header;
 * the remainder stores an array of ext4_extent.
 *//* Inode uses extents *//* Inode uses hash tree index *//*
 * (C) Copyright 2011 - 2012 Samsung Electronics
 * EXT4 filesystem implementation in Uboot by
 * Uma Shankar <uma.shankar@samsung.com>
 * Manjunatha C Achar <a.manjunatha@samsung.com>
 *
 * Ext4 Extent data structures are taken from  original ext4 fs code
 * as found in the linux kernel.
 *
 * Copyright (c) 2003-2006, Cluster File Systems, Inc, info@clusterfs.com
 * Written by Alex Tomas <alex@clusterfs.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */<ext_common.h>cacheuuid_strfs_dev_descfs_partitionfileblockrbddsectorbyte_offsetbyte_lencurrrootpart_lengthsizebytes000010000200004000070001000020000400007000100002000040000700S_ISSOCK(m)(((m) & S_IFMT) == S_IFSOCK)S_ISFIFO(m)(((m) & S_IFMT) == S_IFIFO)S_ISBLK(m)(((m) & S_IFMT) == S_IFBLK)S_ISCHR(m)(((m) & S_IFMT) == S_IFCHR)S_ISDIR(m)(((m) & S_IFMT) == S_IFDIR)S_ISREG(m)(((m) & S_IFMT) == S_IFREG)S_ISLNK(m)(((m) & S_IFMT) == S_IFLNK)00170000_LINUX_STAT_H__PPC__defined (__ARM__) || defined (__I386__) || defined (__M68K__) || defined (__bfin__) ||\defined (__MIPS__)defined(__SH__) || defined(__XTENSA__)/* __SH__  || __XTENSA__ *//* __MIPS__ *//*
	 * Actually this should be timestruc_t st_atime, st_mtime and st_ctime
	 * but we don't have it under Linux.
	 *//* __ARM__ *//* __PPC__ *//* time file status was last changed *//* time file was last modified *//* time file was last accessed *//* file size in # of blocks *//* file size in # of bytes *//* group id *//* user id *//* number of links *//* ownership/protection *//* file id *//* file system id *//* execute/search permission for other *//* read permission for other *//* rwx for other *//* execute/search permission for group *//* write permission for group *//* read permission for group *//* rwx for group *//* execute/search permission for owner *//* write permission for owner *//* read permission for owner *//* rwx for owner *//* save swapped text even after use *//* set group id on execution *//* set user id on execution *//* fifo *//* character special *//* block special *//* regular *//* named socket *//* type of file *//opt/src/include/usb_defs.husb_defsumass_bbb_cswumass_bbb_cbwusb_ttbCSWStatusdCSWDataResiduedCSWTagdCSWSignature__u8[16]CBWCDBLENGTHCBWCDBbCDBLengthbCBWLUNbCBWFlagsdCBWDataTransferLengthdCBWTagdCBWSignaturethink_timemultiUS_BBB_GET_MAX_LUNUS_BBB_RESETUMASS_BBB_CSW_SIZECSWSTATUS_PHASECSWSTATUS_FAILEDCSWSTATUS_GOODCSWSIGNATURE0x53425355UMASS_BBB_CBW_SIZECBWFLAGS_SBZCBWFLAGS_INCBWFLAGS_OUTCBWSIGNATURE0x43425355US_CBI_ADSCUSB_REQ_SET_HUB_DEPTHUSB_HUB_PORT_MASKHUB_CHANGE_OVERCURRENTHUB_CHANGE_LOCAL_POWERHUB_STATUS_OVERCURRENTHUB_STATUS_LOCAL_POWERHUB_CHAR_TTTTHUB_CHAR_OCPMHUB_CHAR_COMPOUNDHUB_CHAR_LPSMUSB_SS_PORT_STAT_C_CONFIG_ERRORUSB_SS_PORT_STAT_C_LINK_STATEUSB_SS_PORT_STAT_C_BH_RESETUSB_PORT_STAT_C_RESETUSB_PORT_STAT_C_OVERCURRENTUSB_PORT_STAT_C_SUSPENDUSB_PORT_STAT_C_ENABLEUSB_PORT_STAT_C_CONNECTIONUSB_SS_PORT_STAT_MASK(USB_PORT_STAT_CONNECTION | USB_PORT_STAT_ENABLE | USB_PORT_STAT_OVERCURRENT | USB_PORT_STAT_RESET)USB_SS_PORT_STAT_SPEED_5GBPSUSB_SS_PORT_STAT_SPEED0x1c00USB_SS_PORT_STAT_POWERUSB_SS_PORT_STAT_LINK_STATE0x01e0USB_PORT_STAT_SPEED_MASK(USB_PORT_STAT_LOW_SPEED | USB_PORT_STAT_HIGH_SPEED)USB_PORT_STAT_SUPER_SPEEDUSB_PORT_STAT_HIGH_SPEEDUSB_PORT_STAT_LOW_SPEEDUSB_PORT_STAT_POWERUSB_PORT_STAT_RESETUSB_PORT_STAT_OVERCURRENTUSB_PORT_STAT_SUSPENDUSB_PORT_STAT_ENABLEUSB_PORT_STAT_CONNECTIONUSB_SS_PORT_FEAT_C_BH_RESETUSB_SS_PORT_FEAT_BH_RESETUSB_SS_PORT_FEAT_C_CONFIG_ERRORUSB_SS_PORT_FEAT_C_LINK_STATEUSB_SS_PORT_FEAT_U2_TIMEOUTUSB_SS_PORT_FEAT_U1_TIMEOUTUSB_PORT_FEAT_TESTUSB_PORT_FEAT_C_RESETUSB_PORT_FEAT_C_OVER_CURRENTUSB_PORT_FEAT_C_SUSPENDUSB_PORT_FEAT_C_ENABLEUSB_PORT_FEAT_C_CONNECTIONUSB_PORT_FEAT_HIGHSPEEDUSB_PORT_FEAT_LOWSPEEDUSB_PORT_FEAT_POWERUSB_PORT_FEAT_RESETUSB_PORT_FEAT_OVER_CURRENTUSB_PORT_FEAT_SUSPENDUSB_PORT_FEAT_ENABLEUSB_PORT_FEAT_CONNECTIONC_HUB_OVER_CURRENTC_HUB_LOCAL_POWERUSB_RT_PORT(USB_TYPE_CLASS | USB_RECIP_OTHER)USB_RT_HUB(USB_TYPE_CLASS | USB_RECIP_DEVICE)USB_ST_NOT_PROC0x80000000LUSB_ST_BIT_ERRUSB_ST_CRC_ERRUSB_ST_NAK_RECUSB_ST_BABBLE_DETUSB_ST_BUF_ERRUSB_ST_STALLEDUSB_ST_ACTIVEUSB_PIPE_EP_MASK(0xf << USB_PIPE_EP_SHIFT)USB_PIPE_EP_SHIFTUSB_PIPE_DEV_MASK(0x7f << USB_PIPE_DEV_SHIFT)USB_PIPE_DEV_SHIFTUSB_PIPE_TYPE_MASK(3 << USB_PIPE_TYPE_SHIFT)USB_PIPE_TYPE_SHIFTUSB_BULKUSB_CONTROLUSB_INTERRUPTUSB_ISOCHRONOUSPIPE_DEVEP_MASK0x0007ff00PIPE_BULK3UPIPE_CONTROLPIPE_INTERRUPTPIPE_ISOCHRONOUSUSB_TEST_MODE_FORCE_ENABLEUSB_TEST_MODE_PACKETUSB_TEST_MODE_SE0_NAKUSB_TEST_MODE_KUSB_TEST_MODE_JUSB_FEAT_TESTUSB_FEAT_WAKEUPUSB_FEAT_HALTUSB_REQ_SET_PROTOCOLUSB_REQ_SET_IDLEUSB_REQ_SET_REPORTUSB_REQ_GET_PROTOCOLUSB_REQ_GET_IDLEUSB_REQ_GET_REPORTUSB_REQ_SYNCH_FRAMEUSB_REQ_SET_INTERFACEUSB_REQ_GET_INTERFACEUSB_REQ_SET_CONFIGURATIONUSB_REQ_GET_CONFIGURATIONUSB_REQ_SET_DESCRIPTORUSB_REQ_GET_DESCRIPTORUSB_REQ_SET_ADDRESSUSB_REQ_SET_FEATUREUSB_REQ_CLEAR_FEATUREUSB_REQ_GET_STATUSUSB_PID_UNDEF_FUSB_PID_STALLUSB_PID_SETUP0x2dUSB_PID_PREAMBLEUSB_PID_DATA10x4bUSB_PID_NAKUSB_PID_IN0x69USB_PID_UNDEF_8USB_PID_UNDEF_70x87USB_PID_UNDEF_60x96USB_PID_SOF0xa5USB_PID_UNDEF_40xb4USB_PID_DATA00xc3USB_PID_ACK0xd2USB_PID_OUT0xe1USB_PID_UNDEF_00xf0USB_ENDPOINT_XFER_INTUSB_ENDPOINT_XFER_BULKUSB_ENDPOINT_XFER_ISOCUSB_ENDPOINT_XFER_CONTROLUSB_ENDPOINT_XFERTYPE_MASKUSB_ENDPOINT_DIR_MASKUSB_ENDPOINT_NUMBER_MASKUSB_DT_HID_SIZEUSB_DT_HUB_NONVAR_SIZEUSB_DT_ENDPOINT_AUDIO_SIZEUSB_DT_ENDPOINT_SIZEUSB_DT_INTERFACE_SIZEUSB_DT_CONFIG_SIZEUSB_DT_DEVICE_SIZEUSB_DT_SS_HUB(USB_TYPE_CLASS | 0x0a)USB_DT_HUB(USB_TYPE_CLASS | 0x09)USB_DT_PHYSICAL(USB_TYPE_CLASS | 0x03)USB_DT_REPORT(USB_TYPE_CLASS | 0x02)USB_DT_HID(USB_TYPE_CLASS | 0x01)USB_DT_ENDPOINTUSB_DT_INTERFACEUSB_DT_STRINGUSB_DT_CONFIGUSB_DT_DEVICEEndpointOutRequest((USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8)EndpointRequest((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8)InterfaceRequestDeviceOutRequest((USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE) << 8)DeviceRequest((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE) << 8)USB_DIR_INUSB_DIR_OUTUSB_RECIP_OTHERUSB_RECIP_ENDPOINTUSB_RECIP_INTERFACEUSB_RECIP_DEVICEUSB_TYPE_RESERVED(0x03 << 5)USB_TYPE_VENDOR(0x02 << 5)USB_TYPE_CLASS(0x01 << 5)USB_TYPE_STANDARD(0x00 << 5)US_PR_BULKUS_PR_CBIUS_PR_CBUS_SC_MAXUS_SC_SCSIUS_SC_MINUS_SC_RBCUS_SC_8070US_SC_UFIUS_SC_QICUS_SC_8020USB_PROT_HID_MOUSEUSB_PROT_HID_KEYBOARDUSB_PROT_HID_NONEUSB_SUB_HID_BOOTUSB_SUB_HID_NONEUSB_CLASS_VENDOR_SPECUSB_CLASS_DATAUSB_CLASS_HUBUSB_CLASS_MASS_STORAGEUSB_CLASS_PRINTERUSB_CLASS_HIDUSB_CLASS_COMMUSB_CLASS_AUDIOUSB_CLASS_PER_INTERFACE_USB_DEFS_H_/*_USB_DEFS_H_ *//*
 * BULK only
 *//* Command Status Wrapper *//* Command Block Wrapper *//*
 * CBI style
 *//* think time in ns *//* true means one TT per port *//*
 * As of USB 2.0, full/low speed devices are segregated into trees.
 * One type grows from USB 1.1 host controllers (OHCI, UHCI etc).
 * The other type grows from high speed hubs when they connect to
 * full/low speed devices using "Transaction Translators" (TTs).
 *//* Hub class request codes *//* Mask for wIndex in get/set port feature *//*
 * Hub Status & Hub Change bit masks
 *//* TT Think Time mask *//* wHubCharacteristics (masks) *//*
 * Changes to wPortChange bit fields in USB 3.0
 * See USB 3.0 spec Table 10-12
 *//* wPortChange bits *//* Bits that are the same from USB 2.0 *//*
 * Changes to wPortStatus bit field in USB 3.0
 * See USB 3.0 spec Table 10-10
 *//* faking support to XHCI *//* support for EHCI *//* wPortStatus bits *//*
 * Changes to Port feature numbers for Super speed,
 * from USB 3.0 spec Table 10-8
 *//*
 * Port feature numbers
 *//*
 * Hub Class feature numbers
 *//*
 * Hub request types
 *//*************************************************************************
 * Hub defines
 *//* Not yet processed *//* Bitstuff error *//* CRC/timeout Error *//* NAK Received*//* Babble detected *//* buffer error *//* TD is stalled *//* TD is active *//* USB-status codes: *//*
 * "pipe" definitions, use unsigned so we can compare reliably, since this
 * value is shifted up to bits 30/31.
 *//* Test modes *//* Device features *//* HID requests *//* Standard requests *//* USB Packet IDs (PIDs) *//* in bmAttributes *//* in bEndpointAddress *//* Endpoints *//* Audio extension *//* Descriptor sizes per descriptor type *//* Descriptor types *//*
 * bmRequestType: USB Device Requests, table 9.2 USB 2.0 spec.
 * (shifted) direction/type/recipient.
 *//* USB directions *//* USB recipients *//* USB types *//* bulk only *//* Control/Bulk/Interrupt *//* Control/Bulk w/o interrupt *//* STORAGE Protocols *//* Transparent *//* Removable media *//* Floppy *//* QIC-157 Tapes *//* CD-ROM *//* Typically, flash devices *//* Sub STORAGE Classes *//* some UID Protocols *//* some HID sub classes *//* for DeviceClass *//* Device and/or Interface Class codes *//* USB constants *//*
 * (C) Copyright 2001
 * Denis Peter, MPL AG Switzerland
 *
 * Note: Part of this code has been derived from linux
 *//opt/src/include/linux/unaligned/le_byteshift.hle_byteshiftput_unaligned_le64put_unaligned_le32put_unaligned_le16get_unaligned_le64get_unaligned_le32get_unaligned_le16__put_unaligned_le64__put_unaligned_le32__put_unaligned_le16__get_unaligned_le64__get_unaligned_le32__get_unaligned_le16_LINUX_UNALIGNED_LE_BYTESHIFT_H/* _LINUX_UNALIGNED_LE_BYTESHIFT_H *//opt/src/include/linux/unaligned/opt/src/include/linux/unaligned/be_byteshift.hbe_byteshiftput_unaligned_be64put_unaligned_be32put_unaligned_be16get_unaligned_be64get_unaligned_be32get_unaligned_be16__put_unaligned_be64__put_unaligned_be32__put_unaligned_be16__get_unaligned_be64__get_unaligned_be32__get_unaligned_be16_LINUX_UNALIGNED_BE_BYTESHIFT_H/* _LINUX_UNALIGNED_BE_BYTESHIFT_H *//opt/src/include/linux/unaligned/generic.hgeneric__bad_unaligned_access_size__put_unaligned_be(val,ptr)({ void *__gu_p = (ptr); switch (sizeof(*(ptr))) { case 1: *(u8 *)__gu_p = (__force u8)(val); break; case 2: put_unaligned_be16((__force u16)(val), __gu_p); break; case 4: put_unaligned_be32((__force u32)(val), __gu_p); break; case 8: put_unaligned_be64((__force u64)(val), __gu_p); break; default: __bad_unaligned_access_size(); break; } (void)0; })__put_unaligned_le(val,ptr)({ void *__gu_p = (ptr); switch (sizeof(*(ptr))) { case 1: *(u8 *)__gu_p = (__force u8)(val); break; case 2: put_unaligned_le16((__force u16)(val), __gu_p); break; case 4: put_unaligned_le32((__force u32)(val), __gu_p); break; case 8: put_unaligned_le64((__force u64)(val), __gu_p); break; default: __bad_unaligned_access_size(); break; } (void)0; })__get_unaligned_be(ptr)((__force typeof(*(ptr)))({ __builtin_choose_expr(sizeof(*(ptr)) == 1, *(ptr), __builtin_choose_expr(sizeof(*(ptr)) == 2, get_unaligned_be16((ptr)), __builtin_choose_expr(sizeof(*(ptr)) == 4, get_unaligned_be32((ptr)), __builtin_choose_expr(sizeof(*(ptr)) == 8, get_unaligned_be64((ptr)), __bad_unaligned_access_size())))); }))__get_unaligned_le(ptr)((__force typeof(*(ptr)))({ __builtin_choose_expr(sizeof(*(ptr)) == 1, *(ptr), __builtin_choose_expr(sizeof(*(ptr)) == 2, get_unaligned_le16((ptr)), __builtin_choose_expr(sizeof(*(ptr)) == 4, get_unaligned_le32((ptr)), __builtin_choose_expr(sizeof(*(ptr)) == 8, get_unaligned_le64((ptr)), __bad_unaligned_access_size())))); }))_LINUX_UNALIGNED_GENERIC_H/* _LINUX_UNALIGNED_GENERIC_H *//*
 * Cause a link-time error if we try an unaligned access other than
 * 1,2,4 or 8 bytes long
 *//opt/src/include/asm-generic/unaligned.hallow_unalignedput_unaligned__put_unaligned_leget_unaligned__get_unaligned_le_GENERIC_UNALIGNED_Hdefined(__LITTLE_ENDIAN)defined(__BIG_ENDIAN)/* Allow unaligned memory access *//*
 * Select endianness
 */<linux/unaligned/generic.h><linux/unaligned/be_byteshift.h><linux/unaligned/le_byteshift.h>/opt/src/arch/sandbox/include/asm/unaligned.h<asm-generic/unaligned.h>/opt/src/include/linux/usb/ch9.hch9usb_speed_stringusb_ss_max_streamsconst usb_ss_ep_comp_descriptorconst usb_ss_ep_comp_descriptor *usb_ss_ep_comp_descriptor *max_streamsusb_endpoint_interrupt_typeconst usb_endpoint_descriptorconst usb_endpoint_descriptor *usb_endpoint_descriptor *USB_ENDPOINT_INTRTYPEusb_endpoint_maxp_multepd->wMaxPacketSizemaxpUSB_EP_MAXP_MULT(maxp)6144usb_endpoint_maxpget_unaligned(&epd->wMaxPacketSize)((typeof(*(&epd->wMaxPacketSize)))({ __builtin_choose_expr(sizeof(*(&epd->wMaxPacketSize)) == 1, *(&epd->wMaxPacketSize), __builtin_choose_expr(sizeof(*(&epd->wMaxPacketSize)) == 2, get_unaligned_le16((&epd->wMaxPacketSize)), __builtin_choose_expr(sizeof(*(&epd->wMaxPacketSize)) == 4, get_unaligned_le32((&epd->wMaxPacketSize)), __builtin_choose_expr(sizeof(*(&epd->wMaxPacketSize)) == 8, get_unaligned_le64((&epd->wMaxPacketSize)), __bad_unaligned_access_size())))); }))const __le16const __le16 *&epd->wMaxPacketSize__le16_to_cpu(get_unaligned(&epd->wMaxPacketSize))usb_endpoint_is_isoc_outusb_endpoint_is_isoc_inusb_endpoint_is_int_outusb_endpoint_is_int_inusb_endpoint_is_bulk_outusb_endpoint_is_bulk_inusb_endpoint_xfer_isocusb_endpoint_xfer_intusb_endpoint_xfer_controlusb_endpoint_xfer_bulkusb_endpoint_dir_outusb_endpoint_dir_inusb_endpoint_typeusb_endpoint_numusb_stringusb_set_sel_requsb3_link_stateUSB3_LPM_U0USB3_LPM_U1USB3_LPM_U2USB3_LPM_U3usb_device_stateUSB_STATE_NOTATTACHEDUSB_STATE_ATTACHEDUSB_STATE_POWEREDUSB_STATE_RECONNECTINGUSB_STATE_UNAUTHENTICATEDUSB_STATE_DEFAULTUSB_STATE_ADDRESSUSB_STATE_CONFIGUREDUSB_STATE_SUSPENDEDusb_device_speedUSB_SPEED_UNKNOWNUSB_SPEED_LOWUSB_SPEED_FULLUSB_SPEED_HIGHUSB_SPEED_WIRELESSUSB_SPEED_SUPERusb_connection_contextusb_handshakeusb_wireless_ep_comp_descriptorusb_ss_container_id_descriptorusb_ss_cap_descriptorusb_ext_cap_descriptorusb_wireless_cap_descriptorusb_dev_cap_headerusb_bos_descriptorusb_encryption_descriptorusb_key_descriptorusb_security_descriptorusb_interface_assoc_descriptorusb_debug_descriptorusb_otg_descriptorusb_qualifier_descriptorusb_ss_ep_comp_descriptorusb_class_report_descriptorusb_class_hid_descriptorusb_generic_descriptorusb_endpoint_descriptorusb_interface_descriptorusb_string_descriptorusb_config_descriptorusb_device_descriptorusb_descriptor_headerusb_ctrlrequestu2_pelu2_selu1_pelu1_selCKCDIDCHIDMICnoncebReserved__u8[3]tTKIDbStatusbMessageNumberbmCompAttributesbOverTheAirIntervalwOverTheAirPacketSizewMaxStreamDelaybMaxSequencebMaxBurstbDescriptorTypebLengthContainerIDbDevCapabilityTypebU2DevExitLatbU1devExitLatbFunctionalitySupportwSpeedSupportedbmAttributesbmBandGroupbmFFITXPowerInfobmTFITXPowerInfowPHYRatesbNumDeviceCapswTotalLengthbAuthKeyIndexbEncryptionValuebEncryptionType__u8[0]bKeyDatabNumEncryptionTypesiFunctionbFunctionProtocolbFunctionSubClassbFunctionClassbInterfaceCountbFirstInterfacebDebugOutEndpointbDebugInEndpointbRESERVEDbNumConfigurationsbMaxPacketSize0bDeviceProtocolbDeviceSubClassbDeviceClassbcdUSBwBytesPerIntervalu8[0]bDatawLengthwDescriptorLength0bDescriptorType0bNumDescriptorsbCountryCodebcdCDCbSynchAddressbRefreshbIntervalwMaxPacketSizebEndpointAddressiInterfacebInterfaceProtocolbInterfaceSubClassbInterfaceClassbNumEndpointsbAlternateSettingbInterfaceNumber__le16[1]wDatabMaxPoweriConfigurationbConfigurationValuebNumInterfacesiSerialNumberiProductiManufacturerbcdDeviceidProductidVendorwIndexwValuebRequestbRequestTypeUSB_SELF_POWER_VBUS_MAX_DRAWUSB3_LPM_MAX_U2_SEL_PEL0xFFFFUSB3_LPM_MAX_U1_SEL_PELUSB3_LPM_DEVICE_INITIATEDUSB3_LPM_U2_MAX_TIMEOUT0xFEUSB3_LPM_U1_MAX_TIMEOUT0x7FUSB3_LPM_DISABLEDUSB_ENDPOINT_SWITCH_SCALEUSB_ENDPOINT_SWITCH_SWITCHUSB_ENDPOINT_SWITCH_NOUSB_ENDPOINT_SWITCH_MASKUSB_DT_USB_SS_CONTN_ID_SIZECONTAINER_ID_TYPEUSB_DT_USB_SS_CAP_SIZEUSB_5GBPS_OPERATIONUSB_HIGH_SPEED_OPERATIONUSB_FULL_SPEED_OPERATIONUSB_LOW_SPEED_OPERATIONUSB_LTM_SUPPORTUSB_SS_CAP_TYPEUSB_DT_USB_EXT_CAP_SIZEUSB_GET_BESL_DEEP(p)(((p) & (0xf << 12)) >> 12)USB_GET_BESL_BASELINE(p)(((p) & (0xf << 8)) >> 8)USB_BESL_DEEP_VALIDUSB_BESL_BASELINE_VALIDUSB_BESL_SUPPORTUSB_LPM_SUPPORTUSB_CAP_TYPE_EXTUSB_WIRELESS_PHY_480USB_WIRELESS_PHY_400USB_WIRELESS_PHY_320USB_WIRELESS_PHY_200USB_WIRELESS_PHY_160USB_WIRELESS_PHY_107USB_WIRELESS_PHY_80USB_WIRELESS_PHY_53USB_WIRELESS_BEACON_NONE(3 << 2)USB_WIRELESS_BEACON_DIRECTED(2 << 2)USB_WIRELESS_BEACON_SELFUSB_WIRELESS_BEACON_MASKUSB_WIRELESS_P2P_DRDUSB_CAP_TYPE_WIRELESS_USBUSB_DT_BOS_SIZEUSB_ENC_TYPE_RSA_1USB_ENC_TYPE_CCM_1USB_ENC_TYPE_WIREDUSB_ENC_TYPE_UNSECUREUSB_OTG_HNPUSB_OTG_SRPUSB_SS_MULT(p)(1 + ((p) & 0x3))USB_DT_SS_EP_COMP_SIZEUSB_ENDPOINT_USAGE_IMPLICIT_FBUSB_ENDPOINT_USAGE_FEEDBACKUSB_ENDPOINT_USAGE_DATAUSB_ENDPOINT_USAGE_MASKUSB_ENDPOINT_SYNC_SYNCUSB_ENDPOINT_SYNC_ADAPTIVEUSB_ENDPOINT_SYNC_ASYNCUSB_ENDPOINT_SYNC_NONE(0 << 2)USB_ENDPOINT_SYNCTYPEUSB_ENDPOINT_INTR_NOTIFICATIONUSB_ENDPOINT_INTR_PERIODIC(0 << 4)USB_EP_MAXP_MULT(m)(((m) & USB_EP_MAXP_MULT_MASK) >> USB_EP_MAXP_MULT_SHIFT)USB_EP_MAXP_MULT_MASK(3 << USB_EP_MAXP_MULT_SHIFT)USB_EP_MAXP_MULT_SHIFTUSB_ENDPOINT_MAXP_MASKUSB_ENDPOINT_MAX_ADJUSTABLEUSB_CONFIG_ATT_BATTERYUSB_CONFIG_ATT_WAKEUPUSB_CONFIG_ATT_SELFPOWERUSB_CONFIG_ATT_ONEUSB_SUBCLASS_VENDOR_SPECUSB_CLASS_APP_SPECUSB_CLASS_MISCUSB_CLASS_WIRELESS_CONTROLLERUSB_CLASS_VIDEOUSB_CLASS_CONTENT_SECUSB_CLASS_CSCIDUSB_CLASS_CDC_DATAUSB_CLASS_STILL_IMAGEUSB_CLASS_PHYSICALUSB_DT_CS_ENDPOINT(USB_TYPE_CLASS | USB_DT_ENDPOINT)USB_DT_CS_INTERFACE(USB_TYPE_CLASS | USB_DT_INTERFACE)USB_DT_CS_STRING(USB_TYPE_CLASS | USB_DT_STRING)USB_DT_CS_CONFIG(USB_TYPE_CLASS | USB_DT_CONFIG)USB_DT_CS_DEVICE(USB_TYPE_CLASS | USB_DT_DEVICE)USB_DT_HID_REPORTUSB_DT_SS_ENDPOINT_COMPUSB_DT_PIPE_USAGEUSB_DT_CS_RADIO_CONTROLUSB_DT_RPIPEUSB_DT_WIRE_ADAPTERUSB_DT_WIRELESS_ENDPOINT_COMPUSB_DT_DEVICE_CAPABILITYUSB_DT_BOSUSB_DT_ENCRYPTION_TYPEUSB_DT_KEYUSB_DT_SECURITYUSB_DT_INTERFACE_ASSOCIATIONUSB_DT_DEBUGUSB_DT_OTGUSB_DT_INTERFACE_POWERUSB_DT_OTHER_SPEED_CONFIGUSB_DT_DEVICE_QUALIFIERUSB_DEV_STAT_LTM_ENABLEDUSB_DEV_STAT_U2_ENABLEDUSB_DEV_STAT_U1_ENABLEDUSB_ENDPOINT_HALTUSB_INTRF_FUNC_SUSPEND_RW(1 << (8 + 1))USB_INTRF_FUNC_SUSPEND_LP(1 << (8 + 0))USB_INTR_FUNC_SUSPEND_OPT_MASK0xFF00USB_INTRF_FUNC_SUSPENDUSB_DEVICE_LTM_ENABLEUSB_DEVICE_U2_ENABLEUSB_DEVICE_U1_ENABLETEST_FORCE_ENTEST_PACKETTEST_SE0_NAKTEST_KTEST_JUSB_DEVICE_DEBUG_MODEUSB_DEVICE_A_ALT_HNP_SUPPORTUSB_DEVICE_A_HNP_SUPPORTUSB_DEVICE_WUSB_DEVICEUSB_DEVICE_B_HNP_ENABLEUSB_DEVICE_BATTERYUSB_DEVICE_TEST_MODEUSB_DEVICE_REMOTE_WAKEUPUSB_DEVICE_SELF_POWEREDUSB_REQ_SET_INTERFACE_DSUSB_REQ_LOOPBACK_DATA_READUSB_REQ_LOOPBACK_DATA_WRITEUSB_REQ_SET_WUSB_DATAUSB_REQ_GET_SECURITY_DATAUSB_REQ_SET_SECURITY_DATAUSB_REQ_SET_CONNECTIONUSB_REQ_GET_HANDSHAKEUSB_REQ_RPIPE_RESETUSB_REQ_SET_HANDSHAKEUSB_REQ_RPIPE_ABORTUSB_REQ_GET_ENCRYPTIONUSB_REQ_SET_ENCRYPTIONUSB_REQ_SET_ISOCH_DELAYUSB_REQ_SET_SELUSB_RECIP_RPIPEUSB_RECIP_PORTUSB_RECIP_MASKUSB_TYPE_MASK__LINUX_USB_CH9_H__KERNEL__/* __LINUX_USB_CH9_H *//**
 * struct usb_string - wraps a C string and its USB id
 * @id:the (nonzero) ID for this string
 * @s:the string, in UTF-8 encoding
 *
 * If you're using usb_gadget_get_string(), use this to wrap a string
 * together with its ID.
 *//*
 * As per USB compliance update, a device that is actively drawing
 * more than 100mA from USB must report itself as bus-powered in
 * the GetStatus(DEVICE) call.
 * http://compliance.usb.org/index.asp?UpdateFile=Electrical&Format=Standard#34
 *//*-------------------------------------------------------------------------*//*
 * The Set System Exit Latency control transfer provides one byte each for
 * U1 SEL and U1 PEL, so the max exit latency is 0xFF.  U2 SEL and U2 PEL each
 * are two bytes long.
 *//*
 * A U1 timeout of 0x0 means the parent hub will reject any transitions to U1.
 * 0xff means the parent hub will accept transitions to U1, but will not
 * initiate a transition.
 *
 * A U1 timeout of 0x1 to 0x7F also causes the hub to initiate a transition to
 * U1 after that many microseconds.  Timeouts of 0x80 to 0xFE are reserved
 * values.
 *
 * A U2 timeout of 0x0 means the parent hub will reject any transitions to U2.
 * 0xff means the parent hub will accept transitions to U2, but will not
 * initiate a transition.
 *
 * A U2 timeout of 0x1 to 0xFE also causes the hub to initiate a transition to
 * U2 after N*256 microseconds.  Therefore a U2 timeout value of 0x1 means a U2
 * idle timer of 256 microseconds, 0x2 means 512 microseconds, 0xFE means
 * 65.024ms.
 *//* NOTE:  there are actually four different SUSPENDED
	 * states, returning to POWERED, DEFAULT, ADDRESS, or
	 * CONFIGURED respectively when SOF tokens flow again.
	 * At this level there's no difference between L1 and L2
	 * suspend states.  (L2 being original USB 1.1 suspend.)
	 *//* most functions *//* limited function *//* auth *//* wired *//* chapter 9 and authentication (wireless) device states *//* NOTATTACHED isn't in the USB spec, and this state acts
	 * the same as ATTACHED ... but it's clearer this way.
	 *//**
 * usb_speed_string() - Returns human readable-name of the speed.
 * @speed: The speed to return human-readable name for.  If it's not
 *   any of the speeds defined in usb_device_speed enum, string for
 *   USB_SPEED_UNKNOWN will be returned.
 *//* usb 3.0 *//* wireless (usb 2.5) *//* usb 2.0 *//* usb 1.1 *//* enumerating *//* USB 2.0 defines three speeds, here's how Linux identifies them *//* connection key *//* device id (unique w/in host context) *//* persistent host id *//* USB_REQ_SET_CONNECTION modifies or revokes a connection context (CC).
 * A CC may also be set up using non-wireless secure channels (including
 * wired USB!), and some devices may support CCs with multiple hosts.
 *//* USB_REQ_SET_HANDSHAKE is a four-way handshake used between a wireless
 * host and a device for connection set up, mutual authentication, and
 * exchanging short lived session keys.  The handshake depends on a CC.
 *//* in bmCompAttributes *//* USB_DT_WIRELESS_ENDPOINT_COMP:  companion descriptor associated with
 * each endpoint descriptor for a wireless device
 *//* 128-bit number *//*
 * Container ID Capability descriptor: Defines the instance unique ID used to
 * identify the instance across all operating modes
 *//* Operation at 5Gbps *//* High speed operation *//* Full speed operation *//* Low speed operation *//* supports LTM *//* Link Power Management *//*
 * SuperSpeed USB Capability descriptor: Defines the set of SuperSpeed USB
 * specific device level capabilities
 *//* Deep BESL valid *//* Baseline BESL valid*//* supports BESL *//* supports LPM *//* USB 2.0 Extension descriptor *//* FFI power levels *//* TFI power levels *//* always set *//* bit rates, Mbps *//* Ultra Wide Band *//* USB_DT_DEVICE_CAPABILITY:  grouped with BOS *//* USB_DT_BOS:  group of device-level capabilities *//* use in SET_ENCRYPTION *//* rsa3072/sha1 auth *//* aes128/cbc session *//* non-wireless mode *//* USB_DT_ENCRYPTION_TYPE:  bundled in DT_SECURITY groups *//* USB_DT_KEY:  used with {GET,SET}_SECURITY_DATA; only public keys
 * may be retrieved.
 *//* USB_DT_SECURITY:  group of wireless security descriptors, including
 * encryption types available for setting up a CC/association.
 *//* USB_DT_INTERFACE_ASSOCIATION: groups interfaces *//* bulk endpoints with 8 byte maxpacket *//* USB_DT_DEBUG:  for special highspeed devices, replacing serial console *//* swap host/device roles *//* from usb_otg_descriptor.bmAttributes *//* support for HNP, SRP, etc *//* USB_DT_OTG (from OTG 1.0a supplement) *//* USB_DT_DEVICE_QUALIFIER: Device Qualifier descriptor *//* Bits 1:0 of bmAttributes if this is an isoc endpoint *//* Bits 4:0 of bmAttributes if this is a bulk endpoint *//* USB_DT_SS_ENDPOINT_COMP: SuperSpeed Endpoint Companion descriptor *//**
 * usb_endpoint_maxp_mult - get endpoint's transactional opportunities
 * @epd: endpoint to be checked
 *
 * Return @epd's wMaxPacketSize[12:11] + 1
 *//**
 * usb_endpoint_maxp - get endpoint's max packet size
 * @epd: endpoint to be checked
 *
 * Returns @epd's max packet
 *//**
 * usb_endpoint_is_isoc_out - check if the endpoint is isochronous OUT
 * @epd: endpoint to be checked
 *
 * Returns true if the endpoint has isochronous transfer type and OUT direction,
 * otherwise it returns false.
 *//**
 * usb_endpoint_is_isoc_in - check if the endpoint is isochronous IN
 * @epd: endpoint to be checked
 *
 * Returns true if the endpoint has isochronous transfer type and IN direction,
 * otherwise it returns false.
 *//**
 * usb_endpoint_is_int_out - check if the endpoint is interrupt OUT
 * @epd: endpoint to be checked
 *
 * Returns true if the endpoint has interrupt transfer type and OUT direction,
 * otherwise it returns false.
 *//**
 * usb_endpoint_is_int_in - check if the endpoint is interrupt IN
 * @epd: endpoint to be checked
 *
 * Returns true if the endpoint has interrupt transfer type and IN direction,
 * otherwise it returns false.
 *//**
 * usb_endpoint_is_bulk_out - check if the endpoint is bulk OUT
 * @epd: endpoint to be checked
 *
 * Returns true if the endpoint has bulk transfer type and OUT direction,
 * otherwise it returns false.
 *//**
 * usb_endpoint_is_bulk_in - check if the endpoint is bulk IN
 * @epd: endpoint to be checked
 *
 * Returns true if the endpoint has bulk transfer type and IN direction,
 * otherwise it returns false.
 *//**
 * usb_endpoint_xfer_isoc - check if the endpoint has isochronous transfer type
 * @epd: endpoint to be checked
 *
 * Returns true if the endpoint is of type isochronous, otherwise it returns
 * false.
 *//**
 * usb_endpoint_xfer_int - check if the endpoint has interrupt transfer type
 * @epd: endpoint to be checked
 *
 * Returns true if the endpoint is of type interrupt, otherwise it returns
 * false.
 *//**
 * usb_endpoint_xfer_control - check if the endpoint has control transfer type
 * @epd: endpoint to be checked
 *
 * Returns true if the endpoint is of type control, otherwise it returns false.
 *//**
 * usb_endpoint_xfer_bulk - check if the endpoint has bulk transfer type
 * @epd: endpoint to be checked
 *
 * Returns true if the endpoint is of type bulk, otherwise it returns false.
 *//**
 * usb_endpoint_dir_out - check if the endpoint has OUT direction
 * @epd: endpoint to be checked
 *
 * Returns true if the endpoint is of type OUT, otherwise it returns false.
 *//**
 * usb_endpoint_dir_in - check if the endpoint has IN direction
 * @epd: endpoint to be checked
 *
 * Returns true if the endpoint is of type IN, otherwise it returns false.
 *//**
 * usb_endpoint_type - get the endpoint's transfer type
 * @epd: endpoint to be checked
 *
 * Returns one of USB_ENDPOINT_XFER_{CONTROL, ISOC, BULK, INT} according
 * to @epd's transfer type.
 *//**
 * usb_endpoint_num - get the endpoint's number
 * @epd: endpoint to be checked
 *
 * Returns @epd's number: 0 to 15.
 *//* Implicit feedback Data endpoint *//* The USB 3.0 spec redefines bits 5:4 of bmAttributes as interrupt ep type. *//*
 * Endpoints
 *//* dummy *//* optional descriptors are not supported. *//* 0x01 *//* Used to access common fields *//* use USB_DT_ENDPOINT*_SIZE in bLength, not sizeof. *//* NOTE:  these two are _only_ in audio endpoints. *//* USB_DT_ENDPOINT: Endpoint descriptor *//* USB_DT_INTERFACE: Interface descriptor *//* note that "string" zero is special, it holds language codes that
 * the device supports, not Unicode characters.
 *//* UTF-16LE encoded *//* USB_DT_STRING: String descriptor *//* battery powered *//* can wakeup *//* self powered *//* must be set *//* from config descriptor bmAttributes *//* USB_DT_CONFIG: Configuration descriptor information.
 *
 * USB_DT_OTHER_SPEED_CONFIG is the same descriptor, except that the
 * descriptor type is different.  Highspeed-capable devices can look
 * different depending on what speed they're currently running.  Only
 * devices with a USB_DT_DEVICE_QUALIFIER have any OTHER_SPEED_CONFIG
 * descriptors.
 *//* content security *//* chip+ smart card *//*
 * Device and/or Interface Class codes
 * as found in bDeviceClass or bInterfaceClass
 * and defined by www.usb.org documents
 *//* USB_DT_DEVICE: Device descriptor *//* All standard descriptors have these 2 fields at the beginning *//* Conventional codes for class-specific descriptors.  The convention is
 * defined in the USB "Common Class" Spec (3.11).  Individual class specs
 * are authoritative for their usage, not the "common class" writeup.
 *//* From HID 1.11 spec *//* From the USB 3.0 spec *//* From the T10 UAS specification *//* these are from the Wireless USB spec *//* these are from a minor usb 2.0 revision (ECN) *//*
 * Descriptor types ... USB 2.0 spec table 9.5
 *//*
 * STANDARD DESCRIPTORS ... as returned by GET_DESCRIPTOR, or
 * (rarely) accepted by SET_DESCRIPTOR.
 *
 * Note that all multi-byte values here are encoded in little endian
 * byte order "on the wire".  Within the kernel and when exposed
 * through the Linux-USB APIs, they are not converted to cpu byte
 * order; it is the responsibility of the client code to do this.
 * The single exception is when device and configuration descriptors (but
 * not other descriptors) are read from usbfs (i.e. /proc/bus/usb/BBB/DDD);
 * in this case the fields are converted to host endianness by the kernel.
 *//**
 * struct usb_ctrlrequest - SETUP data for a USB device control request
 * @bRequestType: matches the USB bmRequestType field
 * @bRequest: matches the USB bRequest field
 * @wValue: matches the USB wValue field (le16 byte order)
 * @wIndex: matches the USB wIndex field (le16 byte order)
 * @wLength: matches the USB wLength field (le16 byte order)
 *
 * This structure is used to send control requests to a USB device.  It matches
 * the different fields of the USB 2.0 Spec section 9.3, table 9-2.  See the
 * USB spec for a fuller description of the different fields, and what they are
 * used for.
 *
 * Note that the driver for any interface can issue control requests.
 * For most devices, interfaces don't coordinate with each other, so
 * such requests may be made at any time.
 *//* Latency tolerance messages *//* transition into U2 state *//* transition into U1 state *//* Bit array elements as returned by the USB_REQ_GET_STATUS request. *//* IN/OUT will STALL *//*
 * Suspend Options, Table 9-7 USB 3.0 spec
 *//* function suspend *//* dev may send LTM *//* dev may initiate U2 transition *//* dev may initiate U1 transition *//*
 * New Feature Selectors as added by USB 3.0
 * See USB 3.0 spec Table 9-6
 *//*
 * Test Mode Selectors
 * See USB 2.0 spec Table 9-7
 *//* (special devices only) *//* (otg) other RH port does *//* (otg) RH port supports HNP *//* (wireless)*//* (otg) dev may initiate HNP *//* (wireless) *//* (wired high speed only) *//* dev may initiate wakeup *//* (read only) *//*
 * USB feature flags are written using USB_REQ_{CLEAR,SET}_FEATURE, and
 * are read as a bit array returned by USB_REQ_GET_STATUS.  (So there
 * are at most sixteen features of each type.)  Hubs may also support a
 * new USB_REQ_TEST_AND_SET_FEATURE to put ports into L1 suspend.
 *//* The Link Power Management (LPM) ECN defines USB_REQ_TEST_AND_SET command,
 * used by hubs to put ports into a new L1 suspend state, except that it
 * forgot to define its number ...
 *//* Wireless USB *//*
 * Standard requests, for the bRequest field of a SETUP packet.
 *
 * These are qualified by the bRequestType field, so that for example
 * TYPE_CLASS or TYPE_VENDOR specific feature flags could be retrieved
 * by a GET_STATUS request.
 *//* From Wireless USB 1.0 *//*
 * USB recipients, the third of three bRequestType fields
 *//*
 * USB types, the second of three bRequestType fields
 *//* to host *//* to device *//*
 * USB directions
 *
 * This bit flag is used in endpoint descriptors' bEndpointAddress field.
 * It's also one of three fields in control requests bRequestType.
 *//* CONTROL REQUEST SUPPORT *//* get_unaligned() *//* le16_to_cpu *//* __u8 etc *//*
 * This file holds USB constants and structures that are needed for
 * USB device APIs.  These are used by the USB device model, which is
 * defined in chapter 9 of the USB 2.0 specification and in the
 * Wireless USB 1.0 (spread around).  Linux has several APIs in C that
 * need these:
 *
 * - the master/host side Linux-USB kernel driver API;
 * - the "usbfs" user space API; and
 * - the Linux "gadget" slave/device/peripheral side driver API.
 *
 * USB 2.0 adds an additional "On The Go" (OTG) mode, which lets systems
 * act either as a USB master/host or as a USB slave/device.  That means
 * the master and slave side APIs benefit from working well together.
 *
 * There's also "Wireless USB", using low power short range radios for
 * peripheral interconnection but otherwise building on the USB framework.
 *
 * Note all descriptors are declared '__attribute__((packed))' so that:
 *
 * [a] they never get padded, either internally (USB spec writers
 *     probably handled that) or externally;
 *
 * [b] so that accessing bigger-than-a-bytes fields will never
 *     generate bus errors on any platform, even when the location of
 *     its descriptor inside a bundle isn't "naturally aligned", and
 *
 * [c] for consistency, removing all doubt even when it appears to
 *     someone that the two other points are non-issues for that
 *     particular descriptor type.
 *//opt/src/include/linux/usbusb<asm/unaligned.h>compepd/opt/src/include/usb.husb_show_treeusb_generic_descriptor *usb_generic_descriptor **usb_emul_find_descriptorusb_emul_find_for_devusb_emul_findusb_emul_intusb_device *usb_emul_bulkusb_emul_controldevrequest *usb_emul_setup_deviceusb_string *usb_get_max_xfer_sizeusb_update_hub_deviceusb_alloc_deviceusb_new_deviceusb_free_deviceusb_alloc_new_deviceusb_device **usb_find_usb2_hub_address_portusb_hub_resetusb_hub_probeusb_device_has_child_on_portusb_stor_resetusb_setup_ehci_gadgetehci_ctrl *ehci_ctrl **usb_child_pre_probeusb_select_configusb_get_bususb_scan_deviceusb_hub_scanusb_hub_is_root_hubusb_setup_deviceusb_get_dev_indexusb_get_port_statususb_set_interfaceusb_clear_haltusb_get_class_descriptorusb_get_reportusb_get_configuration_lenusb_get_configuration_nousb_maxpacketusb_disable_asynchusb_submit_int_msgusb_bulk_msgusb_control_msgusb_set_idleusb_set_protocolusb_detect_changeusb_stopusb_initusb_kbd_deregisterdrv_usb_kbd_initusb_stor_infousb_stor_scanboard_usb_cleanupboard_usb_initudc_disconnectpoll_int_queueint_queue *destroy_int_queuecreate_int_queuesubmit_int_msgsubmit_control_msgsubmit_bulk_msgusb_reset_root_portusb_lowlevel_stopusb_lowlevel_initehci_ctrldm_usb_opsusb_emul_platdatausb_bus_privusb_dev_platdatausb_platdatausb_hub_deviceusb_hub_descriptorusb_hub_statususb_port_statususb_driver_entryusb_device_idusb_init_typeUSB_INIT_HOSTUSB_INIT_DEVICEint_queueusb_devicePACKET_SIZE_8PACKET_SIZE_16PACKET_SIZE_32PACKET_SIZE_64usb_configdevrequestget_max_xfer_sizeupdate_hub_devicereset_root_portalloc_deviceinterruptbulkcontrolport1companiondesc_before_addrnext_addrconfignoudevinit_typetthub_depthUSB_MAXCHILDRENovercurrent_countquery_delayconnect_timeoutpusb_devbHubContrCurrentbPwrOn2PwrGoodwHubCharacteristicsbNbrPortssshsDeviceRemovablewHubDelaybHubHdrDecLat__u8[2]USB_MAXCHILDREN + 1USB_MAXCHILDREN + 1 + 7(USB_MAXCHILDREN + 1 + 7)(USB_MAXCHILDREN + 1 + 7) / 8PortPowerCtrlMaskwHubChangewHubStatuswPortChangewPortStatusconst usb_device_idconst usb_device_id *usb_device_id *bcdDevice_hibcdDevice_lomatch_flagscontroller_devslot_idportnrmaxchildact_lenint_pendingprivptrirq_act_lenirq_statusirq_handlestring_langidhave_langiddescriptorint[16]epmaxpacketoutepmaxpacketinhaltedmaxpacketsizeserialprodmfusb_interface[8]USB_MAXINTERFACESif_descno_of_ifusb_ss_ep_comp_descriptor[16]USB_MAXENDPOINTSss_ep_comp_descusb_endpoint_descriptor[16]ep_descact_altsettingnum_altsettingno_of_eprequesttypeusb_get_emul_ops(dev)((struct dm_usb_ops *)(dev)->driver->ops)usb_get_ops(dev)HUB_TTTT_32_BITSHUB_TTTT_24_BITSHUB_TTTT_16_BITSHUB_TTTT_8_BITSUSB_HUB_PR_SSUSB_HUB_PR_HS_MULTI_TTUSB_HUB_PR_HS_SINGLE_TTUSB_HUB_PR_HS_NO_TTUSB_HUB_PR_FSU_BOOT_USB_DEVICE(__name,__match)ll_entry_declare(struct usb_driver_entry, __name, usb_driver_entry) = { .driver = llsym(struct driver, __name, driver), .match = __match, }USB_DEVICE(vend,prod).match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = (vend), .idProduct = (prod)USB_DEVICE_ID_MATCH_DEVICE(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)USB_DEVICE_ID_MATCH_ALLUSB_DEVICE_ID_MATCH_NONEUSB_DEVICE_ID_MATCH_INT_NUMBERUSB_DEVICE_ID_MATCH_INT_PROTOCOLUSB_DEVICE_ID_MATCH_INT_SUBCLASSUSB_DEVICE_ID_MATCH_INT_CLASSUSB_DEVICE_ID_MATCH_DEV_PROTOCOLUSB_DEVICE_ID_MATCH_DEV_SUBCLASSUSB_DEVICE_ID_MATCH_DEV_CLASSUSB_DEVICE_ID_MATCH_DEV_HIUSB_DEVICE_ID_MATCH_DEV_LOUSB_DEVICE_ID_MATCH_PRODUCTUSB_DEVICE_ID_MATCH_VENDORusb_pipe_ep_index(pipe)usb_pipecontrol(pipe) ? (usb_pipeendpoint(pipe) * 2) : ((usb_pipeendpoint(pipe) * 2) - (usb_pipein(pipe) ? 0 : 1))usb_pipebulk(pipe)(usb_pipetype((pipe)) == PIPE_BULK)usb_pipecontrol(pipe)(usb_pipetype((pipe)) == PIPE_CONTROL)usb_pipeint(pipe)(usb_pipetype((pipe)) == PIPE_INTERRUPT)usb_pipeisoc(pipe)(usb_pipetype((pipe)) == PIPE_ISOCHRONOUS)usb_pipetype(pipe)(((pipe) >> 30) & 3)usb_pipedata(pipe)(((pipe) >> 19) & 1)usb_pipeendpoint(pipe)(((pipe) >> 15) & 0xf)usb_pipe_endpdev(pipe)(((pipe) >> 8) & 0x7ff)usb_pipedevice(pipe)(((pipe) >> 8) & 0x7f)usb_pipein(pipe)(((pipe) >> 7) & 1)usb_pipeout(pipe)((((pipe) >> 7) & 1) ^ 1)usb_packetid(pipe)(((pipe) & USB_DIR_IN) ? USB_PID_IN : USB_PID_OUT)usb_endpoint_halted(dev,ep,out)((dev)->halted[out] & (1 << (ep)))usb_endpoint_running(dev,ep,out)((dev)->halted[out] &= ~(1 << (ep)))usb_endpoint_halt(dev,ep,out)((dev)->halted[out] |= (1 << (ep)))usb_endpoint_out(ep_dir)(((ep_dir >> 7) & 1) ^ 1)usb_settoggle(dev,ep,out,bit)((dev)->toggle[out] = ((dev)->toggle[out] & ~(1 << ep)) | ((bit) << ep))usb_dotoggle(dev,ep,out)((dev)->toggle[out] ^= (1 << ep))usb_gettoggle(dev,ep,out)(((dev)->toggle[out] >> ep) & 1)usb_rcvdefctrl(dev)((PIPE_CONTROL << 30) | default_pipe(dev) | USB_DIR_IN)usb_snddefctrl(dev)((PIPE_CONTROL << 30) | default_pipe(dev))usb_rcvintpipe(dev,endpoint)((PIPE_INTERRUPT << 30) | create_pipe(dev, endpoint) | USB_DIR_IN)usb_sndintpipe(dev,endpoint)((PIPE_INTERRUPT << 30) | create_pipe(dev, endpoint))usb_rcvbulkpipe(dev,endpoint)((PIPE_BULK << 30) | create_pipe(dev, endpoint) | USB_DIR_IN)usb_sndbulkpipe(dev,endpoint)((PIPE_BULK << 30) | create_pipe(dev, endpoint))usb_rcvisocpipe(dev,endpoint)((PIPE_ISOCHRONOUS << 30) | create_pipe(dev, endpoint) | USB_DIR_IN)usb_sndisocpipe(dev,endpoint)((PIPE_ISOCHRONOUS << 30) | create_pipe(dev, endpoint))usb_rcvctrlpipe(dev,endpoint)((PIPE_CONTROL << 30) | create_pipe(dev, endpoint) | USB_DIR_IN)usb_sndctrlpipe(dev,endpoint)((PIPE_CONTROL << 30) | create_pipe(dev, endpoint))default_pipe(dev)((dev)->speed << 26)create_pipe(dev,endpoint)(((dev)->devnum << 8) | ((endpoint) << 15) | (dev)->maxpacketsize)swap_32(x)swap_16(x)__swap_32(x)({ unsigned long x_ = (unsigned long)x; (unsigned long)( ((x_ & 0x000000FFUL) << 24) | ((x_ & 0x0000FF00UL) << 8) | ((x_ & 0x00FF0000UL) >> 8) | ((x_ & 0xFF000000UL) >> 24)); })__swap_16(x)({ unsigned short x_ = (unsigned short)x; (unsigned short)( ((x_ & 0x00FFU) << 8) | ((x_ & 0xFF00U) >> 8)); })USB_MAX_STOR_DEVUSB_UHCI_DEV_ID0x7112USB_UHCI_VEND_ID0x8086USB_TIMEOUT_MS(pipe)(usb_pipebulk(pipe) ? 5000 : 1000)USB_CNTL_TIMEOUTUSB_MAX_HUBUSB_MAXCONFIGUSB_MAX_DEVICEUSB_MAXALTSETTINGUSB_ALTSETTINGALLOCUSB_DMA_MINALIGN_USB_H_ARCH_DMA_MINALIGN > 32!CONFIG_IS_ENABLED(DM_USB)CONFIG_IS_ENABLED(DM_USB)defined(CONFIG_USB_MUSB_HOST) || CONFIG_IS_ENABLED(DM_USB)defined CONFIG_USB_EHCI_HCD || defined CONFIG_USB_MUSB_HOST \CONFIG_USB_STORAGECONFIG_USB_HOST_ETHERCONFIG_USB_KEYBOARD__LITTLE_ENDIANDM_USBCONFIG_VAL(DM_USB)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_DM_USBCONFIG_DM_USBCONFIG_VAL(DM_USB_MODULE)CONFIG_DM_USB_MODULE__ARG_PLACEHOLDER_CONFIG_DM_USB_MODULE__ARG_PLACEHOLDER_CONFIG_DM_USB_MODULE 1DM_USB_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_DM_USB_MODULE/*_USB_H_ *//**
 * usb_show_tree() - show the USB device tree
 *
 * This shows a list of active USB devices along with basic information about
 * each.
 *//**
 * usb_emul_find_descriptor() - Find a USB descriptor of a particular device
 *
 * @ptr:	a pointer to a list of USB descriptor pointers
 * @type:	type of USB descriptor to find
 * @index:	if @type is USB_DT_CONFIG, this is the configuration value
 * @return a pointer to the USB descriptor found, NULL if not found
 *//**
 * usb_emul_find_for_dev() - Find an emulator for a particular device
 *
 * @dev:	USB device to check
 * @emulp:	Returns pointer to emulator, or NULL if not found
 * @return 0 if found, -ve on error
 *//**
 * usb_emul_find() - Find an emulator for a particular device
 *
 * Check @pipe and @port1 to find a device number on bus @bus and return it.
 *
 * @bus:	USB bus (controller)
 * @pipe:	Describes pipe being used, and includes the device number
 * @port1:	Describes port number on the parent hub
 * @emulp:	Returns pointer to emulator, or NULL if not found
 * @return 0 if found, -ve on error
 *//**
 * usb_emul_int() - Send an interrupt packet to an emulator
 *
 * @emul:	Emulator device
 * @udev:	USB device (which the emulator is causing to appear)
 * See struct dm_usb_ops for details on other parameters
 * @return 0 if OK, -ve on error
 *//**
 * usb_emul_bulk() - Send a bulk packet to an emulator
 *
 * @emul:	Emulator device
 * @udev:	USB device (which the emulator is causing to appear)
 * See struct dm_usb_ops for details on other parameters
 * @return 0 if OK, -ve on error
 *//**
 * usb_emul_control() - Send a control packet to an emulator
 *
 * @emul:	Emulator device
 * @udev:	USB device (which the emulator is causing to appear)
 * See struct dm_usb_ops for details on other parameters
 * @return 0 if OK, -ve on error
 *//**
 * usb_emul_setup_device() - Set up a new USB device emulation
 *
 * This is normally called when a new emulation device is bound. It tells
 * the USB emulation uclass about the features of the emulator.
 *
 * @dev:		Emulation device
 * @strings:		List of USB string descriptors, terminated by a NULL
 *			entry
 * @desc_list:		List of points or USB descriptors, terminated by NULL.
 *			The first entry must be struct usb_device_descriptor,
 *			and others follow on after that.
 * @return 0 if OK, -ENOSYS if not implemented, other -ve on error
 *//**
 * usb_get_max_xfer_size() - Get HCD's maximum transfer bytes
 *
 * The HCD may have limitation on the maximum bytes to be transferred
 * in a USB transfer. USB class driver needs to be aware of this.
 *
 * @dev:		USB device
 * @size:		maximum transfer bytes
 * @return 0 if OK, -ve on error
 *//**
 * usb_update_hub_device() - Update HCD's internal representation of hub
 *
 * After a hub descriptor is fetched, notify HCD so that its internal
 * representation of this hub can be updated.
 *
 * @dev:		Hub device
 * @return 0 if OK, -ve on error
 *//**
 * usb_free_device() - Free a partially-inited device
 *
 * This is an internal function. It is used to reverse the action of
 * usb_alloc_new_device() when we hit a problem during init.
 *//**
 * usb_alloc_new_device() - Allocate a new device
 *
 * @devp: returns a pointer of a new device structure. With driver model this
 *		is a device pointer, but with legacy USB this pointer is
 *		driver-specific.
 * @return 0 if OK, -ENOSPC if we have found out of room for new devices
 *//*
 * usb_find_usb2_hub_address_port() - Get hub address and port for TT setting
 *
 * Searches for the first HS hub above the given device. If a
 * HS hub is found, the hub address and the port the device is
 * connected to is return, as required for SPLIT transactions
 *
 * @param: udev full speed or low speed device
 *//* !CONFIG_IS_ENABLED(DM_USB) *//**
 * usb_stor_reset() - Prepare to scan USB storage devices
 *
 * Empty the list of USB storage devices in preparation for scanning them.
 * This must be called before a USB scan.
 *//**
 * usb_setup_ehci_gadget() - Set up a USB device as a gadget
 *
 * TODO(sjg@chromium.org): Tidy this up when USB gadgets can use driver model
 *
 * This provides a way to tell a controller to start up as a USB device
 * instead of as a host. It is untested.
 *//**
 * usb_child_pre_probe() - Pre-probe function for USB devices
 *
 * This is called on all children of hubs and USB controllers (i.e. UCLASS_USB
 * and UCLASS_USB_HUB) when a new device is about to be probed. It sets up the
 * device from the saved platform data and calls usb_select_config() to
 * finish set up.
 *
 * Once this is done, the device's normal driver can take over, knowing the
 * device is accessible on the USB bus.
 *
 * This function is for use only by the internal USB stack.
 *
 * @dev:	Device to set up
 *//**
 * usb_select_config() - Set up a device ready for use
 *
 * This function assumes that the device already has an address and a driver
 * bound, and is ready to be set up.
 *
 * This re-reads the device and configuration descriptors and sets the
 * configuration
 *
 * @dev:	Device to set up
 *//**
 * usb_get_bus() - Find the bus for a device
 *
 * Search up through parents to find the bus this device is connected to. This
 * will be a device with uclass UCLASS_USB.
 *
 * @dev:	Device to check
 * @return The bus, or NULL if not found (this indicates a critical error in
 *	the USB stack
 *//**
 * usb_scan_device() - Scan a device on a bus
 *
 * Scan a device on a bus. It has already been detected and is ready to
 * be enumerated. This may be either the root hub (@parent is a bus) or a
 * normal device (@parent is a hub)
 *
 * @parent:	Parent device
 * @port:	Hub port number (numbered from 1)
 * @speed:	USB speed to use for this device
 * @devp:	Returns pointer to device if all is well
 * @return 0 if OK, -ve on error
 *//**
 * usb_hub_scan() - Scan a hub and find its devices
 *
 * @hub:	Hub device to scan
 *//**
 * usb_hub_is_root_hub() - Test whether a hub device is root hub or not
 *
 * @hub:	USB hub device to test
 * @return:	true if the hub device is root hub, false otherwise.
 *//**
 * usb_setup_device() - set up a device ready for use
 *
 * @dev:	USB device pointer. This need not be a real device - it is
 *		common for it to just be a local variable with its ->dev
 *		member (i.e. @dev->dev) set to the parent device and
 *		dev->portnr set to the port number on the hub (1=first)
 * @do_read:	true to read the device descriptor before an address is set
 *		(should be false for XHCI buses, true otherwise)
 * @parent:	Parent device (either UCLASS_USB or UCLASS_USB_HUB)
 * @return 0 if OK, -ve on error *//**
 * usb_get_dev_index() - look up a device index number
 *
 * Look up devices using their index number (starting at 0). This works since
 * in U-Boot device addresses are allocated starting at 1 with no gaps.
 *
 * TODO(sjg@chromium.org): Remove this function when usb_ether.c is modified
 * to work better with driver model.
 *
 * @bus:	USB bus to check
 * @index:	Index number of device to find (0=first). This is just the
 *		device address less 1.
 *//**
	 * get_max_xfer_size() - Get HCD's maximum transfer bytes
	 *
	 * The HCD may have limitation on the maximum bytes to be transferred
	 * in a USB transfer. USB class driver needs to be aware of this.
	 *//**
	 * update_hub_device() - Update HCD's internal representation of hub
	 *
	 * After a hub descriptor is fetched, notify HCD so that its internal
	 * representation of this hub can be updated (xHCI)
	 *//**
	 * reset_root_port() - Reset usb root port
	 *//**
	 * alloc_device() - Allocate a new device context (XHCI)
	 *
	 * Before sending packets to a new device on an XHCI bus, a device
	 * context must be created. If this method is not NULL it will be
	 * called before the device is enumerated (even before its descriptor
	 * is read). This should be NULL for EHCI, which does not need this.
	 *//**
	 * destroy_int_queue() - Destroy an interrupt queue
	 *
	 * Destroy an interrupt queue created by create_int_queue().
	 *
	 * @queue: queue to poll
	 *
	 * @return 0 if OK, -ve on error
	 *//**
	 * poll_int_queue() - Poll an interrupt queue for completed packets
	 *
	 * Poll an interrupt queue for completed packets. The return value
	 * points to the part of the buffer passed to create_int_queue()
	 * corresponding to the completed packet.
	 *
	 * @queue: queue to poll
	 *
	 * @return Pointer to the data of the first completed packet, or
	 *         NULL if no packets are ready
	 *//**
	 * create_int_queue() - Create and queue interrupt packets
	 *
	 * Create and queue @queuesize number of interrupt usb packets of
	 * @elementsize bytes each. @buffer must be atleast @queuesize *
	 * @elementsize bytes.
	 *
	 * Note some controllers only support a queuesize of 1.
	 *
	 * @interval: Interrupt interval
	 *
	 * @return A pointer to the created interrupt queue or NULL on error
	 *//**
	 * interrupt() - Send an interrupt message
	 *
	 * Most parameters are as above.
	 *
	 * @interval: Interrupt interval
	 *//**
	 * bulk() - Send a bulk message
	 *
	 * Parameters are as above.
	 *//**
	 * control() - Send a control message
	 *
	 * Most parameters are as above.
	 *
	 * @setup: Additional setup information required by the message
	 *//**
 * struct dm_usb_ops - USB controller operations
 *
 * This defines the operations supoorted on a USB controller. Common
 * arguments are:
 *
 * @bus:	USB bus (i.e. controller), which is in UCLASS_USB.
 * @udev:	USB device parent data. Controllers are not expected to need
 *		this, since the device address on the bus is encoded in @pipe.
 *		It is used for sandbox, and can be handy for debugging and
 *		logging.
 * @pipe:	An assortment of bitfields which provide address and packet
 *		type information. See create_pipe() above for encoding
 *		details
 * @buffer:	A buffer to use for sending/receiving. This should be
 *		DMA-aligned.
 * @length:	Buffer length in bytes
 *//* Port number (numbered from 1) *//**
 * struct usb_emul_platdata - platform data about the USB emulator
 *
 * Given a USB emulator (UCLASS_USB_EMUL) 'dev', this is
 * dev_get_uclass_platdata(dev).
 *
 * @port1:	USB emulator device port number on the parent hub
 *//**
 * struct usb_bus_priv - information about the USB controller
 *
 * Given a USB controller (UCLASS_USB) 'dev', this is
 * dev_get_uclass_priv(dev).
 *
 * @next_addr:	Next device address to allocate minus 1. Incremented by 1
 *		each time a new device address is set, so this holds the
 *		number of devices on the bus
 * @desc_before_addr:	true if we can read a device descriptor before it
 *		has been assigned an address. For XHCI this is not possible
 *		so this will be false.
 * @companion:  True if this is a companion controller to another USB
 *		controller
 *//* NULL-terminated list of descriptor pointers *//*
	 * This pointer is used to pass the usb_device used in usb_scan_device,
	 * to get the usb descriptors before the driver is known, to the
	 * actual udevice once the driver is known and the udevice is created.
	 * This will be NULL except during probe, do NOT use.
	 *
	 * This should eventually go away.
	 *//**
 * struct usb_dev_platdata - Platform data about a USB device
 *
 * Given a USB device dev this structure is dev_get_parent_platdata(dev).
 * This is used by sandbox to provide emulation data also.
 *
 * @id:		ID used to match this device
 * @devnum:	Device address on the USB bus
 * @udev:	usb-uclass internal use only do NOT use
 * @strings:	List of descriptor strings (for sandbox emulation purposes)
 * @desc_list:	List of descriptors (for sandbox emulation purposes)
 *//**
 * struct usb_platdata - Platform data about a USB controller
 *
 * Given a USB controller (UCLASS_USB) dev this is dev_get_platdata(dev)
 *//* Transaction Translator *//* USB 3.0 hub depth *//* Over-current counter *//* Device query delay in ms *//* Device connection timeout in ms *//* add 1 bit for hub status change; round to bytes *//* 2.0 and 3.0 hubs differ here *//* Hub descriptor *//* Transaction Translator Think Times, in bits *//* Super speed hub *//* Hi-speed hub with multiple TT *//* Hi-speed hub with single TT *//* Hi-speed hub without TT *//* Full speed hub *//*
 * Hub Device descriptor
 * USB Hub class device protocols
 *//*************************************************************************
 * Hub Stuff
 *//**
 * USB_DEVICE - macro used to describe a specific usb device
 * @vend: the 16 bit USB Vendor ID
 * @prod: the 16 bit USB Product ID
 *
 * This macro is used to create a struct usb_device_id that matches a
 * specific device.
 *//**
 * struct usb_driver_entry - Matches a driver to its usb_device_ids
 * @driver: Driver to use
 * @match: List of match records for this driver, terminated by {}
 *//* Match anything, indicates this is a valid entry even if everything is 0 *//* Some useful macros to use to create struct usb_device_id *//* not matched against *//* Used for vendor-specific interface matches *//* Used for interface class matches *//* Used for device class matches *//* Used for product specific matches; range is inclusive *//* which fields to match against? *//**
 * struct usb_device_id - identifies USB devices for probing and hotplugging
 * @match_flags: Bit mask controlling which of the other fields are used to
 *	match against new devices. Any field except for driver_info may be
 *	used, although some only make sense in conjunction with other fields.
 *	This is usually set by a USB_DEVICE_*() macro, which sets all
 *	other fields in this structure except for driver_info.
 * @idVendor: USB vendor ID for a device; numbers are assigned
 *	by the USB forum to its members.
 * @idProduct: Vendor-assigned product ID.
 * @bcdDevice_lo: Low end of range of vendor-assigned product version numbers.
 *	This is also used to identify individual product versions, for
 *	a range consisting of a single device.
 * @bcdDevice_hi: High end of version number range.  The range of product
 *	versions is inclusive.
 * @bDeviceClass: Class of device; numbers are assigned
 *	by the USB forum.  Products may choose to implement classes,
 *	or be vendor-specific.  Device classes specify behavior of all
 *	the interfaces on a device.
 * @bDeviceSubClass: Subclass of device; associated with bDeviceClass.
 * @bDeviceProtocol: Protocol of device; associated with bDeviceClass.
 * @bInterfaceClass: Class of interface; numbers are assigned
 *	by the USB forum.  Products may choose to implement classes,
 *	or be vendor-specific.  Interface classes specify behavior only
 *	of a given interface; other interfaces may support other classes.
 * @bInterfaceSubClass: Subclass of interface; associated with bInterfaceClass.
 * @bInterfaceProtocol: Protocol of interface; associated with bInterfaceClass.
 * @bInterfaceNumber: Number of interface; composite devices may use
 *	fixed interface numbers to differentiate between vendor-specific
 *	interfaces.
 * @driver_info: Holds information used by the driver.  Usually it holds
 *	a pointer to a descriptor understood by the driver, or perhaps
 *	device flags.
 *
 * In most cases, drivers will create a table of device IDs by using
 * USB_DEVICE(), or similar macros designed for that purpose.
 * They will then export it to userspace using MODULE_DEVICE_TABLE(),
 * and provide it to the USB core through their usb_driver structure.
 *
 * See the usb_match_id() function for information about how matches are
 * performed.  Briefly, you will normally use one of several macros to help
 * construct these entries.  Each entry you provide will either identify
 * one or more specific products, or will identify a class of products
 * which have agreed to behave the same.  You should put the more specific
 * matches towards the beginning of your table, so that driver_info can
 * record quirks of specific products.
 *//* Endpoint halt control/status *//* The D0/D1 toggle bits *//* Create various pipes... *//*
 * Calling this entity a "pipe" is glorifying it. A USB pipe
 * is something embarrassingly simple: it basically consists
 * of the following information:
 *  - device number (7 bits)
 *  - endpoint number (4 bits)
 *  - current Data0/1 state (1 bit)
 *  - direction (1 bit)
 *  - speed (2 bits)
 *  - max packet size (2 bits: 8, 16, 32 or 64)
 *  - pipe type (2 bits: control, interrupt, bulk, isochronous)
 *
 * That's 18 bits. Really. Nothing more. And the USB people have
 * documented these eighteen bits as some kind of glorious
 * virtual data structure.
 *
 * Let's not fall in that trap. We'll just encode it as a simple
 * unsigned int. The encoding is:
 *
 *  - max size:		bits 0-1	(00 = 8, 01 = 16, 10 = 32, 11 = 64)
 *  - direction:	bit 7		(0 = Host-to-Device [Out],
 *					(1 = Device-to-Host [In])
 *  - device:		bits 8-14
 *  - endpoint:		bits 15-18
 *  - Data0/1:		bit 19
 *  - pipe type:	bits 30-31	(00 = isochronous, 01 = interrupt,
 *					 10 = control, 11 = bulk)
 *
 * Why? Because it's arbitrary, and whatever encoding we select is really
 * up to us. This one happens to share a lot of bit positions with the UHCI
 * specification, so that much of the uhci driver can just mask the bits
 * appropriately.
 *//* some CPUs are already little endian e.g. the ARM920T *//* big endian -> little endian conversion *//* detect if a USB device has been (un)plugged *//* stop the USB Controller *//* initialize the USB Controller *//* routines *//*
 * can be used to clean up after failed USB initialization attempt
 * vide: board_usb_init()
 *
 * @param index USB controller number for selective cleanup
 * @param init usb_init_type passed to board_usb_init()
 *//*
 * board-specific hardware initialization, called by
 * usb drivers and u-boot commands
 *
 * @param index USB controller number
 * @param init initializes controller as USB host or device
 *//*
 * PXA25x can only act as USB device. There are drivers
 * which works with USB CDC gadgets implementations.
 * Some of them have common routines which can be used
 * in boards init functions e.g. udc_disconnect() used for
 * forced device disconnection from host.
 *//* Defines *//**********************************************************************
 * this is how the lowlevel part communicate with the outer world
 *//*
 * You can initialize platform's USB host or device
 * ports by passing this enum as an argument to
 * board_usb_init().
 *//* Pointer to associated controller *//* Pointer to associated device *//* slot_id - for xHCI enabled devices *//* hardware controller private data *//* parent hub, or NULL if this is the root hub *//* Port number, 1=first *//* Number of ports if hub *//* transferred bytes *//* 1 bit per ep, used by int_queue *//*
	 * Child devices -  if this is a hub device
	 * Each instance needs its own set of data structures.
	 *//* language ID for strings *//* whether string_langid is valid yet *//* config descriptor *//* Device Descriptor *//* selected config number *//* OUTput endpoint specific maximums *//* INput endpoint specific maximums *//* endpoint halts; one bit per endpoint # & direction;
	 * [0] = IN, [1] = OUT
	 *//* one bit for each endpoint ([0] = IN, [1] = OUT) *//* Maximum packet size; one of: PACKET_SIZE_* *//* serial number *//* product *//* manufacturer *//* full/low/high *//* Device number on USB bus *//**
 * struct usb_device - information about a USB device
 *
 * With driver model both UCLASS_USB (the USB controllers) and UCLASS_USB_HUB
 * (the hubs) have this as parent data. Hubs are children of controllers or
 * other hubs and there is always a single root hub for each controller.
 * Therefore struct usb_device can always be accessed with
 * dev_get_parent_priv(dev), where dev is a USB device.
 *
 * Pointers exist for obtaining both the device (could be any uclass) and
 * controller (UCLASS_USB) from this structure. The controller does not have
 * a struct usb_device since it is not a device.
 *//* Maximum packet size; encoded as 0,1,2,3 = 8,16,32,64 *//* number of interfaces *//* Configuration information.. *//*
	 * Super Speed Device will have Super Speed Endpoint
	 * Companion Descriptor  (section 9.6.7 of usb 3.0 spec)
	 * Revision 1.0 June 6th 2011
	 *//* Interface *//* device request (setup) *//*
 * This is the timeout to allow for submitting an urb in ms. We allow more
 * time for a BULK device to react - some are slow.
 *//* 100ms timeout *//* This is arbitrary *//* Hard limit *//* Everything is aribtrary *//*
 * The EHCI spec says that we must align to at least 32 bytes.  However,
 * some platforms require larger alignment.
 *//*
 * (C) Copyright 2001
 * Denis Peter, MPL AG Switzerland
 *
 * Adapted for U-Boot driver model
 * (C) Copyright 2015 Google, Inc
 * Note: Part of this code has been derived from linux
 *
 */<linux/usb/ch9.h><usb_defs.h>hub_addresshub_portifnumctlrphubdo_readinterfacealternatecfgnotransfer_lenactual_lengthdurationreport_idqueuequeuesizeelementsize/opt/src/cmd/ext4.cext4do_ext4_sizeext4load"load binary file from a Ext4 filesystem""<interface> [<dev[:part]> [addr [filename [bytes [pos]]]]]\n" "    - load binary file 'filename' from 'dev' on 'interface'\n" "      to address 'addr' from ext4 filesystem"load binary file from a Ext4 filesystem<interface> [<dev[:part]> [addr [filename [bytes [pos]]]]]
    - load binary file 'filename' from 'dev' on 'interface'
      to address 'addr' from ext4 filesystem"<interface> [<dev[:part]> [addr [filename [bytes [pos]]]]]\n"
	   "    - load binary file 'filename' from 'dev' on 'interface'\n"
	   "      to address 'addr' from ext4 filesystem"char[164]U_BOOT_CMD(ext4load, 7, 0, do_ext4_load,
	   "load binary file from a Ext4 filesystem",
	   "<interface> [<dev[:part]> [addr [filename [bytes [pos]]]]]\n"
	   "    - load binary file 'filename' from 'dev' on 'interface'\n"
	   "      to address 'addr' from ext4 filesystem")_u_boot_list_2_cmd_2_ext4load.u_boot_list_2_cmd_2_ext4loadext4ls"<interface> <dev[:part]> [directory]\n"
	   "    - list files from 'dev' on 'interface' in a 'directory'"U_BOOT_CMD(ext4ls, 4, 1, do_ext4_ls,
	   "list files in a directory (default /)",
	   "<interface> <dev[:part]> [directory]\n"
	   "    - list files from 'dev' on 'interface' in a 'directory'")_u_boot_list_2_cmd_2_ext4ls.u_boot_list_2_cmd_2_ext4lsext4size"determine a file's size""<interface> <dev[:part]> <filename>\n" "    - Find file 'filename' from 'dev' on 'interface'\n" "      and determine its size."determine a file's size<interface> <dev[:part]> <filename>
    - Find file 'filename' from 'dev' on 'interface'
      and determine its size."<interface> <dev[:part]> <filename>\n"
	"    - Find file 'filename' from 'dev' on 'interface'\n"
	"      and determine its size."char[119]U_BOOT_CMD(
	ext4size,	4,	0,	do_ext4_size,
	"determine a file's size",
	"<interface> <dev[:part]> <filename>\n"
	"    - Find file 'filename' from 'dev' on 'interface'\n"
	"      and determine its size."
)_u_boot_list_2_cmd_2_ext4size.u_boot_list_2_cmd_2_ext4sizeext4write"create a file in the root directory""<interface> <dev[:part]> <addr> <absolute filename path>\n" "    [sizebytes] [file offset]\n" "    - create a file in / directory"create a file in the root directory<interface> <dev[:part]> <addr> <absolute filename path>
    [sizebytes] [file offset]
    - create a file in / directory"<interface> <dev[:part]> <addr> <absolute filename path>\n"
	   "    [sizebytes] [file offset]\n"
	   "    - create a file in / directory"char[122]U_BOOT_CMD(ext4write, 7, 1, do_ext4_write,
	   "create a file in the root directory",
	   "<interface> <dev[:part]> <addr> <absolute filename path>\n"
	   "    [sizebytes] [file offset]\n"
	   "    - create a file in / directory")_u_boot_list_2_cmd_2_ext4write.u_boot_list_2_cmd_2_ext4writedefined(CONFIG_CMD_USB) && defined(CONFIG_USB_STORAGE)defined(CONFIG_CMD_EXT4_WRITE)/*
 * Changelog:
 *	0.1 - Newly created file for ext4fs support. Taken from cmd_ext2.c
 *	        file in uboot. Added ext4fs ls load and write support.
 *//*
 * (C) Copyright 2011 - 2012 Samsung Electronics
 * EXT4 filesystem implementation in Uboot by
 * Uma Shankar <uma.shankar@samsung.com>
 * Manjunatha C Achar <a.manjunatha@samsung.com>
 *
 * Ext4fs support
 * made from existing cmd_ext2.c file of Uboot
 *
 * (C) Copyright 2004
 * esd gmbh <www.esd-electronics.com>
 * Reinhard Arlt <reinhard.arlt@esd-electronics.com>
 *
 * made from cmd_reiserfs by
 *
 * (C) Copyright 2003 - 2004
 * Sysgo Real-Time Solutions, AG <www.elinos.com>
 * Pavel Bartusek <pba@sysgo.com>
 */<usb.h><ext4fs.h>/opt/src/include/linux/usb/gadget.hgadgetusb_gadget_releaseusb_gadget_initializeusb_gadget_handle_interruptsusb_ep_autoconfig_resetusb_gadget *usb_ep *usb_ep_autoconfigusb_gadget_giveback_requestusb_request *usb_gadget_udc_resetusb_gadget_driver *usb_gadget_set_stateusb_gadget_unmap_requestusb_gadget_map_requestusb_gadget_config_bufconst usb_config_descriptorconst usb_config_descriptor *usb_config_descriptor *const usb_descriptor_headerconst usb_descriptor_header *usb_descriptor_header *const usb_descriptor_header **usb_descriptor_header **usb_descriptor_fillbufusb_gadget_get_stringusb_gadget_strings *usb_del_gadget_udcusb_add_gadget_udcusb_add_gadget_udc_releaseusb_gadget_unregister_driverusb_gadget_register_driverusb_gadget_disconnectconst usb_gadget_opsconst usb_gadget_ops *usb_gadget_ops *EOPNOTSUPP-95-EOPNOTSUPPusb_gadget_connectusb_gadget_vbus_disconnectusb_gadget_vbus_drawusb_gadget_vbus_connectusb_gadget_clear_selfpoweredusb_gadget_set_selfpoweredusb_gadget_wakeupusb_gadget_frame_numbergadget_is_otggadget_is_dualspeeddev_to_usb_gadgetconst deviceconst device *struct usb_gadgetcontainer_of(dev, struct usb_gadget, dev)get_gadget_dataset_gadget_datausb_ep_fifo_flushconst usb_ep_opsconst usb_ep_ops *usb_ep_ops *usb_ep_fifo_statususb_ep_clear_haltusb_ep_set_haltusb_ep_dequeueusb_ep_queueusb_ep_free_requestusb_ep_alloc_requestusb_ep_disableusb_ep_enableusb_ep_set_maxpacket_limitusb_gadget_stringsusb_gadget_opsusb_gadget_driverusb_gadgetusb_requestusb_epusb_ep_opsudc_stopudc_startdisconnectconst usb_ctrlrequestconst usb_ctrlrequest *usb_ctrlrequest *functionpullupvbus_drawvbus_sessionset_selfpoweredwakeupget_framequirk_ep_out_aligned_sizea_alt_hnp_supporta_hnp_supportb_hnp_enableis_a_peripheralis_otgis_dualspeedmax_speedep_listep0contextcompletecomp_descmaxburstmaxpacket_limitmaxpacketfifo_statusset_wedgeset_haltdequeuefree_requestalloc_requestshort_not_okzerono_interruptstream_idgadget_for_each_ep(tmp,gadget)list_for_each_entry(tmp, &(gadget)->ep_list, ep_list)__LINUX_USB_GADGET_HCONFIG_USB_GADGET_DUALSPEEDCONFIG_USB_OTGCONFIG_IS_ENABLED(DM_USB_GADGET)DM_USB_GADGETCONFIG_VAL(DM_USB_GADGET_MODULE)CONFIG_DM_USB_GADGET_MODULE__ARG_PLACEHOLDER_CONFIG_DM_USB_GADGET_MODULE__ARG_PLACEHOLDER_CONFIG_DM_USB_GADGET_MODULE 1DM_USB_GADGET_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_DM_USB_GADGET_MODULECONFIG_VAL(DM_USB_GADGET)CONFIG_DM_USB_GADGET__ARG_PLACEHOLDER_CONFIG_DM_USB_GADGET__ARG_PLACEHOLDER_CONFIG_DM_USB_GADGET 1__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_DM_USB_GADGET/* __LINUX_USB_GADGET_H *//* utility wrapping a simple endpoint selection policy *//* utility to give requests back to the gadget layer *//* utility to tell udc core that the bus reset occurs *//* utility to set gadget state properly *//* utility to simplify map/unmap of usb_requests to/from DMA *//* build config descriptor from single descriptor vector *//* write vector of descriptors into buffer *//* utility to simplify managing config descriptors *//* put descriptor for string with that id into buf (buflen >= 256) *//* 0x0409 for en-us *//**
 * struct usb_gadget_strings - a set of USB strings in a given language
 * @language:identifies the strings' language (0x0409 for en-us)
 * @strings:array of strings with their ids
 *
 * If you're using usb_gadget_get_string(), use this to wrap all the
 * strings for a given language.
 *//* utility to simplify dealing with string descriptors *//**
 * usb_gadget_unregister_driver - unregister a gadget driver
 * @driver:the driver being unregistered
 *
 * Call this in your gadget driver's module cleanup function,
 * to tell the underlying usb controller that your driver is
 * going away.  If the controller is connected to a USB host,
 * it will first disconnect().  The driver is also requested
 * to unbind() and clean up any device state, before this procedure
 * finally returns.  It's expected that the unbind() functions
 * will in in exit sections, so may not be linked in some kernels.
 * This function must be called in a context that can sleep.
 *//**
 * usb_gadget_register_driver - register a gadget driver
 * @driver:the driver being registered
 *
 * Call this in your gadget driver's module initialization function,
 * to tell the underlying usb controller driver about your driver.
 * The driver's bind() function will be called to bind it to a
 * gadget before this registration call returns.  It's expected that
 * the bind() functions will be in init sections.
 * This function must be called in a context that can sleep.
 *//* driver modules register and unregister, as usual.
 * these calls must be made in a context that can sleep.
 *
 * these will usually be implemented directly by the hardware-dependent
 * usb bus interface driver, which will only support a single driver.
 *//**
 * struct usb_gadget_driver - driver for usb 'slave' devices
 * @function: String describing the gadget's function
 * @speed: Highest speed the driver handles.
 * @bind: Invoked when the driver is bound to a gadget, usually
 *	after registering the driver.
 *	At that point, ep0 is fully initialized, and ep_list holds
 *	the currently-available endpoints.
 *	Called in a context that permits sleeping.
 * @setup: Invoked for ep0 control requests that aren't handled by
 *	the hardware level driver. Most calls must be handled by
 *	the gadget driver, including descriptor and configuration
 *	management.  The 16 bit members of the setup data are in
 *	USB byte order. Called in_interrupt; this may not sleep.  Driver
 *	queues a response to ep0, or returns negative to stall.
 * @disconnect: Invoked after all transfers have been stopped,
 *	when the host is disconnected.  May be called in_interrupt; this
 *	may not sleep.  Some devices can't detect disconnect, so this might
 *	not be called except as part of controller shutdown.
 * @unbind: Invoked when the driver is unbound from a gadget,
 *	usually from rmmod (after a disconnect is reported).
 *	Called in a context that permits sleeping.
 * @suspend: Invoked on USB suspend.  May be called in_interrupt.
 * @resume: Invoked on USB resume.  May be called in_interrupt.
 * @reset: Invoked on USB bus reset. It is mandatory for all gadget drivers
 *	and should be called in_interrupt.
 *
 * Devices are disabled till a gadget driver successfully bind()s, which
 * means the driver will handle setup() requests needed to enumerate (and
 * meet "chapter 9" requirements) then do some useful work.
 *
 * If gadget->is_otg is true, the gadget driver must provide an OTG
 * descriptor during enumeration, or else fail the bind() call.  In such
 * cases, no USB traffic may flow until both bind() returns without
 * having called usb_gadget_disconnect(), and the USB host stack has
 * initialized.
 *
 * Drivers use hardware-specific knowledge to configure the usb hardware.
 * endpoint addressing is only one of several hardware characteristics that
 * are in descriptors the ep0 implementation returns from setup() calls.
 *
 * Except for ep0 implementation, most driver code shouldn't need change to
 * run on top of different usb controllers.  It'll use endpoints set up by
 * that ep0 implementation.
 *
 * The usb controller driver handles a few standard usb requests.  Those
 * include set_address, and feature flags for devices, interfaces, and
 * endpoints (the get_status, set_feature, and clear_feature requests).
 *
 * Accordingly, the driver's setup() callback must always implement all
 * get_descriptor requests, returning at least a device descriptor and
 * a configuration descriptor.  Drivers must make sure the endpoint
 * descriptors match any hardware constraints. Some hardware also constrains
 * other descriptors. (The pxa250 allows only configurations 1, 2, or 3).
 *
 * The driver's setup() callback must also implement set_configuration,
 * and should also implement set_interface, get_configuration, and
 * get_interface.  Setting a configuration (or interface) is where
 * endpoints should be activated or (config 0) shut down.
 *
 * (Note that only the default control endpoint is supported.  Neither
 * hosts nor devices generally support control traffic except to ep0.)
 *
 * Most devices will ignore USB suspend/resume operations, and so will
 * not provide those callbacks.  However, some may need to change modes
 * when the host is not longer directing those activities.  For example,
 * local controls (buttons, dials, etc) may need to be re-enabled since
 * the (remote) host can't do that any longer; or an error state might
 * be cleared, to make the device behave identically whether or not
 * power is maintained.
 *//**
 * usb_gadget_disconnect - software-controlled disconnect from USB host
 * @gadget:the peripheral being disconnected
 *
 * Disables the D+ (or potentially D-) pullup, which the host may see
 * as a disconnect (when a VBUS session is active).  Not all systems
 * support software pullup controls.
 *
 * This routine may be used during the gadget driver bind() call to prevent
 * the peripheral from ever being visible to the USB host, unless later
 * usb_gadget_connect() is called.  For example, user mode components may
 * need to be activated before the system can talk to hosts.
 *
 * Returns zero on success, else negative errno.
 *//**
 * usb_gadget_connect - software-controlled connect to USB host
 * @gadget:the peripheral being connected
 *
 * Enables the D+ (or potentially D-) pullup.  The host will start
 * enumerating this gadget when the pullup is active and a VBUS session
 * is active (the link is powered).  This pullup is always enabled unless
 * usb_gadget_disconnect() has been used to disable it.
 *
 * Returns zero on success, else negative errno.
 *//**
 * usb_gadget_vbus_disconnect - notify controller about VBUS session end
 * @gadget:the device whose VBUS supply is being described
 *
 * This call is used by a driver for an external transceiver (or GPIO)
 * that detects a VBUS power session ending.  Common responses include
 * reversing everything done in usb_gadget_vbus_connect().
 *
 * Returns zero on success, else negative errno.
 *//**
 * usb_gadget_vbus_draw - constrain controller's VBUS power usage
 * @gadget:The device whose VBUS usage is being described
 * @mA:How much current to draw, in milliAmperes.  This should be twice
 *	the value listed in the configuration descriptor bMaxPower field.
 *
 * This call is used by gadget drivers during SET_CONFIGURATION calls,
 * reporting how much power the device may consume.  For example, this
 * could affect how quickly batteries are recharged.
 *
 * Returns zero on success, else negative errno.
 *//**
 * usb_gadget_vbus_connect - Notify controller that VBUS is powered
 * @gadget:The device which now has VBUS power.
 *
 * This call is used by a driver for an external transceiver (or GPIO)
 * that detects a VBUS power session starting.  Common responses include
 * resuming the controller, activating the D+ (or D-) pullup to let the
 * host detect that a USB device is attached, and starting to draw power
 * (8mA or possibly more, especially after SET_CONFIGURATION).
 *
 * Returns zero on success, else negative errno.
 *//**
 * usb_gadget_clear_selfpowered - clear the device selfpowered feature.
 * @gadget:the device being declared as bus-powered
 *
 * this affects the device status reported by the hardware driver.
 * some hardware may not support bus-powered operation, in which
 * case this feature's value can never change.
 *
 * returns zero on success, else negative errno.
 *//**
 * usb_gadget_set_selfpowered - sets the device selfpowered feature.
 * @gadget:the device being declared as self-powered
 *
 * this affects the device status reported by the hardware driver
 * to reflect that it now has a local power supply.
 *
 * returns zero on success, else negative errno.
 *//**
 * usb_gadget_wakeup - tries to wake up the host connected to this gadget
 * @gadget: controller used to wake up the host
 *
 * Returns zero on success, else negative error code if the hardware
 * doesn't support such attempts, or its support has not been enabled
 * by the usb host.  Drivers must return device descriptors that report
 * their ability to support this, or hosts won't enable it.
 *
 * This may also try to use SRP to wake the host and start enumeration,
 * even if OTG isn't otherwise in use.  OTG devices may also start
 * remote wakeup even when hosts don't explicitly enable it.
 *//**
 * usb_gadget_frame_number - returns the current frame number
 * @gadget: controller that reports the frame number
 *
 * Returns the usb frame number, normally eleven bits from a SOF packet,
 * or negative errno if this device doesn't support this capability.
 *//**
 * gadget_is_otg - return true iff the hardware is OTG-ready
 * @g: controller that might have a Mini-AB connector
 *
 * This is a runtime test, since kernels with a USB-OTG stack sometimes
 * run on boards which only have a Mini-B (or Mini-A) connector.
 *//* runtime test would check "g->is_dualspeed" ... that might be
	 * useful to work around hardware bugs, but is mostly pointless
	 *//**
 * gadget_is_dualspeed - return true iff the hardware handles high speed
 * @g: controller that might support both high and full speeds
 *//* iterates the non-control endpoints; 'tmp' is a struct usb_ep pointer *//* of usb_ep *//* readonly to gadget driver *//**
 * struct usb_gadget - represents a usb slave device
 * @ops: Function pointers used to access hardware-specific operations.
 * @ep0: Endpoint zero, used when reading or writing responses to
 *	driver setup() requests
 * @ep_list: List of other endpoints supported by the device.
 * @speed: Speed of current connection to USB host.
 * @max_speed: Maximal speed the UDC can handle.  UDC must support this
 *      and all slower speeds.
 * @is_dualspeed: true if the controller supports both high and full speed
 *	operation.  If it does, the gadget driver must also support both.
 * @is_otg: true if the USB device port uses a Mini-AB jack, so that the
 *	gadget driver must provide a USB OTG descriptor.
 * @is_a_peripheral: false unless is_otg, the "A" end of a USB cable
 *	is in the Mini-AB jack, and HNP has been used to switch roles
 *	so that the "A" device currently acts as A-Peripheral, not A-Host.
 * @a_hnp_support: OTG device feature flag, indicating that the A-Host
 *	supports HNP at this port.
 * @a_alt_hnp_support: OTG device feature flag, indicating that the A-Host
 *	only supports HNP on a different root port.
 * @b_hnp_enable: OTG device feature flag, indicating that the A-Host
 *	enabled HNP support.
 * @name: Identifies the controller hardware type.  Used in diagnostics
 *	and sometimes configuration.
 * @dev: Driver model state for this abstract device.
 * @quirk_ep_out_aligned_size: epout requires buffer size to be aligned to
 *	MaxPacketSize.
 *
 * Gadgets have a mostly-portable "gadget driver" implementing device
 * functions, handling all usb configurations and interfaces.  Gadget
 * drivers talk to hardware-specific code indirectly, through ops vectors.
 * That insulates the gadget driver from hardware details, and packages
 * the hardware endpoints through generic i/o queues.  The "usb_gadget"
 * and "usb_ep" interfaces provide that insulation from the hardware.
 *
 * Except for the driver data, all fields in this structure are
 * read-only to the gadget driver.  That driver data is part of the
 * "driver model" infrastructure in 2.6 (and later) kernels, and for
 * earlier systems is grouped in a similar structure that's not known
 * to the rest of the kernel.
 *
 * Values of the three OTG device feature flags are updated before the
 * setup() call corresponding to USB_REQ_SET_CONFIGURATION, and before
 * driver suspend() calls.  They are valid only when is_otg, and when the
 * device is acting as a B-Peripheral (so is_a_peripheral is false).
 *//* the rest of the api to the controller hardware: device operations,
 * which don't involve endpoints (or i/o).
 *//**
 * usb_ep_fifo_flush - flushes contents of a fifo
 * @ep: the endpoint whose fifo is being flushed.
 *
 * This call may be used to flush the "unclaimed data" that may exist in
 * an endpoint fifo after abnormal transaction terminations.  The call
 * must never be used except when endpoint is not being used for any
 * protocol translation.
 *//**
 * usb_ep_fifo_status - returns number of bytes in fifo, or error
 * @ep: the endpoint whose fifo status is being checked.
 *
 * FIFO endpoints may have "unclaimed data" in them in certain cases,
 * such as after aborted transfers.  Hosts may not have collected all
 * the IN data written by the gadget driver (and reported by a request
 * completion).  The gadget driver may not have collected all the data
 * written OUT to it by the host.  Drivers that need precise handling for
 * fault reporting or recovery may need to use this call.
 *
 * This returns the number of such bytes in the fifo, or a negative
 * errno if the endpoint doesn't use a FIFO or doesn't support such
 * precise handling.
 *//**
 * usb_ep_clear_halt - clears endpoint halt, and resets toggle
 * @ep:the bulk or interrupt endpoint being reset
 *
 * Use this when responding to the standard usb "set interface" request,
 * for endpoints that aren't reconfigured, after clearing any other state
 * in the endpoint's i/o queue.
 *
 * Returns zero, or a negative error code.  On success, this call clears
 * the underlying hardware state reflecting endpoint halt and data toggle.
 * Note that some hardware can't support this request (like pxa2xx_udc),
 * and accordingly can't correctly implement interface altsettings.
 *//**
 * usb_ep_set_halt - sets the endpoint halt feature.
 * @ep: the non-isochronous endpoint being stalled
 *
 * Use this to stall an endpoint, perhaps as an error report.
 * Except for control endpoints,
 * the endpoint stays halted (will not stream any data) until the host
 * clears this feature; drivers may need to empty the endpoint's request
 * queue first, to make sure no inappropriate transfers happen.
 *
 * Note that while an endpoint CLEAR_FEATURE will be invisible to the
 * gadget driver, a SET_INTERFACE will not be.  To reset endpoints for the
 * current altsetting, see usb_ep_clear_halt().  When switching altsettings,
 * it's simplest to use usb_ep_enable() or usb_ep_disable() for the endpoints.
 *
 * Returns zero, or a negative error code.  On success, this call sets
 * underlying hardware state that blocks data transfers.
 * Attempts to halt IN endpoints will fail (returning -EAGAIN) if any
 * transfer requests are still queued, or if the controller hardware
 * (usually a FIFO) still holds bytes that the host hasn't collected.
 *//**
 * usb_ep_dequeue - dequeues (cancels, unlinks) an I/O request from an endpoint
 * @ep:the endpoint associated with the request
 * @req:the request being canceled
 *
 * if the request is still active on the endpoint, it is dequeued and its
 * completion routine is called (with status -ECONNRESET); else a negative
 * error code is returned.
 *
 * note that some hardware can't clear out write fifos (to unlink the request
 * at the head of the queue) except as part of disconnecting from usb.  such
 * restrictions prevent drivers from supporting configuration changes,
 * even to configuration zero (a "chapter 9" requirement).
 *//**
 * usb_ep_queue - queues (submits) an I/O request to an endpoint.
 * @ep:the endpoint associated with the request
 * @req:the request being submitted
 * @gfp_flags: GFP_* flags to use in case the lower level driver couldn't
 *	pre-allocate all necessary memory with the request.
 *
 * This tells the device controller to perform the specified request through
 * that endpoint (reading or writing a buffer).  When the request completes,
 * including being canceled by usb_ep_dequeue(), the request's completion
 * routine is called to return the request to the driver.  Any endpoint
 * (except control endpoints like ep0) may have more than one transfer
 * request queued; they complete in FIFO order.  Once a gadget driver
 * submits a request, that request may not be examined or modified until it
 * is given back to that driver through the completion callback.
 *
 * Each request is turned into one or more packets.  The controller driver
 * never merges adjacent requests into the same packet.  OUT transfers
 * will sometimes use data that's already buffered in the hardware.
 * Drivers can rely on the fact that the first byte of the request's buffer
 * always corresponds to the first byte of some USB packet, for both
 * IN and OUT transfers.
 *
 * Bulk endpoints can queue any amount of data; the transfer is packetized
 * automatically.  The last packet will be short if the request doesn't fill it
 * out completely.  Zero length packets (ZLPs) should be avoided in portable
 * protocols since not all usb hardware can successfully handle zero length
 * packets.  (ZLPs may be explicitly written, and may be implicitly written if
 * the request 'zero' flag is set.)  Bulk endpoints may also be used
 * for interrupt transfers; but the reverse is not true, and some endpoints
 * won't support every interrupt transfer.  (Such as 768 byte packets.)
 *
 * Interrupt-only endpoints are less functional than bulk endpoints, for
 * example by not supporting queueing or not handling buffers that are
 * larger than the endpoint's maxpacket size.  They may also treat data
 * toggle differently.
 *
 * Control endpoints ... after getting a setup() callback, the driver queues
 * one response (even if it would be zero length).  That enables the
 * status ack, after transfering data as specified in the response.  Setup
 * functions may return negative error codes to generate protocol stalls.
 * (Note that some USB device controllers disallow protocol stall responses
 * in some cases.)  When control responses are deferred (the response is
 * written after the setup callback returns), then usb_ep_set_halt() may be
 * used on ep0 to trigger protocol stalls.
 *
 * For periodic endpoints, like interrupt or isochronous ones, the usb host
 * arranges to poll once per interval, and the gadget driver usually will
 * have queued some data to transfer at that time.
 *
 * Returns zero, or a negative error code.  Endpoints that are not enabled
 * report errors; errors will also be
 * reported when the usb peripheral is disconnected.
 *//**
 * usb_ep_free_request - frees a request object
 * @ep:the endpoint associated with the request
 * @req:the request being freed
 *
 * Reverses the effect of usb_ep_alloc_request().
 * Caller guarantees the request is not queued, and that it will
 * no longer be requeued (or otherwise used).
 *//**
 * usb_ep_alloc_request - allocate a request object to use with this endpoint
 * @ep:the endpoint to be used with with the request
 * @gfp_flags:GFP_* flags to use
 *
 * Request objects must be allocated with this call, since they normally
 * need controller-specific setup and may even need endpoint-specific
 * resources such as allocation of DMA descriptors.
 * Requests may be submitted with usb_ep_queue(), and receive a single
 * completion callback.  Free requests with usb_ep_free_request(), when
 * they are no longer needed.
 *
 * Returns the request, or null if one could not be allocated.
 *//**
 * usb_ep_disable - endpoint is no longer usable
 * @ep:the endpoint being unconfigured.  may not be the endpoint named "ep0".
 *
 * no other task may be using this endpoint when this is called.
 * any pending and uncompleted requests will complete with status
 * indicating disconnect (-ESHUTDOWN) before this call returns.
 * gadget drivers must call usb_ep_enable() again before queueing
 * requests to the endpoint.
 *
 * returns zero, or a negative error code.
 *//**
 * usb_ep_enable - configure endpoint, making it usable
 * @ep:the endpoint being configured.  may not be the endpoint named "ep0".
 *	drivers discover endpoints through the ep_list of a usb_gadget.
 * @desc:descriptor for desired behavior.  caller guarantees this pointer
 *	remains valid until the endpoint is disabled; the data byte order
 *	is little-endian (usb-standard).
 *
 * when configurations are set, or when interface settings change, the driver
 * will enable or disable the relevant endpoints.  while it is enabled, an
 * endpoint may be used for i/o until the driver receives a disconnect() from
 * the host or until the endpoint is disabled.
 *
 * the ep0 implementation (which calls this routine) must ensure that the
 * hardware capabilities of each endpoint match the descriptor provided
 * for it.  for example, an endpoint named "ep2in-bulk" would be usable
 * for interrupt transfers as well as bulk, but it likely couldn't be used
 * for iso transfers or for endpoint 14.  some endpoints are fully
 * configurable, with more generic names like "ep-a".  (remember that for
 * USB, "in" means "towards the USB master".)
 *
 * returns zero, or a negative error code.
 *//**
 * usb_ep_set_maxpacket_limit - set maximum packet size limit for endpoint
 * @ep:the endpoint being configured
 * @maxpacket_limit:value of maximum packet size limit
 *
 * This function shoud be used only in UDC drivers to initialize endpoint
 * (usually in probe function).
 *//**
 * struct usb_ep - device side representation of USB endpoint
 * @name:identifier for the endpoint, such as "ep-a" or "ep9in-bulk"
 * @ops: Function pointers used to access hardware-specific operations.
 * @ep_list:the gadget's ep_list holds all of its endpoints
 * @maxpacket:The maximum packet size used on this endpoint.  The initial
 *	value can sometimes be reduced (hardware allowing), according to
 *      the endpoint descriptor used to configure the endpoint.
 * @maxpacket_limit:The maximum packet size value which can be handled by this
 *	endpoint. It's set once by UDC driver when endpoint is initialized, and
 *	should not be changed. Should not be confused with maxpacket.
 * @max_streams: The maximum number of streams supported
 * 	by this EP (0 - 16, actual number is 2^n)
 * @maxburst: the maximum number of bursts supported by this EP (for usb3)
 * @driver_data:for use by the gadget driver.  all other fields are
 *	read-only to gadget drivers.
 * @desc: endpoint descriptor.  This pointer is set before the endpoint is
 * 	enabled and remains valid until the endpoint is disabled.
 * @comp_desc: In case of SuperSpeed support, this is the endpoint companion
 * 	descriptor that is used to configure the endpoint
 *
 * the bus controller driver lists all the general purpose endpoints in
 * gadget->ep_list.  the control endpoint (gadget->ep0) is not in that list,
 * and is accessed only in response to a driver setup() callback.
 *//* endpoint-specific parts of the api to the usb controller hardware.
 * unlike the urb model, (de)multiplexing layers are not required.
 * (so this api could slash overhead if used on the host side...)
 *
 * note that device side usb controllers commonly differ in how many
 * endpoints they support, as well as their capabilities.
 *//**
 * struct usb_request - describes one i/o request
 * @buf: Buffer used for data.  Always provide this; some controllers
 *	only use PIO, or don't use DMA for some endpoints.
 * @dma: DMA address corresponding to 'buf'.  If you don't set this
 *	field, and the usb controller needs one, it is responsible
 *	for mapping and unmapping the buffer.
 * @stream_id: The stream id, when USB3.0 bulk streams are being used
 * @length: Length of that data
 * @no_interrupt: If true, hints that no completion irq is needed.
 *	Helpful sometimes with deep request queues that are handled
 *	directly by DMA controllers.
 * @zero: If true, when writing data, makes the last packet be "short"
 *     by adding a zero length packet as needed;
 * @short_not_ok: When reading data, makes short packets be
 *     treated as errors (queue stops advancing till cleanup).
 * @complete: Function called when request completes, so this request and
 *	its buffer may be re-used.
 *	Reads terminate with a short packet, or when the buffer fills,
 *	whichever comes first.  When writes terminate, some data bytes
 *	will usually still be in flight (often in a hardware fifo).
 *	Errors (for reads or writes) stop the queue from advancing
 *	until the completion function returns, so that any transfers
 *	invalidated by the error may first be dequeued.
 * @context: For use by the completion callback
 * @list: For use by the gadget driver.
 * @status: Reports completion code, zero or a negative errno.
 *	Normally, faults block the transfer queue from advancing until
 *	the completion callback returns.
 *	Code "-ESHUTDOWN" indicates completion caused by device disconnect,
 *	or when the driver disabled the endpoint.
 * @actual: Reports bytes transferred to/from the buffer.  For reads (OUT
 *	transfers) this may be less than the requested length.  If the
 *	short_not_ok flag is set, short reads are treated as errors
 *	even when status otherwise indicates successful completion.
 *	Note that for writes (IN transfers) some data bytes may still
 *	reside in a device-side FIFO when the request is reported as
 *	complete.
 *
 * These are allocated/freed through the endpoint they're used with.  The
 * hardware's driver can add extra per-request data to the memory it returns,
 * which often avoids separate memory allocations (potential failures),
 * later when the request is queued.
 *
 * Request flags affect request handling, such as whether a zero length
 * packet is written (the "zero" flag), whether a short read should be
 * treated as an error (blocking request queue advance, the "short_not_ok"
 * flag), or hinting that an interrupt is not required (the "no_interrupt"
 * flag, for use with deep request queues).
 *
 * Bulk endpoints can use any size buffers, and can also be used for interrupt
 * transfers. interrupt-only endpoints can be much less functional.
 *
 * NOTE:  this is analagous to 'struct urb' on the host side, except that
 * it's thinner and promotes more pre-allocation.
 *//*
 * <linux/usb/gadget.h>
 *
 * We call the USB code inside a Linux-based peripheral device a "gadget"
 * driver, except for the hardware-specific bus glue.  One USB host can
 * master many USB gadgets, but the gadgets are only slaved to one host.
 *
 *
 * (C) Copyright 2002-2004 by David Brownell
 * All Rights Reserved.
 *
 * This software is licensed under the GNU GPL version 2.
 *
 * Ported to U-Boot by: Thomas Smits <ts.smits@gmail.com> and
 *                      Remy Bohmer <linux@bohmer.net>
 */mAgfp_flagsis_in/opt/src/include/linux/bitmap.hbitmapbitmap_zeronbitssmall_const_nbits(nbits)0ULBITS_PER_BYTE * sizeof(long)BITS_TO_LONGS(nbits)sizeof(unsigned long)(__builtin_constant_p(nbits) && (nbits) <= BITS_PER_LONG)__LINUX_BITMAP_H/* __LINUX_BITMAP_H *//opt/src/include/linux/usb/composite.hcompositeusb_string_ids_nusb_composite_dev *usb_string_ids_tabusb_string_idusb_composite_unregisterusb_composite_driver *usb_composite_registerusb_add_configusb_configuration *ep_chooseusb_interface_idusb_function *usb_function_activateusb_function_deactivateusb_add_functionusb_functionusb_configurationusb_composite_devusb_composite_driverunsigned long[1]endpointsDECLARE_BITMAP(endpoints, 32)get_altset_altusb_function *[16]MAX_CONFIG_INTERFACESfullspeedhighspeednext_interface_idfunctionsdeactivationsnext_string_idusb_gadget_strings **const usb_device_descriptorconst usb_device_descriptor *usb_device_descriptor *configssuspendedbufsizhs_descriptorsUSB_GADGET_DELAYED_STATUS0x7fff__LINUX_USB_COMPOSITE_H/* __LINUX_USB_COMPOSITE_H *//* the gadget driver won't enable the data pullup
	 * while the deactivation count is nonzero.
	 *//* internals *//* private: *//**
 * struct usb_composite_device - represents one composite usb gadget
 * @gadget: read-only, abstracts the gadget's usb peripheral controller
 * @req: used for control responses; buffer is pre-allocated
 * @bufsiz: size of buffer pre-allocated in @req
 * @config: the currently active configuration
 *
 * One of these devices is allocated and initialized before the
 * associated device driver's bind() is called.
 *
 * OPEN ISSUE:  it appears that some WUSB devices will need to be
 * built by combining a normal (wired) gadget with a wireless one.
 * This revision of the gadget framework should probably try to make
 * sure doing that won't hurt too much.
 *
 * One notion for how to handle Wireless USB devices involves:
 * (a) a second gadget here, discovery mechanism TBD, but likely
 *     needing separate "register/unregister WUSB gadget" calls;
 * (b) updates to usb_gadget to include flags "is it wireless",
 *     "is it wired", plus (presumably in a wrapper structure)
 *     bandgroup and PHY info;
 * (c) presumably a wireless_ep wrapping a usb_ep, and reporting
 *     wireless-specific parameters like maxburst and maxsequence;
 * (d) configurations that are specific to wireless links;
 * (e) function drivers that understand wireless configs and will
 *     support wireless for (additional) function instances;
 * (f) a function to support association setup (like CBAF), not
 *     necessarily requiring a wireless adapter;
 * (g) composite device setup that can create one or more wireless
 *     configs, including appropriate association setup support;
 * (h) more, TBD.
 *//* global suspend hooks *//* REVISIT:  bind() functions can be marked __init, which
	 * makes trouble for section mismatch analysis.  See if
	 * we can't restructure things to avoid mismatching...
	 *//**
 * struct usb_composite_driver - groups configurations into a gadget
 * @name: For diagnostics, identifies the driver.
 * @dev: Template descriptor for the device, including default device
 *	identifiers.
 * @strings: tables of strings, keyed by identifiers assigned during bind()
 *	and language IDs provided in control requests
 * @bind: (REQUIRED) Used to allocate resources that are shared across the
 *	whole device, such as string IDs, and add its configurations using
 *	@usb_add_config().  This may fail by returning a negative errno
 *	value; it should return zero on successful initialization.
 * @unbind: Reverses @bind(); called as a side effect of unregistering
 *	this driver.
 * @disconnect: optional driver disconnect method
 * @suspend: Notifies when the host stops sending USB traffic,
 *	after function notifications
 * @resume: Notifies configuration when the host restarts USB traffic,
 *	before function notifications
 *
 * Devices default to reporting self powered operation.  Devices which rely
 * on bus powered operation should report this in their @bind() method.
 *
 * Before returning from @bind, various fields in the template descriptor
 * may be overridden.  These include the idVendor/idProduct/bcdDevice values
 * normally to bind the appropriate host side driver, and the three strings
 * (iManufacturer, iProduct, iSerialNumber) normally used to provide user
 * meaningful device identifiers.  (The strings will not be defined unless
 * they are defined in @dev and @strings.)  The correct ep0 maxpacket size
 * is also reported, as defined by the underlying controller driver.
 *//* fields in the config descriptor *//* configuration management:  bind/unbind *//**
 * struct usb_configuration - represents one gadget configuration
 * @label: For diagnostics, describes the configuration.
 * @strings: Tables of strings, keyed by identifiers assigned during @bind()
 *	and by language IDs provided in control requests.
 * @descriptors: Table of descriptors preceding all function descriptors.
 *	Examples include OTG and vendor-specific descriptors.
 * @bind: Called from @usb_add_config() to allocate resources unique to this
 *	configuration and to call @usb_add_function() for each function used.
 * @unbind: Reverses @bind; called as a side effect of unregistering the
 *	driver which added this configuration.
 * @setup: Used to delegate control requests that aren't handled by standard
 *	device infrastructure or directed at a specific interface.
 * @bConfigurationValue: Copied into configuration descriptor.
 * @iConfiguration: Copied into configuration descriptor.
 * @bmAttributes: Copied into configuration descriptor.
 * @bMaxPower: Copied into configuration descriptor.
 * @cdev: assigned by @usb_add_config() before calling @bind(); this is
 *	the device associated with this configuration.
 *
 * Configurations are building blocks for gadget drivers structured around
 * function drivers.  Simple USB gadgets require only one function and one
 * configuration, and handle dual-speed hardware by always providing the same
 * functionality.  Slightly more complex gadgets may have more than one
 * single-function configuration at a given speed; or have configurations
 * that only work at one speed.
 *
 * Composite devices are, by definition, ones with configurations which
 * include more than one function.
 *
 * The lifecycle of a usb_configuration includes allocation, initialization
 * of the fields described above, and calling @usb_add_config() to set up
 * internal data and bind it to a specific device.  The configuration's
 * @bind() method is then used to initialize all the functions and then
 * call @usb_add_function() for them.
 *
 * Those functions would normally be independant of each other, but that's
 * not mandatory.  CDC WMC devices are an example where functions often
 * depend on other functions, with some functions subsidiary to others.
 * Such interdependency may be managed in any way, so long as all of the
 * descriptors complete by the time the composite driver returns from
 * its bind() routine.
 *//* arbitrary; max 255 *//**
 * ep_choose - select descriptor endpoint at current device speed
 * @g: gadget, connected and running at some speed
 * @hs: descriptor to use for high speed operation
 * @fs: descriptor to use for full or low speed operation
 *//* runtime state management *//* REVISIT:  bind() functions can be marked __init, which
	 * makes trouble for section mismatch analysis.  See if
	 * we can't restructure things to avoid mismatching.
	 * Related:  unbind() may kfree() but bind() won't...
	 *//**
 * struct usb_function - describes one function of a configuration
 * @name: For diagnostics, identifies the function.
 * @strings: tables of strings, keyed by identifiers assigned during bind()
 *	and by language IDs provided in control requests
 * @descriptors: Table of full (or low) speed descriptors, using interface and
 *	string identifiers assigned during @bind().  If this pointer is null,
 *	the function will not be available at full speed (or at low speed).
 * @hs_descriptors: Table of high speed descriptors, using interface and
 *	string identifiers assigned during @bind().  If this pointer is null,
 *	the function will not be available at high speed.
 * @config: assigned when @usb_add_function() is called; this is the
 *	configuration with which this function is associated.
 * @bind: Before the gadget can register, all of its functions bind() to the
 *	available resources including string and interface identifiers used
 *	in interface or class descriptors; endpoints; I/O buffers; and so on.
 * @unbind: Reverses @bind; called as a side effect of unregistering the
 *	driver which added this function.
 * @set_alt: (REQUIRED) Reconfigures altsettings; function drivers may
 *	initialize usb_ep.driver data at this time (when it is used).
 *	Note that setting an interface to its current altsetting resets
 *	interface state, and that all interfaces have a disabled state.
 * @get_alt: Returns the active altsetting.  If this is not provided,
 *	then only altsetting zero is supported.
 * @disable: (REQUIRED) Indicates the function should be disabled.  Reasons
 *	include host resetting or reconfiguring the gadget, and disconnection.
 * @setup: Used for interface-specific control requests.
 * @suspend: Notifies functions when the host stops sending USB traffic.
 * @resume: Notifies functions when the host restarts USB traffic.
 *
 * A single USB function uses one or more interfaces, and should in most
 * cases support operation at both full and high speeds.  Each function is
 * associated by @usb_add_function() with a one configuration; that function
 * causes @bind() to be called so resources can be allocated as part of
 * setting up a gadget driver.  Those resources include endpoints, which
 * should be allocated using @usb_ep_autoconfig().
 *
 * To support dual speed operation, a function driver provides descriptors
 * for both high and full speed operation.  Except in rare cases that don't
 * involve bulk endpoints, each speed needs different endpoint descriptors.
 *
 * Function drivers choose their own strategies for managing instance data.
 * The simplest strategy just declares it "static', which means the function
 * can only be activated once.  If the function needs to be exposed in more
 * than one configuration at a given speed, it needs to support multiple
 * usb_function structures (one for each configuration).
 *
 * A more complex strategy might encapsulate a @usb_function structure inside
 * a driver-specific instance structure to allows multiple activations.  An
 * example of multiple activations might be a CDC ACM function that supports
 * two or more distinct instances within the same configuration, providing
 * several independent logical data links to a USB host.
 *//* Impossibly large value *//*
 * USB function drivers should return USB_GADGET_DELAYED_STATUS if they
 * wish to delay the data/status stages of the control transfer till they
 * are ready. The control transfer will then be kept from completing till
 * all the function drivers that requested for USB_GADGET_DELAYED_STAUS
 * invoke usb_composite_setup_continue().
 *//*
 * This framework is an optional layer on top of the USB Gadget interface,
 * making it easier to build (a) Composite devices, supporting multiple
 * functions within any single configuration, and (b) Multi-configuration
 * devices, also supporting multiple functions but without necessarily
 * having more than one function per configuration.
 *
 * Example:  a device with a single configuration supporting both network
 * link and mass storage functions is a composite device.  Those functions
 * might alternatively be packaged in individual configurations, but in
 * the composite model the host can use both functions at the same time.
 *//*
 * composite.h -- framework for usb gadgets which are composite devices
 *
 * Copyright (C) 2006-2008 David Brownell
 */<linux/bitmap.h><linux/usb/gadget.h>/opt/src/include/g_dnl.hg_dnlrun_usb_dnl_gadgetg_dnl_clear_detachg_dnl_trigger_detachg_dnl_detachg_dnl_set_serialnumberg_dnl_unregisterg_dnl_registerg_dnl_board_usb_cable_connectedg_dnl_get_board_bcd_device_numberg_dnl_bind_fixupg_dnl_bind_callbackg_dnl_bind_callback_fusb_function_nameDECLARE_GADGET_BIND_CALLBACK(usb_fname,callback_ptr)ll_entry_declare(struct g_dnl_bind_callback, __usb_function_name_ ## usb_fname, g_dnl_bind_callbacks) = { .usb_function_name = #usb_fname, .fptr = callback_ptr }__G_DOWNLOAD_H_/* __G_DOWNLOAD_H_ *//* used in Gadget downloader callback linker list *//*
 * @usb_fname: unescaped USB function name
 * @callback_ptr: bind callback, one per function name
 *//*
 *  Copyright (C) 2012 Samsung Electronics
 *  Lukasz Majewski <l.majewski@samsung.com>
 */<linux/usb/composite.h>usbctrl_indexusb_dnl_gadgetgcnum/opt/src/include/fastboot.hfastbootfastboot_data_completefastboot_data_downloadfastboot_data_remainingfastboot_handle_commandfastboot_bootfastboot_initfastboot_set_progress_callbackfastboot_set_reboot_flagfastboot_okayfastboot_failfastboot_responseFASTBOOT_COMMAND_GETVARFASTBOOT_COMMAND_DOWNLOADFASTBOOT_COMMAND_BOOTFASTBOOT_COMMAND_CONTINUEFASTBOOT_COMMAND_REBOOTFASTBOOT_COMMAND_REBOOT_BOOTLOADERFASTBOOT_COMMAND_SET_ACTIVEFASTBOOT_COMMAND_COUNTFASTBOOT_RESPONSE_LEN(64 + 1)FASTBOOT_COMMAND_LENFASTBOOT_VERSION"0.4"_FASTBOOT_H_CONFIG_IS_ENABLED(FASTBOOT_FLASH)CONFIG_IS_ENABLED(FASTBOOT_CMD_OEM_FORMAT)FASTBOOT_CMD_OEM_FORMATCONFIG_VAL(FASTBOOT_CMD_OEM_FORMAT_MODULE)CONFIG_FASTBOOT_CMD_OEM_FORMAT_MODULE__ARG_PLACEHOLDER_CONFIG_FASTBOOT_CMD_OEM_FORMAT_MODULE__ARG_PLACEHOLDER_CONFIG_FASTBOOT_CMD_OEM_FORMAT_MODULE 1FASTBOOT_CMD_OEM_FORMAT_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_FASTBOOT_CMD_OEM_FORMAT_MODULECONFIG_VAL(FASTBOOT_CMD_OEM_FORMAT)CONFIG_FASTBOOT_CMD_OEM_FORMAT__ARG_PLACEHOLDER_CONFIG_FASTBOOT_CMD_OEM_FORMAT__ARG_PLACEHOLDER_CONFIG_FASTBOOT_CMD_OEM_FORMAT 1__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_FASTBOOT_CMD_OEM_FORMATFASTBOOT_FLASHCONFIG_VAL(FASTBOOT_FLASH_MODULE)CONFIG_FASTBOOT_FLASH_MODULE__ARG_PLACEHOLDER_CONFIG_FASTBOOT_FLASH_MODULE__ARG_PLACEHOLDER_CONFIG_FASTBOOT_FLASH_MODULE 1FASTBOOT_FLASH_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_FASTBOOT_FLASH_MODULECONFIG_VAL(FASTBOOT_FLASH)CONFIG_FASTBOOT_FLASH__ARG_PLACEHOLDER_CONFIG_FASTBOOT_FLASH__ARG_PLACEHOLDER_CONFIG_FASTBOOT_FLASH 1__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_FASTBOOT_FLASH/* _FASTBOOT_H_ *//**
 * fastboot_data_complete() - Mark current transfer complete
 *
 * @response: Pointer to fastboot response buffer
 *
 * Set image_size and ${filesize} to the total size of the downloaded image.
 *//**
 * fastboot_data_download() - Copy image data to fastboot_buf_addr.
 *
 * @fastboot_data: Pointer to received fastboot data
 * @fastboot_data_len: Length of received fastboot data
 * @response: Pointer to fastboot response buffer
 *
 * Copies image data from fastboot_data to fastboot_buf_addr. Writes to
 * response. fastboot_bytes_received is updated to indicate the number
 * of bytes that have been transferred.
 *//**
 * fastboot_data_remaining() - return bytes remaining in current transfer
 *
 * Return: Number of bytes left in the current download
 *//**
 * fastboot_handle_command() - Handle fastboot command
 *
 * @cmd_string: Pointer to command string
 * @response: Pointer to fastboot response buffer
 *
 * Return: Executed command, or -1 if not recognized
 *//**
 * fastboot_boot() - Execute fastboot boot command
 *
 * If ${fastboot_bootcmd} is set, run that command to execute the boot
 * process, if that returns, then exit the fastboot server and return
 * control to the caller.
 *
 * Otherwise execute "bootm <fastboot_buf_addr>", if that fails, reset
 * the board.
 *//*
 * fastboot_init() - initialise new fastboot protocol session
 *
 * @buf_addr: Pointer to download buffer, or NULL for default
 * @buf_size: Size of download buffer, or zero for default
 *//**
 * fastboot_set_progress_callback() - set progress callback
 *
 * @progress: Pointer to progress callback
 *
 * Set a callback which is invoked periodically during long running operations
 * (flash and erase). This can be used (for example) by the UDP transport to
 * send INFO responses to keep the client alive whilst those commands are
 * executing.
 *//**
 * fastboot_set_reboot_flag() - Set flag to indicate reboot-bootloader
 *
 * Set flag which indicates that we should reboot into the bootloader
 * following the reboot that fastboot executes after this function.
 *
 * This function should be overridden in your board file with one
 * which sets whatever flag your board specific Android bootloader flow
 * requires in order to re-enter the bootloader.
 *//**
 * fastboot_okay() - Write an OKAY response of the form "OKAY$reason".
 *
 * @reason: Pointer to returned reason string, or NULL to send a bare "OKAY"
 * @response: Pointer to fastboot response buffer
 *//**
 * fastboot_fail() - Write a FAIL response of the form "FAIL$reason".
 *
 * @reason: Pointer to returned reason string
 * @response: Pointer to fastboot response buffer
 *//**
 * fastboot_response() - Writes a response of the form "$tag$reason".
 *
 * @tag: The first part of the response
 * @response: Pointer to fastboot response buffer
 * @format: printf style format string
 *//**
 * All known commands to fastboot
 *//* The 64 defined bytes plus \0 *//*
 * (C) Copyright 2008 - 2009
 * Windriver, <www.windriver.com>
 * Tom Rix <Tom.Rix@windriver.com>
 *
 * Copyright 2011 Sebastian Andrzej Siewior <bigeasy@linutronix.de>
 *
 * Copyright 2014 Linaro, Ltd.
 * Rob Herring <robh@kernel.org>
 */fastboot_datafastboot_data_lencmd_stringbuf_addrprogressreason/opt/src/cmd/fastboot.cdo_fastboot(uintptr_t)NULL"Error: Incorrect USB controller index\n"pr_err("Error: Incorrect USB controller index\n")pr_fmt("Error: Incorrect USB controller index\n")Error: Incorrect USB controller index
"udp""usb"do_fastboot_usb"Fastboot USB not enabled\n"pr_err("Fastboot USB not enabled\n")pr_fmt("Fastboot USB not enabled\n")Fastboot USB not enabled
USB_FUNCTION_FASTBOOTCONFIG_VAL(USB_FUNCTION_FASTBOOT)CONFIG_USB_FUNCTION_FASTBOOT__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_USB_FUNCTION_FASTBOOT__ARG_PLACEHOLDER_CONFIG_USB_FUNCTION_FASTBOOT__ARG_PLACEHOLDER_CONFIG_USB_FUNCTION_FASTBOOT 1CONFIG_VAL(USB_FUNCTION_FASTBOOT_MODULE)CONFIG_USB_FUNCTION_FASTBOOT_MODULEUSB_FUNCTION_FASTBOOT_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_USB_FUNCTION_FASTBOOT_MODULE__ARG_PLACEHOLDER_CONFIG_USB_FUNCTION_FASTBOOT_MODULE__ARG_PLACEHOLDER_CONFIG_USB_FUNCTION_FASTBOOT_MODULE 1do_fastboot_udpFASTBOOTfastboot udp error: %d
"fastboot udp error: %d\n"UDP_FUNCTION_FASTBOOTCONFIG_VAL(UDP_FUNCTION_FASTBOOT)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_UDP_FUNCTION_FASTBOOTCONFIG_UDP_FUNCTION_FASTBOOTCONFIG_VAL(UDP_FUNCTION_FASTBOOT_MODULE)CONFIG_UDP_FUNCTION_FASTBOOT_MODULEUDP_FUNCTION_FASTBOOT_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_UDP_FUNCTION_FASTBOOT_MODULE__ARG_PLACEHOLDER_CONFIG_UDP_FUNCTION_FASTBOOT_MODULE__ARG_PLACEHOLDER_CONFIG_UDP_FUNCTION_FASTBOOT_MODULE 1"run as a fastboot usb or udp device"fastboot_help_textU_BOOT_CMD(
	fastboot, CONFIG_SYS_MAXARGS, 1, do_fastboot,
	"run as a fastboot usb or udp device", fastboot_help_text
)run as a fastboot usb or udp devicechar[161]_u_boot_list_2_cmd_2_fastboot.u_boot_list_2_cmd_2_fastboot[-l addr] [-s size] usb <controller> | udp
	addr - address of buffer used during data transfers (0x0)
	size - size of buffer used during data transfers (0x8192)CONFIG_IS_ENABLED(UDP_FUNCTION_FASTBOOT)CONFIG_IS_ENABLED(USB_FUNCTION_FASTBOOT)0x8192/* Handle case when USB controller param is just '-' *//*
 * Copyright 2008 - 2009 Windriver, <www.windriver.com>
 * Author: Tom Rix <Tom.Rix@windriver.com>
 *
 * (C) Copyright 2014 Linaro, Ltd.
 * Rob Herring <robh@kernel.org>
 *//opt/src/include/watchdog.h<watchdog.h><fastboot.h><g_dnl.h>NXTARG/opt/src/include/s_record.hs_recordsrec_decodeSREC_MAXBINLENSREC_MAXRECLEN(512 + 4)SREC_E_BADCHKSSREC_E_NOSRECSREC_E_BADTYPESREC_REC_OKSREC_EMPTYSREC_END2SREC_END3SREC_END4SREC_COUNTSREC_DATA4SREC_DATA3SREC_DATA2SREC_START/* resulting binary length		    *//* max ASCII record length		    *//* checksum error in an s-record line	    *//* line format differs from s-record	    *//* no valid S-Record		            *//* last code without error condition	    *//* Empty Record without any data	    *//* End   Record with 2 byte start address   *//* End   Record with 3 byte start address   *//* End   Record with 4 byte start address   *//* Count Record (previously transmitted)    *//* Data  Record with 4 byte address	    *//* Data  Record with 3 byte address	    *//* Data  Record with 2 byte address	    *//* Start Record (module name)		    *//*--------------------------------------------------------------------------
 *
 * Motorola S-Record Format:
 *
 * Motorola S-Records are an industry-standard format for
 * transmitting binary files to target systems and PROM
 * programmers. LSI Logic have extended this standard to include
 * an S4-record containing an address and a symbol.
 *
 * The extended S-record standard is as follows:
 *
 * S<type><length><address><data....><checksum>
 * S4<length><address><name>,<checksum>
 *
 * Where:
 *
 * type
 *     is the record type. Where:
 *
 *     0  starting record (optional)
 *     1  data record with 16-bit address
 *     2  data record with 24-bit address
 *     3  data record with 32-bit address
 *     4  symbol record (LSI extension)
 *     5  number of data records in preceding block
 *     6  unused
 *     7  ending record for S3 records
 *     8  ending record for S2 records
 *     9  ending record for S1 records
 *
 * length
 *     is two hex characters. This defines the length of the
 *     record in bytes (not characters). It includes the address
 *     field, the data field, and the checksum field.
 *
 * address
 *     is 4, 6, or 8 characters. Corresponding to a 16-, 24-, or
 *     32-bit address. The address field for S4 records is
 *     always 32 bits.
 *
 * data
 *
 *     Are the data bytes. Each pair of hex characters represent
 *     one byte in memory.
 *
 * name
 *     Is the symbol name. The symbol is terminated by a ','.
 *
 * checksum
 *     Is the one's complement of the 8-bit checksum.
 *
 * Example
 *
 * S0030000FC
 * .
 * .
 * S325000004403C0880018D08DD900000000011000026000000003C0880012508DC50C50000B401
 * S32500000460C50100B8C50200BCC50300C0C50400C4C50500C8C50600CCC50700D0C50800D4FA
 * S32500000480C50900D8C50A00DCC50B00E0C50C00E4C50D00E8C50E00ECC50F00F0C51000F49A
 * S325000004A0C51100F8C51200FCC5130100C5140104C5150108C516010CC5170110C518011434
 * .
 * .
 * S70500000000FA
 *
 * The S0 record starts the file. The S3 records contain the
 * data. The S7 record contains the entry address and terminates
 * the download.
 *
 *--------------------------------------------------------------------------
 *//opt/src/include/libata.hlibataata_swap_buf_le16ata_dump_idata_id_c_stringata_dev_classifyata_id_n_sectorslba_48_ok(u64)1(u64)1 << 48((u64)1 << 48)lba_28_ok(u64)1 << 28((u64)1 << 28)ata_okATA_BUSYATA_DRDYATA_BUSY | ATA_DRDYATA_DFATA_BUSY | ATA_DRDY | ATA_DFATA_DRQATA_BUSY | ATA_DRDY | ATA_DF | ATA_DRQATA_ERRATA_BUSY | ATA_DRDY | ATA_DF | ATA_DRQ | ATA_ERR(ATA_BUSY | ATA_DRDY | ATA_DF | ATA_DRQ | ATA_ERR)is_multi_taskfileata_taskfile *ATA_CMD_READ_MULTIATA_CMD_WRITE_MULTIATA_CMD_READ_MULTI_EXTATA_CMD_WRITE_MULTI_EXTATA_CMD_WRITE_MULTI_FUA_EXTatapi_id_dmadiratapi_command_packet_setatapi_cdb_lenata_drive_40wire_relaxedata_drive_40wire573440xE000ata_id_is_cfa339300x848A( 1 << 2)ata_id_current_chs_validata_id_has_dword_ioata_id_has_tpm0xC000ata_id_is_sataata_id_major_versionATA_ID_MAJOR_VERmverata_id_wcache_enabledata_id_rahead_enabledata_id_has_pmata_id_has_wcacheata_id_hpa_enabled( 1 << 10)ata_id_has_lba48ata_id_u64(id, 100)ata_id_has_flush_extn_blocktf1 << 13ata_id_has_flush1 << 12(1 << 12)ata_id_has_fuaata_is_dataATA_PROT_FLAG_DATAata_is_ncqATA_PROT_FLAG_NCQata_is_dmaATA_PROT_FLAG_DMAata_is_pioATA_PROT_FLAG_PIOata_is_nodataata_is_atapiATA_PROT_FLAG_ATAPIata_prot_flagsATA_PROT_NODATAATA_PROT_PIOATA_PROT_DMAATA_PROT_NCQATA_PROT_FLAG_DMA | ATA_PROT_FLAG_NCQATAPI_PROT_NODATAATAPI_PROT_PIOATA_PROT_FLAG_ATAPI | ATA_PROT_FLAG_PIOATAPI_PROT_DMAATA_PROT_FLAG_ATAPI | ATA_PROT_FLAG_DMAata_taskfileata_dev_typedATA_DEV_ATAATA_DEV_ATAPIATA_DEV_PMPATA_DEV_UNKNOWNata_ioctlsATA_IOC_GET_IO327770x309ATA_IOC_SET_IO328040x324ata_tf_protocolsATA_PROT_UNKNOWNATA_MAX_DEVICESATA_MAX_PRDATA_SECT_SIZEATA_MAX_SECTORS_128ATA_MAX_SECTORSATA_MAX_SECTORS_LBA48ATA_MAX_SECTORS_TAPEATA_ID_WORDSATA_ID_SERNOATA_ID_FW_REVATA_ID_PRODATA_ID_OLD_PIO_MODESATA_ID_FIELD_VALIDATA_ID_LBA_SECTORSATA_ID_MWDMA_MODESATA_ID_PIO_MODESATA_ID_EIDE_DMA_MINATA_ID_EIDE_PIOATA_ID_EIDE_PIO_IORDYATA_ID_PIO4ATA_ID_QUEUE_DEPTHATA_ID_SATA_CAPATA_ID_SATA_FEATURESATA_ID_SATA_FEATURES_ENATA_ID_MINOR_VERATA_ID_UDMA_MODESATA_ID_LBA48_SECTORSATA_ID_SERNO_LENATA_ID_FW_REV_LENATA_ID_PROD_LENATA_PCI_CTL_OFSATA_PIO0ATA_PIO1ATA_PIO0 | (1 << 1)ATA_PIO2ATA_PIO1 | (1 << 2)ATA_PIO3ATA_PIO2 | (1 << 3)ATA_PIO4ATA_PIO3 | (1 << 4)ATA_PIO5ATA_PIO4 | (1 << 5)ATA_PIO6ATA_PIO5 | (1 << 6)ATA_SWDMA0ATA_SWDMA1ATA_SWDMA0 | (1 << 1)ATA_SWDMA2ATA_SWDMA1 | (1 << 2)ATA_SWDMA2_ONLYATA_MWDMA0ATA_MWDMA1ATA_MWDMA0 | (1 << 1)ATA_MWDMA2ATA_MWDMA1 | (1 << 2)ATA_MWDMA12_ONLY(1 << 1) | (1 << 2)ATA_MWDMA2_ONLYATA_UDMA0ATA_UDMA1ATA_UDMA0 | (1 << 1)ATA_UDMA2ATA_UDMA1 | (1 << 2)ATA_UDMA3ATA_UDMA2 | (1 << 3)ATA_UDMA4ATA_UDMA3 | (1 << 4)ATA_UDMA5ATA_UDMA4 | (1 << 5)ATA_UDMA6ATA_UDMA5 | (1 << 6)ATA_UDMA7ATA_UDMA6 | (1 << 7)ATA_UDMA_MASK_40CATA_PRD_SZATA_PRD_TBL_SZATA_MAX_PRD * ATA_PRD_SZ(ATA_MAX_PRD * ATA_PRD_SZ)ATA_PRD_EOT-21474836481 << 31ATA_DMA_TABLE_OFSATA_DMA_STATUSATA_DMA_CMDATA_DMA_WRATA_DMA_STARTATA_DMA_INTRATA_DMA_ERRATA_DMA_ACTIVEATA_HOBATA_NIENATA_LBAATA_DEV1ATA_DEVICE_OBS(1 << 7) | (1 << 5)ATA_DEVCTL_OBSATA_SRSTATA_ICRCATA_UNCATA_IDNFATA_ABORTEDATA_REG_DATAATA_REG_ERRATA_REG_NSECTATA_REG_LBALATA_REG_LBAMATA_REG_LBAHATA_REG_DEVICEATA_REG_STATUSATA_REG_FEATUREATA_REG_CMDATA_REG_BYTELATA_REG_BYTEHATA_REG_DEVSELATA_REG_IRQATA_CMD_DEV_RESETATA_CMD_CHK_POWER0xE5ATA_CMD_STANDBY0xE2ATA_CMD_IDLE0xE3ATA_CMD_EDDATA_CMD_FLUSH0xE7ATA_CMD_FLUSH_EXT0xEAATA_CMD_ID_ATA0xECATA_CMD_ID_ATAPI0xA1ATA_CMD_READ0xC8ATA_CMD_READ_EXTATA_CMD_WRITE0xCAATA_CMD_WRITE_EXTATA_CMD_WRITE_FUA_EXT0x3DATA_CMD_FPDMA_READATA_CMD_FPDMA_WRITEATA_CMD_PIO_READATA_CMD_PIO_READ_EXTATA_CMD_PIO_WRITEATA_CMD_PIO_WRITE_EXT0xC40x290xC50xCEATA_CMD_SET_FEATURES0xEFATA_CMD_SET_MULTI0xC6ATA_CMD_PACKET0xA0ATA_CMD_VERIFYATA_CMD_VERIFY_EXTATA_CMD_STANDBYNOW1ATA_CMD_IDLEIMMEDIATE0xE1ATA_CMD_SLEEP0xE6ATA_CMD_INIT_DEV_PARAMS0x91ATA_CMD_READ_NATIVE_MAX0xF8ATA_CMD_READ_NATIVE_MAX_EXTATA_CMD_SET_MAX0xF9ATA_CMD_SET_MAX_EXTATA_CMD_READ_LOG_EXTATA_CMD_PMP_READ0xE4ATA_CMD_PMP_WRITE0xE8ATA_CMD_CONF_OVERLAY0xB1ATA_CMD_SEC_FREEZE_LOCK0xF5ATA_LOG_SATA_NCQATA_CMD_READ_LONGATA_CMD_READ_LONG_ONCEATA_CMD_WRITE_LONGATA_CMD_WRITE_LONG_ONCESETFEATURES_XFERXFER_UDMA_70x47XFER_UDMA_60x46XFER_UDMA_5XFER_UDMA_4XFER_UDMA_30x43XFER_UDMA_2XFER_UDMA_10x41XFER_UDMA_0XFER_MW_DMA_4XFER_MW_DMA_3XFER_MW_DMA_2XFER_MW_DMA_1XFER_MW_DMA_0XFER_SW_DMA_2XFER_SW_DMA_1XFER_SW_DMA_0XFER_PIO_6XFER_PIO_5XFER_PIO_4XFER_PIO_3XFER_PIO_2XFER_PIO_1XFER_PIO_0XFER_PIO_SLOWSETFEATURES_WC_ONSETFEATURES_WC_OFF0x82SETFEATURES_SPINUPSETFEATURES_SATA_ENABLESETFEATURES_SATA_DISABLESATA_ANSATA_DIPMATA_SET_MAX_ADDRATA_SET_MAX_PASSWDATA_SET_MAX_LOCKATA_SET_MAX_UNLOCKATA_SET_MAX_FREEZE_LOCKATA_DCO_RESTORE0xC0ATA_DCO_FREEZE_LOCK0xC1ATA_DCO_IDENTIFY0xC2ATA_DCO_SET0xC3ATAPI_PKT_DMAATAPI_DMADIRATAPI_CDB_LENSATA_PMP_MAX_PORTSSATA_PMP_CTRL_PORTSATA_PMP_GSCR_DWORDSSATA_PMP_GSCR_PROD_IDSATA_PMP_GSCR_REVSATA_PMP_GSCR_PORT_INFOSATA_PMP_GSCR_ERRORSATA_PMP_GSCR_ERROR_ENSATA_PMP_GSCR_FEATSATA_PMP_GSCR_FEAT_ENSATA_PMP_PSCR_STATUSSATA_PMP_PSCR_ERRORSATA_PMP_PSCR_CONTROLSATA_PMP_FEAT_BISTSATA_PMP_FEAT_PMREQSATA_PMP_FEAT_DYNSSCSATA_PMP_FEAT_NOTIFYATA_CBL_NONEATA_CBL_PATA40ATA_CBL_PATA80ATA_CBL_PATA40_SHORTATA_CBL_PATA_UNKATA_CBL_PATA_IGNATA_CBL_SATASCR_STATUSSCR_ERRORSCR_CONTROLSCR_ACTIVESCR_NOTIFICATIONSERR_DATA_RECOVEREDSERR_COMM_RECOVEREDSERR_DATASERR_PERSISTENTSERR_PROTOCOLSERR_INTERNAL1 << 11(1 << 11)SERR_PHYRDY_CHG1 << 16(1 << 16)SERR_PHY_INT_ERR1 << 17(1 << 17)SERR_COMM_WAKE1 << 18(1 << 18)SERR_10B_8B_ERR1 << 19SERR_DISPARITY1 << 20(1 << 20)SERR_CRC1 << 21(1 << 21)SERR_HANDSHAKE1 << 22SERR_LINK_SEQ_ERR1 << 23(1 << 23)SERR_TRANS_ST_ERROR1 << 24(1 << 24)SERR_UNRECOG_FIS1 << 25(1 << 25)SERR_DEV_XCHG1 << 26(1 << 26)ATA_TFLAG_LBA48ATA_TFLAG_ISADDRATA_TFLAG_DEVICEprotATA_TFLAG_WRITEATA_TFLAG_LBAATA_TFLAG_FUAATA_TFLAG_POLLINGATA_PROT_FLAG_PIO | ATA_PROT_FLAG_DMAlbahlbamlbalnsectfeaturehob_lbahhob_lbamhob_lbalhob_nsecthob_featurectlsata_pmp_gscr_ports(gscr)((gscr)[SATA_PMP_GSCR_PORT_INFO] & 0xf)sata_pmp_gscr_rev(gscr)(((gscr)[SATA_PMP_GSCR_REV] >> 8) & 0xff)sata_pmp_gscr_devid(gscr)((gscr)[SATA_PMP_GSCR_PROD_ID] >> 16)sata_pmp_gscr_vendor(gscr)((gscr)[SATA_PMP_GSCR_PROD_ID] & 0xffff)ata_id_cdb_intr(id)(((id)[0] & 0x60) == 0x20)ata_id_u64(id,n)( ((u64) (id)[(n) + 3] << 48) | ((u64) (id)[(n) + 2] << 32) | ((u64) (id)[(n) + 1] << 16) | ((u64) (id)[(n) + 0]) )ata_id_u32(id,n)(((u32) (id)[(n) + 1] << 16) | ((u32) (id)[(n)]))ata_id_has_iordy(id)((id)[49] & (1 << 11))ata_id_iordy_disable(id)((id)[49] & (1 << 10))ata_id_removeable(id)((id)[0] & (1 << 7))ata_id_queue_depth(id)(((id)[75] & 0x1f) + 1)ata_id_has_ncq(id)((id)[76] & (1 << 8))ata_id_has_dma(id)((id)[49] & (1 << 8))ata_id_has_lba(id)((id)[49] & (1 << 9))ata_id_is_ata(id)(((id)[0] & (1 << 15)) == 0)__LIBATA_H__/* __LIBATA_H__ *//* check the ending block number *//* 80 wire *//* SATA *//* Could be CF hiding as standard ATA *//* Standard CF *//* sectors in current translation *//* heads in current translation *//* cylinders in current translation *//* Current translation valid *//* For ATA-1 devices, if the INITIALIZE DEVICE PARAMETERS command
	   has not been issued to the device then the values of
	   id[54] to id[56] are vendor specific. *//* ATA 8 reuses this flag for "trusted" computing *//* The TPM bits are only valid on ATA8 *//* Yes children, word 83 valid bits cover word 82 data *//* Check command sets enabled as well as supported *//* And 87 covers 85-87 *//*
 * id tests
 *//*
 * protocol tests
 *//* IO operation *//* to support LBA48 *//* additional data *//* control reg *//* ATA_PROT_xxx *//* ATA_TFLAG_xxx *//* unknown *//* Port Multiplier Port *//* ATAPI device *//* ATA device *//* packet command with special DMA sauce *//* packet command, PIO data xfer*//* packet command, no data *//* NCQ *//* DMA *//* PIO data xfer *//* no data *//* unknown/invalid *//* ATA taskfile protocols *//* is ATAPI *//* is NCQ *//* is DMA *//* is PIO *//* protocol flags *//* set nIEN to 1 and use polling *//* enable FUA *//* enable LBA *//* data dir: host->dev==1 (write) *//* enable r/w to device reg *//* enable r/w to nsect/lba regs *//* enable 48-bit LBA and "HOB" *//* struct ata_taskfile flags *//* device exchanged *//* Unrecognized FIS *//* Transport state trans. error *//* Link sequence error *//* Handshake error *//* CRC error *//* Disparity *//* 10b to 8b decode error *//* Comm wake *//* PHY internal error *//* PHY RDY changed *//* host internal error *//* protocol violation *//* persistent data/comm error *//* unrecovered data error *//* recovered comm failure *//* recovered data error *//* SError bits *//* SATA Status and Control Registers *//* don't know, ignore cable handling *//* don't know, maybe 80c? *//* 40 wire cable to high UDMA spec *//* cable types *//* PMP stuff *//* ATAPI data dir:
						   0=to device, 1=to host *//* ATAPI stuff *//* feature values for DEVICE CONFIGURATION OVERLAY *//* feature values for SET_MAX *//* Device Initiated Power Management *//* Asynchronous Notification *//* SETFEATURE Sector counts for SATA features *//* Disable use of SATA feature *//* Enable use of SATA feature *//* Spin-up drive *//* Disable write cache *//* Enable write cache *//* CFA only *//* SETFEATURES stuff *//* READ/WRITE LONG (obsolete) *//* READ_LOG_EXT pages *//* execute device diagnostic *//* place in idle power mode *//* place in standby power mode *//* check power mode *//* ATAPI device reset *//* ATA device commands *//* and their aliases *//* ATA command block registers *//* command aborted *//* ID not found *//* uncorrectable media error *//* interface CRC error *//* software reset *//* have an error *//* data request i/o *//* device fault *//* device ready *//* BSY status bit *//* obsolete bit in devctl reg *//* obs bits in dev reg *//* Select Device 1 (slave) *//* LBA28 selector *//* disable-irq flag *//* LBA48 selector *//* bits in ATA command block registers *//* end-of-table flag *//* DMA-related *//* udma0-2 *//* ATA_UDMA7 is just for completeness... doesn't exist (yet?).  *//* we could make these 256/256 *//* per bus/port *//* various global constants *//*
 * Copyright 2003-2004 Red Hat, Inc.  All rights reserved.
 * Copyright 2003-2004 Jeff Garzik
 * Copyright (C) 2008 Freescale Semiconductor, Inc.
 *		Dave Liu <daveliu@freescale.com>
 *		port from libata of linux kernel
 */buf_words/opt/src/include/ata.hatapio_config_thd_driveid_thd_driveidt_holdt_lengtht_setupunsigned short[92]words164_255cf_advanced_capswords160_162words157_159word156unsigned short[26]words130_155csfodlfword127last_lununsigned short[22]words104_125unsigned short[4]lba48_capacityunsigned short[6]words94_99hw_configword92CurAPMvaluesword90word89dma_ultracsf_defaultcfs_enable_2cfs_enable_1cfssecommand_set_2command_set_1minor_rev_nummajor_rev_numwords76_79queue_depthwords71_74unsigned short[2]words69_70eide_pio_iordyeide_pioeide_dma_timeeide_dma_mineide_pio_modesdma_mworddma_1wordlba_capacitymultsect_validmultsectcur_capacity1cur_capacity0cur_sectorscur_headscur_cylsfield_validtDMAvendor6tPIOvendor5reserved50capabilityvendor4dword_iovendor3max_multsectunsigned char[40]fw_revecc_bytesbuf_typeserial_novendor2vendor1vendor0sectorssector_bytestrack_bytesheadscylsIDE_MAX_PIO_MODEATA_RESET_TIMEATA_SECTORWORDS(512 / sizeof(uint32_t))ATA_BLOCKSHIFTATA_BLOCKSIZEATA_DATA_READY(ATA_STAT_DRQ)ATA_DRIVE_READY(ATA_READY_STAT | ATA_STAT_SEEK)ATA_BAD_STAT(ATA_BAD_R_STAT | ATA_STAT_DRQ)ATA_BAD_W_STAT(ATA_BAD_R_STAT | ATA_STAT_FAULT)ATA_BAD_R_STAT(ATA_STAT_BUSY | ATA_STAT_ERR)ATA_OK_STAT(stat,good,bad)(((stat)&((good)|(bad)))==(good))ATA_GET_STAT()inb(ATA_STATUS)ATA_GET_ERR()ATAPI_CMD_READ_120xA8ATAPI_CMD_START_STOPATAPI_CMD_READ_CAPATAPI_CMD_REQ_SENSEATAPI_CMD_INQUIRYATAPI_CMD_PACKETATAPI_CMD_IDENTATA_CMD_VRFY_EXTATA_CMD_CHK_PWRATA_CMD_SETFATA_CMD_IDENTATA_CMD_WR_DMAN0xCBATA_CMD_WR_DMAATA_CMD_RD_DMAN0xC9ATA_CMD_RD_DMAATA_CMD_SETMULTATA_CMD_WR_MULTATA_CMD_RD_MULTATA_CMD_INITATA_CMD_DIAGATA_CMD_SEEKATA_CMD_VRFYNATA_CMD_VRFYATA_CMD_WRITENATA_CMD_READNATA_DEVICE(x)((x & 1)<<4)ATA_STAT_ERRATA_STAT_INDEXATA_STAT_CORRATA_STAT_DRQATA_STAT_SEEKATA_STAT_FAULTATA_STAT_READYATA_STAT_BUSYATA_LBA_SELATA_DEV_CTLATA_LBA_HIGHATA_CYL_HIGHATA_LBA_MIDATA_CYL_LOWATA_LBA_LOWATA_SECT_NUMATA_IO_ALT(6)ATA_STATUSATA_COMMANDATA_DATA_ODDATA_IO_REG(9)ATA_DATA_EVENATA_IO_REG(8)ATA_IO_REG(7)ATA_DEV_HDATA_IO_REG(6)ATA_IO_REG(5)ATA_IO_REG(4)ATA_IO_REG(3)ATA_SECT_CNTATA_IO_REG(2)ATA_ERROR_REGATA_IO_REG(1)ATA_DATA_REGATA_IO_DATA(0)ATA_IO_ALT(x)(CONFIG_SYS_ATA_ALT_OFFSET +((x) * CONFIG_SYS_ATA_STRIDE))ATA_IO_REG(x)(CONFIG_SYS_ATA_REG_OFFSET +((x) * CONFIG_SYS_ATA_STRIDE))ATA_IO_DATA(x)(CONFIG_SYS_ATA_DATA_OFFSET+((x) * CONFIG_SYS_ATA_STRIDE))_ATA_HCONFIG_SYS_ATA_STRIDEATA_DEVICE/* _ATA_H *//* ------------------------------------------------------------------------- *//* max suppurted PIO mode		*//* Hold   Time in [ns] or clocks	*//* Length Time in [ns] or clocks	*//* Setup  Time in [ns] or clocks	*//*
 * PIO Mode Configuration
 *
 * See ATA-3 (AT Attachment-3 Interface) documentation, Figure 14 / Table 21
 *//* reserved words 164-255 *//* reserved words 160-162 *//* reserved vendor words 157-159 *//* reserved vendor words 130-155 *//* current set features options
					 * 15:4	reserved
					 * 3	auto reassign
					 * 2	reverting
					 * 1	read-look-ahead
					 * 0	write cache
					 *//* device lock function
					 * 15:9	reserved
					 * 8	security level 1:max 0:high
					 * 7:6	reserved
					 * 5	enhanced erase
					 * 4	expire
					 * 3	frozen
					 * 2	locked
					 * 1	en/disabled
					 * 0	capability
					 *//* reserved (word 127) *//* reserved (word 126) *//* reserved words 104-125 *//* 4 16bit values containing lba 48 total number of sectors *//*unsigned long long  lba48_capacity; /--* 4 16bit values containing lba 48 total number of sectors *//* reserved words 94-99 *//* hardware config *//* reserved (word 92) *//* current APM values *//* reserved (word 90) *//* reserved (word 89) *//*  *//* command set-feature default *//* command set-feature enabled *//* command set-feature supported extensions *//* bits 14:Smart Enabled 13:0 zero 10:lba48 support*//* bits 0:Smart 1:Security 2:Removable 3:PM *//* reserved words 76-79 *//* reserved words 71-74 *//* reserved words 69-70 *//* min cycle time (ns), with IORDY *//* min cycle time (ns), no IORDY  *//* recommended mword dma cycle time (ns) *//* min mword dma cycle time (ns) *//* bits 0:mode3 1:mode4 *//* multiple-word dma info *//* single-word dma info *//* total number of sectors *//* when (bit0==1) multsect is ok *//* current multiple sector count *//*  (2 words, misaligned int)     *//* logical total sectors on drive *//* logical sectors per track *//* logical heads *//* logical cylinders *//* bits 0:cur_ok 1:eide_ok *//* 0=slow, 1=medium, 2=fast *//* vendor unique *//* reserved (word 50) *//* bits 0:DMA 1:LBA 2:IORDYsw 3:IORDYsup*//* 0=not_implemented; 1=implemented *//* 0=not_implemented *//* 0 = not_specified *//* for r/w long cmds; 0 = not_specified *//* 512 byte increments; 0 = not_specified *//* "physical" sectors per track *//* unformatted bytes per sector *//* unformatted bytes per track *//* "physical" heads *//* reserved (word 2) *//* "physical" cyls *//* lots of obsolete bit flags *//*
 * structure returned by ATA_CMD_IDENT, as per ANSI ATA2 rev.2f spec
 *//* spec allows up to 31 seconds *//* 2 ^ ATA_BLOCKSIZESHIFT = 512 *//* bytes *//* Packed Command *//* Identify AT Atachment Packed Interface Device *//*
 * ATAPI Commands
 *//* Flush drive cache, with 48bit addressing *//* Flush drive cache *//* Read Verify	(with retries)	with 48bit addressing *//* Write Sectores (with retries) with 48bit addressing *//* Read Sectors (with retries)	with 48bit addressing *//* Check Power Mode		*//* Set Features			*//* Identify Device		*//* Write DMA ( no  retires)	*//* Write DMA (with retries)	*//* Read DMS ( no  retries)	*//* Read DMA (with retries)	*//* Set Multiple Mode		*//* Write Multiple		*//* Read Multiple		*//* Initialize Device Parameters	*//* Execute Device Diagnostic	*//* Seek				*//* Read verify  ( no  retries)	*//* Read Verify  (with retries)	*//* Write Sectors  ( no  retries)*//* Write Sectores (with retries)*//* Read Sectors ( no  retries)	*//* Read Sectors (with retries)	*//*
 * ATA Commands (only mandatory commands listed here)
 *//* ATA_DEVICE *//*
 * Device / Head Register Bits
 *//* Error			*//* Vendor specific		*//* Corrected Data Error		*//* Data Request (ready)		*//* Device Seek Complete		*//* Device Fault			*//* Device Ready			*//* Device Busy			*//*
 * Status register bits
 *//*
 * I/O Register Descriptions
 *//* Register addressing depends on the hardware design; for instance,
 * 8-bit (register) and 16-bit (data) accesses might use different
 * address spaces. This is implemented by the following definitions.
 *//*
 * Most of the following information was derived from the document
 * "Information Technology - AT Attachment-3 Interface (ATA-3)"
 * which can be found at:
 * http://www.dt.wdc.com/ata/ata-3/ata3r5v.zip
 * ftp://poctok.iae.nsk.su/pub/asm/Documents/IDE/ATA3R5V.ZIP
 * ftp://ftp.fee.vutbr.cz/pub/doc/io/ata/ata-3/ata3r5v.zip
 */<libata.h>/opt/src/include/fat.hfatfat_closefat_mkdirfat_unlinkfat_closedirfat_readdirfs_dirent **fat_opendirfs_dir_stream **fat_read_filefile_fat_writefat_register_devicefat_set_blk_devfile_fat_readfile_fat_read_atfat_sizefat_existsfile_fat_detectfssect_to_clustfsdata *clust_to_sectfsdatadir_slotdir_entryvolume_infoboot_sectorfatsroot_clusterrootdir_sizefatbufnumdata_beginclust_sizesect_sizerootdir_sectfat_dirtyfat_sectfatlengthfatsize__u8 *fatbufname11_12__u8[12]unsigned char[12]name5_10alias_checksum__u8[10]name0_4starthiadatecdatectime_mslcasefs_typevolume_idext_boot_signdrive_number__u16[6]backup_bootinfo_sectorfat32_lengthsecs_trackfat_lengthdir_entriescluster_sizesector_sizesystem_idignoredCASE_LOWER_EXTCASE_LOWER_BASECHECK_CLUST(x,fatsize)((x) <= 1 || (x) >= ((fatsize) != 32 ? ((fatsize) != 16 ? 0xff0 : 0xfff0) : 0xffffff0))IS_LAST_CLUST(x,fatsize)((x) >= ((fatsize) != 32 ? ((fatsize) != 16 ? 0xff8 : 0xfff8) : 0xffffff8))START(dent)(FAT2CPU16((dent)->start) + (mydata->fatsize != 32 ? 0 : (FAT2CPU16((dent)->starthi) << 16)))FAT2CPU32le32_to_cpuFAT2CPU16le16_to_cpuFSTYPE_NONEISDIRDELIM(c)((c) == '/' || (c) == '\\')LAST_LONG_ENTRY_MASKaRINGDELETED_FLAG((char)0xe5)ATTR_VFAT(ATTR_RO | ATTR_HIDDEN | ATTR_SYS | ATTR_VOLUME)ATTR_ARCHATTR_DIRATTR_VOLUMEATTR_SYSATTR_HIDDENATTR_ROSIGNLENFAT32_SIGN"FAT32   "FAT16_SIGN"FAT16   "FAT12_SIGN"FAT12   "MAX_LFN_SLOTFAT32BUFSIZE(FATBUFSIZE/4)FAT16BUFSIZE(FATBUFSIZE/2)FAT12BUFSIZE((FATBUFSIZE*2)/3)FATBUFSIZE(mydata->sect_size * FATBUFBLOCKS)FATBUFBLOCKSDIRENTSPERCLUST((mydata->clust_size * mydata->sect_size) / sizeof(dir_entry))DIRENTSPERBLOCK(mydata->sect_size / sizeof(dir_entry))MAX_CLUSTSIZECONFIG_FS_FAT_MAX_CLUSTSIZEPREFETCH_BLOCKSVFAT_MAXSEQVFAT_MAXLEN_BYTES_FAT_H_defined(__linux__) && defined(__KERNEL__)/* _FAT_H_ *//* Number of FATs *//* Number of sectors *//* First cluster of root dir for FAT32 *//* Size of root dir for non-FAT32 *//* Used by get_fatent, init to -1 *//* The sector of the first cluster, can be negative *//* Size of clusters in sectors *//* Size of sectors in bytes *//* Start sector of root directory *//* Set if fatbuf has been modified *//* Starting sector of the FAT *//* Length of FAT in sectors *//* Size of FAT in bits *//* Current FAT buffer *//*
 * Private filesystem parameters
 *
 * Note: FAT buffer has to be 32 bit aligned
 * (see FAT32 accesses)
 *//* Last 2 characters in name *//* Unused *//* 6 more characters in name *//* Checksum for 8.3 alias *//* Attribute byte *//* First 5 characters in name *//* Sequence number for slot *//* File size in bytes *//* Time, date and first cluster *//* High 16 bits of cluster in FAT32 *//* Last access date *//* Creation date *//* Creation time *//* Creation time, milliseconds *//* Case for name and ext (CASE_LOWER_x) *//* Attribute bits *//* Name and extension *//* extension is lower case *//* base (name) is lower case *//* see dir_entry::lcase: *//* Boot sign comes last, 2 bytes *//* Boot code comes next, all but 2 bytes to fill up sector *//* Typically FAT12, FAT16, or FAT32 *//* Volume label *//* Volume ID number *//* 0x29 if fields below exist (DOS 3.3+) *//* BIOS drive number *//* Backup boot sector *//* Filesystem info sector *//* First cluster in root directory *//* Filesystem version *//* Bit 8: fat mirroring, low 4: active fat *//* Sectors/FAT *//* FAT32 only *//* Number of sectors (if sectors == 0) *//* Number of hidden sectors *//* Number of heads *//* Sectors/track *//* Media code *//* Number of root directory entries *//* Number of reserved sectors *//* Sectors/cluster *//* Bytes/sector *//* Name of fs *//* Bootstrap code *//*
 * Indicates that the entry is the last long entry in a set of long
 * dir entries
 *//* Used as special character in name[0] *//* Marks deleted files when in name[0] *//* File attributes *//* Filesystem identifiers *//* Maximum number of entry for long file name according to spec *//* Up to 9 of 13 2-byte UTF-16 entries *//* Maximum LFN buffer in bytes *//* Maximum Long File Name length supported here is 128 UTF-16 code units *//*
 * R/O (V)FAT 12/16/32 filesystem implementation by Marcus Sundberg
 *
 * 2002-07-28 - rjones@nexus-tech.net - ported to ppcboot v1.1.6
 * 2003-03-10 - kharris@nexus-tech.net - ported to u-boot
 */sectclustdentpdirsppart_no/opt/src/cmd/fat.cdo_fat_mkdirdo_fat_rmdo_fat_fswriteconst cmd_tbl_tconst cmd_tbl_t *
** Unable to use %s %d:%d for fatwrite **
"\n** Unable to use %s %d:%d for fatwrite **\n"
** Unable to write "%s" from %s %d:%d **
"\n** Unable to write \"%s\" from %s %d:%d **\n"%llu bytes written
"%llu bytes written\n"do_fat_fsinfousage: fatinfo <interface> [<dev[:part]>]
"usage: fatinfo <interface> [<dev[:part]>]\n"
** Unable to use %s %d:%d for fatinfo **
"\n** Unable to use %s %d:%d for fatinfo **\n"do_fat_lsdo_fat_sizefatmkdir"create a directory""<interface> [<dev[:part]>] <directory>\n" "    - create a directory in 'dev' on 'interface'"create a directory<interface> [<dev[:part]>] <directory>
    - create a directory in 'dev' on 'interface'"<interface> [<dev[:part]>] <directory>\n"
	"    - create a directory in 'dev' on 'interface'"char[88]U_BOOT_CMD(
	fatmkdir,	4,	1,	do_fat_mkdir,
	"create a directory",
	"<interface> [<dev[:part]>] <directory>\n"
	"    - create a directory in 'dev' on 'interface'"
)_u_boot_list_2_cmd_2_fatmkdir.u_boot_list_2_cmd_2_fatmkdirfatrm"delete a file""<interface> [<dev[:part]>] <filename>\n" "    - delete a file from 'dev' on 'interface'"delete a file<interface> [<dev[:part]>] <filename>
    - delete a file from 'dev' on 'interface'"<interface> [<dev[:part]>] <filename>\n"
	"    - delete a file from 'dev' on 'interface'"char[84]U_BOOT_CMD(
	fatrm,	4,	1,	do_fat_rm,
	"delete a file",
	"<interface> [<dev[:part]>] <filename>\n"
	"    - delete a file from 'dev' on 'interface'"
)_u_boot_list_2_cmd_2_fatrm.u_boot_list_2_cmd_2_fatrmfatwrite"write file into a dos filesystem""<interface> <dev[:part]> <addr> <filename> [<bytes> [<offset>]]\n" "    - write file 'filename' from the address 'addr' in RAM\n" "      to 'dev' on 'interface'"write file into a dos filesystem<interface> <dev[:part]> <addr> <filename> [<bytes> [<offset>]]
    - write file 'filename' from the address 'addr' in RAM
      to 'dev' on 'interface'"<interface> <dev[:part]> <addr> <filename> [<bytes> [<offset>]]\n"
	"    - write file 'filename' from the address 'addr' in RAM\n"
	"      to 'dev' on 'interface'"char[153]U_BOOT_CMD(
	fatwrite,	7,	0,	do_fat_fswrite,
	"write file into a dos filesystem",
	"<interface> <dev[:part]> <addr> <filename> [<bytes> [<offset>]]\n"
	"    - write file 'filename' from the address 'addr' in RAM\n"
	"      to 'dev' on 'interface'"
)_u_boot_list_2_cmd_2_fatwrite.u_boot_list_2_cmd_2_fatwritefatinfo"<interface> [<dev[:part]>]\n" "    - print information about filesystem from 'dev' on 'interface'"<interface> [<dev[:part]>]
    - print information about filesystem from 'dev' on 'interface'"<interface> [<dev[:part]>]\n"
	"    - print information about filesystem from 'dev' on 'interface'"U_BOOT_CMD(
	fatinfo,	3,	1,	do_fat_fsinfo,
	"print information about filesystem",
	"<interface> [<dev[:part]>]\n"
	"    - print information about filesystem from 'dev' on 'interface'"
)_u_boot_list_2_cmd_2_fatinfo.u_boot_list_2_cmd_2_fatinfofatls"<interface> [<dev[:part]>] [directory]\n" "    - list files from 'dev' on 'interface' in a 'directory'"<fat.h><ata.h><s_record.h><interface> [<dev[:part]>] [directory]
    - list files from 'dev' on 'interface' in a 'directory'"<interface> [<dev[:part]>] [directory]\n"
	"    - list files from 'dev' on 'interface' in a 'directory'"char[99]U_BOOT_CMD(
	fatls,	4,	1,	do_fat_ls,
	"list files in a directory (default /)",
	"<interface> [<dev[:part]>] [directory]\n"
	"    - list files from 'dev' on 'interface' in a 'directory'"
)_u_boot_list_2_cmd_2_fatls.u_boot_list_2_cmd_2_fatlsfatload"load binary file from a dos filesystem""<interface> [<dev[:part]> [<addr> [<filename> [bytes [pos]]]]]\n" "    - Load binary file 'filename' from 'dev' on 'interface'\n" "      to address 'addr' from dos filesystem.\n" "      'pos' gives the file position to start loading from.\n" "      If 'pos' is omitted, 0 is used. 'pos' requires 'bytes'.\n" "      'bytes' gives the size to load. If 'bytes' is 0 or omitted,\n" "      the load stops on end of file.\n" "      If either 'pos' or 'bytes' are not aligned to\n" "      ARCH_DMA_MINALIGN then a misaligned buffer warning will\n" "      be printed and performance will suffer for the load."load binary file from a dos filesystem<interface> [<dev[:part]> [<addr> [<filename> [bytes [pos]]]]]
    - Load binary file 'filename' from 'dev' on 'interface'
      to address 'addr' from dos filesystem.
      'pos' gives the file position to start loading from.
      If 'pos' is omitted, 0 is used. 'pos' requires 'bytes'.
      'bytes' gives the size to load. If 'bytes' is 0 or omitted,
      the load stops on end of file.
      If either 'pos' or 'bytes' are not aligned to
      ARCH_DMA_MINALIGN then a misaligned buffer warning will
      be printed and performance will suffer for the load."<interface> [<dev[:part]> [<addr> [<filename> [bytes [pos]]]]]\n"
	"    - Load binary file 'filename' from 'dev' on 'interface'\n"
	"      to address 'addr' from dos filesystem.\n"
	"      'pos' gives the file position to start loading from.\n"
	"      If 'pos' is omitted, 0 is used. 'pos' requires 'bytes'.\n"
	"      'bytes' gives the size to load. If 'bytes' is 0 or omitted,\n"
	"      the load stops on end of file.\n"
	"      If either 'pos' or 'bytes' are not aligned to\n"
	"      ARCH_DMA_MINALIGN then a misaligned buffer warning will\n"
	"      be printed and performance will suffer for the load."char[565]U_BOOT_CMD(
	fatload,	7,	0,	do_fat_fsload,
	"load binary file from a dos filesystem",
	"<interface> [<dev[:part]> [<addr> [<filename> [bytes [pos]]]]]\n"
	"    - Load binary file 'filename' from 'dev' on 'interface'\n"
	"      to address 'addr' from dos filesystem.\n"
	"      'pos' gives the file position to start loading from.\n"
	"      If 'pos' is omitted, 0 is used. 'pos' requires 'bytes'.\n"
	"      'bytes' gives the size to load. If 'bytes' is 0 or omitted,\n"
	"      the load stops on end of file.\n"
	"      If either 'pos' or 'bytes' are not aligned to\n"
	"      ARCH_DMA_MINALIGN then a misaligned buffer warning will\n"
	"      be printed and performance will suffer for the load."
)_u_boot_list_2_cmd_2_fatload.u_boot_list_2_cmd_2_fatloadU_BOOT_CMD(
	fatsize,	4,	0,	do_fat_size,
	"determine a file's size",
	"<interface> <dev[:part]> <filename>\n"
	"    - Find file 'filename' from 'dev' on 'interface'\n"
	"      and determine its size."
)_u_boot_list_2_cmd_2_fatsize.u_boot_list_2_cmd_2_fatsizeCONFIG_FAT_WRITE/* offset should be a hex, but "-1" is allowed *//*
 * (C) Copyright 2002
 * Richard Jones, rjones@nexus-tech.net
 *//opt/src/cmd/fdt.cfdt_printnodeoffsetlibfdt fdt_path_offset() returned %s
"libfdt fdt_path_offset() returned %s\n"nodep%s %s
"%s %s\n"%s = "%s = "libfdt fdt_getprop(): %s
"libfdt fdt_getprop(): %s\n"nextoffsetFDT_BEGIN_NODE/* NULL pointer error */"/* NULL pointer error */"%s%s {
"%s%s {\n"MAX_LEVELMAX_LEVEL+1tabs																																Nested too deep, aborting.
"Nested too deep, aborting.\n"FDT_END_NODE%s};
"%s};\n"FDT_PROPconst fdt_propertyconst fdt_property *fdt_property *fdt_propsizeof(*fdt_prop)fdt_prop->nameoff(__force __u32)(__be32)(fdt_prop->nameoff)(__u32)(__be32)(fdt_prop->nameoff)((__u32)(__be32)(fdt_prop->nameoff))fdt32_to_cpu(fdt_prop->nameoff)fdt_prop->len(__force __u32)(__be32)(fdt_prop->len)(__u32)(__be32)(fdt_prop->len)((__u32)(__be32)(fdt_prop->len))fdt32_to_cpu(fdt_prop->len)<fdt_support.h>pathpprop%s%s;
"%s%s;\n"%s%s = "%s%s = ";
";\n"FDT_NOP%s/* NOP */
"%s/* NOP */\n"FDT_ENDUnknown tag 0x%08X
"Unknown tag 0x%08X\n"print_data""\"""\", \""CMD_FDT_MAX_DUMP* 0x%p [0x%08x]"* 0x%p [0x%08x]"<"<"0x%08x%s"0x%08x%s"p[j](__force __u32)(__be32)(p[j])(__u32)(__be32)(p[j])((__u32)(__be32)(p[j]))fdt32_to_cpu(p[j]) " ">">"["["%02x%s"%02x%s"]"]"is_printable_string*sisprint(*s)isspace(*s)fdt_parse_propnewp'<''>'stridxfdt32_t *(tmp)((tmp))cpu_to_fdt32(tmp)Sorry, I could not convert "%s"
"Sorry, I could not convert \"%s\"\n"Unexpected character '%c'
"Unexpected character '%c'\n"'['']'*newpisxdigit(*newp)fdt_validfdt_header **The address of the fdt is invalid (NULL).
"The address of the fdt is invalid (NULL).\n"libfdt fdt_check_header(): %s"libfdt fdt_check_header(): %s"FDT_ERR_BADVERSION-10-FDT_ERR_BADVERSION((const struct fdt_header *)(blob))->version(__force __u32)(__be32)(((const struct fdt_header *)(blob))->version)(__u32)(__be32)(((const struct fdt_header *)(blob))->version)((__u32)(__be32)(((const struct fdt_header *)(blob))->version))fdt_version(blob)FDT_FIRST_SUPPORTED_VERSION - too old, fdt %d < %d" - too old, fdt %d < %d"blobplast_comp_version((const struct fdt_header *)(blob))->last_comp_version(__force __u32)(__be32)(((const struct fdt_header *)(blob))->last_comp_version)(__u32)(__be32)(((const struct fdt_header *)(blob))->last_comp_version)((__u32)(__be32)(((const struct fdt_header *)(blob))->last_comp_version))fdt_last_comp_version(blob)FDT_LAST_SUPPORTED_VERSION - too new, fdt %d > %d" - too new, fdt %d > %d"do_fdtad"ad"-c"-c"The address of the fdt is %#08lx
"The address of the fdt is %#08lx\n""fdtaddr"New length %d < existing length %d, ignoring.
"New length %d < existing length %d, "
					"ignoring.\n"libfdt fdt_open_into(): %s
"libfdt fdt_open_into(): %s\n"No FDT memory address configured. Please configure
the FDT address via "fdt addr <address>" command.
Aborting!
"No FDT memory address configured. Please configure\n"
			"the FDT address via \"fdt addr <address>\" command.\n"
			"Aborting!\n"char[112]mo"mo"newaddrworking_fdt((const struct fdt_header *)(working_fdt))->totalsize(__force __u32)(__be32)(((const struct fdt_header *)(working_fdt))->totalsize)(__u32)(__be32)(((const struct fdt_header *)(working_fdt))->totalsize)((__u32)(__be32)(((const struct fdt_header *)(working_fdt))->totalsize))fdt_totalsize(working_fdt)New length 0x%X < existing length 0x%X, aborting.
"New length 0x%X < existing length "
					"0x%X, aborting.\n"mk"mk"libfdt fdt_add_subnode(): %s
"libfdt fdt_add_subnode(): %s\n"char[1024]SCRATCHPADptmpprop (%d) doesn't fit in scratchpad!
"prop (%d) doesn't fit in scratchpad!\n"libfdt fdt_setprop(): %s
"libfdt fdt_setprop(): %s\n"'g'reqIndexstartDepthcurDepthcurIndexnextNodeOffsetnode_namelibfdt node not found
"libfdt node not found\n"0x%p"0x%p"0x%08X"0x%08X"'p' MAX_LEVELrm"rm"libfdt fdt_delprop():  %s
"libfdt fdt_delprop():  %s\n"libfdt fdt_del_node():  %s
"libfdt fdt_del_node():  %s\n"((const struct fdt_header *)(working_fdt))->version(__force __u32)(__be32)(((const struct fdt_header *)(working_fdt))->version)(__u32)(__be32)(((const struct fdt_header *)(working_fdt))->version)((__u32)(__be32)(((const struct fdt_header *)(working_fdt))->version))fdt_version(working_fdt)magic:			0x%x
"magic:\t\t\t0x%x\n"((const struct fdt_header *)(working_fdt))->magic(__force __u32)(__be32)(((const struct fdt_header *)(working_fdt))->magic)(__u32)(__be32)(((const struct fdt_header *)(working_fdt))->magic)((__u32)(__be32)(((const struct fdt_header *)(working_fdt))->magic))fdt_magic(working_fdt)totalsize:		0x%x (%d)
"totalsize:\t\t0x%x (%d)\n"off_dt_struct:		0x%x
"off_dt_struct:\t\t0x%x\n"off_dt_struct((const struct fdt_header *)(working_fdt))->off_dt_struct(__force __u32)(__be32)(((const struct fdt_header *)(working_fdt))->off_dt_struct)(__u32)(__be32)(((const struct fdt_header *)(working_fdt))->off_dt_struct)((__u32)(__be32)(((const struct fdt_header *)(working_fdt))->off_dt_struct))fdt_off_dt_struct(working_fdt)off_dt_strings:		0x%x
"off_dt_strings:\t\t0x%x\n"((const struct fdt_header *)(working_fdt))->off_dt_strings(__force __u32)(__be32)(((const struct fdt_header *)(working_fdt))->off_dt_strings)(__u32)(__be32)(((const struct fdt_header *)(working_fdt))->off_dt_strings)((__u32)(__be32)(((const struct fdt_header *)(working_fdt))->off_dt_strings))fdt_off_dt_strings(working_fdt)off_mem_rsvmap:		0x%x
"off_mem_rsvmap:\t\t0x%x\n"off_mem_rsvmap((const struct fdt_header *)(working_fdt))->off_mem_rsvmap(__force __u32)(__be32)(((const struct fdt_header *)(working_fdt))->off_mem_rsvmap)(__u32)(__be32)(((const struct fdt_header *)(working_fdt))->off_mem_rsvmap)((__u32)(__be32)(((const struct fdt_header *)(working_fdt))->off_mem_rsvmap))fdt_off_mem_rsvmap(working_fdt)version:		%d
"version:\t\t%d\n"last_comp_version:	%d
"last_comp_version:\t%d\n"((const struct fdt_header *)(working_fdt))->last_comp_version(__force __u32)(__be32)(((const struct fdt_header *)(working_fdt))->last_comp_version)(__u32)(__be32)(((const struct fdt_header *)(working_fdt))->last_comp_version)((__u32)(__be32)(((const struct fdt_header *)(working_fdt))->last_comp_version))fdt_last_comp_version(working_fdt)boot_cpuid_phys:	0x%x
"boot_cpuid_phys:\t0x%x\n"boot_cpuid_phys((const struct fdt_header *)(working_fdt))->boot_cpuid_phys(__force __u32)(__be32)(((const struct fdt_header *)(working_fdt))->boot_cpuid_phys)(__u32)(__be32)(((const struct fdt_header *)(working_fdt))->boot_cpuid_phys)((__u32)(__be32)(((const struct fdt_header *)(working_fdt))->boot_cpuid_phys))fdt_boot_cpuid_phys(working_fdt)size_dt_strings:	0x%x
"size_dt_strings:\t0x%x\n"((const struct fdt_header *)(working_fdt))->size_dt_strings(__force __u32)(__be32)(((const struct fdt_header *)(working_fdt))->size_dt_strings)(__u32)(__be32)(((const struct fdt_header *)(working_fdt))->size_dt_strings)((__u32)(__be32)(((const struct fdt_header *)(working_fdt))->size_dt_strings))fdt_size_dt_strings(working_fdt)size_dt_struct:		0x%x
"size_dt_struct:\t\t0x%x\n"size_dt_struct((const struct fdt_header *)(working_fdt))->size_dt_struct(__force __u32)(__be32)(((const struct fdt_header *)(working_fdt))->size_dt_struct)(__u32)(__be32)(((const struct fdt_header *)(working_fdt))->size_dt_struct)((__u32)(__be32)(((const struct fdt_header *)(working_fdt))->size_dt_struct))fdt_size_dt_struct(working_fdt)number mem_rsv:		0x%x
"number mem_rsv:\t\t0x%x\n"boo"boo"me"me"rs"rs"index		   start		    size
"index\t\t   start\t\t    size\n"------------------------------------------------
"-------------------------------"
				"-----------------\n"libfdt fdt_get_mem_rsv():  %s
"libfdt fdt_get_mem_rsv():  %s\n"    %x	%08x%08x	%08x%08x
"    %x\t%08x%08x\t%08x%08x\n"libfdt fdt_add_mem_rsv():  %s
"libfdt fdt_add_mem_rsv():  %s\n"libfdt fdt_del_mem_rsv():  %s
"libfdt fdt_del_mem_rsv():  %s\n"cho"cho"initrd_startinitrd_endche"che"Could not find configuration node: %s
"Could not find configuration node: %s\n""ap"re"re"extrasizefdt_get_header_valueconst char *const[10]char *[10]fdt_member_tableARRAY_SIZE(fdt_member_table)fdtp[i](__force __u32)(__be32)(fdtp[i])(__u32)(__be32)(fdtp[i])((__u32)(__be32)(fdtp[i]))fdt32_to_cpu(fdtp[i])fdt_value_env_set*(fdt32_t *)nodep(__force __u32)(__be32)(*(fdt32_t *)nodep)(__u32)(__be32)(*(fdt32_t *)nodep)((__u32)(__be32)(*(fdt32_t *)nodep))fdt32_to_cpu(*(fdt32_t *)nodep)%08x"%08x"sizeof(unsigned int)error: unprintable value
"error: unprintable value\n"set_working_fdt_addr"flattened device tree utility commands"fdt_help_textflattened device tree utility commandschar[1897]U_BOOT_CMD(
	fdt,	255,	0,	do_fdt,
	"flattened device tree utility commands", fdt_help_text
)_u_boot_list_2_cmd_2_fdt.u_boot_list_2_cmd_2_fdtaddr [-c]  <addr> [<length>]   - Set the [control] fdt location to <addr>
fdt apply <addr>                    - Apply overlay to the DT
fdt move   <fdt> <newaddr> <length> - Copy the fdt to <addr> and make it active
fdt resize [<extrasize>]            - Resize fdt to size + padding to 4k addr + some optional <extrasize> if needed
fdt print  <path> [<prop>]          - Recursive print starting at <path>
fdt list   <path> [<prop>]          - Print one level starting at <path>
fdt get value <var> <path> <prop>   - Get <property> and store in <var>
fdt get name <var> <path> <index>   - Get name of node <index> and store in <var>
fdt get addr <var> <path> <prop>    - Get start address of <property> and store in <var>
fdt get size <var> <path> [<prop>]  - Get size of [<property>] or num nodes and store in <var>
fdt set    <path> <prop> [<val>]    - Set <property> [to <val>]
fdt mknode <path> <node>            - Create a new node after <path>
fdt rm     <path> [<prop>]          - Delete the node or <property>
fdt header [get <var> <member>]     - Display header info
                                      get - get header member <member> and store it in <var>
fdt bootcpu <id>                    - Set boot cpuid
fdt memory <addr> <size>            - Add/Update memory node
fdt rsvmem print                    - Show current mem reserves
fdt rsvmem add <addr> <size>        - Add a mem reserve
fdt rsvmem delete <index>           - Delete a mem reserves
fdt chosen [<start> <end>]          - Add/update the /chosen branch in the tree
                                        <start>/<end> - initrd start/end addr
fdt checksign [<addr>]              - check FIT signature
                                        <start> - addr of key blob
                                                  default gd->fdt_blob
NOTE: Dereference aliases by omitting the leading '/', e.g. fdt print ethernet0."magic""totalsize""off_dt_struct""off_dt_strings""off_mem_rsvmap""last_comp_version""boot_cpuid_phys""size_dt_strings""size_dt_struct"CONFIG_OF_SYSTEM_SETUPCONFIG_OF_BOARD_SETUPCONFIG_SOC_KEYSTONECONFIG_OF_LIBFDT_OVERLAY/********************************************************************//* the property has no value *//* exit the loop *//* root is nameless *//*
	 * The user passed in a node path and no property,
	 * print the node and all subnodes.
	 *//* no property value *//*
	 * The user passed in a property as well as node path.
	 * Print only the given property and then return.
	 *//*
		 * Not found or something else bad happened.
		 *//* keep track of nesting level *//* length of the property *//* tag *//* next node offset from libfdt *//* node offset from libfdt *//* property node pointer *//*
 * Recursively print (a portion of) the working_fdt.  The depth parameter
 * determines how deeply nested the fdt is printed.
 *//* anything else... hexdump *//*
	 * It is a string, but it may have multiple strings (embedded '\0's).
	 *//* no data, don't print *//*
 * Print the property in the best format, a heuristic guess.  Print as
 * a string, concatenated strings, a byte, word, double word, or (if all
 * else fails) it is printed as a stream of bytes.
 *//* Not the null termination, or not done yet: not printable *//*
		 * If we see a null, there are three possibilities:
		 * 1) If len == 1, it is the end of the string, printable
		 * 2) Next character also a null, not printable.
		 * 3) Next character not a null, continue to check.
		 *//* printable or a null byte (concatenated strings) *//* must terminate with zero or '\n' *//* zero length is not *//*
 * Heuristic to guess if this is a string or concatenated strings.
 *//*
		 * Assume it is one or more strings.  Copy it into our
		 * data area for convenience (including the
		 * terminating '\0's).
		 *//*
		 * Byte stream.  Convert the values.
		 *//* If the ptr didn't advance, something went wrong *//*
			 * Keep searching until we find that last ">"
			 * That way users don't have to escape the spaces
			 *//* An array of cells *//* holds converted values *//* temporary newval char pointer *//* temporary char pointer *//*
 * Parse the user's input, partially heuristic.  Valid formats:
 * <0x00112233 4 05>	- an array of cells.  Numbers follow standard
 *			C conventions.
 * [00 11 22 .. nn] - byte stream
 * "string"	- If the the value doesn't start with "<" or "[", it is
 *			treated as a string.  Note that the quotes are
 *			stripped by the parser before we get the string.
 * newval: An array of strings containing the new property as specified
 *	on the command line
 * count: The number of strings in the array
 * data: A bytestream to be placed in the property
 * len: The length of the resulting bytestream
 *//*
		 * Be more informative on bad version.
		 *//* valid *//**
 * fdt_valid() - Check if an FDT is valid. If not, change it to NULL
 *
 * @blobp: Pointer to FDT pointer
 * @return 1 if OK, 0 if bad (in which case *blobp is set to NULL)
 *//* resize the fdt *//* apply method prints messages on error *//* apply an overlay *//* Create a chosen node *//* Call the board-specific fixup routine *//*
	 * mem reserve commands
	 *//*
	 * memory command
	 *//*
	 * Set boot cpu id
	 *//*
	 * Display header info
	 *//*
		 * Do the delete.  A fourth parameter means delete a property,
		 * otherwise delete the node.
		 *//*
			 * Not found or something else bad happened.
			 *//*
		 * Get the path.  The root node is an oddball, the offset
		 * is zero and has no name.
		 *//*
	 * Remove a property/node
	 *//*
		 * Get the starting path.  The root node is an oddball,
		 * the offset is zero and has no name.
		 *//*
		 * list is an alias for print, but limited to 1 level
		 *//* return value *//* property *//* path *//* how deep to print *//*
	 * Print (recursive) / List (single level)
	 *//* Get size *//* Get address *//* node index not found *//* get the num nodes at this level *//*
		 * Parameters: Node path, property, optional value.
		 *//* new length of the property *//* variable to store result *//* sub-command *//********************************************************************
	 * Get the value of a property in the working_fdt.
	 ********************************************************************//* property storage *//*
	 * Set the value of a property in the working_fdt.
	 *//*
		 * Parameters: Node path, new node to be appended to the path.
		 *//* new node to add *//*
	 * Make a new node
	 *//*
		 * Copy to the new location.
		 *//*
		 * If the user specifies a length, use that.  Otherwise use the
		 * current length.
		 *//*
		 * Set the address and length of the fdt.
		 *//*
	 * Move the working_fdt
	 *//*
				 * Open in place with a new length.
				 *//*
			 * Optional new length
			 *//* Temporary #ifdef - some archs don't have fdt_blob yet *//*
		 * Set the address [and length] of the fdt.
		 *//*
	 * Set the address of the fdt
	 *//*
 * Flattened Device Tree command, see the help for parameter definitions.
 *//* Needed to print things like sha1 hashes. *//*
 * Get a value from the fdt and format it to be set in the environment
 *//*
 * The working_fdt points to our working flattened device tree.
 *//*
 * Global data (for the gd->bd)
 *//* bytes of scratchpad memory *//* how deeply nested we will go *//*
 * (C) Copyright 2007
 * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
 * Based on code written by:
 *   Pantelis Antoniou <pantelis.antoniou@gmail.com> and
 *   Matthew McClintock <msm@freescale.com>
 */load_kerneldevice_findfind_dev_and_partmtd_device **part_info **mtdparts_initmtd_devicemtdidsmask_flagsjffs2_privauto_namenum_partsmtd_idled_blink(x,y,z,a)putLabeledWord(x,y)printf("%s %08x\n", x, (unsigned int)y)ldr_output_string(x)puts(x)putnstr(str,size)printf("%*.*s", size, size, str)UDEBUGmmallocputstr(x)printf("%s", x)ldr_memcpyldr_strncmpldr_strlenMTD_DEV_TYPE(type)(type == MTD_DEV_TYPE_NAND ? "nand" : (type == MTD_DEV_TYPE_NOR ? "nor" : (type == MTD_DEV_TYPE_ONENAND ? "onenand" : "spi-nand")))MTD_DEV_TYPE_SPINANDMTD_DEV_TYPE_ONENANDMTD_DEV_TYPE_NANDload_kernel_h/* load_kernel_h *//* common/cmd_jffs2.c *//* linux kernel device id *//* device size *//* parent device *//* size of sector *//* kernel MTD mask flags *//* used internaly by jffs2 *//* offset within device *//* total size of the partition *//* set to 1 for generated name *//* partition name *//* partitions *//* number of partitions on this device *//* parent mtd id entry *//* mtd device types *//*-------------------------------------------------------------------------
 * Filename:      load_kernel.h
 * Version:       $Id: load_kernel.h,v 1.3 2002/01/25 01:34:11 nyet Exp $
 * Copyright:     Copyright (C) 2001, Russ Dill
 * Author:        Russ Dill <Russ.Dill@asu.edu>
 * Description:   header for load kernel modules
 *-----------------------------------------------------------------------*//opt/src/include/jffs2zlib_decompressdynrubin_decompressrubin_do_decompressrtime_decompressjffs2_1pass_infojffs2_1pass_loadjffs2_1pass_lsjffs2_node_unionjffs2_raw_summaryjffs2_raw_inodejffs2_raw_direntjffs2_unknown_noded__u32[0]sumnode_crcsum_crcpaddedcln_mkrsum_numhdr_crctotlennodetypedata_crcusercomprcomprdsizecsizeisizename_crcnsizemctimepinoJFFS2_INO_FLAG_USERCOMPRJFFS2_INO_FLAG_PREREADJFFS2_NODETYPE_SUMMARY(JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 6)JFFS2_NODETYPE_PADDING(JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 4)JFFS2_NODETYPE_CLEANMARKER(JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 3)JFFS2_NODETYPE_INODE(JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 2)JFFS2_NODETYPE_DIRENT(JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 1)JFFS2_FEATURE_RWCOMPAT_DELETEJFFS2_FEATURE_RWCOMPAT_COPYJFFS2_FEATURE_ROCOMPATJFFS2_FEATURE_INCOMPAT0xc000JFFS2_NODE_ACCURATEJFFS2_COMPAT_MASKJFFS2_NUM_COMPRJFFS2_COMPR_ZLIBJFFS2_COMPR_DYNRUBINJFFS2_COMPR_COPYJFFS2_COMPR_RUBINMIPSJFFS2_COMPR_RTIMEJFFS2_COMPR_ZEROJFFS2_COMPR_NONEJFFS2_MIN_DATA_LENJFFS2_MAX_NAME_LENJFFS2_SUM_MAGIC0x02851885JFFS2_DIRTY_BITMASKJFFS2_EMPTY_BITMASKKSAMTIB_CIGAM_2SFFJ0x5981JFFS2_MAGIC_BITMASK0x1985JFFS2_OLD_MAGIC_BITMASK0x1984JFFS2_SUPER_MAGIC0x72b6__LINUX_JFFS2_H__defined(CONFIG_JFFS2_LZO)/* __LINUX_JFFS2_H__ *//* inode summary info *//* node crc *//* summary information crc *//* sum of the size of padding nodes *//* clean marker size, 0 = no cleanmarker *//* number of sum entries*//* = JFFS2_NODETYPE_SUMMARY *//*	__u8 data[dsize]; *//* CRC for the raw inode (excluding data)  *//* CRC for the (compressed) data.  *//* See JFFS2_INO_FLAG_* *//* Compression algorithm requested by the user *//* Compression algorithm used *//* Size of the node's data. (after decompression) *//* (Compressed) data size *//* Where to begin to write.  *//* Change time.  *//* Last modification time.  *//* Last access time.  *//* Total resultant size of this inode (used for truncations)  *//* The file's group.  *//* The file's owner.  *//* The file's type or mode.  *//* Version number.  *//* Inode number.  *//* Total length of this node (inc data, etc.) *//* == JFFS_NODETYPE_INODE *//* A constant magic number.  *//* The uid, gid, atime, mtime and ctime members could be longer, but
   are left like this for space efficiency. If and when people decide
   they really need them extended, it's simple enough to add support for
   a new type of raw node.
*//* The JFFS2 raw inode structure: Used for storage on physical media.  *//* == zero for unlink *//* == JFFS_NODETYPE_DIRENT *//* So we can skip over nodes we don't grok *//* All start like this *//* User has requested a specific
					   compression type *//* Do read_inode() for this one at
					   mount time, don't wait for it to
					   happen later *//*#define JFFS2_NODETYPE_INODE_ECC (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 6) *//*#define JFFS2_NODETYPE_DIRENT_ECC (JFFS2_FEATURE_INCOMPAT | JFFS2_NODE_ACCURATE | 5) *//* Same as the non_ECC versions, but with extra space for real
 * ECC instead of just the checksum. For use on NAND flash
 *//*#define JFFS2_NODETYPE_OPTIONS (JFFS2_FEATURE_RWCOMPAT_COPY | JFFS2_NODE_ACCURATE | 4) *//*#define JFFS2_NODETYPE_CHECKPOINT (JFFS2_FEATURE_RWCOMPAT_DELETE | JFFS2_NODE_ACCURATE | 3) *//* Maybe later... *//* RWCOMPAT_DELETE: Mount read/write, and delete the node when it's GC'd *//* RWCOMPAT_COPY: Mount read/write, and copy the node when it's GC'd *//* ROCOMPAT: Mount read-only *//* INCOMPAT: Fail to mount the filesystem *//* What do to if an unknown nodetype is found *//* Compatibility flags. *//* How small can we sensibly write nodes? *//* We only allow a single char for length, and 0xFF is empty flash so
   we don't want it confused with a real length. Hence max 254.
*//* Summary node MAGIC marker *//* For detecting wrong-endian fs *//* Values we may expect to find in the 'magic' field *//*
 * JFFS2 -- Journalling Flash File System, Version 2.
 *
 * Copyright (C) 2001 Red Hat, Inc.
 *
 * Created by David Woodhouse <dwmw2@cambridge.redhat.com>
 *
 * The original JFFS, from which the design for JFFS2 was derived,
 * was designed and implemented by Axis Communications AB.
 *
 * The contents of this file are subject to the Red Hat eCos Public
 * License Version 1.1 (the "Licence"); you may not use this file
 * except in compliance with the Licence.  You may obtain a copy of
 * the Licence at http://www.redhat.com/
 *
 * Software distributed under the Licence is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
 * See the Licence for the specific language governing rights and
 * limitations under the Licence.
 *
 * The Original Code is JFFS2 - Journalling Flash File System, version 2
 *
 * Alternatively, the contents of this file may be used under the
 * terms of the GNU General Public License version 2 (the "GPL"), in
 * which case the provisions of the GPL are applicable instead of the
 * above.  If you wish to allow the use of your version of this file
 * only under the terms of the GPL and not to allow others to use your
 * version of this file under the RHEPL, indicate your decision by
 * deleting the provisions above and replace them with the notice and
 * other provisions required by the GPL.  If you do not delete the
 * provisions above, a recipient may use your version of this file
 * under either the RHEPL or the GPL.
 *
 * $Id: jffs2.h,v 1.2 2002/01/17 00:53:20 nyet Exp $
 *
 */data_incpage_outdestlensourcelenpage_out/opt/src/cmd/flash.cdo_protectdo_flerasedo_flinfomtd_id_parseprotect"enable or disable FLASH write protection""on  start end\n" "    - protect FLASH from addr 'start' to addr 'end'\n" "protect on start +len\n" "    - protect FLASH from addr 'start' to end of sect " "w/addr 'start'+'len'-1\n" "protect on  N:SF[-SL]\n" "    - protect sectors SF-SL in FLASH bank # N\n" "protect on  bank N\n    - protect FLASH bank # N\n" TMP_PROT_ON "protect on  all\n    - protect all FLASH banks\n" "protect off start end\n" "    - make FLASH from addr 'start' to addr 'end' writable\n" "protect off start +len\n" "    - make FLASH from addr 'start' to end of sect " "w/addr 'start'+'len'-1 wrtable\n" "protect off N:SF[-SL]\n" "    - make sectors SF-SL writable in FLASH bank # N\n" "protect off bank N\n    - make FLASH bank # N writable\n" TMP_PROT_OFF "protect off all\n    - make all FLASH banks writable""on  start end\n" "    - protect FLASH from addr 'start' to addr 'end'\n" "protect on start +len\n" "    - protect FLASH from addr 'start' to end of sect " "w/addr 'start'+'len'-1\n" "protect on  N:SF[-SL]\n" "    - protect sectors SF-SL in FLASH bank # N\n" "protect on  bank N\n    - protect FLASH bank # N\n" "protect on <part-id>\n    - protect partition\n" "protect on  all\n    - protect all FLASH banks\n" "protect off start end\n" "    - make FLASH from addr 'start' to addr 'end' writable\n" "protect off start +len\n" "    - make FLASH from addr 'start' to end of sect " "w/addr 'start'+'len'-1 wrtable\n" "protect off N:SF[-SL]\n" "    - make sectors SF-SL writable in FLASH bank # N\n" "protect off bank N\n    - make FLASH bank # N writable\n" "protect off <part-id>\n    - make partition writable\n" "protect off all\n    - make all FLASH banks writable"enable or disable FLASH write protectionon  start end
    - protect FLASH from addr 'start' to addr 'end'
protect on start +len
    - protect FLASH from addr 'start' to end of sect w/addr 'start'+'len'-1
protect on  N:SF[-SL]
    - protect sectors SF-SL in FLASH bank # N
protect on  bank N
    - protect FLASH bank # N
protect on <part-id>
    - protect partition
protect on  all
    - protect all FLASH banks
protect off start end
    - make FLASH from addr 'start' to addr 'end' writable
protect off start +len
    - make FLASH from addr 'start' to end of sect w/addr 'start'+'len'-1 wrtable
protect off N:SF[-SL]
    - make sectors SF-SL writable in FLASH bank # N
protect off bank N
    - make FLASH bank # N writable
protect off <part-id>
    - make partition writable
protect off all
    - make all FLASH banks writable"on  start end\n"
	"    - protect FLASH from addr 'start' to addr 'end'\n"
	"protect on start +len\n"
	"    - protect FLASH from addr 'start' to end of sect "
	"w/addr 'start'+'len'-1\n"
	"protect on  N:SF[-SL]\n"
	"    - protect sectors SF-SL in FLASH bank # N\n"
	"protect on  bank N\n    - protect FLASH bank # N\n"
	TMP_PROT_ON
	"protect on  all\n    - protect all FLASH banks\n"
	"protect off start end\n"
	"    - make FLASH from addr 'start' to addr 'end' writable\n"
	"protect off start +len\n"
	"    - make FLASH from addr 'start' to end of sect "
	"w/addr 'start'+'len'-1 wrtable\n"
	"protect off N:SF[-SL]\n"
	"    - make sectors SF-SL writable in FLASH bank # N\n"
	"protect off bank N\n    - make FLASH bank # N writable\n"
	TMP_PROT_OFF
	"protect off all\n    - make all FLASH banks writable"char[787]U_BOOT_CMD(
	protect,  4,  0,   do_protect,
	"enable or disable FLASH write protection",
	"on  start end\n"
	"    - protect FLASH from addr 'start' to addr 'end'\n"
	"protect on start +len\n"
	"    - protect FLASH from addr 'start' to end of sect "
	"w/addr 'start'+'len'-1\n"
	"protect on  N:SF[-SL]\n"
	"    - protect sectors SF-SL in FLASH bank # N\n"
	"protect on  bank N\n    - protect FLASH bank # N\n"
	TMP_PROT_ON
	"protect on  all\n    - protect all FLASH banks\n"
	"protect off start end\n"
	"    - make FLASH from addr 'start' to addr 'end' writable\n"
	"protect off start +len\n"
	"    - make FLASH from addr 'start' to end of sect "
	"w/addr 'start'+'len'-1 wrtable\n"
	"protect off N:SF[-SL]\n"
	"    - make sectors SF-SL writable in FLASH bank # N\n"
	"protect off bank N\n    - make FLASH bank # N writable\n"
	TMP_PROT_OFF
	"protect off all\n    - make all FLASH banks writable"
)_u_boot_list_2_cmd_2_protect.u_boot_list_2_cmd_2_protect"erase FLASH memory""start end\n" "    - erase FLASH from addr 'start' to addr 'end'\n" "erase start +len\n" "    - erase FLASH from addr 'start' to the end of sect " "w/addr 'start'+'len'-1\n" "erase N:SF[-SL]\n    - erase sectors SF-SL in FLASH bank # N\n" "erase bank N\n    - erase FLASH bank # N\n" TMP_ERASE "erase all\n    - erase all FLASH banks""start end\n" "    - erase FLASH from addr 'start' to addr 'end'\n" "erase start +len\n" "    - erase FLASH from addr 'start' to the end of sect " "w/addr 'start'+'len'-1\n" "erase N:SF[-SL]\n    - erase sectors SF-SL in FLASH bank # N\n" "erase bank N\n    - erase FLASH bank # N\n" "erase <part-id>\n    - erase partition\n" "erase all\n    - erase all FLASH banks"erase FLASH memorystart end
    - erase FLASH from addr 'start' to addr 'end'
erase start +len
    - erase FLASH from addr 'start' to the end of sect w/addr 'start'+'len'-1
erase N:SF[-SL]
    - erase sectors SF-SL in FLASH bank # N
erase bank N
    - erase FLASH bank # N
erase <part-id>
    - erase partition
erase all
    - erase all FLASH banks"start end\n"
	"    - erase FLASH from addr 'start' to addr 'end'\n"
	"erase start +len\n"
	"    - erase FLASH from addr 'start' to the end of sect "
	"w/addr 'start'+'len'-1\n"
	"erase N:SF[-SL]\n    - erase sectors SF-SL in FLASH bank # N\n"
	"erase bank N\n    - erase FLASH bank # N\n"
	TMP_ERASE
	"erase all\n    - erase all FLASH banks"char[331]U_BOOT_CMD(
	erase,   3,   0,  do_flerase,
	"erase FLASH memory",
	"start end\n"
	"    - erase FLASH from addr 'start' to addr 'end'\n"
	"erase start +len\n"
	"    - erase FLASH from addr 'start' to the end of sect "
	"w/addr 'start'+'len'-1\n"
	"erase N:SF[-SL]\n    - erase sectors SF-SL in FLASH bank # N\n"
	"erase bank N\n    - erase FLASH bank # N\n"
	TMP_ERASE
	"erase all\n    - erase all FLASH banks"
)_u_boot_list_2_cmd_2_erase.u_boot_list_2_cmd_2_eraseflinfo"print FLASH memory information""\n    - print information for all FLASH memory banks\n" "flinfo N\n    - print information for FLASH memory bank # N"print FLASH memory information
    - print information for all FLASH memory banks
flinfo N
    - print information for FLASH memory bank # N"\n    - print information for all FLASH memory banks\n"
	"flinfo N\n    - print information for FLASH memory bank # N"char[111]U_BOOT_CMD(
	flinfo,    2,    1,    do_flinfo,
	"print FLASH memory information",
	"\n    - print information for all FLASH memory banks\n"
	"flinfo N\n    - print information for FLASH memory bank # N"
)_u_boot_list_2_cmd_2_flinfo.u_boot_list_2_cmd_2_flinfoTMP_PROT_OFFTMP_PROT_ONTMP_ERASE"protect off <part-id>\n    - make partition writable\n""protect on <part-id>\n    - protect partition\n""erase <part-id>\n    - erase partition\n"defined(CONFIG_CMD_MTDPARTS)defined(CONFIG_MTD_NOR_FLASH)defined(CONFIG_SYS_FLASH_PROTECTION)/**************************************************//* CONFIG_MTD_NOR_FLASH *//* CONFIG_SYS_FLASH_PROTECTION *//* protect on/off <part-id> *//* erase <part-id> - erase partition *//* print info for all FLASH banks *//* last address in current sect	*//* last sector   *//* bank end addr *//* last  sector to erase	*//* first sector to erase	*//* "start +length" from used *//*
		 * It may happen that *addr_last doesn't fall on the sector
		 * boundary. We want to round such an address to the next
		 * sector boundary, so that the commands don't fail later on.
		 *//*
		 * *addr_last has the length, compute correct *addr_last
		 * XXX watch out for the integer overflow! Right now it is
		 * checked for in both the callers.
		 *//* indicates if the "start +length" form used *//*
 * This function computes the start and end addresses for both
 * erase and protect commands. The range of the addresses on which
 * either of the commands is to operate can be given in two forms:
 * 1. <cmd> start end - operate on <'start',  'end')
 * 2. <cmd> start +length - operate on <'start', start + length)
 * If the second form is used and the end address doesn't fall on the
 * sector boundary, than it will be adjusted to the next sector boundary.
 * If it isn't in the flash, the function will fail (return -1).
 * Input:
 *    arg1, arg2: address specification (i.e. both command arguments)
 * Output:
 *    addr_first, addr_last: computed address range
 * Return:
 *    1: success
 *   -1: failure (bad format, bad address).
*//* error, address not in flash *//* bank *//* sector *//* adjust *addr if necessary *//* get the end address of the sector *//* find the end addr of the sector where the *addr is *//*
 * Take *addr in Flash and adjust it to fall on the end of its sector
 *//*
 * this routine looks for an abbreviated flash range specification.
 * the syntax is B:SF[-SL], where B is the bank number, SF is the first
 * sector to erase, and SL is the last sector to erase (defaults to SF).
 * bank numbers start at 1 to be consistent with other specs, sector numbers
 * start at zero.
 *
 * returns:	1	- correct spec; *pinfo, *psf and *psl are
 *			  set appropriately
 *		0	- doesn't look like an abbreviated spec
 *		-1	- looks like an abbreviated spec, but got
 *			  a parsing error, a number out of range,
 *			  or an invalid flash bank.
 *//*
 * The user interface starts numbering for Flash banks with 1
 * for historical reasons.
 *//* partition handling routines *//*
 * FLASH support
 */ret_id/opt/src/cmd/fs.cdo_fstype_wrapperdo_ln_wrapperdo_ls_wrapperdo_save_wrapperdo_load_wrapperdo_size_wrapper"Look up a filesystem type""<interface> <dev>:<part>\n" "- print filesystem type\n" "fstype <interface> <dev>:<part> <varname>\n" "- set environment variable to filesystem type\n"Look up a filesystem type<interface> <dev>:<part>
- print filesystem type
fstype <interface> <dev>:<part> <varname>
- set environment variable to filesystem type
"<interface> <dev>:<part>\n"
	"- print filesystem type\n"
	"fstype <interface> <dev>:<part> <varname>\n"
	"- set environment variable to filesystem type\n"char[138]U_BOOT_CMD(
	fstype, 4, 1, do_fstype_wrapper,
	"Look up a filesystem type",
	"<interface> <dev>:<part>\n"
	"- print filesystem type\n"
	"fstype <interface> <dev>:<part> <varname>\n"
	"- set environment variable to filesystem type\n"
)_u_boot_list_2_cmd_2_fstype.u_boot_list_2_cmd_2_fstypeln"Create a symbolic link""<interface> <dev[:part]> target linkname\n" "    - create a symbolic link to 'target' with the name 'linkname' on\n" "      device type 'interface' instance 'dev'."Create a symbolic link<interface> <dev[:part]> target linkname
    - create a symbolic link to 'target' with the name 'linkname' on
      device type 'interface' instance 'dev'."<interface> <dev[:part]> target linkname\n"
	"    - create a symbolic link to 'target' with the name 'linkname' on\n"
	"      device type 'interface' instance 'dev'."char[156]U_BOOT_CMD(
	ln,	5,	1,	do_ln_wrapper,
	"Create a symbolic link",
	"<interface> <dev[:part]> target linkname\n"
	"    - create a symbolic link to 'target' with the name 'linkname' on\n"
	"      device type 'interface' instance 'dev'."
)_u_boot_list_2_cmd_2_ln.u_boot_list_2_cmd_2_lnls"<interface> [<dev[:part]> [directory]]\n" "    - List files in directory 'directory' of partition 'part' on\n" "      device type 'interface' instance 'dev'."<interface> [<dev[:part]> [directory]]
    - List files in directory 'directory' of partition 'part' on
      device type 'interface' instance 'dev'."<interface> [<dev[:part]> [directory]]\n"
	"    - List files in directory 'directory' of partition 'part' on\n"
	"      device type 'interface' instance 'dev'."char[150]U_BOOT_CMD(
	ls,	4,	1,	do_ls_wrapper,
	"list files in a directory (default /)",
	"<interface> [<dev[:part]> [directory]]\n"
	"    - List files in directory 'directory' of partition 'part' on\n"
	"      device type 'interface' instance 'dev'."
)_u_boot_list_2_cmd_2_ls.u_boot_list_2_cmd_2_ls"save file to a filesystem""<interface> <dev[:part]> <addr> <filename> bytes [pos]\n" "    - Save binary file 'filename' to partition 'part' on device\n" "      type 'interface' instance 'dev' from addr 'addr' in memory.\n" "      'bytes' gives the size to save in bytes and is mandatory.\n" "      'pos' gives the file byte position to start writing to.\n" "      If 'pos' is 0 or omitted, the file is written from the start."save file to a filesystem<interface> <dev[:part]> <addr> <filename> bytes [pos]
    - Save binary file 'filename' to partition 'part' on device
      type 'interface' instance 'dev' from addr 'addr' in memory.
      'bytes' gives the size to save in bytes and is mandatory.
      'pos' gives the file byte position to start writing to.
      If 'pos' is 0 or omitted, the file is written from the start."<interface> <dev[:part]> <addr> <filename> bytes [pos]\n"
	"    - Save binary file 'filename' to partition 'part' on device\n"
	"      type 'interface' instance 'dev' from addr 'addr' in memory.\n"
	"      'bytes' gives the size to save in bytes and is mandatory.\n"
	"      'pos' gives the file byte position to start writing to.\n"
	"      If 'pos' is 0 or omitted, the file is written from the start."char[379]U_BOOT_CMD(
	save,	7,	0,	do_save_wrapper,
	"save file to a filesystem",
	"<interface> <dev[:part]> <addr> <filename> bytes [pos]\n"
	"    - Save binary file 'filename' to partition 'part' on device\n"
	"      type 'interface' instance 'dev' from addr 'addr' in memory.\n"
	"      'bytes' gives the size to save in bytes and is mandatory.\n"
	"      'pos' gives the file byte position to start writing to.\n"
	"      If 'pos' is 0 or omitted, the file is written from the start."
)_u_boot_list_2_cmd_2_save.u_boot_list_2_cmd_2_save"load binary file from a filesystem""<interface> [<dev[:part]> [<addr> [<filename> [bytes [pos]]]]]\n" "    - Load binary file 'filename' from partition 'part' on device\n" "       type 'interface' instance 'dev' to address 'addr' in memory.\n" "      'bytes' gives the size to load in bytes.\n" "      If 'bytes' is 0 or omitted, the file is read until the end.\n" "      'pos' gives the file byte position to start reading from.\n" "      If 'pos' is 0 or omitted, the file is read from the start."load binary file from a filesystem<interface> [<dev[:part]> [<addr> [<filename> [bytes [pos]]]]]
    - Load binary file 'filename' from partition 'part' on device
       type 'interface' instance 'dev' to address 'addr' in memory.
      'bytes' gives the size to load in bytes.
      If 'bytes' is 0 or omitted, the file is read until the end.
      'pos' gives the file byte position to start reading from.
      If 'pos' is 0 or omitted, the file is read from the start."<interface> [<dev[:part]> [<addr> [<filename> [bytes [pos]]]]]\n"
	"    - Load binary file 'filename' from partition 'part' on device\n"
	"       type 'interface' instance 'dev' to address 'addr' in memory.\n"
	"      'bytes' gives the size to load in bytes.\n"
	"      If 'bytes' is 0 or omitted, the file is read until the end.\n"
	"      'pos' gives the file byte position to start reading from.\n"
	"      If 'pos' is 0 or omitted, the file is read from the start."char[439]U_BOOT_CMD(
	load,	7,	0,	do_load_wrapper,
	"load binary file from a filesystem",
	"<interface> [<dev[:part]> [<addr> [<filename> [bytes [pos]]]]]\n"
	"    - Load binary file 'filename' from partition 'part' on device\n"
	"       type 'interface' instance 'dev' to address 'addr' in memory.\n"
	"      'bytes' gives the size to load in bytes.\n"
	"      If 'bytes' is 0 or omitted, the file is read until the end.\n"
	"      'pos' gives the file byte position to start reading from.\n"
	"      If 'pos' is 0 or omitted, the file is read from the start."
)_u_boot_list_2_cmd_2_load.u_boot_list_2_cmd_2_loadU_BOOT_CMD(
	size,	4,	0,	do_size_wrapper,
	"determine a file's size",
	"<interface> <dev[:part]> <filename>\n"
	"    - Find file 'filename' from 'dev' on 'interface'\n"
	"      and determine its size."
)_u_boot_list_2_cmd_2_size.u_boot_list_2_cmd_2_size/*
 * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 *
 * Inspired by cmd_ext_common.c, cmd_fat.c.
 *//opt/src/cmd/gettime.cgettimedo_gettimeTimer val: %lu
"Timer val: %lu\n"Seconds : %lu
"Seconds : %lu\n"CONFIG_SYS_HZRemainder : %lu
"Remainder : %lu\n"sys_hz = %lu
"sys_hz = %lu\n"(unsigned long int)CONFIG_SYS_HZ"get timer val elapsed""get time elapsed from uboot start"get timer val elapsedget time elapsed from uboot startU_BOOT_CMD(
	gettime,	1,	1,	do_gettime,
	"get timer val elapsed",
	"get time elapsed from uboot start"
)_u_boot_list_2_cmd_2_gettime.u_boot_list_2_cmd_2_gettime/*
 * Get Timer overflows after 2^32 / CONFIG_SYS_HZ (32Khz) = 131072 sec
 *//*
 * Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
 *
 * Copyright (c) 2009, Code Aurora Forum. All rights reserved.
 *
 * (C) Copyright 2001
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *//opt/src/cmd/gpio.cdo_gpiostr_cmd-a"-a"str_gpio"status"sub_cmdGPIOC_INPUTGPIOC_SETGPIOC_CLEARGPIOC_TOGGLEGPIO: '%s' not found
"GPIO: '%s' not found\n"cmd_gpio"cmd_gpio"EBUSY-EBUSYgpio: requesting pin %u failed
"gpio: requesting pin %u failed\n"(value) >= (unsigned long)-MAX_ERRNO(value) >= (unsigned long)-4095IS_ERR_VALUE(value)gpio: pin %s (gpio %u) value is "gpio: pin %s (gpio %u) value is "unknown (ret=%d)
"unknown (ret=%d)\n"nval(nval) >= (unsigned long)-MAX_ERRNO(nval) >= (unsigned long)-4095IS_ERR_VALUE(nval)   Warning: no access to GPIO output value
"   Warning: no access to GPIO output value\n"   Warning: value of pin is still %d
"   Warning: value of pin is still %d\n"do_gpio_statusnum_bitsFLAG_SHOW_BANKFLAG_SHOW_ALL"GPIO device %s has no bits\n"dev->namedebug("GPIO device %s has no bits\n", dev->name)show_usagegpio_namecmd/gpio.cconst char[15]GPIO device %s has no bits
banklenFLAG_SHOW_NEWLINEUCLASS_GPIOgpio_get_description~FLAG_SHOW_NEWLINEBank %s:
"Bank %s:\n"~FLAG_SHOW_BANKname_to_gpiogpio_cmd"query and control gpio pins""<input|set|clear|toggle> <pin>\n" "    - input/set/clear/toggle the specified pin\n" "gpio status [-a] [<bank> | <pin>]  - show [all/claimed] GPIOs"query and control gpio pins<input|set|clear|toggle> <pin>
    - input/set/clear/toggle the specified pin
gpio status [-a] [<bank> | <pin>]  - show [all/claimed] GPIOs"<input|set|clear|toggle> <pin>\n"
	   "    - input/set/clear/toggle the specified pin\n"
	   "gpio status [-a] [<bank> | <pin>]  - show [all/claimed] GPIOs"char[140]U_BOOT_CMD(gpio, 4, 0, do_gpio,
	   "query and control gpio pins",
	   "<input|set|clear|toggle> <pin>\n"
	   "    - input/set/clear/toggle the specified pin\n"
	   "gpio status [-a] [<bank> | <pin>]  - show [all/claimed] GPIOs")_u_boot_list_2_cmd_2_gpio.u_boot_list_2_cmd_2_gpiodefined(CONFIG_DM_GPIO) && !defined(gpio_status)CONFIG_DM_GPIOgpio_statusdefined(CONFIG_DM_GPIO)/* finally, let's do it: set direction and exec command *//* grab the pin before we tweak it *//* turn the gpio name into a gpio number *//*
	 * TODO(sjg@chromium.org): For now we must fit into the existing GPIO
	 * framework, so we look up the name here and convert it to a GPIO number.
	 * Once all GPIO drivers are converted to driver model, we can change the
	 * code here to use the GPIO uclass interface instead of the numbered
	 * GPIO compatibility layer.
	 *//* parse the behavior *//* Support deprecated gpio_status() *//* Add a newline between bank names *//* A few flags used by show_gpio() *//*
 * Control GPIO pins on the fly
 *
 * Copyright (c) 2008-2011 Analog Devices Inc.
 *
 * Licensed under the GPL-2 or later.
 */show_allULL(x)(_ULL(x))UL(x)(_UL(x))_BITULL(x)(_ULL(1) << (x))_BITUL(x)(_UL(1) << (x))_ULL(x)(_AC(x, ULL))_UL(x)(_AC(x, UL))_AT(T,X)((T)(X))_AC(X,Y)__AC(X,Y)(X ## Y)_LINUX_CONST_H/* _LINUX_CONST_H *//* Some constant macros are used in both assembler and
 * C code.  Therefore we cannot annotate them always with
 * 'UL' and other type specifiers unilaterally.  We
 * use the following macros to deal with this.
 *
 * Similarly, _AT() will cast an expression with a type in C, but
 * leave it unchanged in asm.
 *//* const.h: Macros for dealing with constants.  */sizesSZ_4G_AC(0x100000000, ULL)SZ_2GSZ_1GSZ_512MSZ_256MSZ_128M0x08000000SZ_64M0x04000000SZ_32MSZ_16MSZ_8MSZ_4MSZ_2MSZ_1MSZ_512KSZ_256KSZ_128KSZ_64KSZ_32KSZ_16KSZ_8KSZ_4KSZ_2KSZ_1KSZ_512SZ_256SZ_128SZ_64SZ_32SZ_16SZ_8SZ_4SZ_2SZ_1__LINUX_SIZES_H__/* __LINUX_SIZES_H__ *//*
 * include/linux/sizes.h
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */<linux/const.h>/opt/src/include/stdlib.h__STDLIB_H_/* __STDLIB_H_ *//*
 *  Copyright (C) 2013 Google Inc.
 *//opt/src/cmd/gpt.cgptdo_gpt'%s' is not a number
"'%s' is not a number\n"blk_dev_desc%s: %s dev %d NOT available
"%s: %s dev %d NOT available\n"const char[7]Writing GPT: "Writing GPT: ""verify"Verify GPT: "Verify GPT: ""guid""swap""rename"error!
"error!\n"success!
"success!\n"do_rename_gpt_partsdisk_guidnumpartspartlistlenpartitions_list"OLD partitions_list is %s with %u chars\n"partitions_list, (unsigned)strlen(partitions_list)debug("OLD partitions_list is %s with %u chars\n", partitions_list,
	      (unsigned)strlen(partitions_list))cmd/gpt.c694/opt/src/include/exports.h/opt/src/include/_exports.h<exports.h>subcommname1name2OLD partitions_list is %s with %u chars
disk_partition_t **disk_partition **str_disk_guidnew_partitionspart_countPART_NAME_LENNames longer than %d characters are truncated.
"Names longer than %d characters are truncated.\n"&disk_partitionsdisk_part *currstruct disk_partlist_entry(pos, struct disk_part, list)ctr1ctr2Cannot swap partition names except in pairs.
"Cannot swap partition names except in pairs.\n"partnumIllegal partition number %s
"Illegal partition number %s\n""NEW partitions_list is %s with %u chars\n"debug("NEW partitions_list is %s with %u chars\n", partitions_list,
	      (unsigned)strlen(partitions_list))760NEW partitions_list is %s with %u chars
"Writing new partition table\n"debug("Writing new partition table\n")Writing new partition table
Writing new partition table failed
"Writing new partition table failed\n""Reading back new partition table\n"debug("Reading back new partition table\n")784Reading back new partition table
new partition table with %d partitions is:
"new partition table with %d partitions is:\n"set_gpt_cleanupdo_disk_guidgpt_verifygpt_headergpt_headblk_dev_desc->blkszPAD_SIZE((1) * sizeof(gpt_header), blk_dev_desc->blksz)(((((1) * sizeof(gpt_header)) - 1) / (blk_dev_desc->blksz) + 1) * blk_dev_desc->blksz)(1) * sizeof(gpt_header)ALLOC_CACHE_ALIGN_BUFFER_PAD(gpt_header, gpt_head, 1,
				     blk_dev_desc->blksz)(uintptr_t)__gpt_head((uintptr_t)__gpt_head)(typeof((uintptr_t)__gpt_head))(16)-1No partition list provided - only basic check
"No partition list provided - only basic check\n"gpt_header *_gpt_header *gpt_entry *_gpt_entry *gpt_entry **_gpt_entry **__gpt_headgpt_pteMissing disk guid
"Missing disk guid\n"Partition list incomplete
"Partition list incomplete\n"gpt_defaultNo partition list provided
"No partition list provided\n"set_gpt_info"%s:  lba num: 0x%x %d\n"__func__, (unsigned int)dev_desc->lba, (unsigned int)dev_desc->lbadebug("%s:  lba num: 0x%x %d\n", __func__,
	      (unsigned int)dev_desc->lba, (unsigned int)dev_desc->lba)389%s:  lba num: 0x%x %d
uuid_disk"uuid_disk"UUID_STR_FORMAT_STD;";"Error: is the partitions string NULL-terminated?
"Error: is the partitions string NULL-terminated?\n"namestrstr_partparts_countmax_str_partMAX_SEARCH_PARTITIONS';'p_countsizeof(disk_partition_t)tokuuid"uuid"sizeof(parts[i].uuid)Wrong uuid format for partition %d
"Wrong uuid format for partition %d\n"errno"name"sizeof(parts[i].name)"size"-"-"size_ll"start"start_llbootable"bootable"do_get_gpt_infoget_gpt_infonew_disk_partvalid_parts** No valid partitions found **
"** No valid partitions found **\n"create_gpt_partitions_listuuid_disk="uuid_disk="name="name="PART_NAME_LEN + 1partstr,start=0x%llx",start=0x%llx",size=0x%llx",size=0x%llx",uuid=",uuid="print_gpt_infopartstartstrpartsizestrPartition %d:
"Partition %d:\n"Start %s, size %s
"Start %s, size %s\n"Block size %lu, name %s
"Block size %lu, name %s\n"Type %s, bootable %d
"Type %s, bootable %d\n"UUID %s
"UUID %s\n"prettyprint_part_sizepartbytespartmegabytes%lluMiB"%lluMiB"allocate_disk_partnewpartsizeof(struct disk_part)PART_NAME_LEN - 1PART_TYPE_LENPART_TYPE_LEN - 1del_gpt_infopos->nextlist_entry(pos->next, struct disk_part, list)calc_parts_list_lenname=,"name=,"start=MiB,"start=MiB,"sizeof(lbaint_t)size=MiB,"size=MiB,"uuid=;"uuid=;""Length of partitions_list is %d for %d partitions\n"partlistlen, numpartsdebug("Length of partitions_list is %d for %d partitions\n", partlistlen,
	      numparts)Length of partitions_list is %d for %d partitions
found_keystrcopy,","extract_valsizestrpartsizeblksize="="extract_env${"${"'}'e"%s unset. "debug("%s unset. ", str)%s unset. UUID_STR_FORMAT_GUID"Set to random.\n"debug("Set to random.\n")Set to random.
"Can't get random UUID.\n"debug("Can't get random UUID.\n")Can't get random UUID.
"%s get from environment.\n"debug("%s get from environment.\n", str)%s get from environment.
"GUID Partition Table""<command> <interface> <dev> <partitions_list>\n" " - GUID partition table restoration and validity check\n" " Restore or verify GPT information on a device connected\n" " to interface\n" " Example usage:\n" " gpt write mmc 0 $partitions\n" " gpt verify mmc 0 $partitions\n" " gpt guid <interface> <dev>\n" "    - print disk GUID\n" " gpt guid <interface> <dev> <varname>\n" "    - set environment variable to disk GUID\n" " Example usage:\n" " gpt guid mmc 0\n" " gpt guid mmc 0 varname\n" "gpt partition renaming commands:\n" " gpt read <interface> <dev>\n" "    - read GPT into a data structure for manipulation\n" " gpt swap <interface> <dev> <name1> <name2>\n" "    - change all partitions named name1 to name2\n" "      and vice-versa\n" " gpt rename <interface> <dev> <part> <name>\n" "    - rename the specified partition\n" " Example usage:\n" " gpt swap mmc 0 foo bar\n" " gpt rename mmc 0 3 foo\n"U_BOOT_CMD(gpt, CONFIG_SYS_MAXARGS, 1, do_gpt,
	"GUID Partition Table",
	"<command> <interface> <dev> <partitions_list>\n"
	" - GUID partition table restoration and validity check\n"
	" Restore or verify GPT information on a device connected\n"
	" to interface\n"
	" Example usage:\n"
	" gpt write mmc 0 $partitions\n"
	" gpt verify mmc 0 $partitions\n"
	" gpt guid <interface> <dev>\n"
	"    - print disk GUID\n"
	" gpt guid <interface> <dev> <varname>\n"
	"    - set environment variable to disk GUID\n"
	" Example usage:\n"
	" gpt guid mmc 0\n"
	" gpt guid mmc 0 varname\n"
#ifdef CONFIG_CMD_GPT_RENAME
	"gpt partition renaming commands:\n"
	" gpt read <interface> <dev>\n"
	"    - read GPT into a data structure for manipulation\n"
	" gpt swap <interface> <dev> <name1> <name2>\n"
	"    - change all partitions named name1 to name2\n"
	"      and vice-versa\n"
	" gpt rename <interface> <dev> <part> <name>\n"
	"    - rename the specified partition\n"
	" Example usage:\n"
	" gpt swap mmc 0 foo bar\n"
	" gpt rename mmc 0 3 foo\n"
#endif
)GUID Partition Table<command> <interface> <dev> <partitions_list>
 - GUID partition table restoration and validity check
 Restore or verify GPT information on a device connected
 to interface
 Example usage:
 gpt write mmc 0 $partitions
 gpt verify mmc 0 $partitions
 gpt guid <interface> <dev>
    - print disk GUID
 gpt guid <interface> <dev> <varname>
    - set environment variable to disk GUID
 Example usage:
 gpt guid mmc 0
 gpt guid mmc 0 varname
gpt partition renaming commands:
 gpt read <interface> <dev>
    - read GPT into a data structure for manipulation
 gpt swap <interface> <dev> <name1> <name2>
    - change all partitions named name1 to name2
      and vice-versa
 gpt rename <interface> <dev> <part> <name>
    - rename the specified partition
 Example usage:
 gpt swap mmc 0 foo bar
 gpt rename mmc 0 3 foo
"<command> <interface> <dev> <partitions_list>\n"
	" - GUID partition table restoration and validity check\n"
	" Restore or verify GPT information on a device connected\n"
	" to interface\n"
	" Example usage:\n"
	" gpt write mmc 0 $partitions\n"
	" gpt verify mmc 0 $partitions\n"
	" gpt guid <interface> <dev>\n"
	"    - print disk GUID\n"
	" gpt guid <interface> <dev> <varname>\n"
	"    - set environment variable to disk GUID\n"
	" Example usage:\n"
	" gpt guid mmc 0\n"
	" gpt guid mmc 0 varname\n"
#ifdef CONFIG_CMD_GPT_RENAME
	"gpt partition renaming commands:\n"
	" gpt read <interface> <dev>\n"
	"    - read GPT into a data structure for manipulation\n"
	" gpt swap <interface> <dev> <name1> <name2>\n"
	"    - change all partitions named name1 to name2\n"
	"      and vice-versa\n"
	" gpt rename <interface> <dev> <part> <name>\n"
	"    - rename the specified partition\n"
	" Example usage:\n"
	" gpt swap mmc 0 foo bar\n"
	" gpt rename mmc 0 3 foo\n"char[810]_u_boot_list_2_cmd_2_gpt.u_boot_list_2_cmd_2_gptdisk_partitionsCONFIG_RANDOM_UUIDCONFIG_CMD_GPT_RENAMECONFIG_PARTITION_UUIDSCONFIG_PARTITION_TYPE_GUID/**
 * do_gpt(): Perform GPT operations
 *
 * @param cmdtp - command name
 * @param flag
 * @param argc
 * @param argv
 *
 * @return zero on success; otherwise error
 *//*
	 * Empty the existing disk_partitions list, as otherwise the memory in
	 * the original list is unreachable.
	 *//*
	 * Even though valid pointers are here passed into set_gpt_info(),
	 * it mallocs again, and there's no way to tell which failed.
	 *//* U-Boot partition numbering starts at 1 *//* rename *//* set_gpt_info allocates new_partitions and str_disk_guid *//*
	 * Uncomment the following line to print a string that 'gpt write'
	 * or 'gpt verify' will accept as input.
	 *//*
	 * Allocates disk_partitions, requiring matching call to del_gpt_info()
	 * if successful.
	 *//*
 * There are 3 malloc() calls in set_gpt_info() and there is no info about which
 * failed.
 *//* Check partition layout with provided pattern *//* fill partitions *//* save partitions layout to disk *//* bootable *//* start address is optional *//* start address *//* Let part efi module to auto extend the size *//* 'size' is mandatory *//* size *//* name is mandatory *//* name *//* 'type' is optional *//* guid *//* 'uuid' is optional if random uuid's are enabled *//* uuid *//* retrieve partitions data from string *//* allocate memory for partitions *//* calculate expected number of partitions *//* Move s to first partition *//* extract disk guid *//**
 * set_gpt_info(): Fill partition information from string
 *		function allocates memory, remember to free!
 *
 * @param dev_desc - pointer block device descriptor
 * @param str_part - pointer to string with partition information
 * @param str_disk_guid - pointer to pointer to allocated string with disk guid
 * @param partitions - pointer to pointer to allocated partitions array
 * @param parts_count - number of partitions
 *
 * @return - zero on success, otherwise error
 *
 *//* a wrapper to test get_gpt_info *//* Add 1 here because counter is zero-based but p1 is
		   the first partition *//*
	 * Always re-read partition info from device, in case
	 * it has changed
	 *//* start partition numbering at 1, as U-Boot does *//*
 * read partition info into disk_partitions list where
 * it can be printed or modified
 *//* one extra byte for NULL *//*
 * create the string that upstream 'gpt write' command will accept as an
 * argument
 *
 * From doc/README.gpt, Format of partitions layout:
 *    "uuid_disk=...;name=u-boot,size=60MiB,uuid=...;
 *	name=kernel,size=60MiB,uuid=...;"
 * The fields 'name' and 'size' are mandatory for every partition.
 * The field 'start' is optional. The fields 'uuid' and 'uuid_disk'
 * are optional if CONFIG_RANDOM_UUID is enabled.
 *//* UUID_STR_LEN is correct, as uuid[]'s length is UUID_STR_LEN+1 chars *//* for the terminating null *//* see part.h for definition of struct disk_partition *//* per-partition additions; numparts starts at 1, so this should be correct *//* for the comma *//**
 * found_key(): Found key without value in parameter list (comma separated).
 *
 * @param str - pointer to string with key
 * @param key - pointer to the key to search for
 *
 * @return - true on found key
 *//**
 * extract_val(): Extract value from a key=value pair list (comma separated).
 *                Only value for the given key is returend.
 *                Function allocates memory for the value, remember to free!
 *
 * @param str - pointer to string with key=values pairs
 * @param key - pointer to the key to search for
 *
 * @return - pointer to allocated string with the value
 *//**
 * extract_env(): Expand env name from string format '&{env_name}'
 *                and return pointer to the env (if the env is set)
 *
 * @param str - pointer to string
 * @param env - pointer to pointer to extracted env
 *
 * @return - zero on successful expand and env is set
 *//*
 * cmd_gpt.c -- GPT (GUID Partition Table) handling command
 *
 * Copyright (C) 2015
 * Lukasz Majewski <l.majewski@majess.pl>
 *
 * Copyright (C) 2012 Samsung Electronics
 * author: Lukasz Majewski <l.majewski@samsung.com>
 * author: Piotr Wilczek <p.wilczek@samsung.com>
 *//opt/src/cmd/hash.cdo_hash-v"-v"HASH_FLAG_ENVHASH_FLAG_VERIFYHARGS"compute hash message digest""algorithm address count [[*]hash_dest]\n" "    - compute message digest [save to env var / *address]" "\nhash -v algorithm address count [*]hash\n" "    - verify message digest of memory area to immediate value, \n" "      env var or *address"U_BOOT_CMD(
	hash,	HARGS,	1,	do_hash,
	"compute hash message digest",
	"algorithm address count [[*]hash_dest]\n"
		"    - compute message digest [save to env var / *address]"
#ifdef CONFIG_HASH_VERIFY
	"\nhash -v algorithm address count [*]hash\n"
		"    - verify message digest of memory area to immediate value, \n"
		"      env var or *address"
#endif
)compute hash message digestalgorithm address count [[*]hash_dest]
    - compute message digest [save to env var / *address]
hash -v algorithm address count [*]hash
    - verify message digest of memory area to immediate value, 
      env var or *address"algorithm address count [[*]hash_dest]\n"
		"    - compute message digest [save to env var / *address]"
#ifdef CONFIG_HASH_VERIFY
	"\nhash -v algorithm address count [*]hash\n"
		"    - verify message digest of memory area to immediate value, \n"
		"      env var or *address"char[227]_u_boot_list_2_cmd_2_hash.u_boot_list_2_cmd_2_hashCONFIG_HASH_VERIFY/* Move forward to 'algorithm' parameter *//*
 * Copyright (c) 2012 The Chromium OS Authors.
 *
 * (C) Copyright 2011
 * Joe Hershberger, National Instruments, joe.hershberger@ni.com
 *
 * (C) Copyright 2000
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 */<hash.h>/opt/src/cmd/help.cdo_helpll_entry_start(cmd_tbl_t, cmd).u_boot_list_2_cmd_1ll_entry_count(cmd_tbl_t, cmd).u_boot_list_2_cmd_3_ll_resultalias for 'help'"alias for 'help'"_u_boot_list_2_cmd_2_question_mark.u_boot_list_2_cmd_2_question_markquestion_mark"print command description/usage""\n" "	- print brief description of all commands\n" "help command ...\n" "	- print detailed usage of 'command'"U_BOOT_CMD(
	help,	CONFIG_SYS_MAXARGS,	1,	do_help,
	"print command description/usage",
	"\n"
	"	- print brief description of all commands\n"
	"help command ...\n"
	"	- print detailed usage of 'command'"
)print command description/usage
	- print brief description of all commands
help command ...
	- print detailed usage of 'command'"\n"
	"	- print brief description of all commands\n"
	"help command ...\n"
	"	- print detailed usage of 'command'"char[98]_u_boot_list_2_cmd_2_help.u_boot_list_2_cmd_2_help/* CONFIG_SYS_LONGHELP *//* This does not use the U_BOOT_CMD macro as ? can't be used in symbol names *//opt/src/include/sandboxblockdev.hsandboxblockdevhost_dev_bindhost_block_dev__SANDBOX_BLOCK_DEV__/*
 * Copyright (c) 2013, Henrik Nordstrom <henrik@henriknordstrom.net>
 *//opt/src/cmd/host.chostdo_hostcmd_tbl_t[7]cmd_tbl_s[7]cmd_host_sub392ARRAY_SIZE(cmd_host_sub)do_host_devNo current host device
"No current host device\n"Current host device %d
"Current host device %d\n"** Bad device specification %s **
"** Bad device specification %s **\n"blk_devNot bound to a backing file
"Not bound to a backing file\n"Invalid host device number
"Invalid host device number\n"do_host_infodev_strmin_devmax_devCONFIG_HOST_MAX_DEVICESCONFIG_HOST_MAX_DEVICES - 1%3s %12s %s
"%3s %12s %s\n""blocks""path"host_block_dev *host_dev%3d "%3d "%12lu %s
"%12lu %s\n"do_host_binddo_host_savedo_host_sizedo_host_lsdo_host_load"Miscellaneous host commands""load hostfs - <addr> <filename> [<bytes> <offset>]  - " "load a file from host\n" "host ls hostfs - <filename>                    - list files on host\n" "host save hostfs - <addr> <filename> <bytes> [<offset>] - " "save a file to host\n" "host size hostfs - <filename> - determine size of file on host\n" "host bind <dev> [<filename>] - bind \"host\" device to file\n" "host info [<dev>]            - show device binding & info\n" "host dev [<dev>] - Set or retrieve the current host device\n" "host commands use the \"hostfs\" device. The \"host\" device is used\n" "with standard IO commands such as fatls or ext2load"Miscellaneous host commandsload hostfs - <addr> <filename> [<bytes> <offset>]  - load a file from host
host ls hostfs - <filename>                    - list files on host
host save hostfs - <addr> <filename> <bytes> [<offset>] - save a file to host
host size hostfs - <filename> - determine size of file on host
host bind <dev> [<filename>] - bind "host" device to file
host info [<dev>]            - show device binding & info
host dev [<dev>] - Set or retrieve the current host device
host commands use the "hostfs" device. The "host" device is used
with standard IO commands such as fatls or ext2load"load hostfs - <addr> <filename> [<bytes> <offset>]  - "
		"load a file from host\n"
	"host ls hostfs - <filename>                    - list files on host\n"
	"host save hostfs - <addr> <filename> <bytes> [<offset>] - "
		"save a file to host\n"
	"host size hostfs - <filename> - determine size of file on host\n"
	"host bind <dev> [<filename>] - bind \"host\" device to file\n"
	"host info [<dev>]            - show device binding & info\n"
	"host dev [<dev>] - Set or retrieve the current host device\n"
	"host commands use the \"hostfs\" device. The \"host\" device is used\n"
	"with standard IO commands such as fatls or ext2load"char[577]U_BOOT_CMD(
	host, 8, 1, do_host,
	"Miscellaneous host commands",
	"load hostfs - <addr> <filename> [<bytes> <offset>]  - "
		"load a file from host\n"
	"host ls hostfs - <filename>                    - list files on host\n"
	"host save hostfs - <addr> <filename> <bytes> [<offset>] - "
		"save a file to host\n"
	"host size hostfs - <filename> - determine size of file on host\n"
	"host bind <dev> [<filename>] - bind \"host\" device to file\n"
	"host info [<dev>]            - show device binding & info\n"
	"host dev [<dev>] - Set or retrieve the current host device\n"
	"host commands use the \"hostfs\" device. The \"host\" device is used\n"
	"with standard IO commands such as fatls or ext2load"
)_u_boot_list_2_cmd_2_host.u_boot_list_2_cmd_2_host<sandboxblockdev.h>U_BOOT_CMD_MKENT(load, 7, 0, do_host_load, "", "")U_BOOT_CMD_MKENT(ls, 3, 0, do_host_ls, "", "")U_BOOT_CMD_MKENT(save, 6, 0, do_host_save, "", "")U_BOOT_CMD_MKENT(size, 3, 0, do_host_size, "", "")U_BOOT_CMD_MKENT(bind, 3, 0, do_host_bind, "", "")U_BOOT_CMD_MKENT(info, 3, 0, do_host_info, "", "")U_BOOT_CMD_MKENT(dev, 0, 1, do_host_dev, "", "")host_curr_device/* Skip past 'host' *//*
 * Copyright (c) 2012, Google Inc.
 *//opt/src/include/bootretry.hbootretrybootretry_dont_retrybootretry_reset_cmd_timeoutbootretry_init_cmd_timeoutbootretry_tstc_timeout__BOOTRETRY_HCONFIG_BOOT_RETRY_TIME/** bootretry_dont_retry() - Indicate that we should not retry the boot *//**
 * bootretry_reset_cmd_timeout() - reset command timeout
 *
 * Reset the command timeout so that the user has a fresh start. This is
 * typically used when input is received from the user.
 *//**
 * bootretry_init_cmd_timeout() - set up command timeout
 *
 * Get the required command timeout from the environment.
 *//**
 * bootretry_tstc_timeout() - ensure we get a keypress before timeout
 *
 * Check for a keypress repeatedly, resetting the watchdog each time. If a
 * keypress is not received within the command timeout, return an error.
 *
 * @return 0 if a key is received in time, -ETIMEDOUT if not
 */iomuxsearch_deviceiomux_printdevsiomux_doenvint[3]stdio_dev **[3]_IO_MUX_Hcd_countconsole_devices/* _IO_MUX_H *//*
 * The count of devices assigned to each FILE.  Defined in console.c
 * and populated in iomux.c.
 *//*
 * Pointers to devices used for each file type.  Defined in console.c
 * but storage is allocated in iomux.c.
 *//*
 * Stuff required to support console multiplexing.
 *//*
 * (C) Copyright 2008
 * Gary Jennejohn, DENX Software Engineering GmbH, garyj@denx.de.
 */console_announce_rconsole_record_reset_enableconsole_record_resetconsole_record_initconfirm_yesnodisable_ctrlcclear_ctrlchad_ctrlcctrlcconsole_assignconsole_init_rconsole_init_f__CONSOLE_HCONFIG_CONSOLE_MUXconsole_buffer/*
 * CONSOLE multiplexing.
 *//**
 * console_announce_r() - print a U-Boot console on non-serial consoles
 *
 * When U-Boot starts up with a display it generally does not announce itself
 * on the display. The banner is instead emitted on the UART before relocation.
 * This function prints a banner on devices which (we assume) did not receive
 * it before relocation.
 *
 * @return 0 (meaning no errors)
 *//**
 * console_record_reset_enable() - reset and enable the console buffers
 *
 * This should be called to enable the console buffer.
 *//**
 * console_record_reset() - reset the console recording buffers
 *
 * Removes any data in the buffers
 *//**
 * console_record_init() - set up the console recording buffers
 *
 * This should be called as soon as malloc() is available so that the maximum
 * amount of console output can be recorded.
 *//*  1 if input is "y", "Y", "yes" or "YES" *//* 1 to disable, 0 to enable Control-C detect *//* clear the Control-C condition *//* have we had a Control-C since last clear? *//* Assign the console *//* After  relocation; uses the console stuff *//* Before relocation; uses the serial  stuff *//* common/console.c */<iomux.h>/opt/src/include/edid.hedidedid_get_timingedid_get_timing_validateconst display_timingconst display_timing *edid_get_rangesedid1_info *edid_check_checksumedid_check_infoedid_print_infoedid_cea861_infoedid_cea861_db_typesEDID_CEA861_DB_AUDIOEDID_CEA861_DB_VIDEOEDID_CEA861_DB_VENDOREDID_CEA861_DB_SPEAKERedid1_infoedid_monitor_descriptoredid_monitor_descriptor_typesEDID_MONITOR_DESCRIPTOR_SERIALEDID_MONITOR_DESCRIPTOR_ASCIIEDID_MONITOR_DESCRIPTOR_RANGEEDID_MONITOR_DESCRIPTOR_NAMEedid_detailed_timingedid_aspectASPECT_625ASPECT_75ASPECT_8ASPECT_5625unsigned char[124]dtd_countdtd_offsetextension_tagextension_flagmonitor_detailsstruct <unnamed>[8]standard_timingsestablished_timingscolor_characteristicsfeature_supportgammamax_size_verticalmax_size_horizontalvideo_input_definitionweekserial_numberproduct_codemanufacturer_nameedid_monitor_descriptor[4]timingaspect_vfreqxresolutionzero_flag_3zero_flag_2zero_flag_1range_datagtf_datapixel_clock_maxhorizontal_maxhorizontal_minvertical_maxvertical_minvborderhborderhimage_vimage_size_hivimage_sizehimage_sizehsync_vsync_offset_pulse_width_hivsync_offset_pulse_widthhsync_pulse_widthhsync_offsetvertical_active_blanking_hivertical_blankingvertical_activehorizontal_active_blanking_hihorizontal_blankinghorizontal_activepixel_clockEDID_CEA861_DB_LEN(_x,offset)GET_BITS((_x).data[offset], 4, 0)EDID_CEA861_DB_TYPE(_x,offset)GET_BITS((_x).data[offset], 7, 5)EDID_CEA861_DTD_COUNT(_x)GET_BITS(((_x).dtd_count), 3, 0)EDID_CEA861_SUPPORTS_YUV422(_x)GET_BIT(((_x).dtd_count), 4)EDID_CEA861_SUPPORTS_YUV444(_x)GET_BIT(((_x).dtd_count), 5)EDID_CEA861_SUPPORTS_BASIC_AUDIO(_x)GET_BIT(((_x).dtd_count), 6)EDID_CEA861_SUPPORTS_UNDERSCAN(_x)GET_BIT(((_x).dtd_count), 7)EDID_CEA861_EXTENSION_TAGEDID1_INFO_STANDARD_TIMING_VFREQ(_x,_i)GET_BITS(((_x).standard_timings[_i].aspect_vfreq), 5, 0)EDID1_INFO_STANDARD_TIMING_ASPECT(_x,_i)GET_BITS(((_x).standard_timings[_i].aspect_vfreq), 7, 6)EDID1_INFO_STANDARD_TIMING_XRESOLUTION(_x,_i)(((_x).standard_timings[_i]).xresolution)EDID1_INFO_ESTABLISHED_TIMING_1152X870_75(_x)GET_BIT(((_x).established_timings[2]), 7)EDID1_INFO_ESTABLISHED_TIMING_1280X1024_75(_x)GET_BIT(((_x).established_timings[1]), 0)EDID1_INFO_ESTABLISHED_TIMING_1024X768_75(_x)GET_BIT(((_x).established_timings[1]), 1)EDID1_INFO_ESTABLISHED_TIMING_1024X768_70(_x)GET_BIT(((_x).established_timings[1]), 2)EDID1_INFO_ESTABLISHED_TIMING_1024X768_60(_x)GET_BIT(((_x).established_timings[1]), 3)EDID1_INFO_ESTABLISHED_TIMING_1024X768_87I(_x)GET_BIT(((_x).established_timings[1]), 4)EDID1_INFO_ESTABLISHED_TIMING_832X624_75(_x)GET_BIT(((_x).established_timings[1]), 5)EDID1_INFO_ESTABLISHED_TIMING_800X600_75(_x)GET_BIT(((_x).established_timings[1]), 6)EDID1_INFO_ESTABLISHED_TIMING_800X600_72(_x)GET_BIT(((_x).established_timings[1]), 7)EDID1_INFO_ESTABLISHED_TIMING_800X600_60(_x)GET_BIT(((_x).established_timings[0]), 0)EDID1_INFO_ESTABLISHED_TIMING_800X600_56(_x)GET_BIT(((_x).established_timings[0]), 1)EDID1_INFO_ESTABLISHED_TIMING_640X480_75(_x)GET_BIT(((_x).established_timings[0]), 2)EDID1_INFO_ESTABLISHED_TIMING_640X480_72(_x)GET_BIT(((_x).established_timings[0]), 3)EDID1_INFO_ESTABLISHED_TIMING_640X480_67(_x)GET_BIT(((_x).established_timings[0]), 4)EDID1_INFO_ESTABLISHED_TIMING_640X480_60(_x)GET_BIT(((_x).established_timings[0]), 5)EDID1_INFO_ESTABLISHED_TIMING_720X400_88(_x)GET_BIT(((_x).established_timings[0]), 6)EDID1_INFO_ESTABLISHED_TIMING_720X400_70(_x)GET_BIT(((_x).established_timings[0]), 7)EDID1_INFO_FEATURE_DEFAULT_GTF_SUPPORT(_x)GET_BIT(((_x).feature_support), 0)EDID1_INFO_FEATURE_PREFERRED_TIMING_MODE(_x)GET_BIT(((_x).feature_support), 1)EDID1_INFO_FEATURE_RGB(_x)GET_BIT(((_x).feature_support), 2)EDID1_INFO_FEATURE_DISPLAY_TYPE(_x)GET_BITS(((_x).feature_support), 4, 3)EDID1_INFO_FEATURE_ACTIVE_OFF(_x)GET_BIT(((_x).feature_support), 5)EDID1_INFO_FEATURE_SUSPEND(_x)GET_BIT(((_x).feature_support), 6)EDID1_INFO_FEATURE_STANDBY(_x)GET_BIT(((_x).feature_support), 7)EDID1_INFO_VIDEO_INPUT_SERRATION_V(_x)GET_BIT(((_x).video_input_definition), 0)EDID1_INFO_VIDEO_INPUT_SYNC_ON_GREEN(_x)GET_BIT(((_x).video_input_definition), 1)EDID1_INFO_VIDEO_INPUT_COMPOSITE_SYNC(_x)GET_BIT(((_x).video_input_definition), 2)EDID1_INFO_VIDEO_INPUT_SEPARATE_SYNC(_x)GET_BIT(((_x).video_input_definition), 3)EDID1_INFO_VIDEO_INPUT_BLANK_TO_BLACK(_x)GET_BIT(((_x).video_input_definition), 4)EDID1_INFO_VIDEO_INPUT_VOLTAGE_LEVEL(_x)GET_BITS(((_x).video_input_definition), 6, 5)EDID1_INFO_VIDEO_INPUT_DIGITAL(_x)GET_BIT(((_x).video_input_definition), 7)EDID1_INFO_SERIAL_NUMBER(_x)(((uint32_t)(_x).serial_number[3] << 24) + ((_x).serial_number[2] << 16) + ((_x).serial_number[1] << 8) + (_x).serial_number[0])EDID1_INFO_PRODUCT_CODE(_x)(((uint16_t)(_x).product_code[1] << 8) + (_x).product_code[0])EDID1_INFO_MANUFACTURER_NAME_CHAR3(_x)GET_BITS(((_x).manufacturer_name[1]), 4, 0)EDID1_INFO_MANUFACTURER_NAME_CHAR2(_x)((GET_BITS(((_x).manufacturer_name[0]), 1, 0) << 3) + GET_BITS(((_x).manufacturer_name[1]), 7, 5))EDID1_INFO_MANUFACTURER_NAME_CHAR1(_x)GET_BITS(((_x).manufacturer_name[0]), 6, 2)EDID1_INFO_MANUFACTURER_NAME_ZERO(_x)GET_BIT(((_x).manufacturer_name[0]), 7)EDID_DETAILED_TIMING_FLAG_INTERLEAVED(_x)GET_BIT((_x).flags, 0)EDID_DETAILED_TIMING_FLAG_HSYNC_POLARITY(_x)GET_BIT((_x).flags, 1)EDID_DETAILED_TIMING_FLAG_VSYNC_POLARITY(_x)GET_BIT((_x).flags, 2)EDID_DETAILED_TIMING_FLAG_POLARITY(_x)GET_BITS((_x).flags, 2, 1)EDID_DETAILED_TIMING_FLAG_DIGITAL_COMPOSITE(_x)GET_BITS((_x).flags, 4, 3)EDID_DETAILED_TIMING_FLAG_STEREO(_x)GET_BITS((_x).flags, 6, 5)EDID_DETAILED_TIMING_FLAG_INTERLACED(_x)GET_BIT((_x).flags, 7)EDID_DETAILED_TIMING_VIMAGE_SIZE(_x)((GET_BITS((_x).himage_vimage_size_hi, 3, 0) << 8) + (_x).vimage_size)EDID_DETAILED_TIMING_HIMAGE_SIZE(_x)((GET_BITS((_x).himage_vimage_size_hi, 7, 4) << 8) + (_x).himage_size)EDID_DETAILED_TIMING_VSYNC_PULSE_WIDTH(_x)((GET_BITS((_x).hsync_vsync_offset_pulse_width_hi, 1, 0) << 4) + GET_BITS((_x).vsync_offset_pulse_width, 3, 0))EDID_DETAILED_TIMING_VSYNC_OFFSET(_x)((GET_BITS((_x).hsync_vsync_offset_pulse_width_hi, 3, 2) << 4) + GET_BITS((_x).vsync_offset_pulse_width, 7, 4))EDID_DETAILED_TIMING_HSYNC_PULSE_WIDTH(_x)((GET_BITS((_x).hsync_vsync_offset_pulse_width_hi, 5, 4) << 8) + (_x).hsync_pulse_width)EDID_DETAILED_TIMING_HSYNC_OFFSET(_x)((GET_BITS((_x).hsync_vsync_offset_pulse_width_hi, 7, 6) << 8) + (_x).hsync_offset)EDID_DETAILED_TIMING_VERTICAL_BLANKING(_x)((GET_BITS((_x).vertical_active_blanking_hi, 3, 0) << 8) + (_x).vertical_blanking)EDID_DETAILED_TIMING_VERTICAL_ACTIVE(_x)((GET_BITS((_x).vertical_active_blanking_hi, 7, 4) << 8) + (_x).vertical_active)EDID_DETAILED_TIMING_HORIZONTAL_BLANKING(_x)((GET_BITS((_x).horizontal_active_blanking_hi, 3, 0) << 8) + (_x).horizontal_blanking)EDID_DETAILED_TIMING_HORIZONTAL_ACTIVE(_x)((GET_BITS((_x).horizontal_active_blanking_hi, 7, 4) << 8) + (_x).horizontal_active)EDID_DETAILED_TIMING_PIXEL_CLOCK(_x)(((((uint32_t)(_x).pixel_clock[1]) << 8) + (_x).pixel_clock[0]) * 10000)GET_BITS(_x,_pos_msb,_pos_lsb)(((_x) >> (_pos_lsb)) & ((1 << ((_pos_msb) - (_pos_lsb) + 1)) - 1))GET_BIT(_x,_pos)(((_x) >> (_pos)) & 1)HDMI_IEEE_OUI0x000c03EDID_EXT_SIZEEDID_SIZE__EDID_H_/* __EDID_H_ *//**
 * edid_get_timing() - Get basic digital display parameters
 *
 * @param buf		Buffer containing EDID data
 * @param buf_size	Size of buffer in bytes
 * @param timing	Place to put preferring timing information
 * @param panel_bits_per_colourp	Place to put the number of bits per
 *			colour supported by the panel. This will be set to
 *			-1 if not available
 * @return 0 if timings are OK, -ve on error
 *//**
 * edid_get_timing_validate() - Get basic digital display parameters with
 * mode selection callback
 *
 * @param buf		Buffer containing EDID data
 * @param buf_size	Size of buffer in bytes
 * @param timing	Place to put preferring timing information
 * @param panel_bits_per_colourp	Place to put the number of bits per
 *			colour supported by the panel. This will be set to
 *			-1 if not available
 * @param mode_valid	Callback validating mode, returning true is mode is
 *			supported, false otherwise.
 * @parem valid_priv	Pointer to private data for mode_valid callback
 * @return 0 if timings are OK, -ve on error
 *//**
 * Get the horizontal and vertical rate ranges of the monitor.
 *
 * @param edid	The EDID info
 * @param hmin	Returns the minimum horizontal rate
 * @param hmax	Returns the maxium horizontal rate
 * @param vmin	Returns the minimum vertical rate
 * @param vmax	Returns the maxium vertical rate
 * @return 0 on success, or -1 on error
 *//**
 * Check checksum of a 128 bytes EDID data block
 *
 * @param edid_block	EDID block data
 *
 * @return 0 on success, or a negative errno on error
 *//**
 * Check the EDID info.
 *
 * @param info  The EDID info to be checked
 * @return 0 on valid, or -1 on invalid
 *//**
 * Print the EDID info.
 *
 * @param edid_info	The EDID info to be printed
 *//* Detailed timing information used in EDID v1.x *//* Aspect ratios used in EDID info. *//* OUI of HDMI vendor specific data block *//* Size of the EDID data *//*
 * Copyright (c) 2012 The Chromium OS Authors.
 *
 * (C) Copyright 2010
 * Petr Stetiar <ynezz@true.cz>
 *
 * Contains stolen code from ddcprobe project which is:
 * Copyright (C) Nalin Dahyabhai <bigfun@pobox.com>
 */panel_bits_per_colourpmode_validmode_valid_privhminhmaxvminvmaxedid_blockedid_info/opt/src/cmd/i2c.cdo_i2ccmd_tbl_t[16]cmd_tbl_s[16]cmd_i2c_subARRAY_SIZE(cmd_i2c_sub)i2c_relocdo_i2c_resetError: Not supported by the driver
"Error: Not supported by the driver\n"do_i2c_nmdo_i2c_mmdo_i2c_bus_speedCurrent bus speed=%d
"Current bus speed=%d\n"Setting bus speed to %d Hz
"Setting bus speed to %d Hz\n"Failure changing bus speed (%d)
"Failure changing bus speed (%d)\n"do_i2c_bus_numdo_i2c_show_busUCLASS_I2C&uc->dev_head(&uc->dev_head)->nexttypeof(*bus)uclass_foreach_dev(bus, uc)bus->uclass_node.next<edid.h><bootretry.h>   %02x: %s, offset len %x, flags %x
"   %02x: %s, offset len %x, flags %x\n"do_edidsizeof(edid)I2C_ERR_READContent isn't valid EDID.
"Content isn't valid EDID.\n"do_i2c_loopalenDEFAULT_ADDR_LENI2C_ERR_WRITEu_char[16]sizeof(bytes)do_i2c_probeValid chip addresses:"Valid chip addresses:" %02X" %02X"foundmod_i2c_memincrflag%08lx:"%08lx:"(data)((data))cpu_to_be32 %02lx" %02lx"0x000000FF %04lx" %04lx" %08lx" %08lx" ? " ? "(__force __u32)(__be32)(data)(__u32)(__be32)(data)((__u32)(__be32)(data))CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MSCONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS * 1000do_i2c_crcCRC32 for %08lx ... %08lx ==> "CRC32 for %08lx ... %08lx ==> "byte%08lx
"%08lx\n"do_i2c_mw11000do_i2c_md%04x:"%04x:" %02x" %02x"    "    "0x7e."."%c"%c"do_i2c_olenolen%x
"%x\n"do_i2c_flagsdo_i2c_writememaddrdevaddri2c_chip-s"-s"4294967291~DM_I2C_CHIP_WR_ADDRESSdo_i2c_readi2c_report_errError %s the chip: %d
"Error %s the chip: %d\n"reading"reading""writing"get_aleni2c_init_boardi2c_get_cur_bus_chipi2c_get_cur_busNo I2C bus selected
"No I2C bus selected\n"cmd_i2c_set_bus_numdefault_lencmd/i2c.ci2c_err_op"I2C sub-system"i2c_help_textI2C sub-systemchar[1058]U_BOOT_CMD(
	i2c, 7, 1, do_i2c,
	"I2C sub-system",
	i2c_help_text
)_u_boot_list_2_cmd_2_i2c.u_boot_list_2_cmd_2_i2cbus [muxtype:muxaddr:muxchannel] - show I2C bus info
i2c crc32 chip address[.0, .1, .2] count - compute CRC32 checksum
i2c dev [dev] - show or set current I2C bus
i2c edid chip - print EDID configuration information
i2c loop chip address[.0, .1, .2] [# of objects] - looping read of device
i2c md chip address[.0, .1, .2] [# of objects] - read from I2C device
i2c mm chip address[.0, .1, .2] - write to I2C device (auto-incrementing)
i2c mw chip address[.0, .1, .2] value [count] - write to I2C device (fill)
i2c nm chip address[.0, .1, .2] - write to I2C device (constant address)
i2c probe [address] - test for and show device(s) on the I2C bus
i2c read chip address[.0, .1, .2] length memaddress - read to memory
i2c write memaddress chip address[.0, .1, .2] length [-s] - write memory
          to I2C; the -s option selects bulk write in a single transaction
i2c flags chip [flags] - set or get chip flags
i2c olen chip [offset_length] - set or get chip offset length
i2c reset - re-init the I2C Controller
i2c speed [speed] - show or set I2C bus speedloopmmnmU_BOOT_CMD_MKENT(bus, 1, 1, do_i2c_show_bus, "", "")U_BOOT_CMD_MKENT(crc32, 3, 1, do_i2c_crc, "", "")U_BOOT_CMD_MKENT(dev, 1, 1, do_i2c_bus_num, "", "")U_BOOT_CMD_MKENT(edid, 1, 1, do_edid, "", "")U_BOOT_CMD_MKENT(loop, 3, 1, do_i2c_loop, "", "")U_BOOT_CMD_MKENT(md, 3, 1, do_i2c_md, "", "")U_BOOT_CMD_MKENT(mm, 2, 1, do_i2c_mm, "", "")U_BOOT_CMD_MKENT(mw, 3, 1, do_i2c_mw, "", "")U_BOOT_CMD_MKENT(nm, 2, 1, do_i2c_nm, "", "")U_BOOT_CMD_MKENT(probe, 0, 1, do_i2c_probe, "", "")U_BOOT_CMD_MKENT(read, 5, 1, do_i2c_read, "", "")U_BOOT_CMD_MKENT(write, 6, 0, do_i2c_write, "", "")U_BOOT_CMD_MKENT(flags, 2, 1, do_i2c_flags, "", "")U_BOOT_CMD_MKENT(olen, 2, 1, do_i2c_olen, "", "")U_BOOT_CMD_MKENT(reset, 0, 1, do_i2c_reset, "", "")U_BOOT_CMD_MKENT(speed, 1, 1, do_i2c_bus_speed, "", "")i2c_cur_busi2c_mm_last_aleni2c_mm_last_addri2c_mm_last_chipi2c_dp_last_lengthi2c_dp_last_aleni2c_dp_last_addri2c_dp_last_chipdefined(CONFIG_SYS_I2C_NOPROBES)CONFIG_I2C_SET_DEFAULT_BUS_NUM!defined(CONFIG_SYS_I2C) && !defined(CONFIG_DM_I2C)!defined(CONFIG_SYS_I2C_FRAM)defined(CONFIG_CMD_SDRAM)defined(CONFIG_I2C_EDID)defined(CONFIG_SYS_I2C) || defined(CONFIG_DM_I2C)defined(CONFIG_SYS_I2C) || defined(CONFIG_I2C_MULTI_BUS) || \defined(CONFIG_DM_I2C)defined(CONFIG_SYS_I2C) || \/* CONFIG_I2C_EDID *//* CONFIG_I2C_MULTI_BUS *//* That's the prefix for the crc32 command below. *//* Strip off leading 'i2c' command argument *//**
 * do_i2c() - Handle the "i2c" command-line command
 * @cmdtp:	Command data struct pointer
 * @flag:	Command flag
 * @argc:	Command-line argument count
 * @argv:	Array of command-line arguments
 *
 * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
 * on error.
 *//**
 * do_i2c_reset() - Handle the "i2c reset" command-line command
 * @cmdtp:	Command data struct pointer
 * @flag:	Command flag
 * @argc:	Command-line argument count
 * @argv:	Array of command-line arguments
 *
 * Returns zero always.
 *//**
 * do_i2c_nm() - Handle the "i2c nm" command-line command
 * @cmdtp:	Command data struct pointer
 * @flag:	Command flag
 * @argc:	Command-line argument count
 * @argv:	Array of command-line arguments
 *
 * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
 * on error.
 *//**
 * do_i2c_mm() - Handle the "i2c mm" command-line command
 * @cmdtp:	Command data struct pointer
 * @flag:	Command flag
 * @argc:	Command-line argument count
 * @argv:	Array of command-line arguments
 *
 * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
 * on error.
 *//* querying current speed *//**
 * do_i2c_bus_speed() - Handle the "i2c speed" command-line command
 * @cmdtp:	Command data struct pointer
 * @flag:	Command flag
 * @argc:	Command-line argument count
 * @argv:	Array of command-line arguments
 *
 * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
 * on error.
 *//* defined(CONFIG_SYS_I2C) *//**
 * do_i2c_bus_num() - Handle the "i2c dev" command-line command
 * @cmdtp:	Command data struct pointer
 * @flag:	Command flag
 * @argc:	Command-line argument count
 * @argv:	Array of command-line arguments
 *
 * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
 * on error.
 *//**
 * do_i2c_show_bus() - Handle the "i2c bus" command-line command
 * @cmdtp:	Command data struct pointer
 * @flag:	Command flag
 * @argc:	Command-line argument count
 * @argv:	Array of command-line arguments
 *
 * Returns zero always.
 *//*
 * Syntax:
 *	i2c edid {i2c_chip}
 *//*
	 * Chip is always specified.
	 *//*
 * Syntax:
 *	i2c sdram {i2c_chip}
 *//*
 * The SDRAM command is separately configured because many
 * (most?) embedded boards don't use SDRAM DIMMs.
 *
 * FIXME: Document and probably move elsewhere!
 *//* NOTREACHED *//*
	 * Run the loop...
	 *//*
	 * The delay time (uSec) is optional.
	 *//*
	 * Length is the number of objects, not number of bytes.
	 *//*
	 * Address is always specified.
	 *//**
 * do_i2c_loop() - Handle the "i2c loop" command-line command
 * @cmdtp:	Command data struct pointer
 * @flag:	Command flag
 * @argc:	Command-line argument count
 * @argv:	Array of command-line arguments
 *
 * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
 * on error.
 *
 * Syntax:
 *	i2c loop {i2c_chip} {addr}{.0, .1, .2} [{length}] [{delay}]
 *	{length} - Number of bytes to read
 *	{delay}  - A DECIMAL number and defaults to 1000 uSec
 *//* NOPROBES *//**
 * do_i2c_probe() - Handle the "i2c probe" command-line command
 * @cmdtp:	Command data struct pointer
 * @flag:	Command flag
 * @argc:	Command-line argument count
 * @argv:	Array of command-line arguments
 *
 * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
 * on error.
 *
 * Syntax:
 *	i2c probe {addr}
 *
 * Returns zero (success) if one or more I2C devices was found
 *//*
				 * good enough to not time out
				 *//* timed out, exit the command	*//* good enough to not time out *//*
			 * <CR> pressed as only input, don't modify current
			 * location and move to next.
			 *//*
	 * Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 *//*
		 * Address is always specified.
		 *//*
		 * Chip is always specified.
		 *//*
		 * New command specified.  Check for a size specification.
		 * Defaults to byte if no or incorrect specification.
		 *//* got a good command to get here *//**
 * mod_i2c_mem() - Handle the "i2c mm" and "i2c nm" command-line command
 * @cmdtp:	Command data struct pointer
 * @flag:	Command flag
 * @argc:	Command-line argument count
 * @argv:	Array of command-line arguments
 *
 * Modify memory.
 *
 * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
 * on error.
 *
 * Syntax:
 *	i2c mm{.b, .w, .l} {i2c_chip} {addr}{.0, .1, .2}
 *	i2c nm{.b, .w, .l} {i2c_chip} {addr}{.0, .1, .2}
 *//*
	 * CRC a byte at a time.  This is going to be slooow, but hey, the
	 * memories are small and slow too so hopefully nobody notices.
	 *//*
	 * Count is always specified
	 *//**
 * do_i2c_crc() - Handle the "i2c crc32" command-line command
 * @cmdtp:	Command data struct pointer
 * @flag:	Command flag
 * @argc:	Command-line argument count
 * @argv:	Array of command-line arguments
 *
 * Calculate a CRC on memory
 *
 * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
 * on error.
 *
 * Syntax:
 *	i2c crc32 {i2c_chip} {addr}{.0, .1, .2} {count}
 *//*
 * No write delay with FRAM devices.
 *//*
		 * Wait for the write to complete.  The write can take
		 * up to 10mSec (we allow a little more time).
		 *//*
	 * Optional count
	 *//*
	 * Value to write is always specified.
	 *//**
 * do_i2c_mw() - Handle the "i2c mw" command-line command
 * @cmdtp:	Command data struct pointer
 * @flag:	Command flag
 * @argc:	Command-line argument count
 * @argv:	Array of command-line arguments
 *
 * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
 * on error.
 *
 * Syntax:
 *	i2c mw {i2c_chip} {addr}{.0, .1, .2} {data} [{count}]
 *//*
	 * Print the lines.
	 *
	 * We buffer all read data, so we can make sure data is read only
	 * once.
	 *//*
		 * If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 *//*
		 * I2C data address within the chip.  This can be 1 or
		 * 2 bytes long.  Some day it might be 3 bytes long :-).
		 *//*
		 * I2C chip address
		 *//*
		 * New command specified.
		 *//* We use the last specified parameters, unless new ones are
	 * entered.
	 *//**
 * do_i2c_md() - Handle the "i2c md" command-line command
 * @cmdtp:	Command data struct pointer
 * @flag:	Command flag
 * @argc:	Command-line argument count
 * @argv:	Array of command-line arguments
 *
 * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
 * on error.
 *
 * Syntax:
 *	i2c md {i2c_chip} {addr}{.0, .1, .2} {len}
 *//*
		 * Repeated addressing - perform <length> separate
		 * write transactions of one byte each
		 *//*
		 * Write all bytes in a single I2C transaction. If the target
		 * device is an EEPROM, it is your responsibility to not cross
		 * a page boundary. No write delay upon completion, take this
		 * into account if linking commands.
		 *//*
	 * Length is the number of bytes.
	 *//*
	 * I2C data address within the chip.  This can be 1 or
	 * 2 bytes long.  Some day it might be 3 bytes long :-).
	 *//*
	 * I2C chip address
	 *//*
	 * memaddr is the address where to store things in memory
	 *//**
 * do_i2c_read() - Handle the "i2c read" command-line command
 * @cmdtp:	Command data struct pointer
 * @flag:	Command flag
 * @argc:	Command-line argument count
 * @argv:	Array of command-line arguments
 *
 * Returns zero on success, CMD_RET_USAGE in case of misuse and negative
 * on error.
 *
 * Syntax:
 *	i2c read {i2c_chip} {devaddr}{.0, .1, .2} {len} {memaddr}
 *//**
 * get_alen() - Small parser helper function to get address length
 *
 * Returns the address length.
 *//**
 * i2c_set_bus_speed() - Configure I2C bus speed
 * @speed:	Newly set speed of the I2C bus in Hz
 *
 * This function is the default implementation of function for setting
 * the I2C bus speed in Hz.
 *
 * A driver implementing runtime switching of I2C bus speed must override
 * this function to report the speed correctly. Simple or legacy drivers
 * can use this fallback.
 *
 * Returns zero on success, negative value on error.
 *//*
 * TODO: Implement architecture-specific get/set functions
 * Should go away, if we switched completely to new multibus support
 *//**
 * i2c_get_bus_speed() - Return I2C bus speed
 *
 * This function is the default implementation of function for retrieveing
 * the current I2C bus speed in Hz.
 *
 * A driver implementing runtime switching of I2C bus speed must override
 * this function to report the speed correctly. Simple or legacy drivers
 * can use this fallback.
 *
 * Returns I2C bus speed in Hz.
 *//* TODO: Implement architecture-specific get/set functions *//**
 * i2c_init_board() - Board-specific I2C bus init
 *
 * This function is the default no-op implementation of I2C bus
 * initialization. This function can be overridden by board-specific
 * implementation if needed.
 *//*
 * Default for driver model is to use the chip's existing address length.
 * For legacy code, this is not stored, so we need to use a suitable
 * default.
 *//* Make compiler happy *//* single bus *//* If only one I2C bus is present, the list of devices to ignore when
 * the probe command is issued is represented by a 1D array of addresses.
 * When multiple buses are present, the list is an array of bus-address
 * pairs.  The following macros take care of this *//* Display values from last command.
 * Memory modify remembered values are different from display memory.
 *//*
 * I2C Functions similar to the standard memory functions.
 *
 * There are several parameters in many of the commands that bear further
 * explanations:
 *
 * {i2c_chip} is the I2C chip address (the first byte sent on the bus).
 *   Each I2C chip on the bus has a unique address.  On the I2C data bus,
 *   the address is the upper seven bits and the LSB is the "read/write"
 *   bit.  Note that the {i2c_chip} address specified on the command
 *   line is not shifted up: e.g. a typical EEPROM memory chip may have
 *   an I2C address of 0x50, but the data put on the bus will be 0xA0
 *   for write and 0xA1 for read.  This "non shifted" address notation
 *   matches at least half of the data sheets :-/.
 *
 * {addr} is the address (or offset) within the chip.  Small memory
 *   chips have 8 bit addresses.  Large memory chips have 16 bit
 *   addresses.  Other memory chips have 9, 10, or 11 bit addresses.
 *   Many non-memory chips have multiple registers and {addr} is used
 *   as the register index.  Some non-memory chips have only one register
 *   and therefore don't need any {addr} parameter.
 *
 *   The default {addr} parameter is one byte (.1) which works well for
 *   memories and registers with 8 bits of address space.
 *
 *   You can specify the length of the {addr} field with the optional .0,
 *   .1, or .2 modifier (similar to the .b, .w, .l modifier).  If you are
 *   manipulating a single register device which doesn't use an address
 *   field, use "0.0" for the address and the ".0" length field will
 *   suppress the address in the I2C data stream.  This also works for
 *   successive reads using the I2C auto-incrementing memory pointer.
 *
 *   If you are manipulating a large memory with 2-byte addresses, use
 *   the .2 address modifier, e.g. 210.2 addresses location 528 (decimal).
 *
 *   Then there are the unfortunate memory chips that spill the most
 *   significant 1, 2, or 3 bits of address into the chip address byte.
 *   This effectively makes one chip (logically) look like 2, 4, or
 *   8 chips.  This is handled (awkwardly) by #defining
 *   CONFIG_SYS_I2C_EEPROM_ADDR_OVERFLOW and using the .1 modifier on the
 *   {addr} field (since .1 is the default, it doesn't actually have to
 *   be specified).  Examples: given a memory chip at I2C chip address
 *   0x50, the following would happen...
 *     i2c md 50 0 10   display 16 bytes starting at 0x000
 *                      On the bus: <S> A0 00 <E> <S> A1 <rd> ... <rd>
 *     i2c md 50 100 10 display 16 bytes starting at 0x100
 *                      On the bus: <S> A2 00 <E> <S> A3 <rd> ... <rd>
 *     i2c md 50 210 10 display 16 bytes starting at 0x210
 *                      On the bus: <S> A4 10 <E> <S> A5 <rd> ... <rd>
 *   This is awfully ugly.  It would be nice if someone would think up
 *   a better way of handling this.
 *
 * Adapted from cmd_mem.c which is copyright Wolfgang Denk (wd@denx.de).
 *//*
 * (C) Copyright 2009
 * Sergey Kubushyn, himself, ksi@koi8.net
 *
 * Changes for unified multibus/multiadapter I2C support.
 *
 * (C) Copyright 2001
 * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com.
 */watchdogwatchdog_resetinit_func_watchdog_resetWATCHDOG_RESETINIT_FUNC_WATCHDOG_RESETinit_func_watchdog_reset,INIT_FUNC_WATCHDOG_INITinit_func_watchdog_init,_WATCHDOG_H_!defined(__ASSEMBLY__)defined(CONFIG_WATCHDOG) || defined(CONFIG_HW_WATCHDOG)defined(CONFIG_HW_WATCHDOG) && defined(CONFIG_WATCHDOG)CONFIG_HW_WATCHDOGdefined(__ASSEMBLY__)defined(CONFIG_WATCHDOG)defined(CONFIG_SPL_BUILD) &&		\defined(CONFIG_HW_WATCHDOG) && !defined(__ASSEMBLY__)defined(CONFIG_MPC85xx) && !defined(__ASSEMBLY__)/* _WATCHDOG_H_ *//*
 * Prototypes from $(CPU)/cpu.c.
 *//* CONFIG_HW_WATCHDOG *//* CONFIG_WATCHDOG && !__ASSEMBLY__ *//*XXX DO_NOT_DEL_THIS_COMMENT*//*
		 * No hardware or software watchdog.
		 *//* Don't require the watchdog to be enabled in SPL *//*
	 * Maybe a software watchdog?
	 *//*
 * Hardware watchdog
 *//*
 * Reset the watchdog timer, always returns 0
 *
 * This function is here since it is shared between board_f() and board_r(),
 * and the legacy arch/<arch>/board.c code.
 *//*
 * Watchdog functions and macros.
 *//*
 * (C) Copyright 2001
 * Erik Theisen,  Wave 7 Optics, etheisen@mindspring.com.
 *//opt/src/cmd/ide.cidedo_diskboot"ide"do_ide"res"
Reset IDE: "\nReset IDE: "diskboot"boot from IDE device""loadAddr dev:part"boot from IDE deviceloadAddr dev:partU_BOOT_CMD(diskboot, 3, 1, do_diskboot,
	   "boot from IDE device", "loadAddr dev:part")_u_boot_list_2_cmd_2_diskboot.u_boot_list_2_cmd_2_diskboot"IDE sub-system""reset - reset IDE controller\n" "ide info  - show available IDE devices\n" "ide device [dev] - show or set current device\n" "ide part [dev] - print partition table of one or all IDE devices\n" "ide read  addr blk# cnt\n" "ide write addr blk# cnt - read/write `cnt'" " blocks starting at block `blk#'\n" "    to/from memory address `addr'"IDE sub-systemreset - reset IDE controller
ide info  - show available IDE devices
ide device [dev] - show or set current device
ide part [dev] - print partition table of one or all IDE devices
ide read  addr blk# cnt
ide write addr blk# cnt - read/write `cnt' blocks starting at block `blk#'
    to/from memory address `addr'"reset - reset IDE controller\n"
	   "ide info  - show available IDE devices\n"
	   "ide device [dev] - show or set current device\n"
	   "ide part [dev] - print partition table of one or all IDE devices\n"
	   "ide read  addr blk# cnt\n"
	   "ide write addr blk# cnt - read/write `cnt'"
	   " blocks starting at block `blk#'\n"
	   "    to/from memory address `addr'"char[312]U_BOOT_CMD(ide, 5, 1, do_ide,
	   "IDE sub-system",
	   "reset - reset IDE controller\n"
	   "ide info  - show available IDE devices\n"
	   "ide device [dev] - show or set current device\n"
	   "ide part [dev] - print partition table of one or all IDE devices\n"
	   "ide read  addr blk# cnt\n"
	   "ide write addr blk# cnt - read/write `cnt'"
	   " blocks starting at block `blk#'\n"
	   "    to/from memory address `addr'")_u_boot_list_2_cmd_2_ide.u_boot_list_2_cmd_2_idecurr_devicedefined(CONFIG_IDE_PCMCIA)/* Current I/O Device	*//*
 * IDE support
 */<ide.h>/opt/src/cmd/io.cdo_io_iowdo_io_iod%04x: "%04x: "%08x
"%08x\n"%04x
"%04x\n"%02x
"%02x\n"iow"IO space modify""[.b, .w, .l] address value"IO space modify[.b, .w, .l] address valueU_BOOT_CMD(iow, 3, 0, do_io_iow,
	   "IO space modify",
	   "[.b, .w, .l] address value")_u_boot_list_2_cmd_2_iow.u_boot_list_2_cmd_2_iowiod"IO space display""[.b, .w, .l] address"IO space display[.b, .w, .l] addressU_BOOT_CMD(iod, 2, 0, do_io_iod,
	   "IO space display", "[.b, .w, .l] address")_u_boot_list_2_cmd_2_iod.u_boot_list_2_cmd_2_iod/*
 * IO Display
 *
 * Syntax:
 *	iod{.b, .w, .l} {addr}
 *//*
 * Copyright (c) 2012 The Chromium OS Authors.
 *//opt/src/cmd/iotrace.cdo_iotracedo_set_regiondo_set_bufferdo_print_traceTimestamp  Value          Address
"Timestamp  Value          Address\n"iotrace_record *cur_record%08llu: 0x%08lx --> 0x%08llx
"%08llu: 0x%08lx --> 0x%08llx\n"%08llu: 0x%08lx <-- 0x%08llx
"%08llu: 0x%08lx <-- 0x%08llx\n"do_print_statsiotrace is %sabled
"iotrace is %sabled\n"en"en"dis"dis"Start:  %08lx
"Start:  %08lx\n"Actual Size:   %08lx
"Actual Size:   %08lx\n"Needed Size:   %08lx
"Needed Size:   %08lx\n"Region: %08lx
"Region: %08lx\n"Size:   %08lx
"Size:   %08lx\n"Offset: %08lx
"Offset: %08lx\n"Output: %08lx
"Output: %08lx\n"Count:  %08lx
"Count:  %08lx\n"CRC32:  %08lx
"CRC32:  %08lx\n""iotrace utility commands""stats                        - display iotrace stats\n" "iotrace buffer <address> <size>      - set iotrace buffer\n" "iotrace limit <address> <size>       - set iotrace region limit\n" "iotrace pause                        - pause tracing\n" "iotrace resume                       - resume tracing\n" "iotrace dump                         - dump iotrace buffer"iotrace utility commandsstats                        - display iotrace stats
iotrace buffer <address> <size>      - set iotrace buffer
iotrace limit <address> <size>       - set iotrace region limit
iotrace pause                        - pause tracing
iotrace resume                       - resume tracing
iotrace dump                         - dump iotrace buffer"stats                        - display iotrace stats\n"
	"iotrace buffer <address> <size>      - set iotrace buffer\n"
	"iotrace limit <address> <size>       - set iotrace region limit\n"
	"iotrace pause                        - pause tracing\n"
	"iotrace resume                       - resume tracing\n"
	"iotrace dump                         - dump iotrace buffer"char[341]U_BOOT_CMD(
	iotrace,	4,	1,	do_iotrace,
	"iotrace utility commands",
	"stats                        - display iotrace stats\n"
	"iotrace buffer <address> <size>      - set iotrace buffer\n"
	"iotrace limit <address> <size>       - set iotrace region limit\n"
	"iotrace pause                        - pause tracing\n"
	"iotrace resume                       - resume tracing\n"
	"iotrace dump                         - dump iotrace buffer"
)_u_boot_list_2_cmd_2_iotrace.u_boot_list_2_cmd_2_iotrace/*
 * Copyright (c) 2014 Google, Inc
 *//opt/src/cmd/itest.citestdo_itestInvalid data width specifier
"Invalid data width specifier\n"binary_testconst op_tbl_tconst op_tbl_t[13]op_tbl_s[13]op_tableARRAY_SIZE(op_table)const op_tbl_t *op_tbl_s *optpconst op_tbl_t(*)[13]op_tbl_s(*)[13]op_tbl_t *Unknown operator '%s'
"Unknown operator '%s'\n"arithcompEQNELTGTLEGEstringcompevalstr'*''$' 2'{'evalexpFailed to map physical memory
"Failed to map physical memory\n"arg1arg2op_tbl_top_tbl_s"return true/false on integer compare""[.b, .w, .l, .s] [*]value1 <op> [*]value2"return true/false on integer compare[.b, .w, .l, .s] [*]value1 <op> [*]value2U_BOOT_CMD(
	itest, 4, 0, do_itest,
	"return true/false on integer compare",
	"[.b, .w, .l, .s] [*]value1 <op> [*]value2"
)_u_boot_list_2_cmd_2_itest.u_boot_list_2_cmd_2_itestconst op_tbl_t[]op_tbl_s[]-lt"-lt"-gt"-gt"-eq"-eq"=="=="-ne"-ne"!="!="<>"<>"-ge"-ge">=">="-le"-le"<="<="/* Check for a data width specification.
	 * Defaults to long (4) if no specification.
	 * Uses -2 as 'width' for .s (string) so as not to upset existing code
	 *//* Validate arguments *//* command line interface to the shell test *//* op code not found *//* if the parameter starts with a * then assume a string pointer else its a literal *//* avoid overflow on mask calculus *//* if the parameter starts with a * then assume is a pointer to the value we want *//* internal representation of opcode *//* operator string *//*
 * This file provides a shell like 'test' function to return
 * true/false from an integer or string compare of two memory
 * locations or a location and a scalar/literal.
 * A few parts were lifted from bash 'test' command
 *//*
 * (C) Copyright 2003
 * Tait Electronics Limited, Christchurch, New Zealand
 *//opt/src/cmd/led.cdo_ledled_label"list"freq_msLED '%s' not found (err=%d)
"LED '%s' not found (err=%d)\n"LED '%s': "LED '%s': "LED '%s' operation failed (err=%d)
"LED '%s' operation failed (err=%d)\n"list_ledsled_uc_plat *%-15s "%-15s "<inactive>
"<inactive>\n"UCLASS_LEDshow_led_stateget_led_cmd"manage LEDs""<led_label> on|off|toggle" BLINK "\tChange LED state\n" "led <led_label>\tGet LED state\n" "led list\t\tshow a list of LEDs""<led_label> on|off|toggle" "|blink [blink-freq in ms]" "\tChange LED state\n" "led <led_label>\tGet LED state\n" "led list\t\tshow a list of LEDs"manage LEDs<led_label> on|off|toggle|blink [blink-freq in ms]	Change LED state
led <led_label>	Get LED state
led list		show a list of LEDs"<led_label> on|off|toggle" BLINK "\tChange LED state\n"
	"led <led_label>\tGet LED state\n"
	"led list\t\tshow a list of LEDs"char[128]U_BOOT_CMD(
	led, 4, 1, do_led,
	"manage LEDs",
	"<led_label> on|off|toggle" BLINK "\tChange LED state\n"
	"led <led_label>\tGet LED state\n"
	"led list\t\tshow a list of LEDs"
)_u_boot_list_2_cmd_2_led.u_boot_list_2_cmd_2_led"toggle"blink"blink"state_labelBLINK"|blink [blink-freq in ms]"LED_TOGGLE/opt/src/cmd/license_data_gz.hlicense_data_gz     \[s~_1KU4wdW$b"SZPDx+[$0/#k|?Op2OWkK|qO~~1e]?+{[:gzKJgo:_&-|g<4z6]Uk{EW??+wQzu&*UaDM]*y]9KiL7XjMofe7.yX'KyQ$7S?K6]aK\o[.,6y:E'^0yU&h/]d^OGgHKN	[mL{zd:}Ma8FokO
'Ro@Zf$laVu9&wwJ-2uj]!'MED8}v(H}	whO,}e$W=	(X]n[|3A[i*lKP^,Ru*#'1N`IMWX~}k,\Er$*^$W*jGu=K4.J,	Caoy,gxrJ,g.ey4pY`uY	C7TJmf&tv!YRWV	<*U7DcN@S,YqK_6zI`9j`u~R>1rSxIUH;RZ*'\`,t/V3c5}k"u~M*Al2PUEa_iih`S\HU:\'4/d&Qz[T{!3(9Bk5(bc'A.{`UH1(*ak(5Bi^%ub	b:1L|n>82/`?&
sg[X\(yXH<z	1A},BvbrD)DkGm]qu	$UkBi/eE!Oq+Y;V EWPF2DN"kA-Hdn.8eo
CJ]_&$K`\@b~B-E5U)Z?@-X.N(^kP}Ux}KS;h6zO~||?h:?ft;lcQ1y+o&I$6KTy!Z"Ov}7FIY	F cQ;#x= !cDtPN2Oy8
z|uGg1iMu%#Q$'%	3jew&+l@~ ox3!	d,3
$g
+P)#%PhE;T.2D+S8$p+SC=o9U	&~DW!d}jZqxf8,;G(vlde<v	A9p>$?1xcl!
	522>}&aNKlam)Zz="Kq0~sn(3`rJ'sr,m#6WPAu|tdIW@\4=d]<Gz-r7INWI4[08s"0[fj=^QNUW1lDAr#t=1duP2}0^j8'J".
?KN.`^@Lx3Ux6NY!x%R/U<yJM0Y61G-K\X3hy	u8TcbG$K.}FbkLe
_8a}9LKpRU %%J(I*RE@hAFiT.)%u)|	PB>yQwAP0E/9 .%3P+:.W#/F{J-`;!.[cK qHo4A/%8
9DR1bP>QWNLM
(@'ZAj:i=KCAGV.Q x;2>6
6Wd!6A, [h5-e,(5%#}$~okyO6Wm<o$bc
oj5Bo'dZp[O0@B@n0fBJ#'r$b^oR( J_5R(2NH$w%:X)
s~s&u"3$4)	G92T:=8\
j# W-dG;@?'jW()ROoepu5Yr>R?> %!P'- k>0-SgjSR iZ!m22Y RSF5 A	5UxZ$eJ_"Q[0D0vI,5dIcO{5RYxw'MU0>b)W %\z{?WAXx+s<
q?&2X4SD)+S, 	{=GDY-3E1K9(<%emPE@}1}64iY9}E.fu*RZE(41UnbF-1RkL_v7lz3tIT)mJsbx_,P#Hn]ft+elKL,KbNyG:Xwp\8tQTzLv]2h	.ZK$f!ftz.'H]&_	RrVA71vDZ[f+=Q:s{Wh!Z+ tnLNZFYJ6e5/m}Q3xI4,uSKs):E`?-dIH5q	]kZ:PByo[q9}HyTDyb[8o-&QAn%5@A$;-#d?VX13B  ZTlZqa!-A0@ yVu&%KJYt.5j/)JOk_A|$$e%<P%oM#_:[
;qJZ^<YbzFkdDKW_F1z|BqCc^SKJ7N3g@5fBOY1n%1Ul}0M)uU]r3{)X[Rg\S}: kb\}$VD-rj-PJ7s%du6} J]/_'%JNl"J(si<oR=5kEDZX 9QJ"q/BI@bFzl[F@62}Px=
=xH|32S'"i_PyQXz}7m=G{F!y<a{:p864E	R[;vy 2&]	-x"hk`YRXX`ZOE2sp^P*wNLv:T9!%VSb!|pQE\@ZrabA^^<mZ.g-ndwLdRB&QK`GJn$Z3$Vve~RZfT'ui/p-[nN4"
COjpRWm~`^S^5)TDBV3o Y
z1/ 4%w 1w@[4%DE.nZQX.Zof/S,rLy5 N5:#%ROi	u	1ljb58]PY7*0wJ*:RNyD9-*47?m8KA"8EN|,z\J:@~qx|y5iQz2TW;3P&`ZFnt/ #I)CyQ{b;*<sr&
{Mu+"x\Feb8]  @,Mqx%hPd[}C.OB[T,c/FE3K)MRDdlATk:4bx"7sW!5Zsg43nLia^qm<*vt@TQVAQaZdf0?85.g4jdOxNo<{=L-b@m"	M72vsN%_(6Fg|Y/EuAeok Q@#+IqH`44?vsj`&xJoqi2lG0'{co'}waMx"^S<l8h6\+x~:"z^h61;}wE8F!:n:L3u4{x5ph|/4d8Z{(_
NFt5:C	o<\G%foG1m~@x<>L1|2FYKk|YP{qB	 57lKO6Ct5;<pet>q0"cjz2*cq8iti|N>yh|"m3##~_/Z?=g~V 2YVR9z E!p3:^IH_ E@'=Tk#]{a
eMfWC<=_lN	Dm4fy4	|@hb!d]klzc[Ng;VlHWCzlpe#Hy+(Oy;:-}dS8kJ}<&TUKY(,F2+Cj*I53GjHE4<2!N4<C1\J3bf{ :2dMx obsT.d!!W|xII,k5\ gn8#kynNxb4'B$  1Io'"#TF,=$ee	$2s/VN0K 0:E5ses!#e}2olfN#FM3^;K}qwl5_[cR>tFfET	e>!1"3,~&=u't"cQ_$d^|Eg{CMt/?o7O&Nr&P[Yt&EH4ig32\?IoOIsL94 _~Y4vztp5}'DrK
U[H^[mp29^Ao\5]-ee"#~X;cUeNy[05iG5tJzs9K';)hW@6.an/t_wM<#RpYZ7r4~&=\u^9kL^.y<{qmFax.vr;tnwF2FNX7;4x-`ou2f5.Y|s%;	vdiEK~ VBpiVO e]m~OA+cW[eKz0F8%ZqR(!C`Q7+F&q
oa4_l?91FNF  char[6825]/opt/src/cmd/license_data_size.hlicense_data_size18092/opt/src/cmd/license.clicensedo_license18093const char[6825]Error uncompressing license text
"Error uncompressing license text\n""print GPL license text"print GPL license textU_BOOT_CMD(
	license, 1, 1, do_license,
	"print GPL license text",
	""
)_u_boot_list_2_cmd_2_license.u_boot_list_2_cmd_2_license/*
 * (C) Copyright 2007 by OpenMoko, Inc.
 * Author: Harald Welte <laforge@openmoko.org>
 */"license_data_size.h""license_data_gz.h"_exportsvoid *, int, size_tmdelayunsigned long msecchar *dest, const char *srcustrtoullconst char *, char **, unsigned intustrtoulspi_slave *spi_xferstruct spi_slave *, unsigned int, const void *, void *, unsigned longspi_release_busstruct spi_slave *spi_claim_busspi_free_slavespi_setup_slavei2c_readi2c_writeconst char *cs, const char *ctsimple_strtolstrict_strtoulconst char *, unsigned int , unsigned long *simple_strtoulconst char *, const char *const char*cmd_tbl_t *, int , int , char * const []const char *, va_listget_timerudelayfree_hdlrinstall_hdlrconst char*, ...get_versionEXPORT_FUNC(defined(CONFIG_X86) && !defined(CONFIG_X86_64)) || defined(CONFIG_PPC)!CONFIG_IS_ENABLED(SYS_MALLOC_SIMPLE)defined(CONFIG_CMD_I2C) && !defined(CONFIG_DM_I2C)!defined(CONFIG_CMD_SPI) || defined(CONFIG_DM_SPI)CONFIG_CMD_SPICONFIG_PHY_AQUANTIA/*
 * You need to use #ifdef around functions that may not exist
 * in the final configuration (such as i2c).
 * use a dummyfunction as first parameter to EXPORT_FUNC.
 * As an example see the CONFIG_CMD_I2C section below
 */exportsapp_startupspi_slaveXF_VERSIONEXPORT_FUNC(impl,res,func,__VA_ARGS__...)res(*func)(__VA_ARGS__);__EXPORTS_H__/* __EXPORTS_H__ *//* ifndef __ASSEMBLY__ *//* These are declarations of exported functions available in C code */<_exports.h>csct/opt/src/include/xyzModem.hxyzModemxyzModem_errorxyzModem_stream_readxyzModem_stream_terminatexyzModem_stream_closexyzModem_stream_openconnection_info_t *connection_info_tchanCYGACC_CALL_IF_DELAY_US(x)udelay(x)diag_vsprintfdiag_printfdiag_vprintfCYGACC_CALL_IF_SET_CONSOLE_COMM(x)CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENTxyzModem_abortxyzModem_closexyzModem_sequencexyzModem_cksumxyzModem_frame-6xyzModem_cancelxyzModem_eofxyzModem_timeoutxyzModem_noZmodemxyzModem_accessxyzModem_ymodemxyzModem_xmodem_XYZMODEM_H_/* _XYZMODEM_H_ *//*#define xyzModem_zmodem 3 *//* Don't define this until the protocol support is in place *//*
 *==========================================================================
 *
 *      xyzModem.h
 *
 *      RedBoot stream handler for xyzModem protocol
 *
 *==========================================================================
 *#####DESCRIPTIONBEGIN####
 *
 * Author(s):    gthomas
 * Contributors: gthomas
 * Date:         2000-07-14
 * Purpose:
 * Description:
 *
 * This code is part of RedBoot (tm).
 *
 *####DESCRIPTIONEND####
 *
 *==========================================================================
 *//* SPDX-License-Identifier: eCos-2.0 *//opt/src/cmd/load.cload_serial_ymodemymodemBufstore_addr~0## Total Size      = 0x%08x = %d Bytes
"## Total Size      = 0x%08x = %d Bytes\n"getcxmodemk_recvEND_CHARK_ESCAPEk_statek_state_savedlast_nSEND_DATA_SIZESTART_CHARETX_CHARnew_charuntochar(new_char)len_hilen_lo(sum + ((sum >> 6) & 0x03)) & 0x3f<xyzModem.h>STARTtochar((sum + ((sum >> 6) & 0x03)) & 0x3f)DATA_TYPESEND_TYPEBREAK_TYPEhandle_send_packetSEND_DATA_SIZE - 1 3tochar(94)tochar(1)send_parms[2]untochar(send_parms[2])tochar(0)send_parms[4]untochar(send_parms[4])tochar(END_CHAR)'N''1'tochar(2)tochar(length)tochar(n)ACK_TYPEchk1(&a_b[1])tochar(chk1(&a_b[1]))k_data_charpacket_errork_data_restorek_data_savek_data_initset_kerm_bin_modebin_data_charos_data_restoreos_data_savebin_data_initsend_nacktochar(3)NACK_TYPEsend_acks1_sendpacketchk1ktrans-65~0x40send_padload_serial_bindo_load_serial_binloadaddr"loadaddr"load_baudratecurrent_baudrate## Switch baudrate to %d bps and press ENTER ...
"## Switch baudrate to %d bps and press ENTER ...\n"50000'\r'loady"loady"## Ready for binary (ymodem) download to 0x%08lX at %d bps...
"## Ready for binary (ymodem) download "
			"to 0x%08lX at %d bps...\n"char[63]loadx"loadx"## Ready for binary (xmodem) download to 0x%08lX at %d bps...
"## Ready for binary (xmodem) download "
			"to 0x%08lX at %d bps...\n"## Ready for binary (kermit) download to 0x%08lX at %d bps...
"## Ready for binary (kermit) download "
			"to 0x%08lX at %d bps...\n"## Binary (kermit) download aborted
"## Binary (kermit) download aborted\n"## Start Addr      = 0x%08lX
"## Start Addr      = 0x%08lX\n"## Switch baudrate to %d bps and press ESC ...
"## Switch baudrate to %d bps and press ESC ...\n"read_recordload_serialchar[517]516517SREC_MAXRECLEN + 1recordbinlenchar[255]binbufstart_addrend_addr10000
## First Load Addr = 0x%08lX
## Last  Load Addr = 0x%08lX
## Total Size      = 0x%08lX = %ld Bytes
"\n"
			    "## First Load Addr = 0x%08lX\n"
			    "## Last  Load Addr = 0x%08lX\n"
			    "## Total Size      = 0x%08lX = %ld Bytes\n"char[101]line_count  0do_load_serialenv_echoloads_echo"loads_echo"## Ready for S-Record download ...
"## Ready for S-Record download ...\n"## S-Record download aborted
"## S-Record download aborted\n""load binary file over serial line (ymodem mode)""[ off ] [ baud ]\n" "    - load binary file over serial line" " with offset 'off' and baudrate 'baud'"load binary file over serial line (ymodem mode)[ off ] [ baud ]
    - load binary file over serial line with offset 'off' and baudrate 'baud'"[ off ] [ baud ]\n"
	"    - load binary file over serial line"
	" with offset 'off' and baudrate 'baud'"U_BOOT_CMD(
	loady, 3, 0,	do_load_serial_bin,
	"load binary file over serial line (ymodem mode)",
	"[ off ] [ baud ]\n"
	"    - load binary file over serial line"
	" with offset 'off' and baudrate 'baud'"
)_u_boot_list_2_cmd_2_loady.u_boot_list_2_cmd_2_loady"load binary file over serial line (xmodem mode)"load binary file over serial line (xmodem mode)U_BOOT_CMD(
	loadx, 3, 0,	do_load_serial_bin,
	"load binary file over serial line (xmodem mode)",
	"[ off ] [ baud ]\n"
	"    - load binary file over serial line"
	" with offset 'off' and baudrate 'baud'"
)_u_boot_list_2_cmd_2_loadx.u_boot_list_2_cmd_2_loadxloadb"load binary file over serial line (kermit mode)"load binary file over serial line (kermit mode)U_BOOT_CMD(
	loadb, 3, 0,	do_load_serial_bin,
	"load binary file over serial line (kermit mode)",
	"[ off ] [ baud ]\n"
	"    - load binary file over serial line"
	" with offset 'off' and baudrate 'baud'"
)_u_boot_list_2_cmd_2_loadb.u_boot_list_2_cmd_2_loadbloads"load S-Record file over serial line""[ off ]\n" "    - load S-Record file over serial line with offset 'off'"load S-Record file over serial line[ off ]
    - load S-Record file over serial line with offset 'off'"[ off ]\n"
	"    - load S-Record file over serial line with offset 'off'"U_BOOT_CMD(
	loads, 2, 0,	do_load_serial,
	"load S-Record file over serial line",
	"[ off ]\n"
	"    - load S-Record file over serial line with offset 'off'"
)_u_boot_list_2_cmd_2_loads.u_boot_list_2_cmd_2_loadssend_ptrsend_parmsk_data_escape_savedk_data_escapebin_start_addressos_data_addr_savedos_data_addros_data_state_savedos_data_stateos_data_charos_data_inita_bhis_quotehis_pad_charhis_pad_counthis_eoluntochar(x)((int) (((x) - SPACE) & 0xff))tochar(x)((char) (((x) + SPACE) & 0xff))'Y'SPACEXOFF_CHARXON_CHARdefined(CONFIG_CMD_LOADB)defined(CONFIG_CMD_LOADS)defined(CONFIG_CMD_SAVES)CONFIG_SYS_LOADS_BAUD_CHANGE/* CONFIG_CMD_LOADB *//* CONFIG_CMD_LOADS *//* CONFIG_CMD_SAVES *//* CONFIG_SYS_LOADS_BAUD_CHANGE *//* ! CONFIG_SYS_LOADS_BAUD_CHANGE *//*
 * SAVES always requires LOADS support, but not vice versa
 *//* quit if end of transmission *//* send simple acknowledge packet in *//* crack the protocol parms, build an appropriate ack packet *//* send a negative acknowledge packet in *//* restore state machines *//* get END_CHAR *//* get and validate checksum character *//* if too much data, back off the pointer *//* save send pack in buffer as is *//* pass on the data if this is a data packet *//* bring in rest of packet *//* new length includes only data and block check to come *//* --length; *//* check header checksum *//* get the two length bytes *//* (length byte was 0, decremented twice) *//* check for extended length *//* get packet type *//* END NEW CODE *//* new sequence number, checkpoint the download *//* same sequence number, restore the previous state *//* Note - this new code assumes that the sequence number is correctly
		 * received.  Handling an invalid sequence number adds another layer
		 * of complexity that may not be needed - yet!  At this time, I'm hoping
		 * that I don't need to buffer the incoming data packets and can write
		 * the data into memory in real time.
		 *//* NEW CODE - check sequence numbers for retried packets *//* get sequence number *//* get length of packet *//* ^C waiting for packet *//* start packet *//* wait for the starting character or ^C *//* get a packet *//* first have all state machines save current states *//* OLD CODE, Prior to checking sequence numbers *//* With each packet, start summing the bytes starting with the length.
		   Save the current sequence number.
		   Note the type of the packet.
		   If a character less than SPACE (0x20) is received - error.
		 *//* set the send packet pointer to begining of send packet parms *//* enter main loop *//* expect this "type" sequence (but don't check):
	   S: send initiate
	   F: file header
	   D: data (multiple)
	   Z: end of file
	   B: break transmission
	 *//* just to get rid of a warning *//* initialize the k_recv and k_data state machine *//* default end of line character *//* initialize some protocol parameters *//* k_recv receives a OS Open image file over kermit line *//* large packet lsb *//* large packet msb *//* no windows *//* only long packets *//* ignore what he says - I only do long packets - I don't do windows *//* handle CAPAS - the capabilities mask *//* ignore what he says - I refuse (for now) *//* handle REPT - the repeat prefix *//* ignore what he says - I do type 1 (for now) *//* handle CHKT - the clock check type *//* ignore what he says - I refuse *//* handle QBIN - 8-th bit prefixing *//* remember what he says - I'll use '#' *//* handle QCTL - quote control char he'll use *//* remember what he says - I need CR *//* handle EOL - end of line he needs *//* He should ignore this *//* remember what he says - I need none *//* handle PADC - pad chars I need *//* handle NPAD - number of pad chars I need *//* ignore what he says - don't wait for my ack longer than 1 second *//* handle TIME - time you should wait for my packets *//* ignore what he says - most I'll take (here) is 94 *//* handle MAXL - max length *//* how many bytes we'll process *//* ignore last character if it filled the buffer *//* handle_send_packet interprits the protocol info and builds and
   sends an appropriate ack for what we can do *//* otherwise send this char as-is *//* this char is escape - remember *//* last char was escape - translate this character *//* k_data_* simply handles the kermit escape translations *//* data *//* converts escaped kermit char to binary char *//*
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 *//* ESC *//* default to current baudrate *//* pre-set offset from $loadaddr *//* pre-set offset from CONFIG_SYS_LOAD_ADDR *//* quote chars he'll use *//* pad chars he needs *//* number of pad chars he needs *//* character he needs at end of packet *//*
 * loadb command (load binary) included
 *//* Check for the console hangup (if any different from serial) *//* write the final record *//* increment address *//* output one record: *//* make proper checksum byte: *//* accumulate address bytes into checksum: *//* accumulate length bytes into checksum *//* address + data + checksum *//* build & write a data record: *//* enough data collected for one record: dump it *//* accumulate checksum *//* get one byte    *//* collect hex data in the buffer  *//* write the header *//* buffer for hex data	*//* buffer for one S-Record	*//* line too long - truncate *//* ^C - Control C		*//* ... and echo it		*//* read character		*//* always leave room for terminating '\0' byte *//* Download aborted		*//* print a '.' every 100 lines *//* Invalid S-Record		*//* number of bytes transferred	*//* load address from S-Record	*//* return code for record type	*//* no. of data bytes in S-Rec.	*//* buffer for binary data	*//*
 * Serial up- and download support
 *//opt/src/cmd/log.clogdo_loglog_subARRAY_SIZE(log_sub)do_log_reccatLOGL_NONEInvalid log level '%s'
"Invalid log level '%s'\n"LOGL_MAXInvalid log level %u
"Invalid log level %u\n"do_log_format"default"LOGF_DEFAULTLOGF_ALLLOGF_COUNTInvalid log char '%c'
"Invalid log char '%c'\n"Log format: "Log format: "do_log_levelDefault log level: %d
"Default log level: %d\n""log system"log_help_textU_BOOT_CMD(
	log, CONFIG_SYS_MAXARGS, 1, do_log,
	"log system", log_help_text
)log systemchar[371]_u_boot_list_2_cmd_2_log.u_boot_list_2_cmd_2_loglevel - get/set log level
log test - run log tests
log format <fmt> - set log output format. <fmt> is a string where
	each letter indicates something that should be displayed:
	c=category, l=level, F=file, L=line number, f=function, m=msg
	or 'default', equivalent to 'fm', or 'all' for all
log rec <category> <level> <file> <line> <func> <message> - output a log recorddo_log_testrecU_BOOT_CMD_MKENT(level, CONFIG_SYS_MAXARGS, 1, do_log_level, "", "")U_BOOT_CMD_MKENT(test, 2, 1, do_log_test, "", "")U_BOOT_CMD_MKENT(format, CONFIG_SYS_MAXARGS, 1, do_log_format, "", "")U_BOOT_CMD_MKENT(rec, CONFIG_SYS_MAXARGS, 1, do_log_rec, "", "")clFLflog_fmt_charsCONFIG_LOG_TEST/* drop initial "log" arg *//opt/src/lib/lzma/Types.hTypesSecToRead_CreateVTableCSecToRead *SecToLook_CreateVTableCSecToLook *LookToRead_InitCLookToRead *LookToRead_CreateVTableLookInStream_ReadILookInStream *LookInStream_Read2LookInStream_SeekToLookInStream_LookReadSeqInStream_ReadByteISeqInStream *LZByte *SeqInStream_Read2SeqInStream_ReadISzAllocICompressProgressCSecToReadCSecToLookCLookToReadILookInStreamISeekInStreamESzSeekSZ_SEEK_SETSZ_SEEK_CURSZ_SEEK_ENDISeqOutStreamISeqInStreamIByteOutIByteInBoolSizeTUInt64Int64UInt32Int32UInt16Int16LZByteWResSResFreeAllocProgressrealStreamLZByte[16384]unsigned char[16384]LookToRead_BUF_SIZEISeekInStream *Int64 *SeekReadSkipconst void **LookWriteWSTRING_PATH_SEPARATORL"/"STRING_PATH_SEPARATORWCHAR_PATH_SEPARATORL'/'CHAR_PATH_SEPARATORIAlloc_Free(p,a)(p)->Free((p), a)IAlloc_Alloc(p,size)(p)->Alloc((p), size)MY_FAST_CALLMY_CDECLFalseTrueUINT64_CONST(n)n ## ULLRINOK(x){ int __result__ = (x); if (__result__ != 0) return __result__; }SZ_ERROR_NO_ARCHIVESZ_ERROR_ARCHIVESZ_ERROR_THREADSZ_ERROR_FAILSZ_ERROR_PROGRESSSZ_ERROR_WRITESZ_ERROR_READSZ_ERROR_OUTPUT_EOFSZ_ERROR_INPUT_EOFSZ_ERROR_PARAMSZ_ERROR_UNSUPPORTEDSZ_ERROR_CRCSZ_ERROR_MEMSZ_ERROR_DATASZ_OK__7Z_TYPES_HRINOK_LZMA_UINT32_IS_ULONG_SZ_NO_INT_64defined(_MSC_VER) || defined(__BORLANDC__)_LZMA_NO_SYSTEM_SIZE_T_MSC_VER >= 1300/* address can be 0 *//* Returns: result. (result != SZ_OK) means break.
       Value (UInt64)(Int64)-1 for size means unknown value. *//* reads via ILookInStream::Read *//* reads directly (without buffer). It's same as ISeqInStream::Read *//* offset must be <= output(*size) of Look *//* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
       (output(*size) > input(*size)) is not allowed
       (output(*size) < input(*size)) is allowed *//* same as ISeqInStream::Read *//* Returns: result - the number of actually written bytes.
       (result < size) means error *//* it can return SZ_ERROR_INPUT_EOF *//* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
       (output(*size) < input(*size)) is allowed *//* reads one byte, returns 0 in case of EOF or error *//* The following interfaces use first parameter as pointer to structure *//* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
   NOTES: Some code will work incorrectly in that case! *//* Types.h -- Basic types
2010-10-09 : Igor Pavlov : Public domain *//opt/src/lib/lzmalzmalookaheaderrorType/opt/src/include/lzma/LzmaTypes.hLzmaTypes__TYPES_H__FAKE__/*
 *This avoids the collition with zlib.h Byte definition
 *//*
 * Fake include for Types.h
 *
 * Copyright (C) 2007-2009 Industrie Dial Face S.p.A.
 * Luigi 'Comio' Mantellini (luigi.mantellini@idf-hit.com)
 *//opt/src/include/lzma"../../lib/lzma/Types.h"/opt/src/lib/lzma/LzmaTools.hLzmaToolslzmaBuffToBuffDecompressSizeT *__LZMA_TOOL_H__/*
 * Usefuls routines based on the LzmaTest.c file from LZMA SDK 4.65
 *
 * Copyright (C) 2007-2008 Industrie Dial Face S.p.A.
 * Luigi 'Comio' Mantellini (luigi.mantellini@idf-hit.com)
 *
 * Copyright (C) 1999-2005 Igor Pavlov
 */<lzma/LzmaTypes.h>outStreamuncompressedSizeinStream/opt/src/include/lzma/LzmaTools.h__LZMATOOLS_H__FAKE__/*
 * Fake include for LzmaTools.h
 *
 * Copyright (C) 2007-2009 Industrie Dial Face S.p.A.
 * Luigi 'Comio' Mantellini (luigi.mantellini@idf-hit.com)
 */"../../lib/lzma/LzmaTools.h"/opt/src/cmd/lzmadec.clzmadecdo_lzmadecdst_len~0ULsrc_lenUncompressed size: %ld = %#lX
"Uncompressed size: %ld = %#lX\n""lzma uncompress a memory region""srcaddr dstaddr [dstsize]"lzma uncompress a memory regionsrcaddr dstaddr [dstsize]U_BOOT_CMD(
	lzmadec,    4,    1,    do_lzmadec,
	"lzma uncompress a memory region",
	"srcaddr dstaddr [dstsize]"
)_u_boot_list_2_cmd_2_lzmadec.u_boot_list_2_cmd_2_lzmadec/* fall through *//*
 * (C) Copyright 2013 Patrice Bouchand <pbfwdlist_gmail_com>
 * lzma uncompress command in Uboot
 *
 * made from existing cmd_unzip.c file of Uboot
 *
 * (C) Copyright 2000
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 */<lzma/LzmaTools.h>/opt/src/include/u-boot/md5.hmd5md5_wdMD5Context__u32[4]__u32[16]in32_MD5_H/* _MD5_H *//*
 * Calculate and store in 'output' the MD5 digest of 'len' bytes at 'input'.
 * 'output' must have enough space to hold 16 bytes. If 'chunk' Trigger the
 * watchdog every 'chunk_sz' bytes of input processed.
 *//*
 * Calculate and store in 'output' the MD5 digest of 'len' bytes at
 * 'input'. 'output' must have enough space to hold 16 bytes.
 *//*
 * This file was transplanted with slight modifications from Linux sources
 * (fs/cifs/md5.h) into U-Boot by Bartlomiej Sieka <tur@semihalf.com>.
 */chunk_sz/opt/src/cmd/md5sum.cmd5sumdo_md5sumCHUNKSZ_MD5md5 for %08lx ... %08lx ==> "md5 for %08lx ... %08lx ==> "store_resultstr_outputstr_ptr"compute MD5 message digest""address count [[*]sum]\n" "    - compute MD5 message digest [save to sum]"compute MD5 message digestaddress count [[*]sum]
    - compute MD5 message digest [save to sum]"address count [[*]sum]\n"
		"    - compute MD5 message digest [save to sum]"U_BOOT_CMD(
	md5sum,	4,	1,	do_md5sum,
	"compute MD5 message digest",
	"address count [[*]sum]\n"
		"    - compute MD5 message digest [save to sum]"
)_u_boot_list_2_cmd_2_md5sum.u_boot_list_2_cmd_2_md5sumCONFIG_MD5SUM_VERIFY/*
 * Store the resulting sum to an address or variable
 *//*
 * (C) Copyright 2011
 * Joe Hershberger, National Instruments, joe.hershberger@ni.com
 *
 * (C) Copyright 2000
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 */<u-boot/md5.h>/opt/src/cmd/mdio.cmdiodo_mdioaddrloaddrhidevadlodevadhiregloreghimii_dev *'x'phy_device *phydevextendedphy_driver *PHY does not have extended functions
"PHY does not have extended functions\n"mii_dev **phy_device **No MDIO bus found
"No MDIO bus found\n"extract_phy_rangeextract_reg_rangeregstr/opt/src/include/miiphy.h/opt/src/include/linux/mii.h/opt/src/include/phy.h/opt/src/include/linux/ethtool.h/opt/src/include/linux/mdio.h/opt/src/include/phy_interface.h<phy.h><miiphy.h>devadstrMDIO_DEVAD_NONEmdio_read_rangesReading from bus %s
"Reading from bus %s\n"phy_device *[32]PHY at address %x:
"PHY at address %x:\n"devadError
"Error\n"%d."%d."%d - 0x%x
"%d - 0x%x\n"mdio_write_rangesextract_range"MDIO utility commands""list			- List MDIO buses\n" "mdio read <phydev> [<devad>.]<reg> - " "read PHY's register at <devad>.<reg>\n" "mdio write <phydev> [<devad>.]<reg> <data> - " "write PHY's register at <devad>.<reg>\n" "mdio rx <phydev> [<devad>.]<reg> - " "read PHY's extended register at <devad>.<reg>\n" "mdio wx <phydev> [<devad>.]<reg> <data> - " "write PHY's extended register at <devad>.<reg>\n" "<phydev> may be:\n" "   <busname>  <addr>\n" "   <addr>\n" "   <eth name>\n" "<addr> <devad>, and <reg> may be ranges, e.g. 1-5.4-0x1f.\n"MDIO utility commandslist			- List MDIO buses
mdio read <phydev> [<devad>.]<reg> - read PHY's register at <devad>.<reg>
mdio write <phydev> [<devad>.]<reg> <data> - write PHY's register at <devad>.<reg>
mdio rx <phydev> [<devad>.]<reg> - read PHY's extended register at <devad>.<reg>
mdio wx <phydev> [<devad>.]<reg> <data> - write PHY's extended register at <devad>.<reg>
<phydev> may be:
   <busname>  <addr>
   <addr>
   <eth name>
<addr> <devad>, and <reg> may be ranges, e.g. 1-5.4-0x1f.
"list			- List MDIO buses\n"
	"mdio read <phydev> [<devad>.]<reg> - "
		"read PHY's register at <devad>.<reg>\n"
	"mdio write <phydev> [<devad>.]<reg> <data> - "
		"write PHY's register at <devad>.<reg>\n"
	"mdio rx <phydev> [<devad>.]<reg> - "
		"read PHY's extended register at <devad>.<reg>\n"
	"mdio wx <phydev> [<devad>.]<reg> <data> - "
		"write PHY's extended register at <devad>.<reg>\n"
	"<phydev> may be:\n"
	"   <busname>  <addr>\n"
	"   <addr>\n"
	"   <eth name>\n"
	"<addr> <devad>, and <reg> may be ranges, e.g. 1-5.4-0x1f.\n"char[473]U_BOOT_CMD(
	mdio,	6,	1,	do_mdio,
	"MDIO utility commands",
	"list			- List MDIO buses\n"
	"mdio read <phydev> [<devad>.]<reg> - "
		"read PHY's register at <devad>.<reg>\n"
	"mdio write <phydev> [<devad>.]<reg> <data> - "
		"write PHY's register at <devad>.<reg>\n"
	"mdio rx <phydev> [<devad>.]<reg> - "
		"read PHY's extended register at <devad>.<reg>\n"
	"mdio wx <phydev> [<devad>.]<reg> <data> - "
		"write PHY's extended register at <devad>.<reg>\n"
	"<phydev> may be:\n"
	"   <busname>  <addr>\n"
	"   <addr>\n"
	"   <eth name>\n"
	"<addr> <devad>, and <reg> may be ranges, e.g. 1-5.4-0x1f.\n"
)_u_boot_list_2_cmd_2_mdio.u_boot_list_2_cmd_2_mdiolast_reg_hilast_reg_lolast_devad_hilast_devad_lolast_addr_hilast_addr_lolast_datalast_opCONFIG_DM_MDIO/*
	 * Save the parameters for repeats.
	 *//* Save the chosen bus *//* probe DM MII device before any operation so they are all accesible *//* ---------------------------------------------------------------- *//* It's an address or nothing useful *//*
	 * This argument can be one of two things:
	 * 1) Ethernet device name
	 * 2) Just an address (use the previously-used bus)
	 *
	 * We check all buses for a PHY which is connected to an ethernet
	 * device by the given name.  If none are found, we call
	 * extract_range() on the string, and see if it's an address range.
	 *//* It must be one argument, here *//* If there are two arguments, it's busname addr *//* Otherwise, we have no devad, and we just got regs *//* If it exists, extract the devad(s) *//* use strrchr to find the last string after a '.' *//* The register will be in the form [a[-b].]x[-y] *//*
 * MDIO Commands
 *//*
 * (C) Copyright 2011 Freescale Semiconductor, Inc
 * Andy Fleming
 */err_outplophi/opt/src/cmd/mem.cdo_mem_infoDRAM:  "DRAM:  "do_randomusage: %s <addr> <len> [<seed>]
"usage: %s <addr> <len> [<seed>]\n"The seed cannot be 0. Using 0xDEADBEEF.
"The seed cannot be 0. Using 0xDEADBEEF.\n"37359285590xDEADBEEFbuf8%lu bytes filled with random data
"%lu bytes filled with random data\n"do_mem_crcavHASH_FLAG_VERIFY | HASH_FLAG_ENV"crc32"mod_mem %08x" %08x" %016llx" %016llx" %04x" %04x"do_mem_mtestCONFIG_SYS_MEMTEST_STARTCONFIG_SYS_MEMTEST_END1052672iteration_limitRefusing to do empty test
"Refusing to do empty test\n"Testing %08lx ... %08lx:
"Testing %08lx ... %08lx:\n""%s:%d: start %#08lx end %#08lx\n"__func__, __LINE__, start, enddebug("%s:%d: start %#08lx end %#08lx\n", __func__, __LINE__,
	      start, end)cmd/mem.c899%s:%d: start %#08lx end %#08lx
__Lvu_long *CONFIG_SYS_MEMTEST_SCRATCHsizeof(vu_long)errsIteration: %6d"Iteration: %6d\r"debug("\n")912alt_testvbufvdummyTested %d iteration(s) with %lu errors.
"Tested %d iteration(s) with %lu errors.\n"mem_test_quickincrsizeof(ulong)Pattern %08lX  Writing...%12s"\rPattern %08lX  Writing..."
		"%12s"
		"\b\b\b\b\b\b\b\b\b\b"Reading..."Reading..."readback
Mem error @ 0x%08X: found %08lX, expected %08lX
"\nMem error @ 0x%08X: "
				"found %08lX, expected %08lX\n"mem_test_altnum_wordsconst ulongconst ulong[]unsigned long[]bitpatternconst ulong[8]unsigned long[8]sizeof(bitpattern)const ulong *sizeof(bitpattern[0])sizeof(bitpattern) / sizeof(bitpattern[0])FAILURE (data line): expected %08lx, actual %08lx
"FAILURE (data line): "
					"expected %08lx, actual %08lx\n"FAILURE (data line): Is %08lx, should be %08lx
"FAILURE (data line): "
					"Is %08lx, should be %08lx\n"28633115300xaaaaaaaa(vu_long) 0xaaaaaaaaanti_pattern14316557650x55555555(vu_long) 0x55555555"%s:%d: length = 0x%.8lx\n"__func__, __LINE__, num_wordsdebug("%s:%d: length = 0x%.8lx\n", __func__, __LINE__, num_words)678%s:%d: length = 0x%.8lx
test_offset
FAILURE: Address bit stuck high @ 0x%.8lx: expected 0x%.8lx, actual 0x%.8lx
"\nFAILURE: Address bit stuck high @ 0x%.8lx:"
				" expected 0x%.8lx, actual 0x%.8lx\n"
FAILURE: Address bit stuck low or shorted @ 0x%.8lx: expected 0x%.8lx, actual 0x%.8lx
"\nFAILURE: Address bit stuck low or"
					" shorted @ 0x%.8lx: expected 0x%.8lx,"
					" actual 0x%.8lx\n"
FAILURE (read/write) @ 0x%.8lx: expected 0x%.8lx, actual 0x%.8lx)
"\nFAILURE (read/write) @ 0x%.8lx:"
				" expected 0x%.8lx, actual 0x%.8lx)\n"
FAILURE (read/write): @ 0x%.8lx: expected 0x%.8lx, actual 0x%.8lx)
"\nFAILURE (read/write): @ 0x%.8lx:"
				" expected 0x%.8lx, actual 0x%.8lx)\n"0x000000050x000000150x00000055do_mem_loopwvolatile u64volatile u64 *llplongpshortpvolatile u8volatile u8 *do_mem_loopdo_mem_baseBase Address: 0x%08lx
"Base Address: 0x%08lx\n"do_mem_cpZero length ???
"Zero length ???\n"do_mem_cmpdouble word"double word"word"word"halfword"halfword""byte"addr1addr2ngoodword1word2%s at 0x%p (%#0*llx) != %s at 0x%p (%#0*llx)
"%s at 0x%p (%#0*llx) != %s at 0x%p (%#0*llx)\n"64 << 10(64 << 10)Total of %ld %s(s) were the same
"Total of %ld %s(s) were the same\n"do_mem_mwdo_mem_nmdo_mem_mmdo_mem_md"fill memory with random pattern""<addr> <len> [<seed>]\n" "   - Fill 'len' bytes of memory starting at 'addr' with random data\n"fill memory with random pattern<addr> <len> [<seed>]
   - Fill 'len' bytes of memory starting at 'addr' with random data
"<addr> <len> [<seed>]\n"
	"   - Fill 'len' bytes of memory starting at 'addr' with random data\n"char[91]U_BOOT_CMD(
	random,	4,	0,	do_random,
	"fill memory with random pattern",
	"<addr> <len> [<seed>]\n"
	"   - Fill 'len' bytes of memory starting at 'addr' with random data\n"
)_u_boot_list_2_cmd_2_random.u_boot_list_2_cmd_2_randommeminfo"display memory information"display memory informationU_BOOT_CMD(
	meminfo,	3,	1,	do_mem_info,
	"display memory information",
	""
)_u_boot_list_2_cmd_2_meminfo.u_boot_list_2_cmd_2_meminfomtest"simple RAM read/write test""[start [end [pattern [iterations]]]]"simple RAM read/write test[start [end [pattern [iterations]]]]U_BOOT_CMD(
	mtest,	5,	1,	do_mem_mtest,
	"simple RAM read/write test",
	"[start [end [pattern [iterations]]]]"
)_u_boot_list_2_cmd_2_mtest.u_boot_list_2_cmd_2_mtestloopw"infinite write loop on address range""[.b, .w, .l, .q] address number_of_objects data_to_write"infinite write loop on address range[.b, .w, .l, .q] address number_of_objects data_to_writeU_BOOT_CMD(
	loopw,	4,	1,	do_mem_loopw,
	"infinite write loop on address range",
#ifdef CONFIG_SYS_SUPPORT_64BIT_DATA
	"[.b, .w, .l, .q] address number_of_objects data_to_write"
#else
	"[.b, .w, .l] address number_of_objects data_to_write"
#endif
)_u_boot_list_2_cmd_2_loopw.u_boot_list_2_cmd_2_loopw"infinite loop on address range""[.b, .w, .l, .q] address number_of_objects"infinite loop on address range[.b, .w, .l, .q] address number_of_objectsU_BOOT_CMD(
	loop,	3,	1,	do_mem_loop,
	"infinite loop on address range",
#ifdef CONFIG_SYS_SUPPORT_64BIT_DATA
	"[.b, .w, .l, .q] address number_of_objects"
#else
	"[.b, .w, .l] address number_of_objects"
#endif
)_u_boot_list_2_cmd_2_loop.u_boot_list_2_cmd_2_loop"print or set address offset""\n    - print address offset for memory commands\n" "base off\n    - set address offset for memory commands to 'off'"print or set address offset
    - print address offset for memory commands
base off
    - set address offset for memory commands to 'off'"\n    - print address offset for memory commands\n"
	"base off\n    - set address offset for memory commands to 'off'"U_BOOT_CMD(
	base,	2,	1,	do_mem_base,
	"print or set address offset",
	"\n    - print address offset for memory commands\n"
	"base off\n    - set address offset for memory commands to 'off'"
)_u_boot_list_2_cmd_2_base.u_boot_list_2_cmd_2_base"checksum calculation""address count [addr]\n    - compute CRC32 checksum [save at addr]\n" "-v address count crc\n    - verify crc of memory area"checksum calculationaddress count [addr]
    - compute CRC32 checksum [save at addr]
-v address count crc
    - verify crc of memory area"address count [addr]\n    - compute CRC32 checksum [save at addr]\n"
	"-v address count crc\n    - verify crc of memory area"U_BOOT_CMD(
	crc32,	5,	1,	do_mem_crc,
	"checksum calculation",
	"address count [addr]\n    - compute CRC32 checksum [save at addr]\n"
	"-v address count crc\n    - verify crc of memory area"
)_u_boot_list_2_cmd_2_crc32.u_boot_list_2_cmd_2_crc32cmp"memory compare""[.b, .w, .l, .q] addr1 addr2 count"memory compare[.b, .w, .l, .q] addr1 addr2 countU_BOOT_CMD(
	cmp,	4,	1,	do_mem_cmp,
	"memory compare",
#ifdef CONFIG_SYS_SUPPORT_64BIT_DATA
	"[.b, .w, .l, .q] addr1 addr2 count"
#else
	"[.b, .w, .l] addr1 addr2 count"
#endif
)_u_boot_list_2_cmd_2_cmp.u_boot_list_2_cmd_2_cmp"memory copy""[.b, .w, .l, .q] source target count"memory copy[.b, .w, .l, .q] source target countU_BOOT_CMD(
	cp,	4,	1,	do_mem_cp,
	"memory copy",
#ifdef CONFIG_SYS_SUPPORT_64BIT_DATA
	"[.b, .w, .l, .q] source target count"
#else
	"[.b, .w, .l] source target count"
#endif
)_u_boot_list_2_cmd_2_cp.u_boot_list_2_cmd_2_cp"memory write (fill)""[.b, .w, .l, .q] address value [count]"memory write (fill)[.b, .w, .l, .q] address value [count]U_BOOT_CMD(
	mw,	4,	1,	do_mem_mw,
	"memory write (fill)",
#ifdef CONFIG_SYS_SUPPORT_64BIT_DATA
	"[.b, .w, .l, .q] address value [count]"
#else
	"[.b, .w, .l] address value [count]"
#endif
)_u_boot_list_2_cmd_2_mw.u_boot_list_2_cmd_2_mw"memory modify (constant address)""[.b, .w, .l, .q] address"memory modify (constant address)[.b, .w, .l, .q] addressU_BOOT_CMD(
	nm,	2,	1,	do_mem_nm,
	"memory modify (constant address)",
#ifdef CONFIG_SYS_SUPPORT_64BIT_DATA
	"[.b, .w, .l, .q] address"
#else
	"[.b, .w, .l] address"
#endif
)_u_boot_list_2_cmd_2_nm.u_boot_list_2_cmd_2_nm"memory modify (auto-incrementing address)"memory modify (auto-incrementing address)U_BOOT_CMD(
	mm,	2,	1,	do_mem_mm,
	"memory modify (auto-incrementing address)",
#ifdef CONFIG_SYS_SUPPORT_64BIT_DATA
	"[.b, .w, .l, .q] address"
#else
	"[.b, .w, .l] address"
#endif
)_u_boot_list_2_cmd_2_mm.u_boot_list_2_cmd_2_mm"memory display""[.b, .w, .l, .q] address [# of objects]"memory display[.b, .w, .l, .q] address [# of objects]U_BOOT_CMD(
	md,	3,	1,	do_mem_md,
	"memory display",
#ifdef CONFIG_SYS_SUPPORT_64BIT_DATA
	"[.b, .w, .l, .q] address [# of objects]"
#else
	"[.b, .w, .l] address [# of objects]"
#endif
)_u_boot_list_2_cmd_2_md.u_boot_list_2_cmd_2_mdbase_addressmm_last_sizemm_last_addrCONFIG_MX_CYCLICCONFIG_LOOPWCONFIG_CMD_MEMTESTdefined(CONFIG_SYS_ALT_MEMTEST)CONFIG_CMD_CRC32CONFIG_CRC32_VERIFYCONFIG_CMD_RANDOMCONFIG_CMD_MEMINFO/* CONFIG_MX_CYCLIC *//* CONFIG_CMD_MEMTEST *//* CONFIG_LOOPW *//* CONFIG_CRC32_VERIFY */// NOT INITIALIZED ON PURPOSE/* good enough to not time out
				 *//* <CR> pressed as only input, don't modify current
			 * location and move to next. "-" pressed will go back.
			 *//* Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 *//* Address is specified since argc > 1
		*//* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 *//* Modify memory.
 *
 * Syntax:
 *	mm{.b, .w, .l, .q} {addr}
 *	nm{.b, .w, .l, .q} {addr}
 *//* Memory test was aborted - write a newline to finish off *//*
	 * Work-around for eldk-4.2 which gives this warning if we try to
	 * case in the unmap_sysmem() call:
	 * warning: initialization discards qualifiers from pointer target type
	 *//* number of errors, or -1 if interrupted *//*
 * Perform a memory test. A more complete alternative test can be
 * configured using CONFIG_SYS_ALT_MEMTEST. The complete test loops until
 * interrupted by ctrl-c or by a failure of one of the sub-tests.
 *//* complement & increment *//*
		 * Flip the pattern each time to make lots of zeros and
		 * then, the next time, lots of ones.  We decrement
		 * the "negative" patterns and increment the "positive"
		 * patterns to preserve this feature.
		 *//* Alternate the pattern *//*
	 * Check each location for the inverted pattern and zero it.
	 *//*
	 * Check each location and invert it for the second pass.
	 *//*
	 * Fill memory with a known pattern.
	 *//*
	 * Description: Test the integrity of a physical
	 *		memory device by performing an
	 *		increment/decrement test over the
	 *		entire region. In the process every
	 *		storage bit in the device is tested
	 *		as a zero and a one. The base address
	 *		and the size of the region are
	 *		selected by the caller.
	 *
	 * Returns:     0 if the test succeeds, 1 if the test fails.
	 *//*
	 * Check for addr bits stuck low or shorted.
	 *//*
	 * Check for address bits stuck high.
	 *//*
	 * Write the default pattern at each of the
	 * power-of-two offsets.
	 *//*
	* Address line test

	 * Description: Test the address bus wiring in a
	 *              memory region by performing a walking
	 *              1's test on the relevant bits of the
	 *              address and checking for aliasing.
	 *              This test will find single-bit
	 *              address failures such as stuck-high,
	 *              stuck-low, and shorted pins. The base
	 *              address and size of the region are
	 *              selected by the caller.

	 * Notes:	For best results, the selected base
	 *              address should have enough LSB 0's to
	 *              guarantee single address bit changes.
	 *              For example, to test a 64-Kbyte
	 *              region, select a base address on a
	 *              64-Kbyte boundary. Also, select the
	 *              region size as a power-of-two if at
	 *              all possible.
	 *
	 * Returns:     0 if the test succeeds, 1 if the test fails.
	 *//*
	 * Based on code whose Original Author and Copyright
	 * information follows: Copyright (c) 1998 by Michael
	 * Barr. This software is placed into the public
	 * domain and may be used for any purpose. However,
	 * this notice must not be changed or removed and no
	 * warranty is either expressed or implied by its
	 * publication or distribution.
	 *//* clear the test data off the bus *//*
	 * Data line test: write a pattern to the first
	 * location, write the 1's complement to a 'parking'
	 * address (changes the state of the data bus so a
	 * floating bus doesn't give a false OK), and then
	 * read the value back. Note that we read it back
	 * into a variable because the next time we read it,
	 * it might be right (been there, tough to explain to
	 * the quality guys why it prints a failure when the
	 * "is" and "should be" are obviously the same in the
	 * error message).
	 *
	 * Rather than exhaustively testing, we test some
	 * patterns by shifting '1' bits through a field of
	 * '0's and '0' bits through a field of '1's (i.e.
	 * pattern and ~pattern).
	 *//* alternating 1/0 *//* four non-adjacent bits *//* three non-adjacent bits *//* two non-adjacent bits *//* four adjacent bits *//* three adjacent bits *//* two adjacent bits *//* single bit *//* We want to optimize the loops to run as fast as possible.
	 * If we have only one object, just run infinite loops.
	 *//* data to write *//* Length is the number of objects, not number of bytes.
	*//* Address is always specified.
	*//*
	 * Check for a size specification.
	 * Defaults to long if no or incorrect specification.
	 *//* Print the current base address.
	*//* Set new base address.
		*//* check if we are copying to Flash *//* Check for size specification.
	*//* reset watchdog from time to time *//* check for ctrl-c to abort... *//* delay for <count> ms... *//* Get the value to write.
	*//* Address is specified since argc > 1
	*//* Print the lines. *//* If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 *//* Memory Display
 *
 * Syntax:
 *	md{.b, .w, .l, .q} {addr} {len}
 *//*
 * Memory Functions
 *
 * Copied from FADS ROM, Dan Malek (dmalek@jlc.net)
 */miimii_resolve_flowctrl_fdxADVERTISE_PAUSE_CAPFLOW_CTRL_TXFLOW_CTRL_RXFLOW_CTRL_TX | FLOW_CTRL_RXADVERTISE_PAUSE_ASYMmii_duplexLPA_DUPLEXmii_nway_resultLPA_100FULLLPA_100BASE4LPA_100HALFLPA_10FULLLPA_10HALFMII_MMD_CTRL_INCR_ON_WTMII_MMD_CTRL_INCR_RDWTMII_MMD_CTRL_NOINCRMII_MMD_CTRL_ADDRMII_MMD_CTRL_DEVAD_MASKLPA_1000HALFLPA_1000FULLLPA_1000REMRXOKLPA_1000LOCALRXOKCTL1000_ENABLE_MASTERCTL1000_AS_MASTERADVERTISE_1000HALFADVERTISE_1000FULLNWAYTEST_RESV20xfe00NWAYTEST_LOOPBACKNWAYTEST_RESV10x00ffESTATUS_1000_THALFESTATUS_1000_TFULLESTATUS_1000_XHALFESTATUS_1000_XFULLEXPANSION_RESV0xffe0EXPANSION_MFAULTSEXPANSION_NPCAPABLEEXPANSION_ENABLENPAGEEXPANSION_LCWPEXPANSION_NWAYLPA_100(LPA_100FULL | LPA_100HALF | LPA_100BASE4)(LPA_10FULL | LPA_100FULL)LPA_NPAGELPA_LPACKLPA_RFAULTLPA_RESVLPA_PAUSE_ASYMLPA_PAUSE_CAPLPA_1000XPAUSE_ASYMLPA_1000XPAUSELPA_1000XHALFLPA_1000XFULLLPA_SLCT0x001fADVERTISE_ALL(ADVERTISE_10HALF | ADVERTISE_10FULL | ADVERTISE_100HALF | ADVERTISE_100FULL)ADVERTISE_FULL(ADVERTISE_100FULL | ADVERTISE_10FULL | ADVERTISE_CSMA)ADVERTISE_NPAGEADVERTISE_LPACKADVERTISE_RFAULTADVERTISE_RESVADVERTISE_100BASE4ADVERTISE_1000XPSE_ASYMADVERTISE_100FULLADVERTISE_1000XPAUSEADVERTISE_100HALFADVERTISE_1000XHALFADVERTISE_10FULLADVERTISE_1000XFULLADVERTISE_10HALFADVERTISE_CSMAADVERTISE_SLCTBMSR_100BASE4BMSR_100FULLBMSR_100HALFBMSR_10FULLBMSR_10HALFBMSR_100FULL2BMSR_100HALF2BMSR_ESTATENBMSR_RESV0x00c0BMSR_ANEGCOMPLETEBMSR_RFAULTBMSR_ANEGCAPABLEBMSR_LSTATUSBMSR_JCDBMSR_ERCAPBMCR_SPEED10BMCR_RESETBMCR_LOOPBACKBMCR_SPEED100BMCR_ANENABLEBMCR_PDOWNBMCR_ISOLATEBMCR_ANRESTARTBMCR_FULLDPLXBMCR_CTSTBMCR_SPEED1000BMCR_RESV0x003fMII_NCONFIGMII_TPISTATUSMII_RESV2MII_PHYADDRMII_LBRERRORMII_RESV1MII_SREVISIONMII_RERRCOUNTERMII_NWAYTESTMII_FCSCOUNTERMII_DCOUNTERMII_ESTATUSMII_MMD_DATAMII_MMD_CTRLMII_STAT1000MII_CTRL1000MII_EXPANSIONMII_LPAMII_ADVERTISEMII_PHYSID2MII_PHYSID1MII_BMSRMII_BMCR__LINUX_MII_H__/* __LINUX_MII_H__ *//**
 * mii_resolve_flowctrl_fdx
 * @lcladv: value of MII ADVERTISE register
 * @rmtadv: value of MII LPA register
 *
 * Resolve full duplex flow control as per IEEE 802.3-2005 table 28B-3
 *//**
 * mii_duplex
 * @duplex_lock: Non-zero if duplex is locked at full
 * @negotiated: value of MII ANAR and'd with ANLPAR
 *
 * A small helper function for a common case.  Returns one
 * if the media is operating or locked at full duplex, and
 * returns zero otherwise.
 *//**
 * mii_nway_result
 * @negotiated: value of MII ANAR and'd with ANLPAR
 *
 * Given a set of MII abilities, check each bit and returns the
 * currently supported media, in the priority order defined by
 * IEEE 802.3u.  We use LPA_xxx constants but note this is not the
 * value of LPA solely, as described above.
 *
 * The one exception to IEEE 802.3u is that 100baseT4 is placed
 * between 100T-full and 100T-half.  If your phy does not support
 * 100T4 this is fine. If your phy places 100T4 elsewhere in the
 * priority order, you will need to roll your own function.
 *//* post increment on writes only *//* post increment on reads & writes *//* no post increment *//* Address *//* Mask MMD DEVAD*//* MMD Access Control register fields *//* Flow control flags *//* Link partner 1000BASE-T half duplex *//* Link partner 1000BASE-T full duplex *//* Link partner remote receiver status *//* Link partner local receiver status *//* 1000BASE-T Status register *//* Advertise 1000BASE-T half duplex *//* Advertise 1000BASE-T full duplex *//* 1000BASE-T Control register *//* Unused...                   *//* Enable loopback for N-way   *//* N-way test register. *//* Can do 1000BT Half          *//* Can do 1000BT Full          *//* Can do 1000BX Half *//* Can do 1000BX Full *//* Multiple faults detected    *//* Link partner supports npage *//* This enables npage words    *//* Got new RX page code word   *//* Can do N-way auto-nego      *//* Expansion register for auto-negotiation. *//* Next page bit               *//* Link partner acked us       *//* Link partner faulted        *//* Can pause asymetrically     *//* Can pause                   *//* Can do 100mbps 4k packets   *//* Can do 1000BASE-X pause asym*//* Can do 100mbps full-duplex  *//* Can do 1000BASE-X pause     *//* Can do 100mbps half-duplex  *//* Can do 1000BASE-X half-duplex *//* Can do 10mbps full-duplex   *//* Can do 1000BASE-X full-duplex *//* Can do 10mbps half-duplex   *//* Same as advertise selector  *//* Link partner ability register. *//* Ack link partners response  *//* Say we can detect faults    *//* Try for asymetric pause     *//* Try for pause               *//* Try for 100mbps 4k packets  *//* Try for 1000BASE-X asym pause *//* Try for 100mbps full-duplex *//* Try for 1000BASE-X pause    *//* Try for 100mbps half-duplex *//* Try for 1000BASE-X half-duplex *//* Try for 10mbps full-duplex  *//* Try for 1000BASE-X full-duplex *//* Try for 10mbps half-duplex  *//* Only selector supported     *//* Selector bits               *//* Advertisement control register. *//* Can do 100mbps, 4k packets  *//* Can do 100mbps, full-duplex *//* Can do 100mbps, half-duplex *//* Can do 10mbps, full-duplex  *//* Can do 10mbps, half-duplex  *//* Can do 100BASE-T2 FDX       *//* Can do 100BASE-T2 HDX       *//* Extended Status in R15      *//* Auto-negotiation complete   *//* Remote fault detected       *//* Able to do auto-negotiation *//* Link status                 *//* Jabber detected             *//* Ext-reg capability          *//* Basic mode status register. *//* Select 10Mbps               *//* Reset to default state      *//* TXD loopback bits           *//* Select 100Mbps              *//* Enable auto negotiation     *//* Enable low power state      *//* Isolate data paths from MII *//* Auto negotiation restart    *//* Full duplex                 *//* Collision test              *//* MSB of Speed (1000)         *//* Basic mode control register. *//* Network interface config    *//* TPI status for 10mbps       *//* Reserved...                 *//* PHY address                 *//* Lpback, rx, bypass error    *//* Silicon revision            *//* Receive error counter       *//* N-way auto-neg test reg     *//* False carrier counter       *//* Disconnect counter          *//* Extended Status             *//* MMD Access Data Register *//* MMD Access Control Register *//* 1000BASE-T status           *//* 1000BASE-T control          *//* Expansion register          *//* Link partner ability reg    *//* Advertisement control reg   *//* PHYS ID 2                   *//* PHYS ID 1                   *//* Basic mode status register  *//* Basic mode control register *//* Generic MII registers. *//*
 * linux/mii.h: definitions for MII-compatible transceivers
 * Originally drivers/net/sunhme.h.
 *
 * Copyright (C) 1996, 1999, 2001 David S. Miller (davem@redhat.com)
 */lcladvrmtadvduplex_locknegotiatedethtoolethtool_cmd_speedethtool_cmd *ethtool_cmd_speed_setethtool_reset_flagsETH_RESET_MGMTETH_RESET_IRQETH_RESET_DMAETH_RESET_FILTERETH_RESET_OFFLOADETH_RESET_MACETH_RESET_PHYETH_RESET_RAMETH_RESET_DEDICATEDETH_RESET_ALLethtool_sfeatures_retval_bitsETHTOOL_F_UNSUPPORTED__BITETHTOOL_F_WISH__BITETHTOOL_F_COMPAT__BITethtool_sfeaturesethtool_set_features_blockethtool_gfeaturesethtool_get_features_blockethtool_flashethtool_flash_op_typeETHTOOL_FLASH_ALL_REGIONSethtool_rxfh_indirethtool_usrip4_specethtool_ah_espip4_specethtool_tcpip4_specethtool_flagsETH_FLAG_TXVLANETH_FLAG_RXVLANETH_FLAG_LRO1 << 15ETH_FLAG_NTUPLE1 << 27(1 << 27)ETH_FLAG_RXHASH1 << 28(1 << 28)ethtool_perm_addrethtool_statsethtool_testethtool_test_flagsETH_TEST_FL_OFFLINEETH_TEST_FL_FAILEDethtool_sset_infoethtool_gstringsethtool_stringsetETH_SS_TESTETH_SS_STATSETH_SS_PRIV_FLAGSETH_SS_NTUPLE_FILTERSETH_SS_FEATURESethtool_pauseparamethtool_ringparamethtool_coalesceethtool_eepromethtool_regsethtool_valueethtool_wolinfoethtool_drvinfoethtool_cmdethtool_set_features_block[0]requestedvalidethtool_get_features_block[0]never_changedavailableETHTOOL_FLASH_MAX_FILENAMEring_indexprotoip_verl4_4_bytesip4dstip4srcpdstpsrc__u64[0]unsigned long long[0]n_statssset_maskstring_settx_pauserx_pauseautonegtx_pendingrx_jumbo_pendingrx_mini_pendingrx_pendingtx_max_pendingrx_jumbo_max_pendingrx_mini_max_pendingrx_max_pendingrate_sample_intervaltx_max_coalesced_frames_hightx_coalesce_usecs_highrx_max_coalesced_frames_highrx_coalesce_usecs_highpkt_rate_hightx_max_coalesced_frames_lowtx_coalesce_usecs_lowrx_max_coalesced_frames_lowrx_coalesce_usecs_lowpkt_rate_lowuse_adaptive_tx_coalesceuse_adaptive_rx_coalescestats_block_coalesce_usecstx_max_coalesced_frames_irqtx_coalesce_usecs_irqtx_max_coalesced_framestx_coalesce_usecsrx_max_coalesced_frames_irqrx_coalesce_usecs_irqrx_max_coalesced_framesrx_coalesce_usecs__u8[6]SOPASS_MAXsopasswoloptsregdump_leneedump_lentestinfo_lenn_priv_flagsETHTOOL_BUSINFO_LENbus_infoETHTOOL_FWVERS_LENfw_versionlp_advertisingeth_tp_mdixspeed_himaxrxpktmaxtxpktmdio_supporttransceiverphy_addressduplexadvertisingETH_RESET_SHARED_SHIFTRX_CLS_FLOW_DISC0xffffffffffffffffULLRXH_DISCARDRXH_L4_B_2_3RXH_L4_B_0_1RXH_IP_DSTRXH_IP_SRCRXH_L3_PROTORXH_VLANRXH_L2DAETHER_FLOWIPV6_FLOWIPV4_FLOWIP_USER_FLOWESP_V6_FLOWAH_V6_FLOWESP_V4_FLOWAH_V4_FLOWAH_ESP_V6_FLOWSCTP_V6_FLOWUDP_V6_FLOWTCP_V6_FLOWAH_ESP_V4_FLOWSCTP_V4_FLOWUDP_V4_FLOWTCP_V4_FLOWWAKE_MAGICSECUREWAKE_MAGICWAKE_ARPWAKE_BCASTWAKE_MCASTWAKE_UCASTWAKE_PHYETH_TP_MDI_XETH_TP_MDIETH_TP_MDI_INVALIDAUTONEG_ENABLEAUTONEG_DISABLEXCVR_DUMMY3XCVR_DUMMY2XCVR_DUMMY1XCVR_EXTERNALXCVR_INTERNALPORT_OTHERPORT_NONEPORT_DAPORT_BNCPORT_FIBREPORT_MIIPORT_AUIPORT_TPDUPLEX_FULLDUPLEX_HALFSPEED_10000SPEED_25002500SPEED_1000SPEED_100SPEED_10ADVERTISED_1000baseX_FullADVERTISED_1000baseX_HalfADVERTISED_10000baseR_FECADVERTISED_10000baseKR_FullADVERTISED_10000baseKX4_FullADVERTISED_1000baseKX_FullADVERTISED_BackplaneADVERTISED_2500baseX_FullADVERTISED_Asym_PauseADVERTISED_PauseADVERTISED_10000baseT_FullADVERTISED_BNCADVERTISED_FIBREADVERTISED_MIIADVERTISED_AUIADVERTISED_TPADVERTISED_AutonegADVERTISED_1000baseT_FullADVERTISED_1000baseT_HalfADVERTISED_100baseT_FullADVERTISED_100baseT_HalfADVERTISED_10baseT_FullADVERTISED_10baseT_HalfSUPPORTED_1000baseX_FullSUPPORTED_1000baseX_HalfSUPPORTED_10000baseR_FECSUPPORTED_10000baseKR_FullSUPPORTED_10000baseKX4_FullSUPPORTED_1000baseKX_FullSUPPORTED_BackplaneSUPPORTED_2500baseX_FullSUPPORTED_Asym_PauseSUPPORTED_PauseSUPPORTED_10000baseT_FullSUPPORTED_BNCSUPPORTED_FIBRESUPPORTED_MIISUPPORTED_AUISUPPORTED_TPSUPPORTED_AutonegSUPPORTED_1000baseT_FullSUPPORTED_1000baseT_HalfSUPPORTED_100baseT_FullSUPPORTED_100baseT_HalfSUPPORTED_10baseT_FullSUPPORTED_10baseT_HalfSPARC_ETH_SSETETHTOOL_SSETSPARC_ETH_GSETETHTOOL_GSETETHTOOL_SFEATURES0x0000003bETHTOOL_GFEATURES0x0000003aETHTOOL_SRXFHINDIR0x00000039ETHTOOL_GRXFHINDIR0x00000038ETHTOOL_GSSET_INFO0x00000037ETHTOOL_GRXNTUPLE0x00000036ETHTOOL_SRXNTUPLE0x00000035ETHTOOL_RESET0x00000034ETHTOOL_FLASHDEV0x00000033ETHTOOL_SRXCLSRLINS0x00000032ETHTOOL_SRXCLSRLDEL0x00000031ETHTOOL_GRXCLSRLALL0x00000030ETHTOOL_GRXCLSRULE0x0000002fETHTOOL_GRXCLSRLCNT0x0000002eETHTOOL_GRXRINGS0x0000002dETHTOOL_SGRO0x0000002cETHTOOL_GGRO0x0000002bETHTOOL_SRXFH0x0000002aETHTOOL_GRXFH0x00000029ETHTOOL_SPFLAGS0x00000028ETHTOOL_GPFLAGS0x00000027ETHTOOL_SFLAGS0x00000026ETHTOOL_GFLAGS0x00000025ETHTOOL_SGSO0x00000024ETHTOOL_GGSO0x00000023ETHTOOL_SUFO0x00000022ETHTOOL_GUFO0x00000021ETHTOOL_GPERMADDRETHTOOL_STSO0x0000001fETHTOOL_GTSO0x0000001eETHTOOL_GSTATS0x0000001dETHTOOL_PHYS_ID0x0000001cETHTOOL_GSTRINGS0x0000001bETHTOOL_TEST0x0000001aETHTOOL_SSG0x00000019ETHTOOL_GSG0x00000018ETHTOOL_STXCSUM0x00000017ETHTOOL_GTXCSUM0x00000016ETHTOOL_SRXCSUMETHTOOL_GRXCSUM0x00000014ETHTOOL_SPAUSEPARAM0x00000013ETHTOOL_GPAUSEPARAM0x00000012ETHTOOL_SRINGPARAM0x00000011ETHTOOL_GRINGPARAMETHTOOL_SCOALESCE0x0000000fETHTOOL_GCOALESCE0x0000000eETHTOOL_SEEPROM0x0000000cETHTOOL_GEEPROM0x0000000bETHTOOL_GLINK0x0000000aETHTOOL_NWAY_RST0x00000009ETHTOOL_SMSGLVLETHTOOL_GMSGLVLETHTOOL_SWOL0x00000006ETHTOOL_GWOLETHTOOL_GREGSETHTOOL_GDRVINFOETHTOOL_F_COMPAT(1 << ETHTOOL_F_COMPAT__BIT)ETHTOOL_F_WISH(1 << ETHTOOL_F_WISH__BIT)ETHTOOL_F_UNSUPPORTED(1 << ETHTOOL_F_UNSUPPORTED__BIT)ETH_RX_NFC_IP4ETH_GSTRING_LEN_LINUX_ETHTOOL_H/* _LINUX_ETHTOOL_H *//* All components used by this
						 * interface, even if shared *//* All components dedicated to
						 * this interface *//* RAM shared between
						 * multiple components *//* Transceiver/PHY *//* Media access controller *//* Protocol offload *//* Filtering/flow direction *//* DMA engine *//* Interrupt requester *//* Management processor *//* These flags represent components dedicated to the interface
	 * the command is addressed to.  Shift any flag left by
	 * ETH_RESET_SHARED_SHIFT to reset a shared component of the
	 * same type.
	 *//* The reset() operation must clear the flags for the components which
 * were actually reset.  On successful return, the flags indicate the
 * components which were not reset, either because they do not exist
 * in the hardware or because they cannot be reset independently.  The
 * driver must never reset any components that were not requested.
 *//* Reset flags *//* dst port in case of TCP/UDP/SCTP *//* src port in case of TCP/UDP/SCTP *//* L3-L4 network traffic flow hash options *//* spec only (ether_spec) *//* hash only *//* spec only (usr_ip4_spec) *//* hash or spec (esp_ip4_spec) *//* hash or spec (ah_ip4_spec) *//* hash or spec (sctp_ip4_spec) *//* hash or spec (udp_ip4_spec) *//* hash or spec (tcp_ip4_spec) *//* L2-L4 network traffic flow types *//* only meaningful if WAKE_MAGIC *//* Wake-On-Lan options. *//* Mode MDI or MDI-X *//* Enable or disable autonegotiation.  If this is set to enable,
 * the forced link modes above are completely ignored.
 *//* Which transceiver to use. *//* Which connector port. *//* Duplex, half or full. *//* The forced speed, 10Mb, 100Mb, gigabit, 2.5Gb, 10GbE. *//* The following are all involved in forcing a particular link
 * mode for the device for setting things.  When getting the
 * devices settings, these indicate the current mode and whether
 * it was foced up into this mode or autonegotiated.
 *//* Indicates what features are advertised by the interface. *//* Indicates what features are supported by the interface. *//* compatibility with older code *//* Change device offload settings *//* Get device offload settings *//* Set RX flow hash indir'n table *//* Get RX flow hash indir'n table *//* Get string set info *//* Get n-tuple filters from device *//* Add an n-tuple filter to device *//* Reset hardware *//* Flash firmware to device *//* Insert RX classification rule *//* Delete RX classification rule *//* Get all RX classification rule *//* Get RX classification rule *//* Get RX class rule count *//* Get RX rings available for LB *//* Set GRO enable (ethtool_value) *//* Get GRO enable (ethtool_value) *//* Set RX flow hash configuration *//* Get RX flow hash configuration *//* Set driver-private flags bitmap *//* Get driver-private flags bitmap *//* Set flags bitmap(ethtool_value) *//* Get flags bitmap(ethtool_value) *//* Set GSO enable (ethtool_value) *//* Get GSO enable (ethtool_value) *//* Set UFO enable (ethtool_value) *//* Get UFO enable (ethtool_value) *//* Get permanent hardware address *//* Set TSO enable (ethtool_value) *//* Get TSO enable (ethtool_value) *//* get NIC-specific statistics *//* identify the NIC *//* get specified string set *//* execute NIC self-test. *//* Set scatter-gather enable
					    * (ethtool_value). *//* Get scatter-gather enable
					    * (ethtool_value) *//* Set TX hw csum enable (ethtool_value) *//* Get TX hw csum enable (ethtool_value) *//* Set RX hw csum enable (ethtool_value) *//* Get RX hw csum enable (ethtool_value) *//* Set pause parameters. *//* Get pause parameters *//* Set ring parameters. *//* Get ring parameters *//* Set coalesce config. *//* Get coalesce config *//* Set EEPROM data. *//* Get EEPROM data *//* Get link status for host, i.e. whether the interface *and* the
 * physical port (if there is one) are up (ethtool_value). *//* Restart autonegotiation. *//* Set driver msg level. *//* Get driver message level *//* Set wake-on-lan options. *//* Get wake-on-lan options. *//* Get NIC registers. *//* Get driver info. *//* Set settings. *//* Get settings. *//* CMDs currently supported *//*
 * %ETHTOOL_SFEATURES changes features present in features[].valid to the
 * values of corresponding bits in features[].requested. Bits in .requested
 * not set in .valid or not changeable are ignored.
 *
 * Returns %EINVAL when .valid contains undefined or never-changable bits
 * or size is not equal to required number of features words (32-bit blocks).
 * Returns >= 0 if request was completed; bits set in the value mean:
 *   %ETHTOOL_F_UNSUPPORTED - there were bits set in .valid that are not
 *	changeable (not present in %ETHTOOL_GFEATURES' features[].available)
 *	those bits were ignored.
 *   %ETHTOOL_F_WISH - some or all changes requested were recorded but the
 *      resulting state of bits masked by .valid is not equal to .requested.
 *      Probably there are other device-specific constraints on some features
 *      in the set. When %ETHTOOL_F_UNSUPPORTED is set, .valid is considered
 *      here as though ignored bits were cleared.
 *   %ETHTOOL_F_COMPAT - some or all changes requested were made by calling
 *      compatibility functions. Requested offload state cannot be properly
 *      managed by kernel.
 *
 * Meaning of bits in the masks are obtained by %ETHTOOL_GSSET_INFO (number of
 * bits in the arrays - always multiple of 32) and %ETHTOOL_GSTRINGS commands
 * for ETH_SS_FEATURES string set. First entry in the table corresponds to least
 * significant bit in features[0] fields. Empty strings mark undefined features.
 *//**
 * struct ethtool_sfeatures - command to request change in device's features
 * @cmd: command number = %ETHTOOL_SFEATURES
 * @size: array size of the features[] array
 * @features: feature change masks
 *//**
 * struct ethtool_set_features_block - block with request for 32 features
 * @valid: mask of features to be changed
 * @requested: values of features to be changed
 *//**
 * struct ethtool_gfeatures - command to get state of device's features
 * @cmd: command number = %ETHTOOL_GFEATURES
 * @size: in: number of elements in the features[] array;
 *       out: number of elements in features[] needed to hold all features
 * @features: state of features
 *//**
 * struct ethtool_get_features_block - block with state of 32 features
 * @available: mask of changeable features
 * @requested: mask of features requested to be enabled if possible
 * @active: mask of currently enabled features
 * @never_changed: mask of features not changeable for any device
 *//* for returning and changing feature sets *//* for passing firmware flashing related parameters *//**
 * struct ethtool_rxfh_indir - command to get or set RX flow hash indirection
 * @cmd: Specific command number - %ETHTOOL_GRXFHINDIR or %ETHTOOL_SRXFHINDIR
 * @size: On entry, the array size of the user buffer.  On return from
 *	%ETHTOOL_GRXFHINDIR, the array size of the hardware indirection table.
 * @ring_index: RX ring/queue index for each hash value
 *//**
 * struct ethtool_usrip4_spec - general flow specification for IPv4
 * @ip4src: Source host
 * @ip4dst: Destination host
 * @l4_4_bytes: First 4 bytes of transport (layer 4) header
 * @tos: Type-of-service
 * @ip_ver: Value must be %ETH_RX_NFC_IP4; mask must be 0
 * @proto: Transport protocol number; mask must be 0
 *//**
 * struct ethtool_ah_espip4_spec - flow specification for IPsec/IPv4
 * @ip4src: Source host
 * @ip4dst: Destination host
 * @spi: Security parameters index
 * @tos: Type-of-service
 *
 * This can be used to specify an IPsec transport or tunnel over IPv4.
 *//**
 * struct ethtool_tcpip4_spec - flow specification for TCP/IPv4 etc.
 * @ip4src: Source host
 * @ip4dst: Destination host
 * @psrc: Source port
 * @pdst: Destination port
 * @tos: Type-of-service
 *
 * This can be used to specify a TCP/IPv4, UDP/IPv4 or SCTP/IPv4 flow.
 *//* The following structures are for supporting RX network flow
 * classification and RX n-tuple configuration. Note, all multibyte
 * fields, e.g., ip4src, ip4dst, psrc, pdst, spi, etc. are expected to
 * be in network byte order.
 *//* N-tuple filters enabled *//* LRO is enabled *//* RX VLAN offload enabled *//* TX VLAN offload enabled *//* boolean flags controlling per-interface behavior characteristics.
 * When reading, the flag indicates whether or not a certain behavior
 * is enabled/present.  When writing, the flag indicates whether
 * or not the driver should turn on (set) or off (clear) a behavior.
 *
 * Some behaviors may read-only (unconditionally absent or present).
 * If such is the case, return EINVAL in the set-flags operation if the
 * flag differs from the read-only value.
 *//* ETHTOOL_GPERMADDR *//* number of u64's being returned *//* ETHTOOL_GSTATS *//* for dumping NIC-specific statistics *//* result length, in number of u64 elements *//* ETH_TEST_FL_xxx *//* ETHTOOL_TEST *//* for requesting NIC test and getting results*//* test passed / failed *//* online / offline *//* ETH_SS_xxx count, in order, based on bits
				   in sset_mask.  One bit implies one
				   __u32, two bits implies two
				   __u32's, etc. *//* output: each bit a returned sset *//* input: each bit selects an sset to query *//* ETHTOOL_GSSET_INFO *//* number of strings in the string set *//* string set id e.c. ETH_SS_TEST, etc*//* ETHTOOL_GSTRINGS *//* for passing string sets for data tagging *//* If the link is being auto-negotiated (via ethtool_cmd.autoneg
	 * being true) the user may set 'autonet' here non-zero to have the
	 * pause parameters be auto-negotiated too.  In such a case, the
	 * {rx,tx}_pause values below determine what capabilities are
	 * advertised.
	 *
	 * If 'autoneg' is zero or the link is not being auto-negotiated,
	 * then {rx,tx}_pause force the driver to use/not-use pause
	 * flow control.
	 *//* ETHTOOL_{G,S}PAUSEPARAM *//* for configuring link flow control parameters *//* Values changeable by the user.  The valid values are
	 * in the range 1 to the "*_max_pending" counterpart above.
	 *//* Read only attributes.  These indicate the maximum number
	 * of pending RX/TX ring entries the driver will allow the
	 * user to set.
	 *//* ETHTOOL_{G,S}RINGPARAM *//* for configuring RX/TX ring parameters *//* How often to do adaptive coalescing packet rate sampling,
	 * measured in seconds.  Must not be zero.
	 *//* When the packet rate is (measured in packets per second)
	 * is above pkt_rate_high, the {rx,tx}_*_high parameters are
	 * used.
	 *//* When the packet rate is below pkt_rate_high but above
	 * pkt_rate_low (both measured in packets per second) the
	 * normal {rx,tx}_* coalescing parameters are used.
	 *//* When the packet rate (measured in packets per second)
	 * is below pkt_rate_low, the {rx,tx}_*_low parameters are
	 * used.
	 *//* Adaptive RX/TX coalescing is an algorithm implemented by
	 * some drivers to improve latency under low packet rates and
	 * improve throughput under high packet rates.  Some drivers
	 * only implement one of RX or TX adaptive coalescing.  Anything
	 * not implemented by the driver causes these values to be
	 * silently ignored.
	 *//* How many usecs to delay in-memory statistics
	 * block updates.  Some drivers do not have an in-memory
	 * statistic block, and in such cases this value is ignored.
	 * This value must not be zero.
	 *//* Same as above two parameters, except that these values
	 * apply while an IRQ is being serviced by the host.  Not
	 * all cards support this feature and the values are ignored
	 * in that case.
	 *//* How many packets to delay a TX interrupt after
	 * a packet is sent.  If 0, only tx_coalesce_usecs is
	 * used.  It is illegal to set both usecs and max frames
	 * to zero as this would cause TX interrupts to never be
	 * generated.
	 *//* How many usecs to delay a TX interrupt after
	 * a packet is sent.  If 0, only tx_max_coalesced_frames
	 * is used.
	 *//* How many packets to delay an RX interrupt after
	 * a packet arrives.  If 0, only rx_coalesce_usecs is
	 * used.  It is illegal to set both usecs and max frames
	 * to zero as this would cause RX interrupts to never be
	 * generated.
	 *//* How many usecs to delay an RX interrupt after
	 * a packet arrives.  If 0, only rx_max_coalesced_frames
	 * is used.
	 *//* ETHTOOL_{G,S}COALESCE *//* for configuring coalescing parameters of chip *//* in bytes *//* for passing EEPROM chunks *//* driver-specific, indicates different chips/revs *//* for passing big chunks of data *//* for passing single values *//* SecureOn(tm) password *//* wake-on-lan settings *//* Size of data from ETHTOOL_GREGS (bytes) *//* Size of data from ETHTOOL_GEEPROM (bytes) *//* number of u64's from ETHTOOL_GSTATS *//* number of flags valid in ETHTOOL_GPFLAGS *//*
				 * Some struct members below are filled in
				 * using ops->get_sset_count().  Obtaining
				 * this info from ethtool_drvinfo is now
				 * deprecated; Use ETHTOOL_GSSET_INFO
				 * instead.
				 *//* For PCI devices, use pci_name(pci_dev). *//* Bus info for this IF. *//* firmware version string *//* driver version string *//* driver short name, "tulip", "eepro100" *//* these strings are set to whatever the driver author decides... *//* Features the link partner advertises *//* Rx pkts before generating rx int *//* Tx pkts before generating tx int *//* Enable or disable autonegotiation *//* Which transceiver to use *//* Which connector port *//* Duplex, half or full *//* The forced speed, 10Mb, 100Mb, gigabit *//* Features this interface advertises *//* Features this interface supports *//* This should work for both 32 and 64 bit userland. *//*
 * ethtool.h: Defines for Linux ethtool.
 *
 * Copyright (C) 1998 David S. Miller (davem@redhat.com)
 * Copyright 2001 Jeff Garzik <jgarzik@pobox.com>
 * Portions Copyright 2001 Sun Microsystems (thockin@sun.com)
 * Portions Copyright 2002 Intel (eli.kupermann@intel.com,
 *                                christopher.leech@intel.com,
 *                                scott.feldman@intel.com)
 * Portions Copyright (C) Sun Microsystems 2008
 */mdio_phy_id_c45MDIO_PHY_ID_C45MDIO_EMULATE_C22MDIO_PRTAD_NONEMDIO_PHY_ID_C45_MASK(MDIO_PHY_ID_C45 | MDIO_PHY_ID_PRTAD | MDIO_PHY_ID_DEVAD)MDIO_PHY_ID_DEVADMDIO_PHY_ID_PRTAD0x03e0MDIO_PMA_LASI_RXALARMMDIO_PMA_LASI_TXALARMMDIO_PMA_LASI_LSALARMMDIO_PMA_LASI_TX_LASERBICURRFLTMDIO_PMA_LASI_TX_LASERTEMPFLTMDIO_PMA_LASI_TX_LASERPOWERFLTMDIO_PMA_LASI_TX_PMALFLTMDIO_PMA_LASI_TX_PCSLFLTMDIO_PMA_LASI_TX_PHYXSLFLTMDIO_PMA_LASI_RX_WISLFLTMDIO_PMA_LASI_RX_OPTICPOWERFLTMDIO_PMA_LASI_RX_PMALFLTMDIO_PMA_LASI_RX_PCSLFLTMDIO_PMA_LASI_RX_PHYXSLFLTMDIO_EEE_10GKRMDIO_EEE_10GKX4MDIO_EEE_1000KXMDIO_EEE_10GTMDIO_EEE_1000TMDIO_AN_EEE_ADV_1000TMDIO_EEE_100TXMDIO_AN_EEE_ADV_100TXMDIO_AN_10GBT_STAT_MSFLTMDIO_AN_10GBT_STAT_MSMDIO_AN_10GBT_STAT_LOCOKMDIO_AN_10GBT_STAT_REMOKMDIO_AN_10GBT_STAT_LP10GMDIO_AN_10GBT_STAT_LPLTABLEMDIO_AN_10GBT_STAT_LPTRRMDIO_AN_10GBT_CTRL_ADV10GMDIO_PCS_10GBRT_STAT2_BER0x3f00MDIO_PCS_10GBRT_STAT2_ERRMDIO_PCS_10GBRT_STAT1_BLKLKMDIO_PMA_10GBR_FECABLE_ERRABLEMDIO_PMA_10GBR_FECABLE_ABLEMDIO_PMA_10GBT_SNR_MAXMDIO_PMA_10GBT_SNR_BIASMDIO_PMA_10GBT_TXPWR_SHORTMDIO_PMA_10GBT_SWAPPOL_DREVMDIO_PMA_10GBT_SWAPPOL_CREVMDIO_PMA_10GBT_SWAPPOL_BREVMDIO_PMA_10GBT_SWAPPOL_AREVMDIO_PMA_10GBT_SWAPPOL_CDNXMDIO_PMA_10GBT_SWAPPOL_ABNXMDIO_PHYXS_LNSTAT_ALIGNMDIO_PHYXS_LNSTAT_SYNC3MDIO_PHYXS_LNSTAT_SYNC2MDIO_PHYXS_LNSTAT_SYNC1MDIO_PHYXS_LNSTAT_SYNC0MDIO_PMA_EXTABLE_10BTMDIO_PMA_EXTABLE_100BTXMDIO_PMA_EXTABLE_1000BKXMDIO_PMA_EXTABLE_1000BTMDIO_PMA_EXTABLE_10GBKRMDIO_PMA_EXTABLE_10GBKX4MDIO_PMA_EXTABLE_10GBTMDIO_PMA_EXTABLE_10GBLRMMDIO_PMA_EXTABLE_10GCX4MDIO_PMD_RXDET_3MDIO_PMD_RXDET_2MDIO_PMD_RXDET_1MDIO_PMD_RXDET_0MDIO_PMD_RXDET_GLOBALMDIO_PMD_TXDIS_3MDIO_PMD_TXDIS_2MDIO_PMD_TXDIS_1MDIO_PMD_TXDIS_0MDIO_PMD_TXDIS_GLOBALMDIO_PCS_STAT2_TXFLTABLEMDIO_PCS_STAT2_RXFLTABLEMDIO_PCS_STAT2_10GBWMDIO_PCS_STAT2_10GBXMDIO_PCS_STAT2_10GBRMDIO_PMA_STAT2_TXFLTABLEMDIO_PMA_STAT2_RXFLTABLEMDIO_PMA_STAT2_EXTABLEMDIO_PMD_STAT2_TXDISABMDIO_PMA_STAT2_10GBSRMDIO_PMA_STAT2_10GBLRMDIO_PMA_STAT2_10GBERMDIO_PMA_STAT2_10GBLX4MDIO_PMA_STAT2_10GBSWMDIO_PMA_STAT2_10GBLWMDIO_PMA_STAT2_10GBEWMDIO_PMA_STAT2_LBABLEMDIO_STAT2_DEVPRST_VALMDIO_STAT2_DEVPRSTMDIO_STAT2_TXFAULTMDIO_STAT2_RXFAULTMDIO_PCS_CTRL2_10GBTMDIO_PCS_CTRL2_10GBWMDIO_PCS_CTRL2_10GBXMDIO_PCS_CTRL2_10GBRMDIO_PCS_CTRL2_TYPEMDIO_PMA_CTRL2_10BT0x000fMDIO_PMA_CTRL2_100BTX0x000eMDIO_PMA_CTRL2_1000BKX0x000dMDIO_PMA_CTRL2_1000BT0x000cMDIO_PMA_CTRL2_10GBKR0x000bMDIO_PMA_CTRL2_10GBKX40x000aMDIO_PMA_CTRL2_10GBTMDIO_PMA_CTRL2_10GBLRMMDIO_PMA_CTRL2_10GBSRMDIO_PMA_CTRL2_10GBLRMDIO_PMA_CTRL2_10GBERMDIO_PMA_CTRL2_10GBLX4MDIO_PMA_CTRL2_10GBSWMDIO_PMA_CTRL2_10GBLWMDIO_PMA_CTRL2_10GBEWMDIO_PMA_CTRL2_10GBCX4MDIO_PMA_CTRL2_TYPEMDIO_DEVS_LINK(MDIO_DEVS_PMAPMD | MDIO_DEVS_WIS | MDIO_DEVS_PCS | MDIO_DEVS_PHYXS | MDIO_DEVS_DTEXS | MDIO_DEVS_AN)MDIO_DEVS_VEND2MDIO_DEVS_PRESENT(MDIO_MMD_VEND2)MDIO_DEVS_VEND1MDIO_DEVS_PRESENT(MDIO_MMD_VEND1)MDIO_DEVS_C22EXTMDIO_DEVS_PRESENT(MDIO_MMD_C22EXT)MDIO_DEVS_ANMDIO_DEVS_PRESENT(MDIO_MMD_AN)MDIO_DEVS_TCMDIO_DEVS_PRESENT(MDIO_MMD_TC)MDIO_DEVS_DTEXSMDIO_DEVS_PRESENT(MDIO_MMD_DTEXS)MDIO_DEVS_PHYXSMDIO_DEVS_PRESENT(MDIO_MMD_PHYXS)MDIO_DEVS_PCSMDIO_DEVS_PRESENT(MDIO_MMD_PCS)MDIO_DEVS_WISMDIO_DEVS_PRESENT(MDIO_MMD_WIS)MDIO_DEVS_PMAPMDMDIO_DEVS_PRESENT(MDIO_MMD_PMAPMD)MDIO_DEVS_PRESENT(devad)(1 << (devad))MDIO_PCS_SPEED_10P2BMDIO_PMA_SPEED_10MDIO_PMA_SPEED_100MDIO_PMA_SPEED_1000MDIO_PMA_SPEED_10PMDIO_PMA_SPEED_2BMDIO_SPEED_10GMDIO_AN_STAT1_XNPMDIO_AN_STAT1_PAGEMDIO_AN_STAT1_COMPLETEMDIO_AN_STAT1_RFAULTMDIO_AN_STAT1_ABLEMDIO_AN_STAT1_LPABLEMDIO_STAT1_FAULTMDIO_STAT1_LSTATUSMDIO_STAT1_LPOWERABLEMDIO_CTRL1_SPEED10P2B(MDIO_CTRL1_SPEEDSELEXT | 0x04)MDIO_CTRL1_SPEED10G(MDIO_CTRL1_SPEEDSELEXT | 0x00)MDIO_PCS_CTRL1_CLKSTOP_ENMDIO_AN_CTRL1_XNPMDIO_AN_CTRL1_ENABLEMDIO_AN_CTRL1_RESTARTMDIO_PHYXS_CTRL1_LOOPBACKMDIO_PCS_CTRL1_LOOPBACKMDIO_PMA_CTRL1_SPEED100MDIO_PMA_CTRL1_SPEED1000MDIO_PMA_CTRL1_LOOPBACKMDIO_CTRL1_RESETMDIO_CTRL1_LPOWERMDIO_CTRL1_FULLDPLXMDIO_CTRL1_SPEEDSEL(MDIO_CTRL1_SPEEDSELEXT | 0x003c)MDIO_CTRL1_SPEEDSELEXT(BMCR_SPEED1000 | BMCR_SPEED100)MDIO_PMA_LASI_STAT0x9005MDIO_PMA_LASI_TXSTAT0x9004MDIO_PMA_LASI_RXSTAT0x9003MDIO_PMA_LASI_CTRL0x9002MDIO_PMA_LASI_TXCTRL0x9001MDIO_PMA_LASI_RXCTRLMDIO_AN_10GBT_STATMDIO_AN_10GBT_CTRLMDIO_PCS_10GBRT_STAT2MDIO_PCS_10GBRT_STAT1MDIO_PCS_10GBX_STAT1MDIO_PMA_10GBR_FECABLEMDIO_PMA_10GBT_SNRMDIO_PMA_10GBT_TXPWRMDIO_PMA_10GBT_SWAPPOLMDIO_AN_EEE_LPABLEMDIO_AN_EEE_ADVMDIO_PHYXS_LNSTATMDIO_PCS_EEE_WK_ERRMDIO_PCS_EEE_ABLEMDIO_AN_LPAMDIO_AN_ADVERTISEMDIO_PKGID2MDIO_PKGID1MDIO_PMA_EXTABLEMDIO_PMA_RXDETMDIO_PMA_TXDISMDIO_STAT2MDIO_CTRL2MDIO_DEVS2MDIO_DEVS1MDIO_SPEEDMDIO_DEVID2MDIO_DEVID1MDIO_STAT1MDIO_CTRL1MDIO_MMD_VEND2MDIO_MMD_VEND1MDIO_MMD_C22EXTMDIO_MMD_ANMDIO_MMD_TCMDIO_MMD_DTEXSMDIO_MMD_PHYXSMDIO_MMD_PCSMDIO_MMD_WISMDIO_MMD_PMAPMD__LINUX_MDIO_H__/* __LINUX_MDIO_H__ *//* Mapping between MDIO PRTAD/DEVAD and mii_ioctl_data::phy_id *//* RX_ALARM enable/status *//* TX_ALARM enable/status *//* LS_ALARM enable/status *//* LASI control/status registers. *//* Laser bias current fault *//* Laser temperature fault *//* Laser output power fault *//* PMA/PMD TX local fault *//* PCS TX local fault *//* PHY XS TX local fault *//* LASI TX_ALARM control/status registers. *//* WIS local fault *//* RX optical power fault *//* PMA/PMD RX local fault *//* PCS RX local fault *//* PHY XS RX local fault *//* LASI RX_ALARM control/status registers. *//* 10G KR EEE cap *//* 10G KX4 EEE cap *//* 1000KX EEE cap *//* 10GT EEE cap *//* 1000T EEE cap *//* 100TX EEE cap *//* Note: the two defines above can be potentially used by the user-land
 * and cannot remove them now.
 * So, we define the new generic MDIO_EEE_100TX and MDIO_EEE_1000T macros
 * using the previous ones (that can be considered obsolete).
 *//* Advertise 1000T EEE cap *//* Advertise 100TX EEE cap *//* EEE Supported/Advertisement/LP Advertisement registers.
 *
 * EEE capability Register (3.20), Advertisement (7.60) and
 * Link partner ability (7.61) registers have and can use the same identical
 * bit masks.
 *//* Master/slave config fault *//* Master/slave config *//* Local OK *//* Remote OK *//* LP is 10GBT capable *//* LP loop timing ability *//* LP training reset req. *//* AN 10GBASE-T status register. *//* Advertise 10GBASE-T *//* AN 10GBASE-T control register. *//* PCS 10GBASE-R/-T status register 2. *//* Block lock attained *//* PCS 10GBASE-R/-T status register 1. *//* FEC error indic. ability *//* FEC ability *//* PMA 10GBASE-R FEC ability register. *//* Value is SNR margin in dB, clamped to range [-127, 127], plus 0x8000. *//* PMA 10GBASE-T SNR registers. *//* Short-reach mode *//* PMA 10GBASE-T TX power register. *//* Pair D polarity reversed *//* Pair C polarity reversed *//* Pair B polarity reversed *//* Pair A polarity reversed *//* Pair C/D uncrossed *//* Pair A/B uncrossed *//* PMA 10GBASE-T pair swap & polarity *//* PHY XGXS lane state register. *//* 10BASE-T ability *//* 100BASE-TX ability *//* 1000BASE-KX ability *//* 1000BASE-T ability *//* 10GBASE-KR ability *//* 10GBASE-KX4 ability *//* 10GBASE-T ability *//* 10GBASE-LRM ability *//* 10GBASE-CX4 ability *//* Extended abilities register. *//* PMD RX signal detect 3 *//* PMD RX signal detect 2 *//* PMD RX signal detect 1 *//* PMD RX signal detect 0 *//* Global PMD RX signal detect *//* Receive signal detect register. *//* PMD TX disable 3 *//* PMD TX disable 2 *//* PMD TX disable 1 *//* PMD TX disable 0 *//* Global PMD TX disable *//* Transmit disable register. *//* Transmit fault ability *//* Receive fault ability *//* 10GBASE-W capable *//* 10GBASE-X capable *//* 10GBASE-R capable *//* Extended abilities *//* PMD TX disable ability *//* 10GBASE-SR ability *//* 10GBASE-LR ability *//* 10GBASE-ER ability *//* 10GBASE-LX4 ability *//* 10GBASE-SW ability *//* 10GBASE-LW ability *//* 10GBASE-EW ability *//* PMA loopback ability *//* Device present value *//* Device present *//* Transmit fault *//* Receive fault *//* Status register 2. *//* 10GBASE-T type *//* 10GBASE-W type *//* 10GBASE-X type *//* 10GBASE-R type *//* PCS type selection *//* 10BASE-T type *//* 100BASE-TX type *//* 1000BASE-KX type *//* 1000BASE-T type *//* 10GBASE-KR type *//* 10GBASE-KX4 type *//* 10GBASE-LRM type *//* 10GBASE-SR type *//* 10GBASE-LR type *//* 10GBASE-ER type *//* 10GBASE-LX4 type *//* 10GBASE-SW type *//* 10GBASE-LW type *//* 10GBASE-EW type *//* 10GBASE-CX4 type *//* PMA/PMD type selection *//* Control register 2. *//* Device present registers. *//* 10PASS-TS/2BASE-TL capable *//* 10M capable *//* 100M capable *//* 1000M capable *//* 10PASS-TS capable *//* 2BASE-TL capable *//* 10G capable *//* Speed register. *//* Extended next page status *//* Page received *//* Link partner AN ability *//* Fault *//* Low-power ability *//* Status register 1. *//* 10PASS-TS/2BASE-TL *//* 10 Gb/s *//* Stop the clock during LPI *//* Enable extended next page *//* All speed selection bits *//* Enable extended speed selection *//* Control register 1. *//* LASI status *//* TX_ALARM status *//* RX_ALARM status *//* LASI control *//* TX_ALARM control *//* RX_ALARM control *//* LASI (Link Alarm Status Interrupt) registers, defined by XENPAK MSA. *//* 10GBASE-T auto-negotiation status *//* 10GBASE-T auto-negotiation control *//* 10GBASE-R/-T PCS status 2 *//* 10GBASE-R/-T PCS status 1 *//* 10GBASE-X PCS status 1 *//* 10GBASE-R FEC ability *//* 10GBASE-T SNR margin, lane A.
					 * Lanes B-D are numbered 134-136. *//* 10GBASE-T TX power control *//* 10GBASE-T pair swap & polarity *//* Media-dependent registers. *//* EEE link partner ability *//* EEE advertisement *//* PHY XGXS lane state *//* EEE wake error counter *//* EEE Capability register *//* AN LP abilities (base page) *//* AN advertising (base page) *//* Package identifier *//* 10G PMA/PMD extended ability *//* 10G PMA/PMD receive signal detect *//* 10G PMA/PMD transmit disable *//* 10G status 2 *//* 10G control 2 *//* Devices in package *//* Speed ability *//* Generic MDIO registers. *//* Vendor specific 2 *//* Vendor specific 1 *//* Clause 22 extension *//* Auto-Negotiation *//* Transmission Convergence *//* DTE Extender Sublayer *//* PHY Extender Sublayer *//* Physical Coding Sublayer *//* WAN Interface Sublayer *//* Physical Medium Attachment/
					 * Physical Medium Dependent *//* MDIO Manageable Devices (MMDs). *//*
 * linux/mdio.h: definitions for MDIO (clause 45) transceivers
 * Copyright 2006-2009 Solarflare Communications Inc.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation, incorporated herein by reference.
 */<linux/mii.h>prtadphy_interfacephy_string_for_interfacePHY_INTERFACE_MODE_NONEconst char *const[22]char *[22]phy_interface_tPHY_INTERFACE_MODE_MIIPHY_INTERFACE_MODE_GMIIPHY_INTERFACE_MODE_SGMIIPHY_INTERFACE_MODE_SGMII_2500PHY_INTERFACE_MODE_QSGMIIPHY_INTERFACE_MODE_TBIPHY_INTERFACE_MODE_RMIIPHY_INTERFACE_MODE_RGMIIPHY_INTERFACE_MODE_RGMII_IDPHY_INTERFACE_MODE_RGMII_RXIDPHY_INTERFACE_MODE_RGMII_TXIDPHY_INTERFACE_MODE_RTBIPHY_INTERFACE_MODE_XGMIIPHY_INTERFACE_MODE_XAUIPHY_INTERFACE_MODE_RXAUIPHY_INTERFACE_MODE_SFIPHY_INTERFACE_MODE_INTERNALPHY_INTERFACE_MODE_25G_AUIPHY_INTERFACE_MODE_XLAUIPHY_INTERFACE_MODE_CAUI2PHY_INTERFACE_MODE_CAUI4PHY_INTERFACE_MODE_COUNT"mii"gmii"gmii"sgmii"sgmii"sgmii-2500"sgmii-2500"qsgmii"qsgmii"tbi"tbi"rmii"rmii"rgmii"rgmii"rgmii-id"rgmii-id"rgmii-rxid"rgmii-rxid"rgmii-txid"rgmii-txid"rtbi"rtbi"xgmii"xgmii"xaui"xaui"rxaui"rxaui"sfi"sfi"internal"internal"25g-aui"25g-aui"xlaui4"xlaui4"caui2"caui2"caui4"caui4"phy_interface_strings_PHY_INTERFACE_H/* _PHY_INTERFACE_H *//* Default to unknown *//* Must be last *//*
 * Copyright 2011 Freescale Semiconductor, Inc.
 *	Andy Fleming <afleming@gmail.com>
 *
 * This file pretty much stolen from Linux's mii.h/ethtool.h/phy.h
 */phyphy_interface_is_sgmiiphy_interface_is_rgmiiphy_get_interface_by_nameget_phy_idboard_phy_configphy_fixed_initphy_mscc_initphy_xilinx_initphy_vitesse_initphy_ti_initphy_teranetics_initphy_smsc_initphy_realtek_initphy_natsemi_initphy_meson_gxl_initphy_micrel_ksz90x1_initphy_micrel_ksz8xxx_initphy_marvell_initphy_lxt_initphy_et1011c_initphy_davicom_initphy_cortina_initphy_broadcom_initphy_atheros_initphy_aquantia_initphy_mv88e61xx_initphy_b53_initgen10g_discover_mmdsgen10g_shutdowngen10g_startupgen10g_configgenphy_shutdowngenphy_startupgenphy_configgenphy_parse_linkgenphy_update_linkgenphy_restart_aneggenphy_config_anegphy_set_supportedphy_registerphy_shutdownphy_configphy_startupphy_get_ofnodephy_connectphy_connect_devphy_find_by_maskphy_resetphy_initphy_write_mmd(u16)~0PHY_10G_FEATURES7047197674863phy_read_mmd<phy_interface.h><linux/mdio.h><linux/ethtool.h>regnumphy_mmd_start_indirectphy_writephy_readfixed_linkmii_devphy_devicephy_driverasym_pauselink_speedphy_idphy_maskPHY_MAX_ADDRphymapis_c45mmdswrite_mmdread_mmdwriteextreadextstartupMDIO_NAME_LENPHY_UID_IN112525_S030x02107440PHY_UID_TN20200x00a19410PHY_UID_CS42230x03e57003PHY_UID_CS43400x13e51002PHY_ANEG_TIMEOUT4000(PHY_GBIT_FEATURES | SUPPORTED_10000baseT_Full)PHY_GBIT_FEATURES(PHY_BASIC_FEATURES | PHY_1000BT_FEATURES)PHY_BASIC_FEATURES(PHY_10BT_FEATURES | PHY_100BT_FEATURES | PHY_DEFAULT_FEATURES)PHY_1000BT_FEATURES(SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full)PHY_100BT_FEATURES(SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full)PHY_10BT_FEATURES(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full)PHY_DEFAULT_FEATURES(SUPPORTED_Autoneg | SUPPORTED_TP | SUPPORTED_MII)PHY_FLAG_BROKEN_RESETPHY_FIXED_ID0xa5a55a5a_PHY_HCONFIG_PHYLIB_10G/* PHY UIDs for various PHYs that are referenced in external code *//**
 * phy_interface_is_sgmii - Convenience function for testing if a PHY interface
 * is SGMII (all variants)
 * @phydev: the phy_device struct
 *//**
 * phy_interface_is_rgmii - Convenience function for testing if a PHY interface
 * is RGMII (all variants)
 * @phydev: the phy_device struct
 *//**
 * phy_get_interface_by_name() - Look up a PHY interface name
 *
 * @str:	PHY interface name, e.g. "mii"
 * @return PHY_INTERFACE_MODE_... value, or -1 if not found
 *//**
 * phy_connect() - Creates a PHY device for the Ethernet interface
 *
 * Creates a PHY device for the PHY at the given address, if one doesn't exist
 * already, and associates it with the Ethernet device.
 * The function may be called with addr <= 0, in this case addr value is ignored
 * and the bus is scanned to detect a PHY.  Scanning should only be used if only
 * one PHY is expected to be present on the MDIO bus, otherwise it is undefined
 * which PHY is returned.
 *
 * @bus:	MII/MDIO bus that hosts the PHY
 * @addr:	PHY address on MDIO bus
 * @dev:	Ethernet device to associate to the PHY
 * @interface:	type of MAC-PHY interface
 * @return pointer to phy_device if a PHY is found, or NULL otherwise
 *//**
 * phy_connect_dev() - Associates the given pair of PHY and Ethernet devices
 * @phydev:	PHY device
 * @dev:	Ethernet device
 *//**
 * phy_find_by_mask() - Searches for a PHY on the specified MDIO bus
 *
 * The function checks the PHY addresses flagged in phy_mask and returns a
 * phy_device pointer if it detects a PHY.
 * This function should only be called if just one PHY is expected to be present
 * in the set of addresses flagged in phy_mask.  If multiple PHYs are present,
 * it is undefined which of these PHYs is returned.
 *
 * @bus:	MII/MDIO bus to scan
 * @phy_mask:	bitmap of PYH addresses to scan
 * @interface:	type of MAC-PHY interface
 * @return pointer to phy_device if a PHY is found, or NULL otherwise
 *//**
 * phy_reset() - Resets the specified PHY
 *
 * Issues a reset of the PHY and waits for it to complete
 *
 * @phydev:	PHY to reset
 * @return 0 if OK, -ve on error
 *//**
 * phy_init() - Initializes the PHY drivers
 *
 * This function registers all available PHY drivers
 *
 * @return 0 if OK, -ve on error
 *//* For now, XGMII is the only 10G interface *//* Write the data into MMD's selected register *//* indirect C22 access *//* direct C45 / C22 access *//* driver-specific access *//* Read the content of the MMD's selected register *//* Select the Function : DATA with no post increment *//* Write the desired MMD register address *//* Write the desired MMD Devad *//* The most recently read link state *//* forced speed & duplex (no autoneg)
	 * partner speed & duplex & pause (autoneg)
	 *//* And management functions *//* Information about the PHY type *//* Phy specific driver override for writing a MMD register *//* Phy specific driver override for reading a MMD register *//* Called when bringing down the controller *//* Called when starting up the controller *//* Called to configure the PHY, and modify the controller
	 * based on the results.  Should be called after phy_connect *//* Will be called during phy_connect *//* Called to do any driver startup necessities *//* struct phy_driver: a structure which defines PHY behavior
 *
 * uid will contain a number which represents the PHY.  During
 * startup, the driver will poll the PHY to find out what its
 * UID--as defined by registers 2 and 3--is.  The 32-bit result
 * gotten from the PHY will be masked to
 * discard any bits which may change based on revision numbers
 * unimportant to functionality
 *
 *//* soft reset not supported */miiphydm_mdio_phy_connectdm_mdio_probe_devicesmdio_list_devicesmdio_unregistermdio_register_seqmdio_registermdio_freemdio_allocmiiphy_listdevmdio_phydev_for_ethnamemiiphy_get_dev_by_namemdio_get_list_headmdio_get_current_devmiiphy_get_current_devmiiphy_set_current_devmiiphy_initmiiphy_is_1000base_xmiiphy_duplexmiiphy_speedmiiphy_resetmiiphy_infomiiphy_writemiiphy_readmdio_mux_opsmdio_opsmdio_perdev_privmii_busmdio_mux_get_ops(dev)((struct mdio_mux_ops *)(dev)->driver->ops)MDIO_MUX_SELECT_NONEmdio_get_ops(dev)((struct mdio_ops *)(dev)->driver->ops)ESTATUS_1000XHESTATUS_1000XFPHY_1000BTSR_1000HDPHY_1000BTSR_1000FDPHY_1000BTSR_RRSPHY_1000BTSR_LRSPHY_1000BTSR_MSCRPHY_1000BTSR_MSCFPHY_1000BTCR_1000HDPHY_1000BTCR_1000FDPHY_ANLPAR_PSB_802_9PHY_ANLPAR_PSB_802_3MII_MIPSCRFULLHALF_10BASET_100BASET_1000BASETAUTO_miiphy_h_CONFIG_SYS_FAULT_ECHO_LINK_DOWNCONFIG_BITBANGMIICONFIG_BITBANGMII_MULTICONFIG_DM_MDIO_MUX/**
 * struct mdio_mux_ops - MDIO MUX operations
 *
 * @select: Selects a child bus
 * @deselect: Clean up selection.  Optional, can be NULL
 *//* indicates none of the child buses is selected *//**
 * dm_mdio_phy_connect - Wrapper over phy_connect for DM MDIO
 *
 * @dev: mdio dev
 * @addr: PHY address on MDIO bus
 * @ethdev: ethernet device to connect to the PHY
 * @interface: MAC-PHY protocol
 *
 * @return pointer to phy_device, or 0 on error
 *//**
 * dm_mdio_probe_devices - Call probe on all MII devices, currently used for
 * MDIO console commands.
 *//**
 * struct mdio_ops - MDIO bus operations
 *
 * @read: Read from a PHY register
 * @write: Write to a PHY register
 * @reset: Reset the MDIO bus, NULL if not supported
 *//**
 * struct mdio_perdev_priv - Per-device class data for MDIO DM
 *
 * @mii_bus: Supporting MII legacy bus
 *//* phy EXSR *//* MII_STAT1000 masks *//* MII_CTRL1000 masks *//* MII_LPA *//* phy register offsets *//* phy seed setup *//**
 * mdio_register_seq - Register mdio bus with sequence number
 * @bus: mii device structure
 * @seq: sequence number
 *
 * Return: 0 if success, negative value if error
 *//*----------------------------------------------------------------------------+
|
|  File Name:	miiphy.h
|
|  Function:	Include file defining PHY registers.
|
|  Author:	Mark Wisner
|
+----------------------------------------------------------------------------*//*
 * Additions (C) Copyright 2009 Industrie Dial Face S.p.A.
 *//* SPDX-License-Identifier: GPL-2.0 OR IBM-pibs */ethdevoui/opt/src/cmd/mii.cdo_miide"de"Incorrect PHY address. Range should be 0-31
"Incorrect PHY address. Range should be 0-31\n"PHY 0x%02X: OUI = 0x%04X, Model = 0x%02X, Rev = 0x%02X, %3dbase%s, %s
"PHY 0x%02X: "
					"OUI = 0x%04X, "
					"Model = 0x%02X, "
					"Rev = 0x%02X, "
					"%3dbase%s, %s\n"XT"T"FDX"FDX"HDX"HDX"Error reading from the PHY addr=%02x reg=%02x
"Error reading from the PHY addr=%02x reg=%02x\n"addr=%02x reg=%02x data="addr=%02x reg=%02x data="%04X
"%04X\n"Error writing to the PHY addr=%02x reg=%02x
"Error writing to the PHY addr=%02x reg=%02x\n"Error reading from the PHY"Error reading from the PHY" addr=%02x" addr=%02x" reg=%02x
" reg=%02x\n"Error writing to the PHY"Error writing to the PHY"du"du"ushort[11]unsigned short[11]MII_STAT1000 + 1regsokThe MII dump command only formats the standard MII registers, 0-5, 9-a.
"The MII dump command only formats the standard MII registers, 0-5, 9-a.\n"char[73]const ushortconst ushort *special_fieldconst MII_field_desc_tconst MII_field_desc_t *_MII_field_desc_t *speed_bits8256BMCR_SPEED1000 | BMCR_SPEED100%2u,%2u =   b%u%u    speed selection = %s Mbps"%2u,%2u =   b%u%u    speed selection = %s Mbps""1000""100""10" = %s" = %s"full"full"half"half"sel_bitsIEEE 802.3 CSMA/CD"IEEE 802.3 CSMA/CD"IEEE 802.9 ISLAN-16T"IEEE 802.9 ISLAN-16T"dump_regregnopdescregvalconst MII_reg_desc_tconst MII_reg_desc_t *_MII_reg_desc_t *%u.     (%04hx)                 -- %s --
"%u.     (%04hx)                 -- %s --\n"mask_in_place  (%04hx:%04x) %u."  (%04hx:%04x) %u."dump_field%2u   "%2u   "%2u-%2u"%2u-%2u" = %5u	  %s" = %5u	  %s"MII_dumpconst MII_reg_desc_t[8]_MII_reg_desc_t[8]mii_reg_desc_tblARRAY_SIZE(mii_reg_desc_tbl)const ucharMII_reg_desc_t_MII_reg_desc_tMII_field_desc_t_MII_field_desc_thi"MII utility commands""device                            - list available devices\n" "mii device <devname>                  - set current device\n" "mii info   <addr>                     - display MII PHY info\n" "mii read   <addr> <reg>               - read  MII PHY <addr> register <reg>\n" "mii write  <addr> <reg> <data>        - write MII PHY <addr> register <reg>\n" "mii modify <addr> <reg> <data> <mask> - modify MII PHY <addr> register <reg>\n" "                                        updating bits identified in <mask>\n" "mii dump   <addr> <reg>               - pretty-print <addr> <reg> (0-5 only)\n" "Addr and/or reg may be ranges, e.g. 2-7."MII utility commandsdevice                            - list available devices
mii device <devname>                  - set current device
mii info   <addr>                     - display MII PHY info
mii read   <addr> <reg>               - read  MII PHY <addr> register <reg>
mii write  <addr> <reg> <data>        - write MII PHY <addr> register <reg>
mii modify <addr> <reg> <data> <mask> - modify MII PHY <addr> register <reg>
                                        updating bits identified in <mask>
mii dump   <addr> <reg>               - pretty-print <addr> <reg> (0-5 only)
Addr and/or reg may be ranges, e.g. 2-7."device                            - list available devices\n"
	"mii device <devname>                  - set current device\n"
	"mii info   <addr>                     - display MII PHY info\n"
	"mii read   <addr> <reg>               - read  MII PHY <addr> register <reg>\n"
	"mii write  <addr> <reg> <data>        - write MII PHY <addr> register <reg>\n"
	"mii modify <addr> <reg> <data> <mask> - modify MII PHY <addr> register <reg>\n"
	"                                        updating bits identified in <mask>\n"
	"mii dump   <addr> <reg>               - pretty-print <addr> <reg> (0-5 only)\n"
	"Addr and/or reg may be ranges, e.g. 2-7."char[601]U_BOOT_CMD(
	mii, 6, 1, do_mii,
	"MII utility commands",
	"device                            - list available devices\n"
	"mii device <devname>                  - set current device\n"
	"mii info   <addr>                     - display MII PHY info\n"
	"mii read   <addr> <reg>               - read  MII PHY <addr> register <reg>\n"
	"mii write  <addr> <reg> <data>        - write MII PHY <addr> register <reg>\n"
	"mii modify <addr> <reg> <data> <mask> - modify MII PHY <addr> register <reg>\n"
	"                                        updating bits identified in <mask>\n"
	"mii dump   <addr> <reg>               - pretty-print <addr> <reg> (0-5 only)\n"
	"Addr and/or reg may be ranges, e.g. 2-7."
)_u_boot_list_2_cmd_2_mii.u_boot_list_2_cmd_2_miilast_maskconst MII_reg_desc_t[]_MII_reg_desc_t[]reg_0_desc_tblreg_1_desc_tblreg_2_desc_tblreg_3_desc_tblreg_4_desc_tblreg_5_desc_tblreg_9_desc_tblreg_10_desc_tblconst MII_field_desc_t[10]_MII_field_desc_t[10]ARRAY_SIZE(reg_0_desc_tbl)PHY control register"PHY control register"const MII_field_desc_t[16]_MII_field_desc_t[16]ARRAY_SIZE(reg_1_desc_tbl)PHY status register"PHY status register"const MII_field_desc_t[1]_MII_field_desc_t[1]ARRAY_SIZE(reg_2_desc_tbl)PHY ID 1 register"PHY ID 1 register"const MII_field_desc_t[3]_MII_field_desc_t[3]ARRAY_SIZE(reg_3_desc_tbl)PHY ID 2 register"PHY ID 2 register"const MII_field_desc_t[12]_MII_field_desc_t[12]ARRAY_SIZE(reg_4_desc_tbl)Autonegotiation advertisement register"Autonegotiation advertisement register"ARRAY_SIZE(reg_5_desc_tbl)Autonegotiation partner abilities register"Autonegotiation partner abilities register"const MII_field_desc_t[8]_MII_field_desc_t[8]ARRAY_SIZE(reg_9_desc_tbl)1000BASE-T control register"1000BASE-T control register"ARRAY_SIZE(reg_10_desc_tbl)1000BASE-T status register"1000BASE-T status register"const MII_field_desc_t[]_MII_field_desc_t[]master/slave config fault"master/slave config fault"master/slave config result"master/slave config result"local receiver status OK"local receiver status OK"remote receiver status OK"remote receiver status OK"1000BASE-T full duplex able"1000BASE-T full duplex able"1000BASE-T half duplex able"1000BASE-T half duplex able"(reserved)"(reserved)"1000BASE-T idle error counter"1000BASE-T idle error counter"test mode"test mode"manual master/slave enable"manual master/slave enable"manual master/slave value"manual master/slave value"multi/single port"multi/single port"automatic TDR on link down"automatic TDR on link down"next page able"next page able"acknowledge"acknowledge"remote fault"remote fault"asymmetric pause able"asymmetric pause able"pause able"pause able"prdregvals100BASE-T4 able"100BASE-T4 able"100BASE-X full duplex able"100BASE-X full duplex able"100BASE-TX able"100BASE-TX able"10BASE-T full duplex able"10BASE-T full duplex able"10BASE-T able"10BASE-T able"partner selector"partner selector"asymmetric pause"asymmetric pause"pause enable"pause enable"100BASE-TX full duplex able"100BASE-TX full duplex able"10BASE-T   full duplex able"10BASE-T   full duplex able"10BASE-T   able"10BASE-T   able"selector"selector"OUI portion"OUI portion"manufacturer part number"manufacturer part number"manufacturer rev. number"manufacturer rev. number"100BASE-X  full duplex able"100BASE-X  full duplex able"100BASE-X  half duplex able"100BASE-X  half duplex able"10 Mbps    full duplex able"10 Mbps    full duplex able"10 Mbps    half duplex able"10 Mbps    half duplex able"100BASE-T2 full duplex able"100BASE-T2 full duplex able"100BASE-T2 half duplex able"100BASE-T2 half duplex able"extended status"extended status"MF preamble suppression"MF preamble suppression"A/N complete"A/N complete"A/N able"A/N able"link status"link status"jabber detect"jabber detect"extended capabilities"extended capabilities"loopback"loopback"0x81speed selection"speed selection"A/N enable"A/N enable"power-down"power-down"isolate"isolate"restart A/N"restart A/N""duplex"collision test enable"collision test enable"defined(CONFIG_MII_INIT)/* Last reg is 0x0a *//*
		 * Look for any and all PHYs.  Valid addresses are 0..31.
		 *//*
	 * check info/read/write.
	 *//* use current device *//* Special fields:
** 0.6,13
** 0.8
** 2.15-0
** 3.15-0
** 4.4-0
** 5.4-0
*//* Print out field position, value, name *//* special *//*
 * MII Utilities
 *//*
 * (C) Copyright 2001
 * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
 *//opt/src/cmd/misc.cmiscdo_timer"get"msecs%ld.%03d
"%ld.%03d\n"do_sleepfrpartmultCONFIG_SYS_HZ / 10"access the system timer""start - Reset the timer reference.\n" "timer get   - Print the time since 'start'."access the system timerstart - Reset the timer reference.
timer get   - Print the time since 'start'."start - Reset the timer reference.\n"
	"timer get   - Print the time since 'start'."char[79]U_BOOT_CMD(
	timer,    2,    1,     do_timer,
	"access the system timer",
	"start - Reset the timer reference.\n"
	"timer get   - Print the time since 'start'."
)_u_boot_list_2_cmd_2_timer.u_boot_list_2_cmd_2_timer"delay execution for some time""N\n" "    - delay execution for N seconds (N is _decimal_ and can be\n" "      fractional)"delay execution for some timeN
    - delay execution for N seconds (N is _decimal_ and can be
      fractional)"N\n"
	"    - delay execution for N seconds (N is _decimal_ and can be\n"
	"      fractional)"U_BOOT_CMD(
	sleep ,    2,    1,     do_sleep,
	"delay execution for some time",
	"N\n"
	"    - delay execution for N seconds (N is _decimal_ and can be\n"
	"      fractional)"
)_u_boot_list_2_cmd_2_sleep.u_boot_list_2_cmd_2_sleepCONFIG_CMD_TIMER/*
 * Misc functions
 *//opt/src/cmd/mtdparts.cmtdpartsdo_mtdparts"mtdids""mtdparts"partition"partition"delall"delall"PART_ADD_DESC_MAXLENtmpbufdev_tmpno such device %s defined in mtdids variable
"no such device %s defined in mtdids variable\n"too long partition description
"too long partition description\n"%s:%s(%s)%s"%s:%s(%s)%s""add tmpbuf: %s\n"debug("add tmpbuf: %s\n", tmpbuf)cmd/mtdparts.c2021add tmpbuf: %s
"+ %s\t%d\t%s\n"MTD_DEV_TYPE(dev->id->type), dev->id->num, dev->id->mtd_iddebug("+ %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id)2027+ %s	%d	%s
dev->id->typenoronenandspi-nanddev->parts.nextstruct part_infolist_entry(dev->parts.next, struct part_info, link)char[513]MTDPARTS_MAXLENMTDPARTS_MAXLEN + 1generated mtdparts too long, resetting to null
"generated mtdparts too long, resetting to null\n""del: part-id = %s\n"argv[2]debug("del: part-id = %s\n", argv[2])2060del: part-id = %s
do_chpartno partition id specified
"no partition id specified\n"pnumpartition changed to %s%d,%d
"partition changed to %s%d,%d\n"MTD_DEV_TYPE(dev->id->type)mtd_part_info"\n--- mtd_part_info: partition number %d for device %s%d (%s)\n"part_num, MTD_DEV_TYPE(dev->id->type), dev->id->num, dev->id->mtd_iddebug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id)1881
--- mtd_part_info: partition number %d for device %s%d (%s)
char[62]invalid partition number %d for device %s%d (%s)
"invalid partition number %d for device %s%d (%s)\n"&dev->partslist_entry(entry, struct part_info, link)"\n---mtdparts_init---\n"debug("\n---mtdparts_init---\n")1729
---mtdparts_init---
initializedchar[129]MTDIDS_MAXLENMTDIDS_MAXLEN + 1sizeof(last_ids)sizeof(last_parts)PARTITION_MAXLENPARTITION_MAXLEN + 1sizeof(last_partition)char[512]tmp_partscurrent_partitionsizeof(tmp_parts)tmp_epsizeof(tmp_ep)"last_ids  : %s\n"last_idsdebug("last_ids  : %s\n", last_ids)1755last_ids  : %s
"env_ids   : %s\n"debug("env_ids   : %s\n", ids)1756env_ids   : %s
"last_parts: %s\n"last_partsdebug("last_parts: %s\n", last_parts)1757last_parts: %s
"env_parts : %s\n\n"debug("env_parts : %s\n\n", parts)1758env_parts : %s

"last_partition : %s\n"last_partitiondebug("last_partition : %s\n", last_partition)1760last_partition : %s
"env_partition  : %s\n"debug("env_partition  : %s\n", current_partition)1761env_partition  : %s
"mtdids variable not defined, using default\n"debug("mtdids variable not defined, using default\n")1766mtdids variable not defined, using default
mtdids not defined, no default present
"mtdids not defined, no default present\n"MTDIDS_MAXLEN - 1mtdids too long (> %d)
"mtdids too long (> %d)\n"mtdparts variable not set, see 'help mtdparts'
"mtdparts variable not set, see 'help mtdparts'\n"MTDPARTS_MAXLEN - 1mtdparts too long (> %d)
"mtdparts too long (> %d)\n"ids_changedmtdparts_init: no valid partitions
"mtdparts_init: no valid partitions\n"devices.nextstruct mtd_devicelist_entry(devices.next, struct mtd_device, link)"mtdparts_init: current_mtd_dev  = %s%d, current_mtd_partnum = %d\n"MTD_DEV_TYPE(current_mtd_dev->id->type), current_mtd_dev->id->num, current_mtd_partnumdebug("mtdparts_init: current_mtd_dev  = %s%d, current_mtd_partnum = %d\n",
				MTD_DEV_TYPE(current_mtd_dev->id->type),
				current_mtd_dev->id->num, current_mtd_partnum)1830mtdparts_init: current_mtd_dev  = %s%d, current_mtd_partnum = %d
char[66]current_mtd_dev->id->type"--- getting current partition: %s\n"debug("--- getting current partition: %s\n", tmp_ep)1847--- getting current partition: %s
"no partition variable set, setting...\n"debug("no partition variable set, setting...\n")1855no partition variable set, setting...
parse_mtdids"\n---parse_mtdids---\nmtdids = %s\n\n"debug("\n---parse_mtdids---\nmtdids = %s\n\n", ids)1622
---parse_mtdids---
mtdids = %s

&mtdidsid_tmpstruct mtdidslist_entry(entry, struct mtdids, link)"mtdids del: %d %d\n"id_tmp->type, id_tmp->numdebug("mtdids del: %d %d\n", id_tmp->type, id_tmp->num)1627mtdids del: %d %d
double_entry'='mtdids: incorrect <dev-num>
"mtdids: incorrect <dev-num>\n"mtd_id_lenmtdids: no <mtd-id> identifier
"mtdids: no <mtd-id> identifier\n"device id %s%d redefined, please correct mtdids variable
"device id %s%d redefined, please correct mtdids variable\n"sizeof(struct mtdids)out of memory
"out of memory\n""+ id %s%d\t%16lld bytes\t%s\n"MTD_DEV_TYPE(id->type), id->num, id->size, id->mtd_iddebug("+ id %s%d\t%16lld bytes\t%s\n",
				MTD_DEV_TYPE(id->type), id->num,
				id->size, id->mtd_id)1695+ id %s%d	%16lld bytes	%s
id->typeparse_mtdparts"\n---parse_mtdparts---\nmtdparts = %s\n\n"debug("\n---parse_mtdparts---\nmtdparts = %s\n\n", mtdparts)1559
---parse_mtdparts---
mtdparts = %s

could not initialise device list
"could not initialise device list\n"mtdparts="mtdparts=""+ device: %s\t%d\t%s\n"debug("+ device: %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id)1582+ device: %s	%d	%s
device %s%d redefined, please correct mtdparts variable
"device %s%d redefined, please correct mtdparts variable\n"env_get_mtdpartsdelete_partition"delete_partition: device = %s%d, partition %d = (%s) 0x%08llx@0x%08llx\n"MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum, part->name, part->size, part->offsetdebug("delete_partition: device = %s%d, partition %d = (%s) 0x%08llx@0x%08llx\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum,
				part->name, part->size, part->offset)1417delete_partition: device = %s%d, partition %d = (%s) 0x%08llx@0x%08llx
char[72]partition %s not found
"partition %s not found\n""--- find_dev_and_part ---\nid = %s\n"debug("--- find_dev_and_part ---\nid = %s\n", id)1354--- find_dev_and_part ---
id = %s
dentry&deviceslist_entry(dentry, struct mtd_device, link)pentry&(*dev)->partslist_entry(pentry, struct part_info, link)dnumno partition number specified
"no partition number specified\n"unexpected trailing character '%c'
"unexpected trailing character '%c'\n"no such device %s%d
"no such device %s%d\n"no such partition
"no such partition\n"list_partitions"\n---list_partitions---\n"debug("\n---list_partitions---\n")1308
---list_partitions---

active partition: %s%d,%d - (%s) 0x%08llx @ 0x%08llx
"\nactive partition: %s%d,%d - (%s) 0x%08llx @ 0x%08llx\n"char[55]MTD_DEV_TYPE(current_mtd_dev->id->type)could not get current partition info

"could not get current partition info\n\n"
defaults:
"\ndefaults:\n"mtdids  : %s
"mtdids  : %s\n"mtdparts: "mtdparts: "print_partition_table
device %s%d <%s>, # parts = %d
"\ndevice %s%d <%s>, # parts = %d\n" #: name		size		offset		mask_flags
" #: name\t\tsize\t\toffset\t\tmask_flags\n"%2d: %-20s0x%08llx	0x%08llx	%d
"%2d: %-20s0x%08llx\t0x%08llx\t%d\n"no partitions defined
"no partitions defined\n"generate_mtdparts_savegenerate_mtdparts"--- generate_mtdparts ---\n"debug("--- generate_mtdparts ---\n")1095--- generate_mtdparts ---
prev_partpart_cnt'@''('')'MTD_WRITEABLE_CMD'o'"nand""nor""onenand""spi-nand"incorrect device type in %s
"incorrect device type in %s\n"*pisdigit(*p)incorrect device number in %s
"incorrect device number in %s\n"id_find_by_mtd_id"--- id_find_by_mtd_id: '%.*s' (len = %d)\n"mtd_id_len, mtd_id, mtd_id_lendebug("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len)1015--- id_find_by_mtd_id: '%.*s' (len = %d)
"entry: '%s' (len = %zu)\n"id->mtd_id, strlen(id->mtd_id)debug("entry: '%s' (len = %zu)\n",
				id->mtd_id, strlen(id->mtd_id))1021entry: '%s' (len = %zu)
id_findcleanupmtd_devices_initdevice_parsetmp_list"===device_parse===\n"debug("===device_parse===\n")855===device_parse===
retdevassert(retdev)857no <mtd-id> identifier
"no <mtd-id> identifier\n"invalid mtd device '%.*s'
"invalid mtd device '%.*s'\n"pend"dev type = %d (%s), dev num = %d, mtd-id = %s\n"id->type, MTD_DEV_TYPE(id->type), id->num, id->mtd_iddebug("dev type = %d (%s), dev num = %d, mtd-id = %s\n",
			id->type, MTD_DEV_TYPE(id->type),
			id->num, id->mtd_id)881dev type = %d (%s), dev num = %d, mtd-id = %s
"parsing partitions %.*s\n"(int)(pend ? pend - p : strlen(p)), pdebug("parsing partitions %.*s\n", (int)(pend ? pend - p : strlen(p)), p)882parsing partitions %.*s
dev->parts.prevlist_entry(dev->parts.prev, struct part_info, link)OFFSET_NOT_SPECIFIED"\ntotal partitions: %d\n"debug("\ntotal partitions: %d\n", num_parts)921
total partitions: %d
unexpected character '%c' at the end of device
"unexpected character '%c' at the end of device\n"sizeof(struct mtd_device)&tmp_listmtd_dev"===\n\n"debug("===\n\n")962===

device_addcurrent_save_neededlist_entry(entry, struct mtd_device, link)device_deldevice_delallmtd_device_validatemtd_info **part_parse"'-': remaining size assigned\n"debug("'-': remaining size assigned\n")618'-': remaining size assigned
SIZE_REMAININGMIN_PART_SIZEpartition size too small (%llx)
"partition size too small (%llx)\n"no closing ) found in partition name
"no closing ) found in partition name\n"name_lenempty partition name
"empty partition name\n"no partitions allowed after a fill-up partition
"no partitions allowed after a fill-up partition\n"unexpected character '%c' at the end of partition
"unexpected character '%c' at the end of partition\n"sizeof(struct part_info)partdefretpart0x%08llx@0x%08llx"0x%08llx@0x%08llx""+ partition: name %-22s size 0x%08llx offset 0x%08llx mask flags %d\n"part->name, part->size, part->offset, part->mask_flagsdebug("+ partition: name %-22s size 0x%08llx offset 0x%08llx mask flags %d\n",
			part->name, part->size,
			part->offset, part->mask_flags)705+ partition: name %-22s size 0x%08llx offset 0x%08llx mask flags %d
part_addpart_sort_add"part_sort_add: list empty\n"debug("part_sort_add: list empty\n")525part_sort_add: list empty
new_pi&part->linklist_entry(&part->link, struct part_info, link)curr_pipicannot add second partition at offset 0
"cannot add second partition at offset 0\n"part_delallpart_tmppart_delcurrent partition deleted, resetting current to 0
"current partition deleted, resetting current to 0\n"part_validate%s: offset %08llx beyond flash size %08llx
"%s: offset %08llx beyond flash size %08llx\n"%s%d: partition (%s) size too big
"%s%d: partition (%s) size too big\n"MTD_DEV_TYPE(id->type)%s: partitioning exceeds flash size
"%s: partitioning exceeds flash size\n"part_validate_eraseblockdo_div(offset, mtd->erasesize)((offset) >> 32) == 0%s%d: partition (%s) start offsetalignment incorrect
"%s%d: partition (%s) start offset"
			       "alignment incorrect\n"do_div(size, mtd->erasesize)((size) >> 32) == 0%s%d: partition (%s) size alignment incorrect
"%s%d: partition (%s) size alignment incorrect\n"%s%d: partition (%s) start offset alignment incorrect
"%s%d: partition (%s) start offset alignment incorrect\n"get_mtd_info%s%d"%s%d"Device %s not found!
"Device %s not found!\n"current_save"--- current_save ---\n"debug("--- current_save ---\n")--- current_save ---
%s%d,%d"%s%d,%d""=> partition %s\n"debug("=> partition %s\n", buf)=> partition %s
"=> partition NULL\n"debug("=> partition NULL\n")start_okend_ok=> partition NULL
index_partitions"--- index partitions ---\n"debug("--- index partitions ---\n")--- index partitions ---
mtddevnum"mtddevnum""=> mtddevnum %d,\n"debug("=> mtddevnum %d,\n", mtddevnum)=> mtddevnum %d,
mtddevname"mtddevname""=> mtddevname %s\n"part->namedebug("=> mtddevname %s\n", part->name)=> mtddevname %s
"=> mtddevname NULL\n"debug("=> mtddevname NULL\n")=> mtddevname NULL
"=> mtddevnum NULL\n=> mtddevname NULL\n"debug("=> mtddevnum NULL\n=> mtddevname NULL\n")=> mtddevnum NULL
=> mtddevname NULL
memsize_formatSIZE_GB%llug"%llug"SIZE_MB%llum"%llum"SIZE_KB%lluk"%lluk"%llu"%llu"memsize_parse'G''K''k'jffs2_free_cache"define flash/nand partitions"mtdparts_help_textdefine flash/nand partitionschar[1246]U_BOOT_CMD(
	mtdparts,	6,	0,	do_mtdparts,
	"define flash/nand partitions", mtdparts_help_text
)_u_boot_list_2_cmd_2_mtdparts.u_boot_list_2_cmd_2_mtdparts
    - list partition table
mtdparts delall
    - delete all partitions
mtdparts del part-id
    - delete partition (e.g. part-id = nand0,1)
mtdparts add <mtd-dev> <size>[@<offset>] [<name>] [ro]
    - add partition
mtdparts default
    - reset partition table to defaults

-----

this command uses three environment variables:

'partition' - keeps current partition identifier

partition  := <part-id>
<part-id>  := <dev-id>,part_num

'mtdids' - linux kernel mtd device id <-> u-boot device id mapping

mtdids=<idmap>[,<idmap>,...]

<idmap>    := <dev-id>=<mtd-id>
<dev-id>   := 'nand'|'nor'|'onenand'|'spi-nand'<dev-num>
<dev-num>  := mtd device number, 0...
<mtd-id>   := unique device tag used by linux kernel to find mtd device (mtd->name)

'mtdparts' - partition list

mtdparts=mtdparts=<mtd-def>[;<mtd-def>...]

<mtd-def>  := <mtd-id>:<part-def>[,<part-def>...]
<mtd-id>   := unique device tag used by linux kernel to find mtd device (mtd->name)
<part-def> := <size>[@<offset>][<name>][<ro-flag>]
<size>     := standard linux memsize OR '-' to denote all remaining space
<offset>   := partition start offset within the device
<name>     := '(' NAME ')'
<ro-flag>  := when set to 'ro' makes partition read-only (not used, passed to kernel)chpart"change active partition""part-id\n" "    - change active partition (e.g. part-id = nand0,1)"change active partitionpart-id
    - change active partition (e.g. part-id = nand0,1)"part-id\n"
	"    - change active partition (e.g. part-id = nand0,1)"U_BOOT_CMD(
	chpart,	2,	0,	do_chpart,
	"change active partition",
	"part-id\n"
	"    - change active partition (e.g. part-id = nand0,1)"
)_u_boot_list_2_cmd_2_chpart.u_boot_list_2_cmd_2_chpartuse_defaultscurrent_mtd_partnumcurrent_mtd_devdevicesMTDPARTS_DEFAULTmtdparts_defaultMTDIDS_DEFAULTmtdids_default((u32)1024)((u32)1024*1024)((u32)1024*1024*1024)CONFIG_MTDPARTS_DEFAULTCONFIG_MTDIDS_DEFAULT(~0llu)defined(CONFIG_CMD_NAND)defined(CONFIG_CMD_ONENAND)!defined(MTDIDS_DEFAULT)!defined(MTDPARTS_DEFAULT)defined(CONFIG_SYS_MTDPARTS_RUNTIME)defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES)defined(CONFIG_CMD_MTDPARTS_SPREAD)/* CONFIG_CMD_MTDPARTS_SPREAD *//* mtdparts del part-id *//* merge new partition with existing ones*//* 'ro' *//* '(' name ')' *//* size@offset *//* 'mtd_id:' *//* mtdparts add <mtd-dev> <size>[@<offset>] <name> [ro] *//* make sure we are in sync with env variables *//* mtd_devices_init() calls current_save() *//* this may be the first run, initialize lists if needed *//**
 * Routine implementing u-boot mtdparts command. Initialize/update default global
 * partition list and process user partition request (list, add, del).
 *
 * @param cmdtp command internal data
 * @param flag command flag
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 *//**
 * Routine implementing u-boot chpart command. Sets new current partition based
 * on the user supplied partition id. For partition id format see find_dev_and_part().
 *
 * @param cmdtp command internal data
 * @param flag command flag
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 *//* locate partition number, return it *//**
 * Return pointer to the partition of a requested number from a requested
 * device.
 *
 * @param dev device that is to be searched for a partition
 * @param part_num requested partition number
 * @return pointer to the part_info, NULL otherwise
 *//* is current partition set in environment? if so, use it *//* do not process current partition if mtdparts variable is null *//* mtdparts variable was reset to NULL, delete all devices/partitions *//* reset first partition from first dev from the list as current *//* ok it's good, save new parts *//* parse partitions if either mtdparts or mtdids were updated *//* ok it's good, save new ids *//* check if we have already parsed those mtdids *//* use defaults when mtdparts variable is not defined
	 * once mtdparts is saved environment, drop use_defaults flag *//* if mtdids variable is empty try to use defaults *//* save it for later parsing, cannot rely on current partition pointer
	 * as 'partition' variable may be updated during init *//* get variables *//**
 * Parse and initialize global mtdids mapping and create global
 * device/partition list.
 *
 * @return 0 on success, 1 otherwise
 *//* clean mtdids list and free allocated memory *//* allocate mtdids structure *//* check if this id is already on the list *//* locate <mtd-id> *//* check if requested device exists *//* parse 'nor'|'nand'|'onenand'|'spi-nand'<dev-num> *//* clean global mtdids list *//**
 * Parse provided string describing mtdids mapping (see file header for mtdids
 * variable format). Allocate memory for each entry and add all found entries
 * to the global mtdids list.
 *
 * @param ids mapping string
 * @return 0 on success, 1 otherwise
 *//* check if parsed device is already on the list *//* Skip the useless prefix, if any *//* re-read 'mtdparts' variable, mtd_devices_init may be updating env *//* delete all devices and partitions *//**
 * Accept character string describing mtd partitions and call device_parse()
 * for each entry. Add created devices to the global devices list.
 *
 * @param mtdparts string specifing mtd partitions
 * @return 0 on success, 1 otherwise
 *//**
 * The mtdparts variable tends to be long. If we need to access it
 * before the env is relocated, then we need to use our own stack
 * buffer.  gd->env_buf will be too small.
 *
 * @param buf temporary buffer pointer MTDPARTS_MAXLEN long
 * @return mtdparts variable string, NULL if not found
 *//**
 * Adjust all of the partition sizes, such that all partitions are at least
 * as big as their mtdparts environment variable sizes and they each start
 * on a good block.
 *
 * @return 0 on success, 1 otherwise
 *//*
	 * Absorb bad blocks immediately following this
	 * partition also into the partition, such that
	 * the next partition starts with a good block.
	 *//**
 * Increase the size of the given partition so that it's net size is at least
 * as large as the size member and such that the next partition would start on a
 * good block if it were adjacent to this partition.
 *
 * @param mtd the mtd device
 * @param part the partition
 * @param next_offset pointer to the offset of the next partition after this
 *                    partition's size has been modified (output)
 *//**
 * Find and delete partition. For partition id format see find_dev_and_part().
 *
 * @param id string describing device and partition
 * @return 0 on success, 1 otherwise
 *//**
 * Given partition identifier in form of <dev_type><dev_num>,<part_num> find
 * corresponding device and verify partition number.
 *
 * @param id string describing device and partition or partition name
 * @param dev pointer to the requested device (output)
 * @param part_num verified partition number (output)
 * @param part pointer to requested partition (output)
 * @return 0 on success, 1 otherwise
 *//*
	 * Using printf() here results in printbuffer overflow
	 * if default mtdparts string is greater than console
	 * printbuffer. Use puts() to prevent system crashes.
	 *//* current_mtd_dev is not NULL only when we have non empty device list *//**
 * Format and print out a partition list for each device from global device
 * list.
 *//* defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) *//* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) *//* list partitions for given device *//**
 * Get the net size (w/o bad blocks) of the given partition.
 *
 * @param mtd the mtd info
 * @param part the partition
 * @return the calculated net size of this partition
 *//**
 * Call generate_mtdparts to process all devices and generate corresponding
 * mtdparts string, save it in mtdparts environment variable.
 *
 * @param buf output buffer holding generated mtdparts string (output)
 * @param buflen buffer size
 * @return 0 on success, 1 otherwise
 *//* we still have at least one char left, as we decremented maxlen at
	 * the begining *//* print ';' separator if there are other devices following *//* print ',' separator if there are other partitions
			 * following *//* ro mask flag *//* copy name only if user supplied *//* add offset only when there is a gap between
			 * partitions *//* partition size *//* format partitions *//* copy mtd_id *//**
 * Process all devices and generate corresponding mtdparts string describing
 * all partitions on all devices.
 *
 * @param buf output buffer holding generated mtdparts string (output)
 * @param buflen buffer size
 * @return 0 on success, 1 otherwise
 *//**
 * Parse device id string <dev-id> := 'nand'|'nor'|'onenand'|'spi-nand'<dev-num>,
 * return device type and number.
 *
 * @param id string describing device id
 * @param ret_id output pointer to next char after parse completes (output)
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 *//**
 * Search global mtdids list and find id of a requested mtd_id.
 *
 * Note: first argument is not null terminated.
 *
 * @param mtd_id string containing requested mtd_id
 * @param mtd_id_len length of supplied mtd_id
 * @return pointer to the id if it exists, NULL otherwise
 *//*
 * Search global mtdids list and find id of requested type and number.
 *
 * @return pointer to the id if it exists, NULL otherwise
 *//**
 * Initialize global device list.
 *
 * @return 0 on success, 1 otherwise
 *//* move partitions from tmp_list to dev->parts *//* part_sort_add increments num_parts *//* allocate memory for mtd_device structure *//* check for next device presence *//* partition is ok, add it to the list *//* verify alignment and size *//* calculate offset when not specified *//* if device already exists start at the end of the last partition *//* parse partitions *//* verify if we have a valid device specified *//* fetch <mtd-id> *//**
 * Parse device type, name and mtd-id. If syntax is ok allocate memory and
 * return pointer to the device structure.
 *
 * @param mtd_dev pointer to the device definition string i.e. <mtd-dev>
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 *//**
 * Add specified device to the global device list.
 *
 * @param dev device to be added
 *//**
 * Search global device list and return pointer to the device of type and num
 * specified.
 *
 * @param type device type
 * @param num device number
 * @return NULL if requested device does not exist
 *//* reset first partition from first dev from the
			 * devices list as current *//* we just deleted current device *//**
 * If provided device exists it's partitions are deleted, device is removed
 * from device list and device memory is freed.
 *
 * @param dev device to be deleted
 * @return 0 on success, 1 otherwise
 *//* clean devices list *//**
 * Delete all mtd devices from a supplied devices list, free memory allocated for
 * each device and delete all device partitions.
 *
 * @return 0 on success, 1 otherwise
 *//**
 * Check device number to be within valid range for given device type.
 *
 * @param type mtd type
 * @param num mtd number
 * @param size a pointer to the size of the mtd device (output)
 * @return 0 if device is valid, 1 otherwise
 *//* auto generated name in form of size@offset *//* copy user provided name *//*  allocate memory *//* check for next partition definition *//* test for options *//* 0x00000000@0x00000000 *//* now look for the name *//* check for offset *//* assign all remaining space to this partition *//* fetch the partition size *//**
 * Parse one partition definition, allocate memory and return pointer to this
 * location in retpart.
 *
 * @param partdef pointer to the partition definition string i.e. <part-def>
 * @param ret output pointer to next char after parse completes (output)
 * @param retpart pointer to the allocated partition (output)
 * @return 0 on success, 1 otherwise
 *//**
 * Add provided partition to the partition list of a given device.
 *
 * @param dev device to which partition is added
 * @param part partition to be added
 * @return 0 on success, 1 otherwise
 *//* we are modyfing partitions for the current
				 * device, update current *//* be compliant with kernel cmdline, allow only one partition at offset zero *//* get current partition info if we are updating current device *//* link partition to parrent dev *//**
 * Add new partition to the supplied partition list. Make sure partitions are
 * sorted by offset in ascending order.
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 *//* clean tmp_list and free allocated memory *//**
 * Delete all partitions from parts head list, free memory.
 *
 * @param head list of partitions to delete
 *//* we are modyfing partitions for the current device,
		 * update current *//* otherwise just delete this partition *//* if there is only one partition, remove whole device *//**
 * Delete selected partition from the partition list of the specified device.
 *
 * @param dev device to delete partition from
 * @param part partition to delete
 * @return 0 on success, 1 otherwise
 *//*
	 * Now we need to check if the partition starts and ends on
	 * sector (eraseblock) regions
	 *//**
 * Performs sanity check for supplied partition. Offset and size are
 * verified to be within valid range. Partition type is checked and
 * part_validate_eraseblock() is called with the argument of part.
 *
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 *//* Check last sector alignment *//* Check end/size alignment *//* Check start alignment *//*
		 * Multiple eraseregions (non-uniform NOR),
		 * checking for alignment is more complex here
		 *//*
		 * Only one eraseregion (NAND, SPI-NAND, OneNAND or uniform NOR),
		 * checking for alignment is easy here
		 *//**
 * Performs sanity check for supplied flash partition.
 * Table of existing MTD flash devices is searched and partition device
 * is located. Alignment with the granularity of nand erasesize is verified.
 *
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 *//**
 * Produce a mtd_info given a type and num.
 *
 * @param type mtd type
 * @param num mtd number
 * @param mtd a pointer to an mtd_info instance (output)
 * @return 0 if device is valid, 1 otherwise
 *//**
 * Save current device and partition in environment variable 'partition'.
 *//**
 * This routine does global indexing of all partitions. Resulting index for
 * current partition is saved in 'mtddevnum'. Current partition name in
 * 'mtddevname'.
 *//**
 * Format string describing supplied size. This routine does the opposite job
 * to memsize_parse(). Size in bytes is converted to string and if possible
 * shortened by using k (kilobytes), m (megabytes) or g (gigabytes) suffix.
 *
 * Note, that this routine does not check for buffer overflow, it's the caller
 * who must assure enough space.
 *
 * @param buf output buffer
 * @param size size to be converted to string
 *//* Fallthrough *//**
 * Parses a string into a number.  The number stored at ptr is
 * potentially suffixed with K (for kilobytes, or 1024 bytes),
 * M (for megabytes, or 1048576 bytes), or G (for gigabytes, or
 * 1073741824).  If the number is suffixed with K, M, or G, then
 * the return value is the number multiplied by one kilobyte, one
 * megabyte, or one gigabyte, respectively.
 *
 * @param ptr where parse begins
 * @param retptr output pointer to next char after parse completes (output)
 * @return resulting unsigned int
 *//* command line only routines *//* current active device and partition number *//* device/partition list, parse_cmdline() parses into here *//* mtdids mapping list, filled by parse_ids() *//* low level jffs2 cache cleaning routine *//* copies of last seen 'mtdids', 'mtdparts' and 'partition' env variables *//* default values for mtdids and mtdparts variables *//* this flag needs to be set in part_info struct mask_flags
 * field for read-only partitions *//* minimum partition size *//* special offset value, it is used when not provided by user
 *
 * this value is used temporarily during parsing, later such offests
 * are recalculated *//* special size referring to all the remaining space in a partition *//*
 * Three environment variables are used by the parsing routines:
 *
 * 'partition' - keeps current partition identifier
 *
 * partition  := <part-id>
 * <part-id>  := <dev-id>,part_num
 *
 *
 * 'mtdids' - linux kernel mtd device id <-> u-boot device id mapping
 *
 * mtdids=<idmap>[,<idmap>,...]
 *
 * <idmap>    := <dev-id>=<mtd-id>
 * <dev-id>   := 'nand'|'nor'|'onenand'|'spi-nand'<dev-num>
 * <dev-num>  := mtd device number, 0...
 * <mtd-id>   := unique device tag used by linux kernel to find mtd device (mtd->name)
 *
 *
 * 'mtdparts' - partition list
 *
 * mtdparts=[mtdparts=]<mtd-def>[;<mtd-def>...]
 *
 * <mtd-def>  := <mtd-id>:<part-def>[,<part-def>...]
 * <mtd-id>   := unique device tag used by linux kernel to find mtd device (mtd->name)
 * <part-def> := <size>[@<offset>][<name>][<ro-flag>]
 * <size>     := standard linux memsize OR '-' to denote all remaining space
 * <offset>   := partition start offset within the device
 * <name>     := '(' NAME ')'
 * <ro-flag>  := when set to 'ro' makes partition read-only (not used, passed to kernel)
 *
 * Notes:
 * - each <mtd-id> used in mtdparts must albo exist in 'mtddis' mapping
 * - if the above variables are not set defaults for a given target are used
 *
 * Examples:
 *
 * 1 NOR Flash, with 1 single writable partition:
 * mtdids=nor0=edb7312-nor
 * mtdparts=[mtdparts=]edb7312-nor:-
 *
 * 1 NOR Flash with 2 partitions, 1 NAND with one
 * mtdids=nor0=edb7312-nor,nand0=edb7312-nand
 * mtdparts=[mtdparts=]edb7312-nor:256k(ARMboot)ro,-(root);edb7312-nand:-(home)
 *
 *//*
 * (C) Copyright 2002
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *
 * (C) Copyright 2002
 * Robert Schwebel, Pengutronix, <r.schwebel@pengutronix.de>
 *
 * (C) Copyright 2003
 * Kai-Uwe Bloem, Auerswald GmbH & Co KG, <linux-development@auerswald.de>
 *
 * (C) Copyright 2005
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *
 *   Added support for reading flash partition table from environment.
 *   Parsing routines are based on driver/mtd/cmdline.c from the linux 2.4
 *   kernel tree.
 *
 * (C) Copyright 2008
 * Harald Welte, OpenMoko, Inc., Harald Welte <laforge@openmoko.org>
 *
 *   $Id: cmdlinepart.c,v 1.17 2004/11/26 11:18:47 lavinen Exp $
 *   Copyright 2002 SYSGO Real-Time Solutions GmbH
 */retptr/opt/src/cmd/net.cdo_link_localLINKLOCALgatewayip"gatewayip"netmask"netmask"llipaddr"llipaddr"do_dnsdns error: hostname too long
"dns error: hostname too long\n"DNSdns lookup of %s failed, check setup
"dns lookup of %s failed, check setup\n"do_sntpntpserverip"ntpserverip"ntpserverip not set
"ntpserverip not set\n"Bad NTP server IP address
"Bad NTP server IP address\n"tofftimeoffset"timeoffset"SNTPSNTP failed: host %pI4 not responding
"SNTP failed: host %pI4 not responding\n"do_cdpCDPcdp failed; perhaps not a CISCO switch?
"cdp failed; perhaps not a CISCO switch?\n"cdp_update_envhtons(-1)((-1))CDP offered appliance VLAN %d
"CDP offered appliance VLAN %d\n"cdp_appliance_vlan(__force __u16)(__be16)(cdp_appliance_vlan)(__u16)(__be16)(cdp_appliance_vlan)((__u16)(__be16)(cdp_appliance_vlan))ntohs(cdp_appliance_vlan)CDP offered native VLAN %d
"CDP offered native VLAN %d\n"cdp_native_vlan(__force __u16)(__be16)(cdp_native_vlan)(__u16)(__be16)(cdp_native_vlan)((__u16)(__be16)(cdp_native_vlan))ntohs(cdp_native_vlan)nvlan"nvlan"do_pingPINGping failed; host %s is not alive
"ping failed; host %s is not alive\n"host %s is alive
"host %s is alive\n"netboot_commonsizeof(net_boot_file_name)Invalid address/size
"Invalid address/size\n"BOOTSTAGE_ID_NET_STARTBOOTSTAGE_ID_NET_NETLOOP_OKBOOTSTAGE_ID_NET_LOADEDBOOTSTAGE_ID_NET_DONEBOOTSTAGE_ID_NET_DONE_ERRnetboot_update_envhostname"hostname"rootpath"rootpath"dnsip"dnsip"dnsip2"dnsip2"domain"domain"do_nfsNFSdo_dhcpDHCPdo_rarpbRARPdo_tftpsrvTFTPSRVdo_tftpputTFTPPUTBOOTSTAGE_KERNELREAD_STARTtftp_start"tftp_start"TFTPGETBOOTSTAGE_KERNELREAD_STOPtftp_done"tftp_done"do_bootpBOOTPlinklocal"acquire a network IP address using the link-local protocol"acquire a network IP address using the link-local protocolU_BOOT_CMD(
	linklocal,	1,	1,	do_link_local,
	"acquire a network IP address using the link-local protocol",
	""
)_u_boot_list_2_cmd_2_linklocal.u_boot_list_2_cmd_2_linklocaldns"lookup the IP of a hostname""hostname [envvar]"lookup the IP of a hostnamehostname [envvar]U_BOOT_CMD(
	dns,	3,	1,	do_dns,
	"lookup the IP of a hostname",
	"hostname [envvar]"
)_u_boot_list_2_cmd_2_dns.u_boot_list_2_cmd_2_dnssntp"synchronize RTC via network""[NTP server IP]\n"synchronize RTC via network[NTP server IP]
U_BOOT_CMD(
	sntp,	2,	1,	do_sntp,
	"synchronize RTC via network",
	"[NTP server IP]\n"
)_u_boot_list_2_cmd_2_sntp.u_boot_list_2_cmd_2_sntpcdp"Perform CDP network configuration"Perform CDP network configurationU_BOOT_CMD(
	cdp,	1,	1,	do_cdp,
	"Perform CDP network configuration",
	"\n"
)_u_boot_list_2_cmd_2_cdp.u_boot_list_2_cmd_2_cdpping"send ICMP ECHO_REQUEST to network host""pingAddress"send ICMP ECHO_REQUEST to network hostpingAddressU_BOOT_CMD(
	ping,	2,	1,	do_ping,
	"send ICMP ECHO_REQUEST to network host",
	"pingAddress"
)_u_boot_list_2_cmd_2_ping.u_boot_list_2_cmd_2_pingnfs"boot image via network using NFS protocol""[loadAddress] [[hostIPaddr:]bootfilename]"boot image via network using NFS protocol[loadAddress] [[hostIPaddr:]bootfilename]U_BOOT_CMD(
	nfs,	3,	1,	do_nfs,
	"boot image via network using NFS protocol",
	"[loadAddress] [[hostIPaddr:]bootfilename]"
)_u_boot_list_2_cmd_2_nfs.u_boot_list_2_cmd_2_nfs"boot image via network using DHCP/TFTP protocol"boot image via network using DHCP/TFTP protocolU_BOOT_CMD(
	dhcp,	3,	1,	do_dhcp,
	"boot image via network using DHCP/TFTP protocol",
	"[loadAddress] [[hostIPaddr:]bootfilename]"
)_u_boot_list_2_cmd_2_dhcp.u_boot_list_2_cmd_2_dhcprarpboot"boot image via network using RARP/TFTP protocol"boot image via network using RARP/TFTP protocolU_BOOT_CMD(
	rarpboot,	3,	1,	do_rarpb,
	"boot image via network using RARP/TFTP protocol",
	"[loadAddress] [[hostIPaddr:]bootfilename]"
)_u_boot_list_2_cmd_2_rarpboot.u_boot_list_2_cmd_2_rarpboottftpsrv"act as a TFTP server and boot the first received file""[loadAddress]\n" "Listen for an incoming TFTP transfer, receive a file and boot it.\n" "The transfer is aborted if a transfer has not been started after\n" "about 50 seconds or if Ctrl-C is pressed."act as a TFTP server and boot the first received file[loadAddress]
Listen for an incoming TFTP transfer, receive a file and boot it.
The transfer is aborted if a transfer has not been started after
about 50 seconds or if Ctrl-C is pressed."[loadAddress]\n"
	"Listen for an incoming TFTP transfer, receive a file and boot it.\n"
	"The transfer is aborted if a transfer has not been started after\n"
	"about 50 seconds or if Ctrl-C is pressed."U_BOOT_CMD(
	tftpsrv,	2,	1,	do_tftpsrv,
	"act as a TFTP server and boot the first received file",
	"[loadAddress]\n"
	"Listen for an incoming TFTP transfer, receive a file and boot it.\n"
	"The transfer is aborted if a transfer has not been started after\n"
	"about 50 seconds or if Ctrl-C is pressed."
)_u_boot_list_2_cmd_2_tftpsrv.u_boot_list_2_cmd_2_tftpsrvtftpput"TFTP put command, for uploading files to a server""Address Size [[hostIPaddr:]filename]"TFTP put command, for uploading files to a serverAddress Size [[hostIPaddr:]filename]U_BOOT_CMD(
	tftpput,	4,	1,	do_tftpput,
	"TFTP put command, for uploading files to a server",
	"Address Size [[hostIPaddr:]filename]"
)_u_boot_list_2_cmd_2_tftpput.u_boot_list_2_cmd_2_tftpputtftpboot"boot image via network using TFTP protocol"boot image via network using TFTP protocolU_BOOT_CMD(
	tftpboot,	3,	1,	do_tftpb,
	"boot image via network using TFTP protocol",
	"[loadAddress] [[hostIPaddr:]bootfilename]"
)_u_boot_list_2_cmd_2_tftpboot.u_boot_list_2_cmd_2_tftpbootbootp"boot image via network using BOOTP/TFTP protocol"boot image via network using BOOTP/TFTP protocolU_BOOT_CMD(
	bootp,	3,	1,	do_bootp,
	"boot image via network using BOOTP/TFTP protocol",
	"[loadAddress] [[hostIPaddr:]bootfilename]"
)_u_boot_list_2_cmd_2_bootp.u_boot_list_2_cmd_2_bootpCONFIG_CMD_BOOTPCONFIG_CMD_TFTPBOOTCONFIG_CMD_TFTPPUTCONFIG_CMD_TFTPSRVCONFIG_CMD_RARPdefined(CONFIG_CMD_DHCP)defined(CONFIG_CMD_NFS)!defined(CONFIG_BOOTP_SERVERIP)defined(CONFIG_BOOTP_DNS2)defined(CONFIG_CMD_SNTP) && defined(CONFIG_BOOTP_TIMEOFFSET)defined(CONFIG_CMD_SNTP) && defined(CONFIG_BOOTP_NTPSERVER)defined(CONFIG_CMD_PING)defined(CONFIG_CMD_CDP)defined(CONFIG_CMD_SNTP)defined(CONFIG_CMD_DNS)defined(CONFIG_CMD_LINK_LOCAL)/* CONFIG_CMD_LINK_LOCAL *//* store this for next time *//* CONFIG_CMD_DNS *//*
	 * We should check for a valid hostname:
	 * - Each label must be between 1 and 63 characters long
	 * - the entire hostname has a maximum of 255 characters
	 * - only the ASCII letters 'a' through 'z' (case-insensitive),
	 *   the digits '0' through '9', and the hyphen
	 * - cannot begin or end with a hyphen
	 * - no other symbols, punctuation characters, or blank spaces are
	 *   permitted
	 * but hey - this is a minimalist implmentation, so only check length
	 * and let the name server deal with things.
	 *//* done if no file was loaded (no errors though) *//* net_loop ok, update environment *//* refresh bootfile name from env *//*
		 * Only one arg - accept two forms:
		 * Just load address, or just boot file name. The latter
		 * form must be written in a format which can not be
		 * mis-interpreted as a valid number.
		 *//* pre-set load_addr *//*
	 * Only attempt to change serverip if net/bootp.c:store_net_params()
	 * could have set it
	 *//opt/src/cmd/nvedit.cnveditdo_envcmd_tbl_t[13]cmd_tbl_s[13]cmd_env_sub728ARRAY_SIZE(cmd_env_sub)do_env_existsdo_env_importsepchkcrlf_is_lf## Warning: defaulting to text format
"## Warning: defaulting to text format\n"## Error: external checksum format must pass size
"## Error: external checksum format must pass size\n"MAX_ENV_SIZE## Warning: Input data exceeds %d bytes - truncated
"## Warning: Input data exceeds %d bytes"
				" - truncated\n"## Info: input data size = %zu = 0x%zX
"## Info: input data size = %zu = 0x%zX\n"wloffsetof(env_t, data)sizeof(crc)## Error: bad CRC, import failed
"## Error: bad CRC, import failed\n""## Error: Environment import failed: errno = %d\n"pr_err("## Error: Environment import failed: errno = %d\n",
		       errno)pr_fmt("## Error: Environment import failed: errno = %d\n")## Error: Environment import failed: errno = %d
## %s: only one of "-b", "-c" or "-t" allowed
"## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n"do_env_exportH_MATCH_KEY | H_MATCH_IDENT"## Error: Cannot export environment: errno = %d\n"pr_err("## Error: Cannot export environment: errno = %d\n",
			       errno)pr_fmt("## Error: Cannot export environment: errno = %d\n")## Error: Cannot export environment: errno = %d
%zX"%zX"envppr_err("## Error: Cannot export environment: errno = %d\n",
		       errno)## Error: %s: only one of "-b", "-c" or "-t" allowed
"## Error: %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n"do_env_delete"Initial value for argc=%d\n"debug("Initial value for argc=%d\n", argc)cmd/nvedit.cInitial value for argc=%d
env_flagsep_err"Final value for argc=%d\n"debug("Final value for argc=%d\n", argc)870Final value for argc=%d
do_env_default816833## Resetting to default environment
"## Resetting to default environment\n"nxtenv_buf [%u bytes] too small for value of "%s"
"env_buf [%u bytes] too small for value of \"%s\"\n"sizeof(gd->env_buf)do_env_editi2init_valCONFIG_SYS_CBSIZE%s"%s"edit: "edit: "_argv"setenv"do_env_flagsAvailable variable type flags (position %d):
"Available variable type flags (position %d):\n"	Flag	Variable Type Name
"\tFlag\tVariable Type Name\n"	----	------------------
"\t----\t------------------\n"Available variable access flags (position %d):
"Available variable access flags (position %d):\n"	Flag	Variable Access Name
"\tFlag\tVariable Access Name\n"	----	--------------------
"\t----\t--------------------\n"Static flags:
"Static flags:\n"	%-20s %-20s %-20s
"\t%-20s %-20s %-20s\n"Variable Name"Variable Name"Variable Type"Variable Type"Variable Access"Variable Access"-------------"-------------"---------------"---------------"eth\d*addr:mo,ipaddr:i,gatewayip:i,netmask:i,serverip:i,nvlan:d,vlan:d,dnsip:i,serial#:so,Active flags:
"Active flags:\n"print_active_flagsprint_static_flagsdo_env_callbackAvailable callbacks:
"Available callbacks:\n"	Callback Name
"\tCallback Name\n"	-------------
"\t-------------\n"num_callbacksenv_clbk_tbl *struct env_clbk_tblenv_clbkll_entry_count(struct env_clbk_tbl, env_clbk).u_boot_list_2_env_clbk_1.u_boot_list_2_env_clbk_3	%s
"\t%s\n"clbkpll_entry_start(struct env_clbk_tbl, env_clbk)Static callback bindings:
"Static callback bindings:\n"	%-20s %-20s
"\t%-20s %-20s\n"Callback Name"Callback Name"\.callbacks:callbacks,\.flags:flags,baudrate:baudrate,bootfile:bootfile,ipaddr:ipaddr,gatewayip:gatewayip,netmask:netmask,serverip:serverip,nvlan:nvlan,vlan:vlan,dnsip:dnsip,eth\d*addr:ethaddr,loadaddr:loadaddr,silent:silent,stdin:console,stdout:console,stderr:console,serial#:serialno,char[287]Active callback bindings:
"Active callback bindings:\n"print_active_callback	%-20s %p
"\t%-20s %p\n"print_static_bindingdo_env_askvar_namecallback_name1023CONFIG_SYS_CBSIZE - 1Please enter '%s': "Please enter '%s': "sizeof(message)sizeof(message) - 1do_env_setARP_HLEN_ASCIIARP_HLEN_ASCII + 1EEXIST-17-EEXIST%pM"%pM"%lx"%lx"_do_env_set'e'varvalue## Error: illegal character '='in variable name "%s"
"## Error: illegal character '='"
		       "in variable name \"%s\"\n"## Can't malloc %d bytes
"## Can't malloc %d bytes\n"## Error inserting "%s" variable, errno=%d
"## Error inserting \"%s\" variable, errno=%d\n"CMD_NVEDIT_EFICONFIG_VAL(CMD_NVEDIT_EFI)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_CMD_NVEDIT_EFICONFIG_CMD_NVEDIT_EFICONFIG_VAL(CMD_NVEDIT_EFI_MODULE)CONFIG_CMD_NVEDIT_EFI_MODULECMD_NVEDIT_EFI_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_CMD_NVEDIT_EFI_MODULE__ARG_PLACEHOLDER_CONFIG_CMD_NVEDIT_EFI_MODULE__ARG_PLACEHOLDER_CONFIG_CMD_NVEDIT_EFI_MODULE 1do_env_grepgrep_howgrep_whatdo_env_print-9~H_HIDE_DOT
Environment size: %d/%ld bytes
"\nEnvironment size: %d/%ld bytes\n"(ulong)ENV_SIZE## Error: "%s" not defined
"## Error: \"%s\" not defined\n"env_print%s=%s
"%s=%s\n"## Error: cannot export environment
"## Error: cannot export environment\n"do_run"run commands in an environment variable""var [...]\n" "    - run the commands in the environment variable(s) 'var'"var_completeU_BOOT_CMD_COMPLETE(
	run,	CONFIG_SYS_MAXARGS,	1,	do_run,
	"run commands in an environment variable",
	"var [...]\n"
	"    - run the commands in the environment variable(s) 'var'",
	var_complete
)run commands in an environment variablevar [...]
    - run the commands in the environment variable(s) 'var'"var [...]\n"
	"    - run the commands in the environment variable(s) 'var'"_u_boot_list_2_cmd_2_run.u_boot_list_2_cmd_2_runaskenv"get environment variables from stdin""name [message] [size]\n" "    - get environment variable 'name' from stdin (max 'size' chars)"U_BOOT_CMD(
	askenv,	CONFIG_SYS_MAXARGS,	1,	do_env_ask,
	"get environment variables from stdin",
	"name [message] [size]\n"
	"    - get environment variable 'name' from stdin (max 'size' chars)"
)get environment variables from stdinname [message] [size]
    - get environment variable 'name' from stdin (max 'size' chars)"name [message] [size]\n"
	"    - get environment variable 'name' from stdin (max 'size' chars)"_u_boot_list_2_cmd_2_askenv.u_boot_list_2_cmd_2_askenv"set environment variables""-e [-nv] name [value ...]\n" "    - set UEFI variable 'name' to 'value' ...'\n" "      'nv' option makes the variable non-volatile\n" "    - delete UEFI variable 'name' if 'value' not specified\n" "setenv [-f] name value ...\n" "    - [forcibly] set environment variable 'name' to 'value ...'\n" "setenv [-f] name\n" "    - [forcibly] delete environment variable 'name'"U_BOOT_CMD_COMPLETE(
	setenv, CONFIG_SYS_MAXARGS, 0,	do_env_set,
	"set environment variables",
#if defined(CONFIG_CMD_NVEDIT_EFI)
	"-e [-nv] name [value ...]\n"
	"    - set UEFI variable 'name' to 'value' ...'\n"
	"      'nv' option makes the variable non-volatile\n"
	"    - delete UEFI variable 'name' if 'value' not specified\n"
#endif
	"setenv [-f] name value ...\n"
	"    - [forcibly] set environment variable 'name' to 'value ...'\n"
	"setenv [-f] name\n"
	"    - [forcibly] delete environment variable 'name'",
	var_complete
)set environment variables-e [-nv] name [value ...]
    - set UEFI variable 'name' to 'value' ...'
      'nv' option makes the variable non-volatile
    - delete UEFI variable 'name' if 'value' not specified
setenv [-f] name value ...
    - [forcibly] set environment variable 'name' to 'value ...'
setenv [-f] name
    - [forcibly] delete environment variable 'name'"-e [-nv] name [value ...]\n"
	"    - set UEFI variable 'name' to 'value' ...'\n"
	"      'nv' option makes the variable non-volatile\n"
	"    - delete UEFI variable 'name' if 'value' not specified\n"
#endif
	"setenv [-f] name value ...\n"
	"    - [forcibly] set environment variable 'name' to 'value ...'\n"
	"setenv [-f] name\n"
	"    - [forcibly] delete environment variable 'name'"char[342]_u_boot_list_2_cmd_2_setenv.u_boot_list_2_cmd_2_setenvgrepenv"search environment variables""[-e] [-n | -v | -b] string ...\n" "    - list environment name=value pairs matching 'string'\n" "      \"-e\": enable regular expressions;\n" "      \"-n\": search variable names; \"-v\": search values;\n" "      \"-b\": search both names and values (default)"U_BOOT_CMD_COMPLETE(
	grepenv, CONFIG_SYS_MAXARGS, 0,  do_env_grep,
	"search environment variables",
#ifdef CONFIG_REGEX
	"[-e] [-n | -v | -b] string ...\n"
#else
	"[-n | -v | -b] string ...\n"
#endif
	"    - list environment name=value pairs matching 'string'\n"
#ifdef CONFIG_REGEX
	"      \"-e\": enable regular expressions;\n"
#endif
	"      \"-n\": search variable names; \"-v\": search values;\n"
	"      \"-b\": search both names and values (default)",
	var_complete
)search environment variables[-e] [-n | -v | -b] string ...
    - list environment name=value pairs matching 'string'
      "-e": enable regular expressions;
      "-n": search variable names; "-v": search values;
      "-b": search both names and values (default)"[-e] [-n | -v | -b] string ...\n"
#else
	"[-n | -v | -b] string ...\n"
#endif
	"    - list environment name=value pairs matching 'string'\n"
#ifdef CONFIG_REGEX
	"      \"-e\": enable regular expressions;\n"
#endif
	"      \"-n\": search variable names; \"-v\": search values;\n"
	"      \"-b\": search both names and values (default)"char[236]_u_boot_list_2_cmd_2_grepenv.u_boot_list_2_cmd_2_grepenvprintenv"print environment variables""[-a]\n    - print [all] values of all environment variables\n" "printenv -e [name ...]\n" "    - print UEFI variable 'name' or all the variables\n" "printenv name ...\n" "    - print value of environment variable 'name'"U_BOOT_CMD_COMPLETE(
	printenv, CONFIG_SYS_MAXARGS, 1,	do_env_print,
	"print environment variables",
	"[-a]\n    - print [all] values of all environment variables\n"
#if defined(CONFIG_CMD_NVEDIT_EFI)
	"printenv -e [name ...]\n"
	"    - print UEFI variable 'name' or all the variables\n"
#endif
	"printenv name ...\n"
	"    - print value of environment variable 'name'",
	var_complete
)print environment variables[-a]
    - print [all] values of all environment variables
printenv -e [name ...]
    - print UEFI variable 'name' or all the variables
printenv name ...
    - print value of environment variable 'name'"[-a]\n    - print [all] values of all environment variables\n"
#if defined(CONFIG_CMD_NVEDIT_EFI)
	"printenv -e [name ...]\n"
	"    - print UEFI variable 'name' or all the variables\n"
#endif
	"printenv name ...\n"
	"    - print value of environment variable 'name'"char[203]_u_boot_list_2_cmd_2_printenv.u_boot_list_2_cmd_2_printenveditenv"edit environment variable""name\n" "    - edit environment variable 'name'"edit environment variablename
    - edit environment variable 'name'"name\n"
	"    - edit environment variable 'name'"_u_boot_list_2_cmd_2_editenv.u_boot_list_2_cmd_2_editenv"environment handling commands"env_help_textDONEU_BOOT_CMD(
	env, CONFIG_SYS_MAXARGS, 1, do_env,
	"environment handling commands", env_help_text
)environment handling commandschar[941]_u_boot_list_2_cmd_2_env.u_boot_list_2_cmd_2_envask name [message] [size] - ask for environment variable
env callbacks - print callbacks and their associated variables
env default [-f] -a - [forcibly] reset default environment
env default [-f] var [...] - [forcibly] reset variable(s) to their default values
env delete [-f] var [...] - [forcibly] delete variable(s)
env edit name - edit environment variable
env exists name - tests for existence of variable
env export [-t | -b | -c] [-s size] addr [var ...] - export environment
env flags - print variables that have non-default flags
env grep [-e] [-n | -v | -b] string [...] - search environment
env import [-d] [-t [-r] | -b | -c] addr [size] [var ...] - import environment
env print [-a | name ...] - print environment
env print -e [name ...] - print UEFI environment
env run var [...] - run commands in an environment variable
env set -e name [arg ...] - set UEFI variable; unset if 'arg' not specified
env set [-f] name [arg ...]
askeditcallbacksexportgrepimportexistsU_BOOT_CMD_MKENT(ask, CONFIG_SYS_MAXARGS, 1, do_env_ask, "", "")U_BOOT_CMD_MKENT(default, 1, 0, do_env_default, "", "")U_BOOT_CMD_MKENT(delete, CONFIG_SYS_MAXARGS, 0, do_env_delete, "", "")U_BOOT_CMD_MKENT(edit, 2, 0, do_env_edit, "", "")U_BOOT_CMD_MKENT(callbacks, 1, 0, do_env_callback, "", "")U_BOOT_CMD_MKENT(flags, 1, 0, do_env_flags, "", "")U_BOOT_CMD_MKENT(export, 4, 0, do_env_export, "", "")U_BOOT_CMD_MKENT(grep, CONFIG_SYS_MAXARGS, 1, do_env_grep, "", "")U_BOOT_CMD_MKENT(import, 5, 0, do_env_import, "", "")U_BOOT_CMD_MKENT(print, CONFIG_SYS_MAXARGS, 1, do_env_print, "", "")U_BOOT_CMD_MKENT(run, CONFIG_SYS_MAXARGS, 1, do_run, "", "")U_BOOT_CMD_MKENT(set, CONFIG_SYS_MAXARGS, 0, do_env_set, "", "")U_BOOT_CMD_MKENT(exists, 2, 0, do_env_exists, "", "")env_iddefined(CONFIG_ENV_IS_IN_EEPROM)	|| \!defined(ENV_IS_IN_DEVICE)		&& \defined(CONFIG_CMD_NVEDIT_EFI)CONFIG_CMD_GREPENVCONFIG_IS_ENABLED(CMD_NVEDIT_EFI)defined(CONFIG_CMD_ASKENV)defined(CONFIG_CMD_ENV_CALLBACK)defined(CONFIG_CMD_ENV_FLAGS)defined(CONFIG_CMD_EDITENV)defined(CONFIG_CMD_SAVEENV) && defined(ENV_IS_IN_DEVICE)defined(CONFIG_CMD_ERASEENV)CONFIG_CMD_EXPORTENVCONFIG_ENV_ADDR_REDUNDCONFIG_CMD_IMPORTENVdefined(CONFIG_CMD_NVEDIT_INFO)defined(CONFIG_CMD_SAVEENV) && !defined(CONFIG_ENV_IS_NOWHERE)defined(CONFIG_CMD_ENV_EXISTS)defined(CONFIG_CMD_EXPORTENV)defined(CONFIG_CMD_GREPENV)defined(CONFIG_CMD_IMPORTENV)defined(CONFIG_CMD_RUN)/* CONFIG_SPL_BUILD *//*
 * Old command line interface, kept for compatibility
 *//* drop initial "env" arg *//*
 * New command line interface: "env" command with subcommands
 *//* The result of evaluations is combined with AND *//* evaluate whether environment can be persisted *//* evaluate whether default environment is used *//* process options *//* display environment information *//*
 * env info - display environment information
 * env info [-d] - evaluate whether default environment is used
 * env info [-p] - evaluate whether environment can be persisted
 *//* environment persistence bit mask *//* default environment bit mask *//* print environment using default flag *//* print environment ready flag *//* print environment validity value *//*
 * print_env_info - print environment information
 *//* handle CRLF like LF *//* text format *//* external checksum format *//* raw binary format *//*
 * env import [-d] [-t [-r] | -b | -c] addr [size] [var ...]
 *	-d:	delete existing environment before importing if no var is
 *		passed; if vars are passed, if one var is in the current
 *		environment but not in the environment at addr, delete var from
 *		current environment;
 *		otherwise overwrite / append to existing definitions
 *	-t:	assume text format; either "size" must be given or the
 *		text data must be '\0' terminated
 *	-r:	handle CRLF like LF, that means exported variables with
 *		a content which ends with \r won't get imported. Used
 *		to import text files created with editors which are using CRLF
 *		for line endings. Only effective in addition to -t.
 *	-b:	assume binary format ('\0' separated, "\0\0" terminated)
 *	-c:	assume checksum protected environment format
 *	addr:	memory address to read from
 *	size:	length of input data; if missing, proper '\0'
 *		termination is mandatory
 *		if var is set and size should be missing (i.e. '\0'
 *		termination), set size to '-'
 *	var...	List of the names of the only variables that get imported from
 *		the environment at address 'addr'. Without arguments, the whole
 *		environment gets imported.
 *//* export as raw binary data *//* export as checksum protected block *//* export as text file *//* size given *//*
 * env export [-t | -b | -c] [-s size] addr [var ...]
 *	-t:	export as text format; if size is given, data will be
 *		padded with '\0' bytes; if not, one terminating '\0'
 *		will be added (which is included in the "filesize"
 *		setting so you can for exmple copy this to flash and
 *		keep the termination).
 *	-b:	export as binary format (name=value pairs separated by
 *		'\0', list end marked by double "\0\0")
 *	-c:	export as checksum protected environment format as
 *		used for example by "saveenv" command
 *	-s size:
 *		size of output buffer
 *	addr:	memory address where environment gets stored
 *	var...	List of variable names that get included into the
 *		export. Without arguments, the whole environment gets
 *		exported.
 *
 * With "-c" and size is NOT given, then the export command will
 * format the data as currently used for the persistent storage,
 * i. e. it will use CONFIG_ENV_SECT_SIZE as output block size and
 * prepend a valid CRC32 checksum and, in case of redundant
 * environment, a "current" redundancy flag. If size is given, this
 * value will be used instead of CONFIG_ENV_SECT_SIZE; again, CRC32
 * checksum and redundancy flag will be inserted.
 *
 * With "-b" and "-t", always only the real data (including a
 * terminating '\0' byte) will be written; here the optional size
 * argument will be used to make sure not to overflow the user
 * provided buffer; the command will abort if the size is not
 * sufficient. Any remaining space will be '\0' padded.
 *
 * On successful return, the variable "filesize" will be set.
 * Note that filesize includes the trailing/terminating '\0' byte(s).
 *
 * Usage scenario:  create a text snapshot/backup of the current settings:
 *
 *	=> env export -t 100000
 *	=> era ${backup_addr} +${filesize}
 *	=> cp.b 100000 ${backup_addr} ${filesize}
 *
 * Re-import this snapshot, deleting all other settings:
 *
 *	=> env import -d -t ${backup_addr}
 *//* force *//* Reset individual variables *//* Reset the whole environment *//* default all *//*
 * Match a name / name=value pair
 *
 * s1 is either a simple 'name', or a 'name=value' pair.
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 *//*
	 * We can use env_get() here, even before relocation, since the
	 * environment variable value is an integer and thus short.
	 *//**
 * Decode the integer value of an environment variable and return it.
 *
 * @param name		Name of environment variable
 * @param base		Number base to use (normally 10, or 16 for hex)
 * @param default_val	Default value to return if the variable is not
 *			found
 * @return the decoded value, or default_val if not found
 *//* found; copy out *//*
 * Look up variable from environment for restricted C runtime env.
 *//* restricted capabilities before import *//* after import into hashtable *//*
 * Look up variable from environment,
 * return address of storage for that variable,
 * or NULL if not found
 *//* CONFIG_CMD_EDITENV *//* Set read buffer to initial value or empty sting *//* before import into hashtable *//*
 * Interactively edit an environment variable
 *//* walk through each variable and print the flags if non-default *//* Print the static flags that may exist *//* Print the available variable access types *//* Print the available variable types *//*
 * Print the flags available and what variables have flags
 *//* walk through each variable and print the callback if it has one *//* Print the static bindings that may exist *//* Print the available callbacks *//*
 * Print the callbacks available and what they are bound to
 *//* this should probably never happen, but just in case... *//* look up the callback in the linker-list *//* Continue calling setenv code *//* prompt for input *//* env_ask envname message1 ... messagen [size] *//* no size *//*
	 * We test the last argument if it can be converted
	 * into a decimal number.  If yes, we assume it's
	 * the size.  Otherwise we echo it as part of the
	 * message.
	 *//*
	 * Check the syntax:
	 *
	 * env_ask envname [message1 ...] [size]
	 *//*
 * Prompt for environment variable
 *//**
 * Set an environment variable to an value in hex
 *
 * @param varname	Environment variable to set
 * @param value		Value to set it to
 * @return 0 if ok, 1 on error
 *//* TODO: this should be unsigned *//**
 * Set an environment variable to an integer value
 *
 * @param varname	Environment variable to set
 * @param value		Value to set it to
 * @return 0 if ok, 1 on error
 *//*
	 * Insert / replace new value
	 *//* Delete only ? *//*
 * Set a new environment variable,
 * or replace or delete an existing one.
 *//* grep for both *//* grep for value *//* grep for name *//* use regex matching *//* default: grep names and values *//* default: substring search	*//* print selected env vars *//* print all env vars *//* should never happen *//* print whole list *//* print a single name *//*
 * Command interface: print one or all environment variables
 *
 * Returns 0 in case of error, or length of printed string
 *//*
 * This variable is incremented on each do_env_set(), so it can
 * be used via get_env_id() as an indication, if the environment
 * has changed or not. So it is possible to reread an environment
 * variable only if the environment was changed ... done so for
 * example in NetInitLoop()
 *//* 1 MiB *//*
 * Maximum expected input data size for import command
 *//*
 * Support for persistent environment data
 *
 * The "environment" is stored on external storage as a list of '\0'
 * terminated "name=value" strings. The end of the list is marked by
 * a double '\0'. The environment is preceded by a 32 bit CRC over
 * the data part and, in case of redundant environment, a byte of
 * flags.
 *
 * This linearized representation will also be used before
 * relocation, i. e. as long as we don't have a full C runtime
 * environment. After that, we use a hash table.
 *//*
 * (C) Copyright 2000-2013
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *
 * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
 * Andreas Heppel <aheppel@sysgo.de>
 *
 * Copyright 2011 Freescale Semiconductor, Inc.
 *//opt/src/include/hexdump.hhexdumpprint_hex_dump_bytesprint_hex_dumphex_dump_to_bufferbin2hex_srchex2binhex_to_binhex_byte_packhex_asc_hi(byte)hex_asc_lo(byte)DUMP_PREFIX_NONEDUMP_PREFIX_ADDRESSDUMP_PREFIX_OFFSEThex_asc_hi(x)hex_asc[((x) & 0xf0) >> 4]hex_asc_lo(x)hex_asc[((x) & 0x0f)]HEXDUMP_Hhex_asc/* HEXDUMP_H *//**
 * bin2hex - convert binary data to an ascii hexadecimal string
 * @dst: ascii hexadecimal result
 * @src: binary data
 * @count: binary data length
 *//**
 * hex2bin - convert an ascii hexadecimal string to its binary representation
 * @dst: binary result
 * @src: ascii hexadecimal string
 * @count: result length
 *
 * Return 0 on success, -1 in case of bad input.
 *//**
 * hex_to_bin - convert a hex digit to its real value
 * @ch: ascii character represents hex digit
 *
 * hex_to_bin() converts one hex digit to its actual value or -1 in case of bad
 * input.
 *//*
 * Copyright (C) 2018 Synopsys, Inc. All rights reserved.
 *
 */prefix_strprefix_typerowsizegroupsizelinebuflen/opt/src/cmd/nvedit_efi.cnvedit_efido_env_set_efiEFI_VARIABLE_BOOTSERVICE_ACCESS |
		     EFI_VARIABLE_RUNTIME_ACCESS-nv"-nv"## Failed to process an argument, %s
"## Failed to process an argument, %s\n"var_name16## Out of memory
"## Out of memory\n"efi_set_variable(var_name16, &guid, attributes, size, value)__efi_nesting_inc(), "efi_set_variable(var_name16, &guid, attributes, size, value)"EFI_CALL(efi_set_variable(var_name16, &guid, attributes,
					size, value))cmd/nvedit_efi.c406efi_set_variable(var_name16, &guid, attributes,
					size, value)char[61]__efi_nesting_dec(), (unsigned long)((uintptr_t)_r & ~EFI_ERROR_MASK), "efi_set_variable(var_name16, &guid, attributes, size, value)"<hexdump.h>## Failed to set EFI variable
"## Failed to set EFI variable\n"append_value=0x"=0x"tmp_datahex_valuehex_ptrtmp_buf=H"=H"Error: illegal hexadecimal string
"Error: illegal hexadecimal string\n"=""=\""=S""=S\""'"'new_bufdo_env_print_efiefi_dump_var_allefi_get_next_variable_name(&size, var_name16, &guid)__efi_nesting_inc(), "efi_get_next_variable_name(&size, var_name16, &guid)"EFI_CALL(efi_get_next_variable_name(&size, var_name16,
							  &guid))efi_get_next_variable_name(&size, var_name16,
							  &guid)__efi_nesting_dec(), (unsigned long)((uintptr_t)_r & ~EFI_ERROR_MASK), "efi_get_next_variable_name(&size, var_name16, &guid)"9223372036854775813EFI_CALL(efi_get_next_variable_name(&size,
								  var_name16,
								  &guid))efi_get_next_variable_name(&size,
								  var_name16,
								  &guid)efi_dump_varsargv[0]utf8_utf16_strlen(argv[0])&putf8_utf16_strcpy(&p, argv[0])efi_dump_single_varefi_get_variable(name, guid, &attributes, &size, data)__efi_nesting_inc(), "efi_get_variable(name, guid, &attributes, &size, data)"EFI_CALL(efi_get_variable(name, guid, &attributes, &size, data))__efi_nesting_dec(), (unsigned long)((uintptr_t)_r & ~EFI_ERROR_MASK), "efi_get_variable(name, guid, &attributes, &size, data)"EFI_CALL(efi_get_variable(name, guid, &attributes, &size,
						data))efi_get_variable(name, guid, &attributes, &size,
						data)Error: "%ls" not defined
"Error: \"%ls\" not defined\n"%ls:"%ls:"const struct <unnamed>[5]struct <unnamed>[5]efi_var_attrsARRAY_SIZE(efi_var_attrs)'|', DataSize = 0x%zx
", DataSize = 0x%zx\n"const struct <unnamed>[]NV"NV"BS"BS"RT"RT"AW"AW"AT"AT"/* set *//* delete *//**
 * do_env_print_efi() - set UEFI variable
 *
 * @cmdtp:	Command table
 * @flag:	Command flag
 * @argc:	Number of arguments
 * @argv:	Argument array
 * Return:	CMD_RET_SUCCESS on success, or CMD_RET_RET_FAILURE
 *
 * This function is for "env set -e" or "setenv -e" command:
 *   => env set -e var [value ...]]
 * Encode values specified and set given UEFI variable.
 * If no value is specified, delete the variable.
 *//* string *//* not multiple of two *//* hexadecimal-byte array *//* convert hex hexadecimal number *//* hexadecimal number *//**
 * append_value() - encode UEFI variable's value
 * @bufp:	Buffer of encoded UEFI variable's value
 * @sizep:	Size of buffer
 * @data:	data to be encoded into the value
 * Return:	0 on success, -1 otherwise
 *
 * Interpret a given data string and append it to buffer.
 * Buffer will be realloc'ed if necessary.
 *
 * Currently supported formats are:
 *   =0x0123...:		Hexadecimal number
 *   =H0123...:			Hexadecimal-byte array
 *   ="...", =S"..." or <string>:
 *				String
 *//* enumerate and show all UEFI variables *//* show specified UEFI variables *//**
 * do_env_print_efi() - show information about UEFI variables
 *
 * @cmdtp:	Command table
 * @flag:	Command flag
 * @argc:	Number of arguments
 * @argv:	Argument array
 * Return:	CMD_RET_SUCCESS on success, or CMD_RET_RET_FAILURE
 *
 * This function is for "env print -e" or "printenv -e" command:
 *   => env print -e [var [...]]
 * If one or more variable names are specified, show information
 * named UEFI variables, otherwise show all the UEFI variables.
 *//**
 * efi_dump_vars() - show information about all the UEFI variables
 *
 * Return:	CMD_RET_SUCCESS on success, or CMD_RET_RET_FAILURE
 *
 * Show information encoded in all the UEFI variables
 *//**
 * efi_dump_vars() - show information about named UEFI variables
 *
 * @argc:	Number of arguments (variables)
 * @argv:	Argument (variable name) array
 * Return:	CMD_RET_SUCCESS on success, or CMD_RET_RET_FAILURE
 *
 * Show information encoded in named UEFI variables
 *//**
 * efi_dump_single_var() - show information about a UEFI variable
 *
 * @name:	Name of the variable
 * @guid:	Vendor GUID
 *
 * Show information encoded in one UEFI variable
 *//*
 * From efi_variable.c,
 *
 * Mapping between UEFI variables and u-boot variables:
 *
 *   efi_$guid_$varname = {attributes}(type)value
 *//*
 *  Integrate UEFI variables to u-boot env interface
 *
 *  Copyright (c) 2018 AKASHI Takahiro, Linaro Limited
 *//opt/src/include/nvme.hnvmenvme_print_infonvme_scan_namespacenvme_set_featuresnvme_dev *nvme_get_featuresnvme_identifynvme_dev__NVME_H__/* __NVME_H__ *//**
 * nvme_print_info - print detailed NVMe controller and namespace information
 *
 * This prints out detailed human readable NVMe controller and namespace
 * information which is very useful for debugging.
 *
 * @udev:	NVMe controller device
 * @return:	0 on success, -EIO if NVMe identify command fails
 *//**
 * nvme_scan_namespace - scan all namespaces attached to NVMe controllers
 *
 * This probes all registered NVMe uclass device drivers in the system,
 * and tries to find all namespaces attached to the NVMe controllers.
 *
 * @return:	0 on success, -ve on error
 *//**
 * nvme_set_features - specify the attributes of the feature indicated
 *
 * This specifies the attributes of the feature indicated.
 *
 * @dev:	NVMe controller device
 * @fid:	feature id to provide data
 * @dword11:	command-specific input parameter
 * @dma_addr:	data structure used as part of the specified feature
 * @result:	command-specific result in the completion queue entry
 * @return:	0 on success, -ETIMEDOUT on command execution timeout,
 *		-EIO on command execution fails
 *//**
 * nvme_get_features - retrieve the attributes of the feature specified
 *
 * This retrieves the attributes of the feature specified.
 *
 * @dev:	NVMe controller device
 * @fid:	feature id to provide data
 * @nsid:	namespace id the command applies to
 * @dma_addr:	data structure used as part of the specified feature
 * @result:	command-specific result in the completion queue entry
 * @return:	0 on success, -ETIMEDOUT on command execution timeout,
 *		-EIO on command execution fails
 *//**
 * nvme_identify - identify controller or namespace capabilities and status
 *
 * This issues an identify command to the NVMe controller to return a data
 * buffer that describes the controller or namespace capabilities and status.
 *
 * @dev:	NVMe controller device
 * @nsid:	0 for controller, namespace id for namespace to identify
 * @cns:	1 for controller, 0 for namespace
 * @dma_addr:	dma buffer address to store the identify result
 * @return:	0 on success, -ETIMEDOUT on command execution timeout,
 *		-EIO on command execution fails
 *//*
 * Copyright (C) 2017 NXP Semiconductors
 * Copyright (C) 2017 Bin Meng <bmeng.cn@gmail.com>
 */fiddword11dma_addrnsidcns/opt/src/cmd/nvme.cdo_nvme"scan"deta"deta""NVM Express sub-system""scan - scan NVMe devices\n" "nvme detail - show details of current NVMe device\n" "nvme info - show all available NVMe devices\n" "nvme device [dev] - show or set current NVMe device\n" "nvme part [dev] - print partition table of one or all NVMe devices\n" "nvme read addr blk# cnt - read `cnt' blocks starting at block\n" "     `blk#' to memory address `addr'\n" "nvme write addr blk# cnt - write `cnt' blocks starting at block\n" "     `blk#' from memory address `addr'"NVM Express sub-systemscan - scan NVMe devices
nvme detail - show details of current NVMe device
nvme info - show all available NVMe devices
nvme device [dev] - show or set current NVMe device
nvme part [dev] - print partition table of one or all NVMe devices
nvme read addr blk# cnt - read `cnt' blocks starting at block
     `blk#' to memory address `addr'
nvme write addr blk# cnt - write `cnt' blocks starting at block
     `blk#' from memory address `addr'"scan - scan NVMe devices\n"
	"nvme detail - show details of current NVMe device\n"
	"nvme info - show all available NVMe devices\n"
	"nvme device [dev] - show or set current NVMe device\n"
	"nvme part [dev] - print partition table of one or all NVMe devices\n"
	"nvme read addr blk# cnt - read `cnt' blocks starting at block\n"
	"     `blk#' to memory address `addr'\n"
	"nvme write addr blk# cnt - write `cnt' blocks starting at block\n"
	"     `blk#' from memory address `addr'"char[440]U_BOOT_CMD(
	nvme, 8, 1, do_nvme,
	"NVM Express sub-system",
	"scan - scan NVMe devices\n"
	"nvme detail - show details of current NVMe device\n"
	"nvme info - show all available NVMe devices\n"
	"nvme device [dev] - show or set current NVMe device\n"
	"nvme part [dev] - print partition table of one or all NVMe devices\n"
	"nvme read addr blk# cnt - read `cnt' blocks starting at block\n"
	"     `blk#' to memory address `addr'\n"
	"nvme write addr blk# cnt - write `cnt' blocks starting at block\n"
	"     `blk#' from memory address `addr'"
)_u_boot_list_2_cmd_2_nvme.u_boot_list_2_cmd_2_nvmenvme_curr_dev<nvme.h>/opt/src/include/video_osd.hvideo_osdvideo_osd_printvideo_osd_set_sizevideo_osd_set_memvideo_osd_get_infovideo_osd_info *video_osd_opsvideo_osd_infoset_sizeminor_versionmajor_versionvideo_osd_get_ops(dev)((struct video_osd_ops *)(dev)->driver->ops)_VIDEO_OSD_H_/* !_VIDEO_OSD_H_ *//**
 * video_osd_print() - Print a string in a given color to specified coordinates
 *		       on the OSD
 *
 * @dev:	OSD instance to write to.
 * @col		The x-coordinate of the position the string should be written
 *		to
 * @row		The y-coordinate of the position the string should be written
 *		to
 * @color:	The color in which the specified string should be printed; the
 *		interpretation of the value is driver-specific, and possible
 *		values should be defined e.g. in a driver include file.
 * @text:	The string data that should be printed on the OSD
 * @return 0 if OK, -ve on error.
 *//**
 * video_osd_set_size() - Set the position and dimension of the OSD's
 *              writeable window
 *
 * @dev:	OSD instance to write to.
 * @col		The number of characters in the window's columns
 * @row		The number of characters in the window's rows
 * @return 0 if OK, -ve on error.
 *//**
 * video_osd_set_mem() - Write text data to OSD memory
 *
 * The passed data are device-specific, and it's up to the driver how to
 * interpret them. How the count parameter is interpreted is also
 * driver-specific; most likely the given data will be written to the OSD count
 * times back-to-back, which is e.g. convenient for filling areas of the OSD
 * with a single character.
 *
 * For example a invocation of
 *
 * video_osd_set_mem(dev, 0, 0, "A", 1, 10);
 *
 * will write the device-specific text data "A" to the positions (0, 0) to (9,
 * 0) on the OSD.
 *
 * Device-specific text data may, e.g. be a special encoding of glyphs to
 * display and color values in binary format.
 *
 * @dev:	OSD instance to write to.
 * @col:	Horizontal character coordinate to write to.
 * @row		Vertical character coordinate to write to.
 * @buf:	Array containing device-specific data to write to the specified
 *		coordinate on the OSD screen.
 * @buflen:	Length of the data in the passed buffer (in byte).
 * @count:	Write count many repetitions of the given text data
 * @return 0 if OK, -ve on error.
 *//**
 * video_osd_get_info() - Get information about a OSD instance
 *
 * A OSD instance may keep some internal data about itself. This function can
 * be used to access this data.
 *
 * @dev:	OSD instance to query.
 * @info:	Pointer to a structure that takes the information read from the
 *		OSD instance.
 * @return 0 if OK, -ve on error.
 *//**
	 * print() - Print a string in a given color to specified coordinates
	 *	     on the OSD
	 *
	 * @dev:	OSD instance to write to.
	 * @col		The x-coordinate of the position the string should be
	 *		written to
	 * @row		The y-coordinate of the position the string should be
	 *		written to
	 * @color:	The color in which the specified string should be
	 *		printed; the interpretation of the value is
	 *		driver-specific, and possible values should be defined
	 *		e.g. in a driver include file.
	 * @text:	The string data that should be printed on the OSD
	 * @return 0 if OK, -ve on error.
	 *//**
	 * set_size() - Set the position and dimension of the OSD's
	 *              writeable window
	 *
	 * @dev:	OSD instance to write to.
	 * @col		The number of characters in the window's columns
	 * @row		The number of characters in the window's rows
	 * @return 0 if OK, -ve on error.
	 *//**
	 * set_mem() - Write driver-specific text data to OSD screen
	 *
	 * The passed data are device-specific, and it's up to the driver how
	 * to interpret them. How the count parameter is interpreted is also
	 * driver-specific; most likely the given data will be written to the
	 * OSD count times back-to-back, which is e.g. convenient for filling
	 * areas of the OSD with a single character.
	 *
	 * For example a invocation of
	 *
	 * video_osd_set_mem(dev, 0, 0, "A", 1, 10);
	 *
	 * will write the device-specific text data "A" to the positions (0, 0)
	 * to (9, 0) on the OSD.
	 *
	 * Device-specific text data may, e.g. be a special encoding of glyphs
	 * to display and color values in binary format.
	 *
	 * @dev:	OSD instance to write to.
	 * @col:	Horizontal character coordinate to write to.
	 * @row		Vertical character coordinate to write to.
	 * @buf:	Array containing device-specific data to write to the
	 *		specified coordinate on the OSD screen.
	 * @buflen:	Length of the data in the passed buffer (in byte).
	 * @count:	Write count many repetitions of the given text data
	 * @return 0 if OK, -ve on error.
	 *//**
	 * get_info() - Get information about a OSD instance
	 *
	 * A OSD instance may keep some internal data about itself. This
	 * function can be used to access this data.
	 *
	 * @dev:	OSD instance to query.
	 * @info:	Pointer to a structure that takes the information read
	 *		from the OSD instance.
	 * @return 0 if OK, -ve on error.
	 *//**
 * struct video_osd_ops - driver operations for OSD uclass
 *
 * The OSD uclass implements support for text-oriented on-screen displays,
 * which are taken to be devices that independently display a graphical
 * text-based overlay over the video output of an associated display.
 *
 * The functions defined by the uclass support writing text to the display in
 * either a generic form (by specifying a string, a driver-specific color value
 * for the text, and screen coordinates in rows and columns) or a
 * driver-specific form (by specifying "raw" driver-specific data to display at
 * a given coordinate).
 *
 * Functions to read device information and set the size of the virtual OSD
 * screen (in rows and columns) are also supported.
 *
 * Drivers should support these operations unless otherwise noted. These
 * operations are intended to be used by uclass code, not directly from
 * other code.
 *//* The minor version of the OSD device *//* The major version of the OSD device *//* The height of the OSD display in rows *//* The width of the OSD display in columns *//*
 * (C) Copyright 2017
 * Mario Six,  Guntermann & Drunck GmbH, mario.six@gdsys.cc
 *//opt/src/cmd/osd.cosddo_osdcmd_tbl_t[5]cmd_tbl_s[5]cmd_osd_subARRAY_SIZE(cmd_osd_sub)do_osd_numosd_noCurrent osd is %d
"Current osd is %d\n"Setting osd to %d
"Setting osd to %d\n"Failure changing osd number (err = %d)
"Failure changing osd number (err = %d)\n"do_show_osdUCLASS_VIDEO_OSDError while getting OSD uclass (err=%d)
"Error while getting OSD uclass (err=%d)\n"typeof(*osd)uclass_foreach_dev(osd, uc)osd->uclass_node.nextInvalid osd %d: err=%d
"Invalid osd %d: err=%d\n"do_osd_sizeNo osd selected
"No osd selected\n"Could not set size on osd %s
"Could not set size on osd %s\n"do_osd_print<video_osd.h>Could not print string to osd %s
"Could not print string to osd %s\n"do_osd_writehexstrMemory allocation failure
"Memory allocation failure\n"Hexadecimal input contained invalid characters
"Hexadecimal input contained invalid characters\n"%s: Could not write to video mem
"%s: Could not write to video mem\n"show_osdOSD %d:	%s"OSD %d:\t%s"device_active(osd)osd_get_osd_curcmd_osd_set_osd_num%s: No OSD %u (err = %d)
"%s: No OSD %u (err = %d)\n""OSD sub-system"osd_help_textOSD sub-systemchar[355]U_BOOT_CMD(
	osd, 6, 1, do_osd,
	"OSD sub-system",
	osd_help_text
)_u_boot_list_2_cmd_2_osd.u_boot_list_2_cmd_2_osdshow  - show OSD info
osd dev [dev] - show or set current OSD
write [pos_x] [pos_y] [buffer] [count] - write 8-bit hex encoded buffer to osd memory at a given position
print [pos_x] [pos_y] [color] [text] - write ASCII buffer (given by text data and driver-specific color information) to osd memory
size [size_x] [size_y] - set OSD XY size in characters
U_BOOT_CMD_MKENT(show, 1, 1, do_show_osd, "", "")U_BOOT_CMD_MKENT(dev, 1, 1, do_osd_num, "", "")U_BOOT_CMD_MKENT(write, 4, 1, do_osd_write, "", "")U_BOOT_CMD_MKENT(print, 4, 1, do_osd_print, "", "")U_BOOT_CMD_MKENT(size, 2, 1, do_osd_size, "", "")osd_cur/* Strip off leading 'osd' command argument *//* show specific OSD *//* show all OSDs *//**
 * show_osd() - Display information about a OSD device
 *
 * Display a device's ID (sequence number), and whether it is active (i.e.
 * probed) or not.
 *
 * @osd: OSD device to print information for
 *//**
 * osd_get_osd_cur() - Get the selected OSD device
 *
 * Get the OSD device that is used by all OSD commands.
 *
 * @osdp: Pointer to structure that will receive the currently selected OSD
 *	  device.
 * Return: 0 if OK, -ve on error
 *//**
 * cmd_osd_set_osd_num() - Set the OSD selected for operation
 *
 * Set the OSD device, which will be used by all subsequent OSD commands.
 *
 * Devices are identified by their uclass sequence number (as listed by 'osd
 * show').
 *
 * @osdnum: The OSD device to be selected, identified by its sequence number.
 * Return: 0 if OK, -ve on error
 *//* Container for selected OSD device *//*
 * (C) Copyright 2017
 * Mario Six,  Guntermann & Drunck GmbH, mario.six@gdsys.cc
 *
 * based on the gdsys osd driver, which is
 *
 * (C) Copyright 2010
 * Dirk Eibach,  Guntermann & Drunck GmbH, eibach@gdsys.de
 */osdposdnum/opt/src/cmd/part.cdo_partnumber"number"do_part_numberCMD_PART_INFO_NUMBERdo_part_sizeCMD_PART_INFO_SIZEdo_part_startCMD_PART_INFO_STARTdo_part_info%d"%d"** Unknown cmd_part_info value: %d
"** Unknown cmd_part_info value: %d\n"do_part_list-bootable"-bootable"Unknown option %s
"Unknown option %s\n"%s%x"%s%x"do_part_uuidcmd_part_info"disk partition related commands""uuid <interface> <dev>:<part>\n" "    - print partition UUID\n" "part uuid <interface> <dev>:<part> <varname>\n" "    - set environment variable to partition UUID\n" "part list <interface> <dev>\n" "    - print a device's partition table\n" "part list <interface> <dev> [flags] <varname>\n" "    - set environment variable to the list of partitions\n" "      flags can be -bootable (list only bootable partitions)\n" "part start <interface> <dev> <part> <varname>\n" "    - set environment variable to the start of the partition (in blocks)\n" "      part can be either partition number or partition name\n" "part size <interface> <dev> <part> <varname>\n" "    - set environment variable to the size of the partition (in blocks)\n" "      part can be either partition number or partition name\n" "part number <interface> <dev> <part> <varname>\n" "    - set environment variable to the partition number using the partition name\n" "      part must be specified as partition name"U_BOOT_CMD(
	part,	CONFIG_SYS_MAXARGS,	1,	do_part,
	"disk partition related commands",
	"uuid <interface> <dev>:<part>\n"
	"    - print partition UUID\n"
	"part uuid <interface> <dev>:<part> <varname>\n"
	"    - set environment variable to partition UUID\n"
	"part list <interface> <dev>\n"
	"    - print a device's partition table\n"
	"part list <interface> <dev> [flags] <varname>\n"
	"    - set environment variable to the list of partitions\n"
	"      flags can be -bootable (list only bootable partitions)\n"
	"part start <interface> <dev> <part> <varname>\n"
	"    - set environment variable to the start of the partition (in blocks)\n"
	"      part can be either partition number or partition name\n"
	"part size <interface> <dev> <part> <varname>\n"
	"    - set environment variable to the size of the partition (in blocks)\n"
	"      part can be either partition number or partition name\n"
	"part number <interface> <dev> <part> <varname>\n"
	"    - set environment variable to the partition number using the partition name\n"
	"      part must be specified as partition name"
)disk partition related commandsuuid <interface> <dev>:<part>
    - print partition UUID
part uuid <interface> <dev>:<part> <varname>
    - set environment variable to partition UUID
part list <interface> <dev>
    - print a device's partition table
part list <interface> <dev> [flags] <varname>
    - set environment variable to the list of partitions
      flags can be -bootable (list only bootable partitions)
part start <interface> <dev> <part> <varname>
    - set environment variable to the start of the partition (in blocks)
      part can be either partition number or partition name
part size <interface> <dev> <part> <varname>
    - set environment variable to the size of the partition (in blocks)
      part can be either partition number or partition name
part number <interface> <dev> <part> <varname>
    - set environment variable to the partition number using the partition name
      part must be specified as partition name"uuid <interface> <dev>:<part>\n"
	"    - print partition UUID\n"
	"part uuid <interface> <dev>:<part> <varname>\n"
	"    - set environment variable to partition UUID\n"
	"part list <interface> <dev>\n"
	"    - print a device's partition table\n"
	"part list <interface> <dev> [flags] <varname>\n"
	"    - set environment variable to the list of partitions\n"
	"      flags can be -bootable (list only bootable partitions)\n"
	"part start <interface> <dev> <part> <varname>\n"
	"    - set environment variable to the start of the partition (in blocks)\n"
	"      part can be either partition number or partition name\n"
	"part size <interface> <dev> <part> <varname>\n"
	"    - set environment variable to the size of the partition (in blocks)\n"
	"      part can be either partition number or partition name\n"
	"part number <interface> <dev> <part> <varname>\n"
	"    - set environment variable to the partition number using the partition name\n"
	"      part must be specified as partition name"char[912]_u_boot_list_2_cmd_2_part.u_boot_list_2_cmd_2_part/* Loops should have been exited at the last argument, which
		 * as it contained the variable *//*
 * Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
 *
 * made from cmd_ext2, which was:
 *
 * (C) Copyright 2004
 * esd gmbh <www.esd-electronics.com>
 * Reinhard Arlt <reinhard.arlt@esd-electronics.com>
 *
 * made from cmd_reiserfs by
 *
 * (C) Copyright 2003 - 2004
 * Sysgo Real-Time Solutions, AG <www.elinos.com>
 * Pavel Bartusek <pba@sysgo.com>
 *//opt/src/arch/sandbox/include/asm/processor.hprocessor_ASM_PROCESSOR_H/* This file is required for PCI *//opt/src/cmd/pci.cdo_pcicmd_sizeNo such bus
"No such bus\n"No such device
"No such device\n"pci_show_regionsBus '%s' is not a PCI controller
"Bus '%s' is not a PCI controller\n"#   %-16s %-16s %-16s  %s
"#   %-16s %-16s %-16s  %s\n"Bus start"Bus start"Phys start"Phys start"Size"Size"Flags"Flags"%d   %#016llx %#016llx %#016llx  "%d   %#016llx %#016llx %#016llx  "const pci_regionconst pci_region *mem "mem "const pci_flag_infoconst pci_flag_info[5]pci_flag_info[5]pci_flag_infoARRAY_SIZE(pci_flag_info)const pci_flag_info *pci_flag_info *<asm/processor.h>usagepci_cfg_modify %0*lx" %0*lx"pci_cfg_displaybyte_sizeget_pci_devcnumioldbdfsbdfs[0]bdfs[1]bdfs[2]PCI_BDF(bdfs[0], bdfs[1], bdfs[2])pciinfopci_child_platdata *pplat%02x.%02x.%02x   "%02x.%02x.%02x   "pplat->devfnPCI_DEV(pplat->devfn)PCI_FUNC(pplat->devfn)
Found PCI device %02x.%02x.%02x:
"\nFound PCI device %02x.%02x.%02x:\n"pci_header_show_briefsubclassshort_listing0x%.4lx     0x%.4lx     %-23s 0x%.2lx
"0x%.4lx     0x%.4lx     %-23s 0x%.2lx\n"pciinfo_headerScanning PCI devices on bus %d
"Scanning PCI devices on bus %d\n"BusDevFun  VendorId   DeviceId   Device Class       Sub-Class
"BusDevFun  VendorId   DeviceId   Device Class       Sub-Class\n"_____________________________________________________________
"_____________________________________________________________\n"pci_header_showheader_typepci_reg_info *pci_reg_info[6]  class code =                  0x%.2x (%s)
"  class code =                  0x%.2x (%s)\n"pci_reg_info[8]pci_reg_info[14]pci_reg_info[21]pci_reg_info[25]unknown header
"unknown header\n"pci_bar_showCardBus doesn't support BARs
"CardBus doesn't support BARs\n"bar_cntID   Base                Size                Width  Type
"ID   Base                Size                Width  Type\n"----------------------------------------------------------
"----------------------------------------------------------\n"bar_idreg_addrbase_lowsize_low4294967280~0xfbase_highis_64prefetchableis_io %d   %#016llx  %#016llx  %d     %s   %s
" %d   %#016llx  %#016llx  %d     %s   %s\n"I/O"I/O"MEM"MEM"Prefetchable"Prefetchable"pci_show_regs  %s =%*s%#.*lx
"  %s =%*s%#.*lx\n"pci_field_widthpci_byte_sizepci_reg_info"list and access PCI Configuration Space"pci_help_textlist and access PCI Configuration Spacechar[591]U_BOOT_CMD(
	pci,	5,	1,	do_pci,
	"list and access PCI Configuration Space", pci_help_text
)_u_boot_list_2_cmd_2_pci.u_boot_list_2_cmd_2_pci[bus] [long]
    - short or long list of PCI devices on bus 'bus'
pci enum
    - Enumerate PCI buses
pci header b.d.f
    - show header of PCI device 'bus.device.function'
pci bar b.d.f
    - show BARs base and size for device b.d.f'
pci regions
    - show PCI regions
pci display[.b, .w, .l] b.d.f [address] [# of objects]
    - display PCI configuration space (CFG)
pci next[.b, .w, .l] b.d.f address
    - modify, read and keep CFG address
pci modify[.b, .w, .l] b.d.f address
    -  modify, auto increment CFG address
pci write[.b, .w, .l] b.d.f address value
    - write to CFG addressconst pci_flag_info[]pci_flag_info[]"io""prefetch"sysmem"sysmem"readonly"readonly"pci_reg_info[]"capabilities"secondary status"secondary status"primary bus number"primary bus number"CardBus number"CardBus number"subordinate bus number"subordinate bus number"CardBus latency timer"CardBus latency timer"CardBus memory base 0"CardBus memory base 0"CardBus memory limit 0"CardBus memory limit 0"CardBus memory base 1"CardBus memory base 1"CardBus memory limit 1"CardBus memory limit 1"CardBus IO base 0"CardBus IO base 0"CardBus IO base high 0"CardBus IO base high 0"CardBus IO limit 0"CardBus IO limit 0"CardBus IO limit high 0"CardBus IO limit high 0"CardBus IO base 1"CardBus IO base 1"CardBus IO base high 1"CardBus IO base high 1"CardBus IO limit 1"CardBus IO limit 1"CardBus IO limit high 1"CardBus IO limit high 1"interrupt line"interrupt line"interrupt pin"interrupt pin"bridge control"bridge control"subvendor ID"subvendor ID"subdevice ID"subdevice ID"PC Card 16bit base address"PC Card 16bit base address"regs_cardbusbase address 1"base address 1"secondary bus number"secondary bus number"secondary latency timer"secondary latency timer"IO base"IO base"IO limit"IO limit"memory base"memory base"memory limit"memory limit"prefetch memory base"prefetch memory base"prefetch memory limit"prefetch memory limit"prefetch memory base upper"prefetch memory base upper"prefetch memory limit upper"prefetch memory limit upper"IO base upper 16 bits"IO base upper 16 bits"IO limit upper 16 bits"IO limit upper 16 bits"expansion ROM base address"expansion ROM base address"regs_bridgebase address 2"base address 2"base address 3"base address 3"base address 4"base address 4"base address 5"base address 5"cardBus CIS pointer"cardBus CIS pointer"sub system vendor ID"sub system vendor ID"sub system ID"sub system ID"min Grant"min Grant"max Latency"max Latency"regs_normalsub class code"sub class code"programming interface"programming interface"cache line"cache line"latency time"latency time"header type"header type"BIST"BIST"base address 0"base address 0"regs_restvendor ID"vendor ID"device ID"device ID"command register ID"command register ID"status register"status register"revision ID"revision ID"regs_startdefined(CONFIG_DM_PCI)/* bars *//* write *//* modify *//* next *//* display *//* header *//* short listing *//* scan bus *//* no break *//* Check for a size specification. *//* PCI Configuration Space access commands
 *
 * Syntax:
 *	pci display[.b, .w, .l] bus.device.function} [addr] [len]
 *	pci next[.b, .w, .l] bus.device.function [addr]
 *      pci modify[.b, .w, .l] bus.device.function [addr]
 *      pci write[.b, .w, .l] bus.device.function addr value
 *//* Print the lines.
	 * once, and all accesses are with the specified bus width.
	 *//* Standard PCI config space *//**
 * get_pci_dev() - Convert the "bus.device.function" identifier into a number
 *
 * @name: Device string in the form "bus.device.function" where each is in hex
 * @return encoded pci_dev_t or -1 if the string was invalid
 *//*
			 * If this is not a multi-function device, we skip
			 * the rest.
			 *//**
 * pciinfo() - Show a list of devices on the PCI bus
 *
 * Show information about devices on PCI bus. Depending on @short_pci_listing
 * the output will be more or less exhaustive.
 *
 * @bus_num: The number of the bus to be scanned
 * @short_pci_listing: true to use short form, showing only a brief header
 * for each device
 *//**
 * pci_header_show_brief() - Show the short-form PCI device header
 *
 * Reads and prints the header of the specified PCI device in short form.
 *
 * @dev: Bus+Device+Function number
 *//**
 * pci_header_show_brief() - Show the short-form PCI device header
 *
 * Reads and prints the header of the specified PCI device in short form.
 *
 * @dev: PCI device to show
 *//* PCI-to-CardBus bridge *//* PCI-to-PCI bridge *//* "normal" PCI device *//**
 * pci_header_show() - Show the header of the specified PCI device.
 *
 * @dev: Bus+Device+Function number
 *//*
 * PCI routines
 *//*
 * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
 * Andreas Heppel <aheppel@sysgo.de>
 *
 * (C) Copyright 2002
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 * Wolfgang Grandegger, DENX Software Engineering, wg@denx.de.
 *//opt/src/include/dm/pinctrl.hpinctrlpinctrl_gpio_freepinctrl_gpio_requestpinctrl_get_pin_namepinctrl_get_pins_countpinctrl_get_pin_muxingpinctrl_get_gpio_muxpinctrl_decode_pin_configpinctrl_get_periph_idpinctrl_request_noflagspinctrl_requestpinctrl_select_statepinctrl_generic_set_statepin_config_paramPIN_CONFIG_BIAS_BUS_HOLDPIN_CONFIG_BIAS_DISABLEPIN_CONFIG_BIAS_HIGH_IMPEDANCEPIN_CONFIG_BIAS_PULL_DOWNPIN_CONFIG_BIAS_PULL_PIN_DEFAULTPIN_CONFIG_BIAS_PULL_UPPIN_CONFIG_DRIVE_OPEN_DRAINPIN_CONFIG_DRIVE_OPEN_SOURCEPIN_CONFIG_DRIVE_PUSH_PULLPIN_CONFIG_DRIVE_STRENGTHPIN_CONFIG_DRIVE_STRENGTH_UAPIN_CONFIG_INPUT_DEBOUNCEPIN_CONFIG_INPUT_ENABLEPIN_CONFIG_INPUT_SCHMITTPIN_CONFIG_INPUT_SCHMITT_ENABLEPIN_CONFIG_LOW_POWER_MODEPIN_CONFIG_OUTPUT_ENABLEPIN_CONFIG_OUTPUTPIN_CONFIG_POWER_SOURCEPIN_CONFIG_SLEEP_HARDWARE_STATEPIN_CONFIG_SLEW_RATEPIN_CONFIG_SKEW_DELAYPIN_CONFIG_ENDPIN_CONFIG_MAXpinctrl_opspinconf_paramgpio_disable_freegpio_request_enableget_pin_muxingget_gpio_muxget_periph_idset_state_simplepinconf_group_setpinconf_setconst pinconf_paramconst pinconf_param *pinconf_param *pinconf_paramspinconf_num_paramspinmux_group_setpinmux_setget_function_nameget_functions_countget_group_nameget_groups_countget_pin_nameget_pins_countdefault_valuepinctrl_get_ops(dev)((struct pinctrl_ops *)(dev)->driver->ops)PINMUX_SIZEPINNAME_SIZE__PINCTRL_HCONFIG_IS_ENABLED(PINCTRL_GENERIC)CONFIG_IS_ENABLED(PINCTRL)PINCTRLCONFIG_VAL(PINCTRL)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_PINCTRLCONFIG_PINCTRLPINCTRL_GENERICCONFIG_VAL(PINCTRL_GENERIC_MODULE)CONFIG_PINCTRL_GENERIC_MODULE__ARG_PLACEHOLDER_CONFIG_PINCTRL_GENERIC_MODULE__ARG_PLACEHOLDER_CONFIG_PINCTRL_GENERIC_MODULE 1PINCTRL_GENERIC_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_PINCTRL_GENERIC_MODULECONFIG_VAL(PINCTRL_GENERIC)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_PINCTRL_GENERICCONFIG_PINCTRL_GENERICCONFIG_VAL(PINCTRL_MODULE)CONFIG_PINCTRL_MODULE__ARG_PLACEHOLDER_CONFIG_PINCTRL_MODULE__ARG_PLACEHOLDER_CONFIG_PINCTRL_MODULE 1PINCTRL_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_PINCTRL_MODULE/* __PINCTRL_H *//**
 * pinctrl_gpio_free() - free a single pin used as GPIO
 *
 * @dev: GPIO peripheral device
 * @offset: the GPIO pin offset from the GPIO controller
 * @return: 0 on success, or negative error code on failure
 *//**
 * pinctrl_gpio_request() - request a single pin to be used as GPIO
 *
 * @dev: GPIO peripheral device
 * @offset: the GPIO pin offset from the GPIO controller
 * @return: 0 on success, or negative error code on failure
 *//**
 * pinctrl_get_pin_name() - Returns the pin's name
 *
 * This allows to display the pin's name for debug purpose
 *
 * @dev:	Pinctrl device to use
 * @selector	Pin index within pin-controller
 * @buf		Pin's name
 * @return 0 if OK, -ve on error
 *//**
 * pinctrl_get_pins_count() - display pin-controller pins number
 *
 * This allows to know the number of pins owned by a given pin-controller
 *
 * @dev:	Pinctrl device to use
 * @return pins number if OK, -ve on error
 *//**
 * pinctrl_get_pin_muxing() - Returns the muxing description
 *
 * This allows to display the muxing description of the given pin for
 * debug purpose
 *
 * @dev:	Pinctrl device to use
 * @selector	Pin index within pin-controller
 * @buf		Pin's muxing description
 * @size	Pin's muxing description length
 * @return 0 if OK, -ve on error
 *//**
 * pinctrl_get_gpio_mux() - get the mux value for a particular GPIO
 *
 * This allows the raw mux value for a GPIO to be obtained. It is
 * useful for displaying the function being used by that GPIO, such
 * as with the 'gpio' command. This function is internal to the GPIO
 * subsystem and should not be used by generic code. Typically it is
 * used by a GPIO driver with knowledge of the SoC pinctrl setup.
 *
 * @dev:	Pinctrl device to use
 * @banknum:	GPIO bank number
 * @index:	GPIO index within the bank
 * @return mux value (SoC-specific, e.g. 0 for input, 1 for output)
*//**
 * pinctrl_decode_pin_config() - decode pin configuration flags
 *
 * This decodes some of the PIN_CONFIG values into flags, with each value
 * being (1 << pin_cfg). This does not support things with values like the
 * slew rate.
 *
 * @blob:	Device tree blob
 * @node:	Node containing the PIN_CONFIG values
 * @return decoded flag value, or -ve on error
 *//**
 * pinctrl_get_periph_id() - get the peripheral ID for a device
 *
 * This generally looks at the peripheral's device tree node to work out the
 * peripheral ID. The return value is normally interpreted as enum periph_id.
 * so long as this is defined by the platform (which it should be).
 *
 * @dev:	Pinctrl device to use for decoding
 * @periph:	Device to check
 * @return peripheral ID of @periph, or -ENOENT on error
 *//**
 * pinctrl_request_noflags() - Request a particular pinctrl function
 *
 * This is similar to pinctrl_request() but uses 0 for @flags.
 *
 * @dev:	Device to check (UCLASS_PINCTRL)
 * @func:	Function number (driver-specific)
 * @return 0 if OK, -ve on error
 *//**
 * pinctrl_request() - Request a particular pinctrl function
 *
 * @dev:	Device to check (UCLASS_PINCTRL)
 * @func:	Function number (driver-specific)
 * @flags:	Flags (driver-specific)
 * @return 0 if OK, -ve on error
 *//**
 * pinctrl_select_state() - set a device to a given state
 *
 * @dev: peripheral device
 * @statename: state name, like "default"
 * @return: 0 on success, or negative error code on failure
 *//**
 * pinctrl_generic_set_state() - generic set_state operation
 * Parse the DT node of @config and its children and handle generic properties
 * such as "pins", "groups", "functions", and pin configuration parameters.
 *
 * @pctldev: pinctrl device
 * @config: config device (pseudo device), pointing a config node in DTS
 * @return: 0 on success, or negative error code on failure
 *//**
 * Generic pin configuration paramters
 *
 * enum pin_config_param - possible pin configuration parameters
 * @PIN_CONFIG_BIAS_BUS_HOLD: the pin will be set to weakly latch so that it
 *	weakly drives the last value on a tristate bus, also known as a "bus
 *	holder", "bus keeper" or "repeater". This allows another device on the
 *	bus to change the value by driving the bus high or low and switching to
 *	tristate. The argument is ignored.
 * @PIN_CONFIG_BIAS_DISABLE: disable any pin bias on the pin, a
 *	transition from say pull-up to pull-down implies that you disable
 *	pull-up in the process, this setting disables all biasing.
 * @PIN_CONFIG_BIAS_HIGH_IMPEDANCE: the pin will be set to a high impedance
 *	mode, also know as "third-state" (tristate) or "high-Z" or "floating".
 *	On output pins this effectively disconnects the pin, which is useful
 *	if for example some other pin is going to drive the signal connected
 *	to it for a while. Pins used for input are usually always high
 *	impedance.
 * @PIN_CONFIG_BIAS_PULL_DOWN: the pin will be pulled down (usually with high
 *	impedance to GROUND). If the argument is != 0 pull-down is enabled,
 *	if it is 0, pull-down is total, i.e. the pin is connected to GROUND.
 * @PIN_CONFIG_BIAS_PULL_PIN_DEFAULT: the pin will be pulled up or down based
 *	on embedded knowledge of the controller hardware, like current mux
 *	function. The pull direction and possibly strength too will normally
 *	be decided completely inside the hardware block and not be readable
 *	from the kernel side.
 *	If the argument is != 0 pull up/down is enabled, if it is 0, the
 *	configuration is ignored. The proper way to disable it is to use
 *	@PIN_CONFIG_BIAS_DISABLE.
 * @PIN_CONFIG_BIAS_PULL_UP: the pin will be pulled up (usually with high
 *	impedance to VDD). If the argument is != 0 pull-up is enabled,
 *	if it is 0, pull-up is total, i.e. the pin is connected to VDD.
 * @PIN_CONFIG_DRIVE_OPEN_DRAIN: the pin will be driven with open drain (open
 *	collector) which means it is usually wired with other output ports
 *	which are then pulled up with an external resistor. Setting this
 *	config will enable open drain mode, the argument is ignored.
 * @PIN_CONFIG_DRIVE_OPEN_SOURCE: the pin will be driven with open source
 *	(open emitter). Setting this config will enable open source mode, the
 *	argument is ignored.
 * @PIN_CONFIG_DRIVE_PUSH_PULL: the pin will be driven actively high and
 *	low, this is the most typical case and is typically achieved with two
 *	active transistors on the output. Setting this config will enable
 *	push-pull mode, the argument is ignored.
 * @PIN_CONFIG_DRIVE_STRENGTH: the pin will sink or source at most the current
 *	passed as argument. The argument is in mA.
 * @PIN_CONFIG_DRIVE_STRENGTH_UA: the pin will sink or source at most the current
 *	passed as argument. The argument is in uA.
 * @PIN_CONFIG_INPUT_DEBOUNCE: this will configure the pin to debounce mode,
 *	which means it will wait for signals to settle when reading inputs. The
 *	argument gives the debounce time in usecs. Setting the
 *	argument to zero turns debouncing off.
 * @PIN_CONFIG_INPUT_ENABLE: enable the pin's input.  Note that this does not
 *	affect the pin's ability to drive output.  1 enables input, 0 disables
 *	input.
 * @PIN_CONFIG_INPUT_SCHMITT: this will configure an input pin to run in
 *	schmitt-trigger mode. If the schmitt-trigger has adjustable hysteresis,
 *	the threshold value is given on a custom format as argument when
 *	setting pins to this mode.
 * @PIN_CONFIG_INPUT_SCHMITT_ENABLE: control schmitt-trigger mode on the pin.
 *      If the argument != 0, schmitt-trigger mode is enabled. If it's 0,
 *      schmitt-trigger mode is disabled.
 * @PIN_CONFIG_LOW_POWER_MODE: this will configure the pin for low power
 *	operation, if several modes of operation are supported these can be
 *	passed in the argument on a custom form, else just use argument 1
 *	to indicate low power mode, argument 0 turns low power mode off.
 * @PIN_CONFIG_OUTPUT_ENABLE: this will enable the pin's output mode
 *	without driving a value there. For most platforms this reduces to
 *	enable the output buffers and then let the pin controller current
 *	configuration (eg. the currently selected mux function) drive values on
 *	the line. Use argument 1 to enable output mode, argument 0 to disable
 *	it.
 * @PIN_CONFIG_OUTPUT: this will configure the pin as an output and drive a
 *	value on the line. Use argument 1 to indicate high level, argument 0 to
 *	indicate low level. (Please see Documentation/driver-api/pinctl.rst,
 *	section "GPIO mode pitfalls" for a discussion around this parameter.)
 * @PIN_CONFIG_POWER_SOURCE: if the pin can select between different power
 *	supplies, the argument to this parameter (on a custom format) tells
 *	the driver which alternative power source to use.
 * @PIN_CONFIG_SLEEP_HARDWARE_STATE: indicate this is sleep related state.
 * @PIN_CONFIG_SLEW_RATE: if the pin can select slew rate, the argument to
 *	this parameter (on a custom format) tells the driver which alternative
 *	slew rate to use.
 * @PIN_CONFIG_SKEW_DELAY: if the pin has programmable skew rate (on inputs)
 *	or latch delay (on outputs) this parameter (in a custom format)
 *	specifies the clock skew or latch delay. It typically controls how
 *	many double inverters are put in front of the line.
 * @PIN_CONFIG_END: this is the last enumerator for pin configurations, if
 *	you need to pass in custom configurations to the pin controller, use
 *	PIN_CONFIG_END+1 as the base offset.
 * @PIN_CONFIG_MAX: this is the maximum configuration value that can be
 *	presented using the packed format.
 *//**
	 * gpio_disable_free: free up GPIO muxing on a certain pin.
	 *
	 * @dev:	Pinctrl device to use
	 * @selector:	Pin selector
	 * return 0 if OK, -ve on error
	 *//**
	 * gpio_request_enable: requests and enables GPIO on a certain pin.
	 *
	 * @dev:	Pinctrl device to use
	 * @selector:	Pin selector
	 * return 0 if OK, -ve on error
	 *//**
	 * get_pin_muxing() - show pin muxing
	 *
	 * This allows to display the muxing of a given pin. It's useful for
	 * debug purpose to know if a pin is configured as GPIO or as an
	 * alternate function and which one.
	 * Typically it is used by a PINCTRL driver with knowledge of the SoC
	 * pinctrl setup.
	 *
	 * @dev:	Pinctrl device to use
	 * @selector:	Pin selector
	 * @buf		Pin's muxing description
	 * @size	Pin's muxing description length
	 * return 0 if OK, -ve on error
	 *//**
	 * get_gpio_mux() - get the mux value for a particular GPIO
	 *
	 * This allows the raw mux value for a GPIO to be obtained. It is
	 * useful for displaying the function being used by that GPIO, such
	 * as with the 'gpio' command. This function is internal to the GPIO
	 * subsystem and should not be used by generic code. Typically it is
	 * used by a GPIO driver with knowledge of the SoC pinctrl setup.
	 *
	* @dev:		Pinctrl device to use
	* @banknum:	GPIO bank number
	* @index:	GPIO index within the bank
	* @return mux value (SoC-specific, e.g. 0 for input, 1 for output)
	 *//**
	* get_periph_id() - get the peripheral ID for a device
	*
	* This generally looks at the peripheral's device tree node to work
	* out the peripheral ID. The return value is normally interpreted as
	* enum periph_id. so long as this is defined by the platform (which it
	* should be).
	*
	* @dev:		Pinctrl device to use for decoding
	* @periph:	Device to check
	* @return peripheral ID of @periph, or -ENOENT on error
	*//**
	 * request() - Request a particular pinctrl function
	 *
	 * This activates the selected function.
	 *
	 * @dev:	Device to adjust (UCLASS_PINCTRL)
	 * @func:	Function number (driver-specific)
	 * @return 0 if OK, -ve on error
	 *//* for pinctrl-simple *//**
 * struct pinctrl_ops - pin control operations, to be implemented by
 * pin controller drivers.
 *
 * The @set_state is the only mandatory operation.  You can implement your
 * pinctrl driver with its own @set_state.  In this case, the other callbacks
 * are not required.  Otherwise, generic pinctrl framework is also available;
 * use pinctrl_generic_set_state for @set_state, and implement other operations
 * depending on your necessity.
 *
 * @get_pins_count: return number of selectable named pins available
 *	in this driver.  (necessary to parse "pins" property in DTS)
 * @get_pin_name: return the pin name of the pin selector,
 *	called by the core to figure out which pin it shall do
 *	operations to.  (necessary to parse "pins" property in DTS)
 * @get_groups_count: return number of selectable named groups available
 *	in this driver.  (necessary to parse "groups" property in DTS)
 * @get_group_name: return the group name of the group selector,
 *	called by the core to figure out which pin group it shall do
 *	operations to.  (necessary to parse "groups" property in DTS)
 * @get_functions_count: return number of selectable named functions available
 *	in this driver.  (necessary for pin-muxing)
 * @get_function_name: return the function name of the muxing selector,
 *	called by the core to figure out which mux setting it shall map a
 *	certain device to.  (necessary for pin-muxing)
 * @pinmux_set: enable a certain muxing function with a certain pin.
 *	The @func_selector selects a certain function whereas @pin_selector
 *	selects a certain pin to be used. On simple controllers one of them
 *	may be ignored.  (necessary for pin-muxing against a single pin)
 * @pinmux_group_set: enable a certain muxing function with a certain pin
 *	group.  The @func_selector selects a certain function whereas
 *	@group_selector selects a certain set of pins to be used. On simple
 *	controllers one of them may be ignored.
 *	(necessary for pin-muxing against a pin group)
 * @pinconf_num_params: number of driver-specific parameters to be parsed
 *	from device trees  (necessary for pin-configuration)
 * @pinconf_params: list of driver_specific parameters to be parsed from
 *	device trees  (necessary for pin-configuration)
 * @pinconf_set: configure an individual pin with a given parameter.
 *	(necessary for pin-configuration against a single pin)
 * @pinconf_group_set: configure all pins in a group with a given parameter.
 *	(necessary for pin-configuration against a pin group)
 * @set_state: do pinctrl operations specified by @config, a pseudo device
 *	pointing a config node. (necessary for pinctrl_full)
 * @set_state_simple: do needed pinctrl operations for a peripherl @periph.
 *	(necessary for pinctrl_simple)
 * @get_pin_muxing: display the muxing of a given pin.
 * @gpio_request_enable: requests and enables GPIO on a certain pin.
 *	Implement this only if you can mux every pin individually as GPIO. The
 *	affected GPIO range is passed along with an offset(pin number) into that
 *	specific GPIO range - function selectors and pin groups are orthogonal
 *	to this, the core will however make sure the pins do not collide.
 * @gpio_disable_free: free up GPIO muxing on a certain pin, the reverse of
 *	@gpio_request_enable
 *//**
 * struct pinconf_param - pin config parameters
 *
 * @property: property name in DT nodes
 * @param: ID for this config parameter
 * @default_value: default value for this config parameter used in case
 *	no value is specified in DT nodes
 *//*
 * Copyright (C) 2015  Masahiro Yamada <yamada.masahiro@socionext.com>
 */banknumperiphstatenamepctldev/opt/src/cmd/pinmux.cpinmuxdo_pinmuxpinmux_subcmdARRAY_SIZE(pinmux_subcmd)do_list| %-*.*s| %-*.*s| %s
"| %-*.*s| %-*.*s| %s\n"LIMIT_DEVNAMEDevice"Device"Driver"Driver"Parent"Parent"_retUCLASS_PINCTRLdo_status--------------------------
"--------------------------\n"%s:
"%s:\n"Can't display pin muxing for %s
"Can't display pin muxing for %s\n"show_pinmuxpins_countOps get_pins_count not supported
"Ops get_pins_count not supported\n"pin_nameOps get_pin_name not supported
"Ops get_pin_name not supported\n"pin_muxOps get_pin_muxing error (%d)
"Ops get_pin_muxing error (%d)\n"%-*s: %-*s
"%-*s: %-*s\n"do_devCan't get the pin-controller: %s!
"Can't get the pin-controller: %s!\n"Pin-controller device is not set!
"Pin-controller device is not set!\n"dev: %s
"dev: %s\n""show pin-controller muxing""list                     - list UCLASS_PINCTRL devices\n" "pinmux dev [pincontroller-name] - select pin-controller device\n" "pinmux status [-a]              - print pin-controller muxing [for all]\n"U_BOOT_CMD(pinmux, CONFIG_SYS_MAXARGS, 1, do_pinmux,
	   "show pin-controller muxing",
	   "list                     - list UCLASS_PINCTRL devices\n"
	   "pinmux dev [pincontroller-name] - select pin-controller device\n"
	   "pinmux status [-a]              - print pin-controller muxing [for all]\n"
)show pin-controller muxinglist                     - list UCLASS_PINCTRL devices
pinmux dev [pincontroller-name] - select pin-controller device
pinmux status [-a]              - print pin-controller muxing [for all]
"list                     - list UCLASS_PINCTRL devices\n"
	   "pinmux dev [pincontroller-name] - select pin-controller device\n"
	   "pinmux status [-a]              - print pin-controller muxing [for all]\n"char[191]_u_boot_list_2_cmd_2_pinmux.u_boot_list_2_cmd_2_pinmuxU_BOOT_CMD_MKENT(dev, 2, 1, do_dev, "", "")<dm/pinctrl.h>U_BOOT_CMD_MKENT(list, 1, 1, do_list, "", "")U_BOOT_CMD_MKENT(status, 2, 1, do_status, "", "")currdev/* insert a separator between each pin-controller display *//*
 * Copyright (C) 2018, STMicroelectronics - All Rights Reserved
 *//opt/src/include/power/power_chrg.hpower_chrgUNKNOWNEXT_SOURCECHARGENORMALCHARGER_NOCHARGER_TACHARGER_USBCHARGER_TA_500CHARGER_UNKNOWN__POWER_CHARGER_H_/* __POWER_CHARGER_H_ *//* Type of available chargers *//opt/src/include/powerpower/opt/src/include/power/pmic.hpmicpmic_clrsetbitspmic_reg_writepmic_reg_readpmic_writepmic_readpmic_reg_countpmic_getpmic_bind_childrenconst pmic_child_infoconst pmic_child_info *pmic_child_info *uc_pmic_privpmic_child_infopmic_op_typePMIC_OP_GETPMIC_OP_SETdm_pmic_opsPMIC_I2CPMIC_SPIPMIC_NONEtrans_lenprefixreg_countpmic_spi_flags(p->hw.spi.flags)pmic_spi_bitlen(p->hw.spi.bitlen)pmic_i2c_tx_num(p->hw.i2c.tx_num)pmic_i2c_addr(p->hw.i2c.addr)__CORE_PMIC_H_CONFIG_POWERCONFIG_DM_PMIC/* __CORE_PMIC_H_ *//* CONFIG_DM_PMIC *//*
 * This structure holds the private data for PMIC uclass
 * For now we store information about the number of bytes
 * being sent at once to the device.
 *//**
 * pmic_clrsetbits() - clear and set bits in a PMIC register
 *
 * This reads a register, optionally clears some bits, optionally sets some
 * bits, then writes the register.
 *
 * @dev:	PMIC device to update
 * @reg:	Register to update
 * @clr:	Bit mask to clear (set those bits that you want cleared)
 * @set:	Bit mask to set (set those bits that you want set)
 * @return 0 on success or negative value of errno.
 *//**
 * pmic_reg_write() - write a PMIC register value
 *
 * @dev:	PMIC device to write
 * @reg:	Register to write
 * @value:	Value to write
 * @return 0 on success or negative value of errno.
 *//**
 * pmic_reg_read() - read a PMIC register value
 *
 * @dev:	PMIC device to read
 * @reg:	Register to read
 * @return value read on success or negative value of errno.
 *//**
 * pmic_read/write: read/write to the UCLASS_PMIC device
 *
 * The required pmic device can be obtained by 'pmic_get()'
 *
 * @pmic   - pointer to the UCLASS_PMIC device
 * @reg    - device register offset
 * @buffer - pointer to read/write buffer
 * @len    - byte count for read/write
 * @return 0 on success or negative value of errno.
 *//**
 * pmic_reg_count: get the pmic register count
 *
 * The required pmic device can be obtained by 'pmic_get()'
 *
 * @dev - pointer to the UCLASS_PMIC device
 * @return register count value on success or negative value of errno.
 *//**
 * pmic_get: get the pmic device using its name
 *
 * @name - device name
 * @devp - returned pointer to the pmic device
 * @return 0 on success or negative value of errno.
 *
 * The returned devp device can be used with pmic_read/write calls
 *//**
 * pmic_bind_children() - bind drivers for given parent pmic, using child info
 * found in 'child_info' array.
 *
 * @pmic       - pmic device - the parent of found child's
 * @child_info - N-childs info array
 * @return a positive number of childs, or 0 if no child found (error)
 *
 * Note: For N-childs the child_info array should have N+1 entries and the last
 * entry prefix should be NULL - the same as for drivers compatible.
 *
 * For example, a single prefix info (N=1):
 * static const struct pmic_child_info bind_info[] = {
 *     { .prefix = "ldo", .driver = "ldo_driver" },
 *     { },
 * };
 *
 * This function is useful for regulator sub-nodes:
 * my_regulator@0xa {
 *     reg = <0xa>;
 *     (pmic - bind automatically by compatible)
 *     compatible = "my_pmic";
 *     ...
 *     (pmic's childs - bind by pmic_bind_children())
 *     (nodes prefix: "ldo", driver: "my_regulator_ldo")
 *     ldo1 { ... };
 *     ldo2 { ... };
 *
 *     (nodes prefix: "buck", driver: "my_regulator_buck")
 *     buck1 { ... };
 *     buck2 { ... };
 * };
 *//* drivers/power/pmic-uclass.c *//**
 * struct pmic_child_info - basic device's child info for bind child nodes with
 * the driver by the node name prefix and driver name. This is a helper struct
 * for function: pmic_bind_children().
 *
 * @prefix - child node name prefix (or its name if is unique or single)
 * @driver - driver name for the sub-node with prefix
 *//**
 * enum pmic_op_type - used for various pmic devices operation calls,
 * for reduce a number of lines with the same code for read/write or get/set.
 *
 * @PMIC_OP_GET - get operation
 * @PMIC_OP_SET - set operation
*//**
 * struct dm_pmic_ops - PMIC device I/O interface
 *
 * Should be implemented by UCLASS_PMIC device drivers. The standard
 * device operations provides the I/O interface for it's childs.
 *
 * @reg_count: device's register count
 * @read:      read 'len' bytes at "reg" and store it into the 'buffer'
 * @write:     write 'len' bytes from the 'buffer' to the register at 'reg' address
 *//**
 * U-Boot PMIC Framework
 * =====================
 *
 * UCLASS_PMIC - This is designed to provide an I/O interface for PMIC devices.
 *
 * For the multi-function PMIC devices, this can be used as parent I/O device
 * for each IC's interface. Then, each child uses its parent for read/write.
 *
 * The driver model tree could look like this:
 *
 *_ root device
 * |_ BUS 0 device (e.g. I2C0)                 - UCLASS_I2C/SPI/...
 * | |_ PMIC device (READ/WRITE ops)           - UCLASS_PMIC
 * |   |_ REGULATOR device (ldo/buck/... ops)  - UCLASS_REGULATOR
 * |   |_ CHARGER device (charger ops)         - UCLASS_CHARGER (in the future)
 * |   |_ MUIC device (microUSB connector ops) - UCLASS_MUIC    (in the future)
 * |   |_ ...
 * |
 * |_ BUS 1 device (e.g. I2C1)                 - UCLASS_I2C/SPI/...
 *   |_ PMIC device (READ/WRITE ops)           - UCLASS_PMIC
 *     |_ RTC device (rtc ops)                 - UCLASS_RTC     (in the future)
 *
 * We can find two PMIC cases in boards design:
 * - single I/O interface
 * - multiple I/O interfaces
 * We bind a single PMIC device for each interface, to provide an I/O for
 * its child devices. And each child usually implements a different function,
 * controlled by the same interface.
 *
 * The binding should be done automatically. If device tree nodes/subnodes are
 * proper defined, then:
 *
 * |_ the ROOT driver will bind the device for I2C/SPI node:
 *   |_ the I2C/SPI driver should bind a device for pmic node:
 *     |_ the PMIC driver should bind devices for its childs:
 *       |_ regulator (child)
 *       |_ charger   (child)
 *       |_ other     (child)
 *
 * The same for other device nodes, for multi-interface PMIC.
 *
 * Note:
 * Each PMIC interface driver should use a different compatible string.
 *
 * If a PMIC child device driver needs access the PMIC-specific registers,
 * it need know only the register address and the access can be done through
 * the parent pmic driver. Like in the example:
 *
 *_ root driver
 * |_ dev: bus I2C0                                         - UCLASS_I2C
 * | |_ dev: my_pmic (read/write)              (is parent)  - UCLASS_PMIC
 * |   |_ dev: my_regulator (set value/etc..)  (is child)   - UCLASS_REGULATOR
 *
 * To ensure such device relationship, the pmic device driver should also bind
 * all its child devices, like in the example below. It can be done by calling
 * the 'pmic_bind_children()' - please refer to the function description, which
 * can be found in this header file. This function, should be called inside the
 * driver's bind() method.
 *
 * For the example driver, please refer the MAX77686 driver:
 * - 'drivers/power/pmic/max77686.c'
 *//* CONFIG_POWER *//* Keep info about power devices involved with battery operation *//*
 *  Copyright (C) 2014-2015 Samsung Electronics
 *  Przemyslaw Marczak <p.marczak@samsung.com>
 *
 *  Copyright (C) 2011-2012 Samsung Electronics
 *  Lukasz Majewski <l.majewski@samsung.com>
 */<power/power_chrg.h>child_info/opt/src/cmd/pmic.cdo_pmicARRAY_SIZE(subcmd)do_writeFirst, set the PMIC device!
"First, set the PMIC device!\n"PMIC max reg: %d
"PMIC max reg: %d\n"EFAULT-14-EFAULTCan't write PMIC register: %d!
"Can't write PMIC register: %d!\n"uc_pmic_priv *Can't read PMIC register: %d!
"Can't read PMIC register: %d!\n"0x%%02x: 0x%%%d.%dx
"0x%%02x: 0x%%%d.%dx\n"do_dumpDump pmic: %s registers
"Dump pmic: %s registers\n"%%%d.%dx "%%%d.%dx "Can't read register: %d
"Can't read register: %d\n"
0x%02x: "\n0x%02x: "| %-*.*s| %-*.*s| %s @ %s
"| %-*.*s| %-*.*s| %s @ %s\n"LIMIT_DEVName"Name"LIMIT_PARENTParent name"Parent name"Parent uclass"Parent uclass""seq"<power/pmic.h>| %-*.*s| %-*.*s| %s @ %d
"| %-*.*s| %-*.*s| %s @ %d\n"UCLASS_PMICCan't get PMIC: %s!
"Can't get PMIC: %s!\n"PMIC device is not set!

"PMIC device is not set!\n\n"dev: %d @ %s
"dev: %d @ %s\n"failureError: %d (%s)
"Error: %d (%s)\n""PMIC sub-system""list          - list pmic devices\n" "pmic dev [name]    - show or [set] operating PMIC device\n" "pmic dump          - dump registers\n" "pmic read address  - read byte of register at address\n" "pmic write address - write byte to register at address\n"U_BOOT_CMD(pmic, CONFIG_SYS_MAXARGS, 1, do_pmic,
	"PMIC sub-system",
	"list          - list pmic devices\n"
	"pmic dev [name]    - show or [set] operating PMIC device\n"
	"pmic dump          - dump registers\n"
	"pmic read address  - read byte of register at address\n"
	"pmic write address - write byte to register at address\n"
)PMIC sub-systemlist          - list pmic devices
pmic dev [name]    - show or [set] operating PMIC device
pmic dump          - dump registers
pmic read address  - read byte of register at address
pmic write address - write byte to register at address
"list          - list pmic devices\n"
	"pmic dev [name]    - show or [set] operating PMIC device\n"
	"pmic dump          - dump registers\n"
	"pmic read address  - read byte of register at address\n"
	"pmic write address - write byte to register at address\n"char[237]_u_boot_list_2_cmd_2_pmic.u_boot_list_2_cmd_2_pmicU_BOOT_CMD_MKENT(dump, 1, 1, do_dump, "", "")U_BOOT_CMD_MKENT(read, 2, 1, do_read, "", "")U_BOOT_CMD_MKENT(write, 3, 1, do_write, "", "")/*
 * Copyright (C) 2014-2015 Samsung Electronics
 * Przemyslaw Marczak <p.marczak@samsung.com>
 *//opt/src/include/menu.hmenumenu_default_choicemenu *menu_display_statuslinemenu_destroymenu_item_addmenu_get_choicemenu_default_setmenu_create__MENU_H__defined(CONFIG_MENU_SHOW)/* __MENU_H__ *//*
 * Copyright 2010-2011 Calxeda, Inc.
 */choiceitem_keyitem_dataitem_data_printitem_choiceitem_choice_data/opt/src/cmd/pxe.cpxedo_sysboot-p"-p"pxefile_addr_strpxefile_addr_r"pxefile_addr_r""ext2""fat"any"any"Invalid filesystem: %s
"Invalid filesystem: %s\n"Invalid pxefile address: %s
"Invalid pxefile address: %s\n"Error reading config file
"Error reading config file\n"pxe_menu *Error parsing config file
"Error parsing config file\n"do_pxecmd_pxe_subARRAY_SIZE(cmd_pxe_sub)do_pxe_boothandle_pxe_menucls"cls"Skipping background bmp %s for failure
"Skipping background bmp %s for failure\n""cli.h""menu.h"pxe_label *boot_unattempted_labels&cfg->labelsstruct pxe_labellist_entry(pos, struct pxe_label, list)pxe_menu_to_menucfg->timeoutDIV_ROUND_UP(cfg->timeout, 10)default_numMissing default: %s
"Missing default: %s\n"parse_pxefilesizeof(struct pxe_menu)destroy_pxe_menuparse_pxefile_topMAX_NEST_LEVELMaximum nesting (%d) exceeded
"Maximum nesting (%d) exceeded\n"EMLINK-31-EMLINKtoken *L_KEYWORDT_MENUstrlen(b) + 1(strlen(b) + 1)(typeof(strlen(b) + 1))(4)-1ALIGN(strlen(b) + 1, 4)18446744073709551612menucfgnest_levelT_TIMEOUTT_LABELT_DEFAULTT_ONTIMEOUTlabel_nameT_INCLUDEstrlen(b)(strlen(b))(typeof(strlen(b)))(4)-1ALIGN(strlen(b), 4)T_PROMPTT_EOLT_EOFIgnoring unknown command: %.*s
"Ignoring unknown command: %.*s\n"parse_labelExpected label name: %.*s
"Expected label name: %.*s\n"T_KERNELT_LINUXT_APPENDinitrd="initrd="T_INITRDT_FDTT_FDTDIRT_LOCALBOOTT_IPAPPENDparse_label_kernel#"#"parse_label_menuIgnoring malformed menu command: %.*s
"Ignoring malformed menu command: %.*s\n"parse_menuT_TITLET_BACKGROUNDhandle_includeinclude_pathExpected include path: %.*s
"Expected include path: %.*s\n"Couldn't retrieve %s
"Couldn't retrieve %s\n"parse_integerL_SLITERALT_STRINGExpected string: %.*s
"Expected string: %.*s\n"parse_sliteralExpected string literal: %.*s
"Expected string literal: %.*s\n"eol_or_eofget_tokenT_INVALID*cisblank(*c)get_keywordconst tokenconst token[20]token[20]const token **eisspace(*e)*blabel_bootNo kernel given, skipping %s
"No kernel given, skipping %s\n"ramdisk_addr_r"ramdisk_addr_r"delimlowerSkipping %s for failure retrieving initrd
"Skipping %s for failure retrieving initrd\n"bootm_argv"bootm"initrd_str:":"kernel_addr_r"kernel_addr_r"Skipping %s for failure retrieving kernel
"Skipping %s for failure retrieving kernel\n"ip_str ip=%s:%s:%s:%s" ip=%s:%s:%s:%s"serverip"serverip"mac_str BOOTIF=" BOOTIF="sizeof(mac_str)sizeof(mac_str) - 8finalbootargssizeof(bootargs)bootarg overflow %zd+%zd+%zd+1 > %zd
"bootarg overflow %zd+%zd+%zd+1 > %zd\n"append: %s
"append: %s\n"fit_addrmalloc fail (FIT address)
"malloc fail (FIT address)\n"fdt_addr_r"fdt_addr_r"fdtfilefdtfilefreef1f2f3f4slash"fdtfile"soc"soc""board".dtb".dtb"./"./"malloc fail (FDT filename)
"malloc fail (FDT filename)\n"%s%s%s%s%s%s"%s%s%s%s%s%s"Skipping %s for failure retrieving fdt
"Skipping %s for failure retrieving fdt\n""fdt_addr"bootm_argckernel_addrIMAGE_FORMAT_INVALIDlabel_localbootlocalcmd"localcmd""running: %s\n"debug("running: %s\n", localcmd)cmd/pxe.c606running: %s
label_print%s:	%s
"%s:\t%s\n"label_destroylabel_createsizeof(struct pxe_label)get_relfile_envaddrenvaddrfile_addrdo_pxe_getConfig file found
"Config file found\n"Config file not found
"Config file not found\n"pxe_ipaddr_paths%08X"%08X"net_ip.s_addr(__force __u32)(__be32)(net_ip.s_addr)(__u32)(__be32)(net_ip.s_addr)((__u32)(__be32)(net_ip.s_addr))ntohl(net_ip.s_addr)mask_pospxe_mac_pathpxe_uuid_pathpxeuuid"pxeuuid"get_pxelinux_pathbase_lenpxelinux.cfg/PXELINUX_DIRMAX_TFTP_PATH_LENpath (%s%s) too long, skipping
"path (%s%s) too long, skipping\n"ENAMETOOLONG-36-ENAMETOOLONGMAX_TFTP_PATH_LEN+1pxelinux.cfg/%sPXELINUX_DIR "%s"envaddr_nameget_pxe_filetftp_filesizeconfig_file_sizeget_relfilerelfilesizeof(relfile)path_lenBase path too long (%s%s)
"Base path too long (%s%s)\n"Retrieving file: %s
"Retrieving file: %s\n"addr_bufdo_get_any"load"do_get_fat"fatload"do_get_ext2"ext2load"do_get_tftptftp_argvtftp"tftp"get_bootfile_pathlast_slashbootfile_path too small. (%zd < %zd)
"bootfile_path too small. (%zd < %zd)\n"format_mac_pxeoutbuf is too small (%zd < 21)
"outbuf is too small (%zd < 21)\n"eth"eth"01-%02x-%02x-%02x-%02x-%02x-%02x"01-%02x-%02x-%02x-%02x-%02x-%02x"from_envmissing environment variable: %s
"missing environment variable: %s\n"lex_stateL_NORMALtokentoken_typepxe_menupxe_labellabelsdefault_labellocalboot_vallocalbootattemptedipappendfdtdirinitrdappendkernelsysboot"command to get and boot from syslinux files""[-p] <interface> <dev[:part]> <ext2|fat|any> [addr] [filename]\n" "    - load and parse syslinux menu file 'filename' from ext2, fat\n" "      or any filesystem on 'dev' on 'interface' to address 'addr'"command to get and boot from syslinux files[-p] <interface> <dev[:part]> <ext2|fat|any> [addr] [filename]
    - load and parse syslinux menu file 'filename' from ext2, fat
      or any filesystem on 'dev' on 'interface' to address 'addr'"[-p] <interface> <dev[:part]> <ext2|fat|any> [addr] [filename]\n"
	"    - load and parse syslinux menu file 'filename' from ext2, fat\n"
	"      or any filesystem on 'dev' on 'interface' to address 'addr'"char[195]U_BOOT_CMD(
	sysboot, 7, 1, do_sysboot,
	"command to get and boot from syslinux files",
	"[-p] <interface> <dev[:part]> <ext2|fat|any> [addr] [filename]\n"
	"    - load and parse syslinux menu file 'filename' from ext2, fat\n"
	"      or any filesystem on 'dev' on 'interface' to address 'addr'"
)_u_boot_list_2_cmd_2_sysboot.u_boot_list_2_cmd_2_sysboot"commands to get and boot from pxe files""get - try to retrieve a pxe file using tftp\npxe " "boot [pxefile_addr_r] - boot from the pxe file at pxefile_addr_r\n"commands to get and boot from pxe filesget - try to retrieve a pxe file using tftp
pxe boot [pxefile_addr_r] - boot from the pxe file at pxefile_addr_r
"get - try to retrieve a pxe file using tftp\npxe "
	"boot [pxefile_addr_r] - boot from the pxe file at pxefile_addr_r\n"char[114]U_BOOT_CMD(
	pxe, 3, 1, do_pxe,
	"commands to get and boot from pxe files",
	"get - try to retrieve a pxe file using tftp\npxe "
	"boot [pxefile_addr_r] - boot from the pxe file at pxefile_addr_r\n"
)_u_boot_list_2_cmd_2_pxe.u_boot_list_2_cmd_2_pxeU_BOOT_CMD_MKENT(get, 1, 1, do_pxe_get, "", "")U_BOOT_CMD_MKENT(boot, 2, 1, do_pxe_boot, "", "")const token[]token[]"menu""title""timeout""prompt""label""kernel""linux""localboot""append""initrd""include"bootfile_pathbootfile_path_sizeoutbuf_lenenvvardevicetree"devicetree""fdt"devicetreedir"devicetreedir""fdtdir"ontimeout"ontimeout""ipappend"background"background"keywordsfs_argvdo_getfileis_pxeconst char *[]default-sandbox"default-" CONFIG_SYS_ARCHpxe_default_paths"pxelinux.cfg/"CONFIG_SYS_SOCCONFIG_SYS_BOARDCONFIG_CMD_EXT2CONFIG_CMD_FATCONFIG_CMD_FS_GENERICCONFIG_CMD_BOOTIdefined(CONFIG_CMD_BOOTZ)CONFIG_CMD_BMP/*
 * Boots a system using a local disk syslinux/extlinux file
 *
 * Returns 0 on success, 1 on error.
 *//* drop initial "pxe" arg *//*
 * Boots a system using a pxe file
 *
 * Returns 0 on success, 1 on error.
 *//*
	 * err == 1 means we got a choice back from menu_get_choice.
	 *
	 * err == -ENOENT if the menu was setup to select the default but no
	 * default was set. in that case, we should continue trying to boot
	 * labels that haven't been attempted yet.
	 *
	 * otherwise, the user interrupted or there was some other error and
	 * we give up.
	 *//* display BMP if available *//*
 * Boot the system as prescribed by a pxe_menu.
 *
 * Use the menu system to either get the user's choice or the default, based
 * on config or user input.  If there is no default or user's choice,
 * attempted to boot labels in the order they were given in pxe files.
 * If the default or user's choice fails to boot, attempt to boot other
 * labels in the order they were given in pxe files.
 *
 * If this function returns, there weren't any labels that successfully
 * booted, or the user interrupted the menu selection via ctrl+c.
 *//*
 * Try to boot any labels we have yet to attempt to boot.
 *//*
	 * After we've created items for each label in the menu, set the
	 * menu's default label if one was specified.
	 *//*
	 * Create a menu and add items for all the labels.
	 *//*
 * Converts a pxe_menu struct into a menu struct for use with U-Boot's generic
 * menu code.
 *//*
 * Entry point for parsing a pxe file. This is only used for the top level
 * file.
 *
 * Returns NULL if there is an error, otherwise, returns a pointer to a
 * pxe_menu struct populated with the results of parsing the pxe file (and any
 * files it includes). The resulting pxe_menu struct can be free()'d by using
 * the destroy_pxe_menu() function.
 *//*
 * Free the memory used by a pxe_menu and its labels.
 *//*
 * Entry point for parsing a menu file. nest_level indicates how many times
 * we've nested in includes.  It will be 1 for the top level menu file.
 *
 * Returns 1 on success, < 0 on error.
 *//*
 * This 16 comes from the limit pxelinux imposes on nested includes.
 *
 * There is no reason at all we couldn't do more, but some limit helps prevent
 * infinite (until crash occurs) recursion if a file tries to include itself.
 *//*
			 * put the token back! we don't want it - it's the end
			 * of a label and whatever token this is, it's
			 * something for the menu level context to handle.
			 *//*
 * Parses a label and adds it to the list of labels for a menu.
 *
 * A label ends when we either get to the end of a file, or
 * get some input we otherwise don't have a handler defined
 * for.
 *
 *//*
 * Handles parsing a 'kernel' label.
 * expecting "filename" or "<fit_filename>#cfg"
 *//*
 * Handles parsing a 'menu line' when we're parsing a label.
 *//*
 * Parse lines that begin with 'menu'.
 *
 * base and nest are provided to handle the 'menu include' case.
 *
 * base should point to a location where it's safe to store the included file.
 *
 * nest_level should be 1 when parsing the top level pxe file, 2 when parsing
 * a file it includes, 3 when parsing a file included by that file, and so on.
 *//*
 * Parse an include statement, and retrieve and parse the file it mentions.
 *
 * base should point to a location where it's safe to store the file, and
 * nest_level should indicate how many nested includes have occurred. For this
 * include, nest_level has already been incremented and doesn't need to be
 * incremented here.
 *//*
 * Parse a base 10 (unsigned) integer and store it at *dst.
 *//*
 * Parse a string literal and store a pointer it at *dst. String literals
 * terminate at the end of the line.
 *//*
 * All of these parse_* functions share some common behavior.
 *
 * They finish with *c pointing after the token they parse, and return 1 on
 * success, or < 0 on error.
 *//*
 * Increment *c until we get to the end of the current line, or EOF.
 *//*
		 * when we expect a keyword, we first get the next string
		 * token delimited by whitespace, and then check if it
		 * matches a keyword in our keyword list. if it does, it's
		 * converted to a keyword token of the appropriate type, and
		 * if not, it remains a string token.
		 *//*
	 * eat comments. note that string literals can't begin with #, but
	 * can contain a # after their first character.
	 *//* eat non EOL whitespace *//*
 * Get the next token.  We have to keep track of which state we're in to know
 * if we're looking to get a string literal or a keyword.
 *
 * *p is updated to point at the first character after the current token.
 *//*
 * Populate a keyword token with a type and value.
 *//*
	 * Update *p so the caller knows where to continue scanning.
	 *//*
	 * Allocate memory to hold the string, and copy it in, converting
	 * characters to lowercase if lower is != 0.
	 *//*
	 * b and e both start at the beginning of the input stream.
	 *
	 * e is incremented until we find the ending delimiter, or a NUL byte
	 * is reached. Then, we take e - b to find the length of the token.
	 *//*
 * get_string retrieves a string from *p and stores it as a token in
 * *t.
 *
 * get_string used for scanning both string literals and keywords.
 *
 * Characters from *p are copied into t-val until a character equal to
 * delim is found, or a NUL byte is reached. If delim has the special value of
 * ' ', any whitespace character will be used as a delimiter.
 *
 * If lower is unequal to 0, uppercase characters will be converted to
 * lowercase in the result. This is useful to make keywords case
 * insensitive.
 *
 * The location of *p is updated to point to the first character after the end
 * of the token - the ending delimiter.
 *
 * On success, the new value of t->val is returned. Memory for t->val is
 * allocated using malloc and must be free()'d to reclaim it.  If insufficient
 * memory is available, NULL is returned.
 *//*
 * Since pxe(linux) files don't have a token to identify the start of a
 * literal, we have to keep track of when we're in a state where a literal is
 * expected vs when we're in a state a keyword is expected.
 *//*
 * Keywords recognized.
 *//*
 * A token - given by a value and a type.
 *//*
 * Tokens for the pxe file parser.
 *//* Try booting a Image *//* Try booting an AArch64 Linux kernel image *//* Try bootm for legacy and FIT format image *//*
				 * For complex cases where this code doesn't
				 * generate the correct filename, the board
				 * code should set $fdtfile during early boot,
				 * or the boot scripts should set $fdtfile
				 * before invoking "pxe" or "sysboot".
				 *//* if fdt label is defined then get fdt from server *//*
	 * fdt usage is optional:
	 * It handles the following scenarios. All scenarios are exclusive
	 *
	 * Scenario 1: If fdt_addr_r specified and "fdt" label is defined in
	 * pxe file, retrieve fdt blob from server. Pass fdt_addr_r to bootm,
	 * and adjust argc appropriately.
	 *
	 * Scenario 2: If there is an fdt_addr specified, pass it along to
	 * bootm, and adjust argc appropriately.
	 *
	 * Scenario 3: fdt blob is not available.
	 *//* for FIT, append the configuration identifier *//*
 * Boot according to the contents of a pxe_label.
 *
 * If we can't boot for any reason, we return.  A successful boot never
 * returns.
 *
 * The kernel will be stored in the location given by the 'kernel_addr_r'
 * environment variable.
 *
 * If the label specifies an initrd file, it will be stored in the location
 * given by the 'ramdisk_addr_r' environment variable.
 *
 * If the label specifies an 'append' line, its contents will overwrite that
 * of the 'bootargs' environment variable.
 *//*
 * Boot a label that specified 'localboot'. This requires that the 'localcmd'
 * environment variable is defined. Its contents will be executed as U-Boot
 * command.  If the label specified an 'append' line, its contents will be
 * used to overwrite the contents of the 'bootargs' environment variable prior
 * to running 'localcmd'.
 *
 * Returns 1 on success or < 0 on error.
 *//*
 * Print a label and its string members if they're defined.
 *
 * This is passed as a callback to the menu code for displaying each
 * menu entry.
 *//*
 * Free the memory used by a pxe_label, including that used by its name,
 * kernel, append and initrd members, if they're non NULL.
 *
 * So - be sure to only use dynamically allocated memory for the members of
 * the pxe_label struct, unless you want to clean it up first. These are
 * currently only created by the pxe file parsing code.
 *//*
 * Allocates memory for and initializes a pxe_label. This uses malloc, so the
 * result must be free()'d to reclaim the memory.
 *
 * Returns NULL if malloc fails.
 *//*
 * Describes a pxe menu as given via pxe files.
 *
 * title - the name of the menu as given by a 'menu title' line.
 * default_label - the name of the default label, if any.
 * bmp - the bmp file name which is displayed in background
 * timeout - time in tenths of a second to wait for a user key-press before
 *           booting the default label.
 * prompt - if 0, don't prompt for a choice unless the timeout period is
 *          interrupted.  If 1, always prompt for a choice regardless of
 *          timeout.
 * labels - a list of labels defined for the menu.
 *//*
 * Describes a single label given in a pxe file.
 *
 * Create these with the 'label_create' function given below.
 *
 * name - the name of the menu as given on the 'menu label' line.
 * kernel - the path to the kernel file to use for this label.
 * append - kernel command line to use when booting this label
 * initrd - path to the initrd to use for this label.
 * attempted - 0 if we haven't tried to boot this label, 1 if we have.
 * localboot - 1 if this label specified 'localboot', 0 otherwise.
 * list - lets these form a list, which a pxe_menu struct will hold.
 *//*
 * A note on the pxe file parser.
 *
 * We're parsing files that use syslinux grammar, which has a few quirks.
 * String literals must be recognized based on context - there is no
 * quoting or escaping support. There's also nothing to explicitly indicate
 * when a label section completes. We deal with that by ending a label
 * section whenever we see a line that doesn't include.
 *
 * As with the syslinux family, this same file format could be reused in the
 * future for non pxe purposes. The only action it takes during parsing that
 * would throw this off is handling of include files. It assumes we're using
 * pxe, and does a tftp download of a file listed as an include file in the
 * middle of the parsing operation. That could be handled by refactoring it to
 * take a 'include file getter' function.
 *//*
 * Wrapper to make it easier to store the file at file_path in the location
 * specified by envaddr_name. file_path will be joined to the bootfile path,
 * if any is specified.
 *
 * Returns 1 on success or < 0 on error.
 *//*
	 * Keep trying paths until we successfully get a file we're looking
	 * for.
	 *//*
 * Entry point for the 'pxe get' command.
 * This Follows pxelinux's rules to download a config file from a tftp server.
 * The file is stored at the location given by the pxefile_addr_r environment
 * variable, which must be set.
 *
 * UUID comes from pxeuuid env variable, if defined
 * MAC addr comes from ethaddr env variable, if defined
 * IP
 *
 * see http://syslinux.zytor.com/wiki/index.php/PXELINUX
 *
 * Returns 0 on success or 1 on error.
 *//*
 * Looks for pxe files with names based on our IP address. See pxelinux
 * documentation for details on what these file names look like.  We match
 * that exactly.
 *
 * Returns 1 on success or < 0 on error.
 *//*
 * Looks for a pxe file with a name based on the 'ethaddr' environment
 * variable.
 *
 * Returns 1 on success or < 0 on error.
 *//*
 * Looks for a pxe file with a name based on the pxeuuid environment variable.
 *
 * Returns 1 on success or < 0 on error.
 *//*
 * Retrieves a file in the 'pxelinux.cfg' folder. Since this uses get_pxe_file
 * to do the hard work, the location of the 'pxelinux.cfg' folder is generated
 * from the bootfile path, as described above.
 *
 * Returns 1 on success or < 0 on error.
 *//*
	 * the file comes without a NUL byte at the end, so find out its size
	 * and add the NUL byte.
	 *//*
 * Retrieve the file at 'file_path' to the locate given by 'file_addr'. If
 * 'bootfile' was specified in the environment, the path to bootfile will be
 * prepended to 'file_path' and the resulting path will be used.
 *
 * Returns 1 on success, or < 0 for error.
 *//*
 * As in pxelinux, paths to files referenced from files we retrieve are
 * relative to the location of bootfile. get_relfile takes such a path and
 * joins it with the bootfile path to get the full path to the target file. If
 * the bootfile path is NULL, we use file_path as is.
 *
 * Returns 1 for success, or < 0 on error.
 *//* Only syslinux allows absolute paths *//*
 * Returns the directory the file specified in the bootfile env variable is
 * in. If bootfile isn't defined in the environment, return NULL, which should
 * be interpreted as "don't prepend anything to paths".
 *//*
 * Convert an ethaddr from the environment to the format used by pxelinux
 * filenames based on mac addresses. Convert's ':' to '-', and adds "01-" to
 * the beginning of the ethernet address to indicate a hardware type of
 * Ethernet. Also converts uppercase hex characters into lowercase, to match
 * pxelinux's behavior.
 *
 * Returns 1 for success, -ENOENT if 'ethaddr' is undefined in the
 * environment, or some other value < 0 on error.
 *//*
 * Like env_get, but prints an error if envvar isn't defined in the
 * environment.  It always returns what env_get does, so it can be used in
 * place of env_get without changing error handling otherwise.
 *//*
 * Copyright 2010-2011 Calxeda, Inc.
 * Copyright (c) 2014, NVIDIA CORPORATION.  All rights reserved.
 *//opt/src/include/qfw.hqfwqemu_fwcfg_dma_presentqemu_fwcfg_presentqemu_fwcfg_file_iter_endfw_cfg_file_iter *fw_file *qemu_fwcfg_file_iter_nextqemu_fwcfg_file_iter_initqemu_fwcfg_online_cpusqemu_fwcfg_find_fileqemu_fwcfg_read_firmware_listqemu_fwcfg_read_entryqemu_fwcfg_initfw_cfg_arch_ops *bios_linker_entryfw_cfg_arch_opsfw_cfg_dma_accessfw_cfg_file_iterfw_filefw_cfg_fileBIOS_LINKER_LOADER_ALLOC_ZONE_HIGHBIOS_LINKER_LOADER_ALLOC_ZONE_FSEGBIOS_LINKER_LOADER_COMMAND_ALLOCATEBIOS_LINKER_LOADER_COMMAND_ADD_POINTERBIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUMqemu_fwcfg_itemsFW_CFG_SIGNATUREFW_CFG_IDFW_CFG_UUIDFW_CFG_RAM_SIZEFW_CFG_NOGRAPHICFW_CFG_NB_CPUSFW_CFG_MACHINE_IDFW_CFG_KERNEL_ADDRFW_CFG_KERNEL_SIZEFW_CFG_KERNEL_CMDLINEFW_CFG_INITRD_ADDRFW_CFG_INITRD_SIZEFW_CFG_BOOT_DEVICEFW_CFG_NUMAFW_CFG_BOOT_MENUFW_CFG_MAX_CPUSFW_CFG_KERNEL_ENTRYFW_CFG_KERNEL_DATAFW_CFG_INITRD_DATAFW_CFG_CMDLINE_ADDRFW_CFG_CMDLINE_SIZEFW_CFG_CMDLINE_DATAFW_CFG_SETUP_ADDRFW_CFG_SETUP_SIZEFW_CFG_SETUP_DATAFW_CFG_FILE_DIRFW_CFG_FILE_FIRSTFW_CFG_WRITE_CHANNELFW_CFG_ARCH_LOCALFW_CFG_INVALIDchar[124]cksumpointerallocBIOS_LINKER_LOADER_FILESZsrc_filedest_filezonefw_cfg_dma_access *arch_read_dmaarch_read_pioFW_CFG_MAX_FILE_PATHFW_CFG_DMA_ENABLEDFW_CFG_DMA_SELECTFW_CFG_DMA_SKIPFW_CFG_DMA_READFW_CFG_DMA_ERRORQEMU_FW_CFG_SIGNATURE(('Q' << 24) | ('E' << 16) | ('M' << 8) | 'U')FW_CFG_ENTRY_MASK~(FW_CFG_WRITE_CHANNEL | FW_CFG_ARCH_LOCAL)FW_CFG_MAX_ENTRY(FW_CFG_FILE_FIRST + FW_CFG_FILE_SLOTS)FW_CFG_FILE_SLOTS__FW_CFG__/* helper functions to iterate firmware file list *//**
 * Get system cpu number
 *
 * @return:   cpu number in system
 *//**
 * Initialize QEMU fw_cfg interface
 *
 * @ops: arch specific read operations
 *//* padding *//*
		 * COMMAND_ADD_CHECKSUM - calculate checksum of the range
		 * specified by @cksum_start and @cksum_length fields,
		 * and then add the value at @cksum.offset.
		 * Checksum simply sums -X for each byte X in the range
		 * using 8-bit math.
		 *//*
		 * COMMAND_ADD_POINTER - patch the table (originating from
		 * @dest_file) at @pointer.offset, by adding a pointer to the
		 * table originating from @src_file. 1,2,4 or 8 byte unsigned
		 * addition is used depending on @pointer.size.
		 *//*
		 * COMMAND_ALLOCATE - allocate a table from @alloc.file
		 * subject to @alloc.align alignment (must be power of 2)
		 * and @alloc.zone (can be HIGH or FSEG) requirements.
		 *
		 * Must appear exactly once for each file, and before
		 * this file is referenced by any other command.
		 *//* structure to iterate file list *//* list node to link to fw_list *//* firmware file in-memory address *//* firmware file information *//*
 * (C) Copyright 2015 Miao Yan <yanmiaobest@gmail.com>
 */iter/opt/src/cmd/qfw.cdo_qemu_fwQEMU fw_cfg interface not found
"QEMU fw_cfg interface not found\n"fwcfg_cmdfwcfg_commandsARRAY_SIZE(fwcfg_commands)qemu_fwcfg_do_loadramdiskaddr"ramdiskaddr"initrd_addrmissing load or initrd address
"missing load or initrd address\n"qemu_fwcfg_do_cpus%d cpu(s) online
"%d cpu(s) online\n"qemu_fwcfg_do_listqemu_fwcfg_list_firmware%-56s
"%-56s\n"qemu_fwcfg_setup_kernelsetup_sizekernel_sizewarning: no kernel available
"warning: no kernel available\n"data_addrinitrd_sizewarning: no initrd available
"warning: no initrd available\n"cmdline_size<qfw.h>warning: unable to change bootargs
"warning: unable to change bootargs\n"loading kernel to address %p size %x"loading kernel to address %p size %x" initrd %p size %x
" initrd %p size %x\n""QEMU firmware interface""<command>\n" "    - list                             : print firmware(s) currently loaded\n" "    - cpus                             : print online cpu number\n" "    - load <kernel addr> <initrd addr> : load kernel and initrd (if any), and setup for zboot\n"QEMU firmware interface<command>
    - list                             : print firmware(s) currently loaded
    - cpus                             : print online cpu number
    - load <kernel addr> <initrd addr> : load kernel and initrd (if any), and setup for zboot
"<command>\n"
	"    - list                             : print firmware(s) currently loaded\n"
	"    - cpus                             : print online cpu number\n"
	"    - load <kernel addr> <initrd addr> : load kernel and initrd (if any), and setup for zboot\n"char[246]U_BOOT_CMD(
	qfw,	4,	1,	do_qemu_fw,
	"QEMU firmware interface",
	"<command>\n"
	"    - list                             : print firmware(s) currently loaded\n"
	"    - cpus                             : print online cpu number\n"
	"    - load <kernel addr> <initrd addr> : load kernel and initrd (if any), and setup for zboot\n"
)_u_boot_list_2_cmd_2_qfw.u_boot_list_2_cmd_2_qfwcpusU_BOOT_CMD_MKENT(list, 0, 1, qemu_fwcfg_do_list, "", "")U_BOOT_CMD_MKENT(cpus, 0, 1, qemu_fwcfg_do_cpus, "", "")U_BOOT_CMD_MKENT(load, 2, 1, qemu_fwcfg_do_load, "", "")CONFIG_LOADADDRCONFIG_RAMDISK_ADDR/* make sure fw_list is loaded *//*
		 * if kernel cmdline only contains '\0', (e.g. no -append
		 * when invoking qemu), do not update bootargs
		 *//*
 * This function prepares kernel for zboot. It loads kernel data
 * to 'load_addr', initrd to 'initrd_addr' and kernel command
 * line using qemu fw_cfg interface.
 *//opt/src/cmd/read.cInvalid block device %s
"Invalid block device %s\n"Block device %s %d not supported
"Block device %s %d not supported\n"Cannot find partition %d
"Cannot find partition %d\n"0uRead out of range
"Read out of range\n"Error reading blocks
"Error reading blocks\n""Load binary data from a partition""<interface> <dev[:part]> addr blk# cnt"Load binary data from a partition<interface> <dev[:part]> addr blk# cntU_BOOT_CMD(
	read,	6,	0,	do_read,
	"Load binary data from a partition",
	"<interface> <dev[:part]> addr blk# cnt"
)_u_boot_list_2_cmd_2_read.u_boot_list_2_cmd_2_read/* Largest address not available in struct blk_desc. *//*
 * Copyright (c) 2011 The Chromium OS Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *//opt/src/include/power/regulator.hregulatordevice_get_supply_regulatorregulator_get_by_platnameregulator_get_by_devnameregulator_list_autosetudevice *[]regulator_autoset_by_nameregulator_autosetregulators_enable_boot_onregulator_set_moderegulator_get_moderegulator_set_enable_if_allowedregulator_set_enableregulator_get_enableregulator_set_currentregulator_get_currentregulator_set_value_forceregulator_set_valueregulator_get_valueregulator_modedm_regulator_mode *dm_regulator_mode **dm_regulator_opsdm_regulator_uclass_platdataregulator_flagREGULATOR_FLAG_AUTOSET_UVREGULATOR_FLAG_AUTOSET_UAdm_regulator_moderegulator_typeREGULATOR_TYPE_LDOREGULATOR_TYPE_BUCKREGULATOR_TYPE_DVSREGULATOR_TYPE_FIXEDREGULATOR_TYPE_GPIOREGULATOR_TYPE_OTHERget_modeset_enableget_enableset_currentget_currentvolt_regctrl_regboot_onalways_onramp_delaymax_uAmin_uAmax_uVmin_uVmode_countregister_value_INCLUDE_REGULATOR_H_/* _INCLUDE_REGULATOR_H_ *//**
 * device_get_supply_regulator: returns the pointer to the supply regulator.
 * Search by phandle, found in device's node.
 *
 * Note: Please pay attention to proper order of device bind sequence.
 * The regulator device searched by the phandle, must be binded before
 * this function call.
 *
 * @dev         - device with supply phandle
 * @supply_name - phandle name of regulator
 * @devp        - returned pointer to the supply device
 * @return 0 on success or negative value of errno.
 *//**
 * regulator_get_by_platname: returns the pointer to the pmic regulator device.
 * Search by name, found in regulator uclass platdata.
 *
 * @platname - expected string for uc_pdata->name of regulator uclass platdata
 * @devp     - returns pointer to the regulator device or NULL on error
 * @return 0 on success or negative value of errno.
 *
 * The returned 'regulator' device is probed and can be used with:
 * - regulator_get/set_*
 *//**
 * regulator_get_by_devname: returns the pointer to the pmic regulator device.
 * Search by name, found in regulator device's name.
 *
 * @devname - expected string for 'dev->name' of regulator device
 * @devp    - returned pointer to the regulator device
 * @return 0 on success or negative value of errno.
 *
 * The returned 'regulator' device is probed and can be used with:
 * - regulator_get/set_*
 *//**
 * regulator_list_autoset: setup the regulators given by list of their uclass's
 * platform data name field. The setup depends on constraints found in device's
 * uclass's platform data. The function loops with calls to:
 * regulator_autoset_by_name() for each name from the list.
 *
 * @list_platname - an array of expected strings for .name field of each
 *                  regulator's uclass platdata
 * @list_devp     - an array of returned pointers to the successfully setup
 *                  regulator devices if non-NULL passed
 * @verbose       - (true/false) print each regulator setup info, or be quiet
 * @return 0 on successfully setup of all list entries, otherwise first error.
 *
 * The returned 'regulator' devices can be used with:
 * - regulator_get/set_*
 *
 * Note: The list must ends with NULL entry, like in the "platname" list below:
 * char *my_regulators[] = {
 *     "VCC_3.3V",
 *     "VCC_1.8V",
 *     NULL,
 * };
 *//**
 * regulator_autoset_by_name: setup the regulator given by its uclass's
 * platform data name field. The setup depends on constraints found in device's
 * uclass's platform data (struct dm_regulator_uclass_platdata):
 * - Enable - will set - if any of: 'always_on' or 'boot_on' is set to true,
 *   or if both are unset, then the function returns
 * - Voltage value - will set - if '.min_uV' and '.max_uV' values are equal
 * - Current limit - will set - if '.min_uA' and '.max_uA' values are equal
 *
 * The function returns on first encountered error.
 *
 * @platname - expected string for dm_regulator_uclass_platdata .name field
 * @devp     - returned pointer to the regulator device - if non-NULL passed
 * @return: 0 on success or negative value of errno.
 *
 * The returned 'regulator' device can be used with:
 * - regulator_get/set_*
 *//**
 * regulator_autoset: setup the voltage/current on a regulator
 *
 * The setup depends on constraints found in device's uclass's platform data
 * (struct dm_regulator_uclass_platdata):
 *
 * - Enable - will set - if any of: 'always_on' or 'boot_on' is set to true,
 *   or if both are unset, then the function returns
 * - Voltage value - will set - if '.min_uV' and '.max_uV' values are equal
 * - Current limit - will set - if '.min_uA' and '.max_uA' values are equal
 *
 * The function returns on the first-encountered error.
 *
 * @platname - expected string for dm_regulator_uclass_platdata .name field
 * @devp     - returned pointer to the regulator device - if non-NULL passed
 * @return: 0 on success or negative value of errno.
 *//**
 * regulators_enable_boot_on() - enable regulators needed for boot
 *
 * This enables all regulators which are marked to be on at boot time. This
 * only works for regulators which don't have a range for voltage/current,
 * since in that case it is not possible to know which value to use.
 *
 * This effectively calls regulator_autoset() for every regulator.
 *//**
 * regulator_set_mode: set the given regulator's, active mode id
 *
 * @dev     - pointer to the regulator device
 * @mode_id - mode id to set ('id' field of struct type dm_regulator_mode)
 * @return  - 0 on success or -errno value if fails
 * Note:
 * The device can provide an array of operating modes, which is type of struct
 * dm_regulator_mode. Each mode has it's own 'id', which should be unique inside
 * that array. By calling this function, the driver should set the active mode
 * of a given regulator to given by "mode_id" argument.
 *//**
 * regulator_get_mode: get active operation mode id of a given regulator
 *
 * @dev    - pointer to the regulator device
 * @return - positive mode 'id' number on success or -errno val if fails
 * Note:
 * The device can provide an array of operating modes, which is type of struct
 * dm_regulator_mode. Each mode has it's own 'id', which should be unique inside
 * that array. By calling this function, the driver should return an active mode
 * id of the given regulator device.
 *//**
 * regulator_set_enable_if_allowed: set regulator enable state if allowed by
 *					regulator
 *
 * @dev    - pointer to the regulator device
 * @enable - set true or false
 * @return - 0 on success or if enabling is not supported
 *	     -errno val if fails.
 *//**
 * regulator_set_enable: set regulator enable state
 *
 * @dev    - pointer to the regulator device
 * @enable - set true or false
 * @return - 0 on success or -errno val if fails
 *//**
 * regulator_get_enable: get regulator device enable state.
 *
 * @dev    - pointer to the regulator device
 * @return - true/false of enable state or -errno val if fails
 *//**
 * regulator_set_current: set the microampere value of a given regulator.
 *
 * @dev    - pointer to the regulator device
 * @uA     - set the output current [micro Amps]
 * @return - 0 on success or -errno val if fails
 *//**
 * regulator_get_current: get microampere value of a given regulator
 *
 * @dev    - pointer to the regulator device
 * @return - positive output current [uA] on success or negative errno if fail.
 *//**
 * regulator_set_value_force: set the microvoltage value of a given regulator
 *			      without any min-,max condition check
 *
 * @dev    - pointer to the regulator device
 * @uV     - the output value to set [micro Volts]
 * @return - 0 on success or -errno val if fails
 *//**
 * regulator_set_value: set the microvoltage value of a given regulator.
 *
 * @dev    - pointer to the regulator device
 * @uV     - the output value to set [micro Volts]
 * @return - 0 on success or -errno val if fails
 *//**
 * regulator_get_value: get microvoltage voltage value of a given regulator
 *
 * @dev    - pointer to the regulator device
 * @return - positive output value [uV] on success or negative errno if fail.
 *//**
 * regulator_mode: returns a pointer to the array of regulator mode info
 *
 * @dev        - pointer to the regulator device
 * @modep      - pointer to the returned mode info array
 * @return     - count of modep entries on success or negative errno if fail.
 *//**
	 * The 'get/set_mode()' function calls should operate on a driver-
	 * specific mode id definitions, which should be found in:
	 * field 'id' of struct dm_regulator_mode.
	 *
	 * get/set_mode - get/set operation mode of the given output number
	 * @dev         - regulator device
	 * Sets
	 * @mode_id     - set output mode id (struct dm_regulator_mode->id)
	 * @return id/0 for get/set on success or negative errno if fail.
	 * Note:
	 * The field 'id' of struct type 'dm_regulator_mode', should be always
	 * a positive number, since the negative is reserved for the error.
	 *//**
	 * The most basic feature of the regulator output is its enable state.
	 *
	 * get/set_enable - get/set enable state of the given output number
	 * @dev           - regulator device
	 * Sets:
	 * @enable         - set true - enable or false - disable
	 * @return true/false for get or -errno if fail; 0 / -errno for set.
	 *//**
	 * The regulator output current function calls operates on a micro Amps.
	 *
	 * get/set_current - get/set output current of the given output number
	 * @dev            - regulator device
	 * Sets:
	 * @uA           - set the output current [micro Amps]
	 * @return output value [uA] on success or negative errno if fail.
	 *//**
	 * The regulator output value function calls operates on a micro Volts.
	 *
	 * get/set_value - get/set output value of the given output number
	 * @dev          - regulator device
	 * Sets:
	 * @uV           - set the output value [micro Volts]
	 * @return output value [uV] on success or negative errno if fail.
	 *//* Regulator device operations *//**
 * struct dm_regulator_uclass_platdata - pointed by dev->uclass_platdata, and
 * allocated on each regulator bind. This structure holds an information
 * about each regulator's constraints and supported operation modes.
 * There is no "step" voltage value - so driver should take care of this.
 *
 * @type       - one of 'enum regulator_type'
 * @mode       - pointer to the regulator mode (array if more than one)
 * @mode_count - number of '.mode' entries
 * @min_uV*    - minimum voltage (micro Volts)
 * @max_uV*    - maximum voltage (micro Volts)
 * @min_uA*    - minimum amperage (micro Amps)
 * @max_uA*    - maximum amperage (micro Amps)
 * @always_on* - bool type, true or false
 * @boot_on*   - bool type, true or false
 * TODO(sjg@chromium.org): Consider putting the above two into @flags
 * @ramp_delay - Time to settle down after voltage change (unit: uV/us)
 * @flags:     - flags value (see REGULATOR_FLAG_...)
 * @name**     - fdt regulator name - should be taken from the device tree
 * ctrl_reg:   - Control register offset used to enable/disable regulator
 * volt_reg:   - register offset for writing voltage vsel values
 *
 * Note:
 * *  - set automatically on device probe by the uclass's '.pre_probe' method.
 * ** - set automatically on device bind by the uclass's '.post_bind' method.
 * The constraints: type, mode, mode_count, can be set by device driver, e.g.
 * by the driver '.probe' method.
 *//* Set only as >= 0 (negative value is reserved for errno) *//**
 * struct dm_regulator_mode - this structure holds an information about
 * each regulator operation mode. Probably in most cases - an array.
 * This will be probably a driver-static data, since it is device-specific.
 *
 * @id             - a driver-specific mode id
 * @register_value - a driver-specific value for its mode id
 * @name           - the name of mode - used for regulator command
 * Note:
 * The field 'id', should be always a positive number, since the negative values
 * are reserved for the errno numbers when returns the mode id.
 *//* enum regulator_type - used for regulator_*() variant calls *//**
 * U-Boot Voltage/Current Regulator
 * ================================
 *
 * The regulator API is based on a driver model, with the device tree support.
 * And this header describes the functions and data types for the uclass id:
 * 'UCLASS_REGULATOR' and the regulator driver API.
 *
 * The regulator uclass - is based on uclass platform data which is allocated,
 * automatically for each regulator device on bind and 'dev->uclass_platdata'
 * points to it. The data type is: 'struct dm_regulator_uclass_platdata'.
 * The uclass file: 'drivers/power/regulator/regulator-uclass.c'
 *
 * The regulator device - is based on driver's model 'struct udevice'.
 * The API can use regulator name in two meanings:
 * - devname  - the regulator device's name: 'dev->name'
 * - platname - the device's platdata's name. So in the code it looks like:
 *              'uc_pdata = dev->uclass_platdata'; 'name = uc_pdata->name'.
 *
 * The regulator device driver - provide an implementation of uclass operations
 * pointed by 'dev->driver->ops' as a struct of type 'struct dm_regulator_ops'.
 *
 * To proper bind the regulator device, the device tree node should provide
 * regulator constraints, like in the example below:
 *
 * ldo1 {
 *      regulator-name = "VDD_MMC_1.8V";     (must be unique for proper bind)
 *      regulator-min-microvolt = <1000000>; (optional)
 *      regulator-max-microvolt = <1000000>; (optional)
 *      regulator-min-microamp = <1000>;     (optional)
 *      regulator-max-microamp = <1000>;     (optional)
 *      regulator-always-on;                 (optional)
 *      regulator-boot-on;                   (optional)
 * };
 *
 * Note: For the proper operation, at least name constraint is needed, since
 * it can be used when calling regulator_get_by_platname(). And the mandatory
 * rule for this name is, that it must be globally unique for the single dts.
 * If regulator-name property is not provided, node name will be chosen.
 *
 * Regulator bind:
 * For each regulator device, the device_bind() should be called with passed
 * device tree offset. This is required for this uclass's '.post_bind' method,
 * which does the scan on the device node, for the 'regulator-name' constraint.
 * If the parent is not a PMIC device, and the child is not bind by function:
 * 'pmic_bind_childs()', then it's recommended to bind the device by call to
 * dm_scan_fdt_dev() - this is usually done automatically for bus devices,
 * as a post bind method.
 *
 * Regulator get:
 * Having the device's name constraint, we can call regulator_by_platname(),
 * to find the required regulator. Before return, the regulator is probed,
 * and the rest of its constraints are put into the device's uclass platform
 * data, by the uclass regulator '.pre_probe' method.
 *
 * For more info about PMIC bind, please refer to file: 'include/power/pmic.h'
 *
 * Note:
 * Please do not use the device_bind_by_name() function, since it pass '-1' as
 * device node offset - and the bind will fail on uclass .post_bind method,
 * because of missing 'regulator-name' constraint.
 *
 *
 * Fixed Voltage/Current Regulator
 * ===============================
 *
 * When fixed voltage regulator is needed, then enable the config:
 * - CONFIG_DM_REGULATOR_FIXED
 *
 * The driver file: 'drivers/power/regulator/fixed.c', provides basic support
 * for control the GPIO, and return the device tree constraint values.
 *
 * To bind the fixed voltage regulator device, we usually use a 'simple-bus'
 * node as a parent. And 'regulator-fixed' for the driver compatible. This is
 * the same as in the kernel. The example node of fixed regulator:
 *
 * simple-bus {
 *     compatible = "simple-bus";
 *     #address-cells = <1>;
 *     #size-cells = <0>;
 *
 *     blue_led {
 *         compatible = "regulator-fixed";
 *         regulator-name = "VDD_LED_3.3V";
 *         regulator-min-microvolt = <3300000>;
 *         regulator-max-microvolt = <3300000>;
 *         gpio = <&gpc1 0 GPIO_ACTIVE_LOW>;
 *     };
 * };
 *
 * The fixed regulator devices also provide regulator uclass platform data. And
 * devices bound from such node, can use the regulator drivers API.
*//*
 *  Copyright (C) 2014-2015 Samsung Electronics
 *  Przemyslaw Marczak <p.marczak@samsung.com>
 */supply_nameplatnamelist_platnamelist_devpmode_iduAuVmodep/opt/src/cmd/regulator.cdo_regulatorcmd_tbl_t[9]cmd_tbl_s[9]504do_disabledm_regulator_uclass_platdata *dm_regulator_uclass_platdata **uc_pdataRegulator: %s - can't disable!
"Regulator: %s - can't disable!\n"do_enableRegulator: %s - can't enable!
"Regulator: %s - can't enable!\n"do_modeRegulator: %s - can't get the operation mode!
"Regulator: %s - can't get the operation mode!\n"mode id: %d
"mode id: %d\n"Regulator: %s - can't set the operation mode!
"Regulator: %s - can't set the operation mode!\n"do_currentRegulator: %s - can't get the Current!
"Regulator: %s - can't get the Current!\n"%d uA
"%d uA\n"Current exceeds regulator constraint limits
"Current exceeds regulator constraint limits\n"Regulator: %s - can't set the Current!
"Regulator: %s - can't set the Current!\n"do_valueRegulator: %s - can't get the Voltage!
"Regulator: %s - can't get the Voltage!\n"%d uV
"%d uV\n"-f"-f"<power/regulator.h>Value exceeds regulator constraint limits %d..%d uV
"Value exceeds regulator constraint limits %d..%d uV\n"Regulator: %s - can't set the Voltage!
"Regulator: %s - can't set the Voltage!\n"%-20s %-10s %10s %10s %-10s
"%-20s %-10s %10s %10s %-10s\n"Enabled"Enabled""uV""mA"Mode"Mode"UCLASS_REGULATORdo_status_linepdatamode_name%-20s %-10s "%-20s %-10s ""enabled""disabled"%10d "%10d "%10s "%10s "%-10s"%-10s"do_status_detailRegulator %s status:
"Regulator %s status:\n" * enable:" * enable:""true""false" * value uV:" * value uV:" * current uA:" * current uA:" * mode id:" * mode id:"do_infoparent_uc%s
%-*s %s
%-*s %s
%-*s %s
%-*s %s
%-*s
"%s\n%-*s %s\n%-*s %s\n%-*s %s\n%-*s %s\n%-*s\n"Regulator info:"Regulator info:"LIMIT_INFO* regulator-name:"* regulator-name:"* device name:"* device name:"* parent name:"* parent name:"* parent uclass:"* parent uclass:"* constraints:"* constraints:"  - min uV:"  - min uV:"  - max uV:"  - max uV:"  - min uA:"  - min uA:"  - max uA:"  - max uA:"  - always on:"  - always on:"  - boot on:"  - boot on:"* op modes:"* op modes:"  - mode id:"  - mode id:"get_mode_nameconstraint%-*s"%-*s" %s (err: %d)
" %s (err: %d)\n" %d (%s)
" %d (%s)\n" %d
" %d\n"LIMIT_OFNAMEregulator-name"regulator-name"curr_dev_and_platdataFirst, set the regulator device!
"First, set the regulator device!\n""Regulator: %s - missing platform data!\n"currdev->namepr_err("Regulator: %s - missing platform data!\n", currdev->name)pr_fmt("Regulator: %s - missing platform data!\n")Regulator: %s - missing platform data!
Operation not allowed for fixed regulator!
"Operation not allowed for fixed regulator!\n"ENXIO-ENXIOCan't get the regulator: %s!
"Can't get the regulator: %s!\n"Regulator device is not set!

"Regulator device is not set!\n\n"%s: no regulator platform data!
"%s: no regulator platform data!\n"dev: %s @ %s
"dev: %s @ %s\n""uclass operations""list             - list UCLASS regulator devices\n" "regulator dev [regulator-name] - show/[set] operating regulator device\n" "regulator info                 - print constraints info\n" "regulator status [-a]          - print operating status [for all]\n" "regulator value [val] [-f]     - print/[set] voltage value [uV] (force)\n" "regulator current [val]        - print/[set] current value [uA]\n" "regulator mode [id]            - print/[set] operating mode id\n" "regulator enable               - enable the regulator output\n" "regulator disable              - disable the regulator output\n"U_BOOT_CMD(regulator, CONFIG_SYS_MAXARGS, 1, do_regulator,
	"uclass operations",
	"list             - list UCLASS regulator devices\n"
	"regulator dev [regulator-name] - show/[set] operating regulator device\n"
	"regulator info                 - print constraints info\n"
	"regulator status [-a]          - print operating status [for all]\n"
	"regulator value [val] [-f]     - print/[set] voltage value [uV] (force)\n"
	"regulator current [val]        - print/[set] current value [uA]\n"
	"regulator mode [id]            - print/[set] operating mode id\n"
	"regulator enable               - enable the regulator output\n"
	"regulator disable              - disable the regulator output\n"
)uclass operationslist             - list UCLASS regulator devices
regulator dev [regulator-name] - show/[set] operating regulator device
regulator info                 - print constraints info
regulator status [-a]          - print operating status [for all]
regulator value [val] [-f]     - print/[set] voltage value [uV] (force)
regulator current [val]        - print/[set] current value [uA]
regulator mode [id]            - print/[set] operating mode id
regulator enable               - enable the regulator output
regulator disable              - disable the regulator output
"list             - list UCLASS regulator devices\n"
	"regulator dev [regulator-name] - show/[set] operating regulator device\n"
	"regulator info                 - print constraints info\n"
	"regulator status [-a]          - print operating status [for all]\n"
	"regulator value [val] [-f]     - print/[set] voltage value [uV] (force)\n"
	"regulator current [val]        - print/[set] current value [uA]\n"
	"regulator mode [id]            - print/[set] operating mode id\n"
	"regulator enable               - enable the regulator output\n"
	"regulator disable              - disable the regulator output\n"_u_boot_list_2_cmd_2_regulator.u_boot_list_2_cmd_2_regulatorU_BOOT_CMD_MKENT(info, 2, 1, do_info, "", "")U_BOOT_CMD_MKENT(value, 3, 1, do_value, "", "")U_BOOT_CMD_MKENT(current, 3, 1, do_current, "", "")val_nameallow_type_fixedU_BOOT_CMD_MKENT(mode, 2, 1, do_mode, "", "")U_BOOT_CMD_MKENT(enable, 1, 1, do_enable, "", "")U_BOOT_CMD_MKENT(disable, 1, 1, do_disable, "", "")/* Show all of them in a list, probing them as needed *//opt/src/include/remoteproc.hremoteprocrproc_elf32_load_imagerproc_elf32_sanity_checkrproc_is_runningrproc_pingrproc_resetrproc_stoprproc_startrproc_loadrproc_is_initializedrproc_dev_initrproc_initdm_rproc_opsdm_rproc_uclass_pdatarproc_mem_typeRPROC_INTERNAL_MEMORY_MAPPEDdevice_to_virtis_runningdriver_plat_datarproc_get_ops(dev)((struct dm_rproc_ops *)(dev)->driver->ops)_RPROC_H_CONFIG_IS_ENABLED(REMOTEPROC)REMOTEPROCCONFIG_VAL(REMOTEPROC_MODULE)CONFIG_REMOTEPROC_MODULE__ARG_PLACEHOLDER_CONFIG_REMOTEPROC_MODULE__ARG_PLACEHOLDER_CONFIG_REMOTEPROC_MODULE 1REMOTEPROC_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_REMOTEPROC_MODULECONFIG_VAL(REMOTEPROC)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_REMOTEPROCCONFIG_REMOTEPROC/* _RPROC_H_ *//**
 * rproc_elf32_load_image() - load an ELF32 image
 * @dev:	device loading the ELF32 image
 * @addr:	valid ELF32 image address
 * @return 0 if the image is successfully loaded, else appropriate error value.
 *//**
 * rproc_elf32_sanity_check() - Verify if an image is a valid ELF32 one
 *
 * Check if a valid ELF32 image exists at the given memory location. Verify
 * basic ELF32 format requirements like magic number and sections size.
 *
 * @addr:	address of the image to verify
 * @size:	size of the image
 * @return 0 if the image looks good, else appropriate error value.
 *//**
 * rproc_is_running() - check to see if remote processor is running
 * @id:		id of the remote processor
 * @return 0 if running, 1 if not running, -ve on error.
 *
 * NOTE: this may not involve actual communication capability of the remote
 * processor, but just ensures that it is out of reset and executing code.
 *//**
 * rproc_ping() - ping a remote processor to check if it can communicate
 * @id:		id of the remote processor
 * @return 0 if all ok, else appropriate error value.
 *
 * NOTE: this might need communication path available, which is not implemented
 * as part of remoteproc framework - hook on to appropriate bus architecture to
 * do the same
 *//**
 * rproc_reset() - reset a remote processor
 * @id:		id of the remote processor
 * @return 0 if all ok, else appropriate error value.
 *//**
 * rproc_stop() - Stop a remote processor
 * @id:		id of the remote processor
 * @return 0 if all ok, else appropriate error value.
 *//**
 * rproc_start() - Start a remote processor
 * @id:		id of the remote processor
 * @return 0 if all ok, else appropriate error value.
 *//**
 * rproc_load() - load binary or elf to a remote processor
 * @id:		id of the remote processor
 * @addr:	address in memory where the image is located
 * @size:	size of the image
 * @return 0 if all ok, else appropriate error value.
 *//**
 * rproc_is_initialized() - check to see if remoteproc devices are initialized
 * @return true if all devices are initialized, false otherwise.
 *//**
 * rproc_dev_init() - Initialize a remote proc device based on id
 * @id:		id of the remote processor
 * @return 0 if all ok, else appropriate error value.
 *//**
 * rproc_init() - Initialize all bound remote proc devices
 * @return 0 if all ok, else appropriate error value.
 *//* Accessor *//**
	 * device_to_virt() - Return translated virtual address (optional)
	 *
	 * Translate a device address (remote processor view) to virtual
	 * address (main processor view).
	 *
	 * @dev:	Remote proc device
	 * @da:		Device address
	 * @return virtual address.
	 *//**
	 * ping() - Ping the remote device for basic communication (optional)
	 *
	 * @dev:	Remote proc device
	 * @return 0 on success, 1 if not responding, -ve on other errors.
	 *//**
	 * is_running() - Check if the remote processor is running (optional)
	 *
	 * @dev:	Remote proc device
	 * @return 0 if running, 1 if not running, -ve on error.
	 *//**
	 * reset() - Reset the remoteproc device (optional)
	 *
	 * @dev:	Remote proc device
	 * @return 0 if all ok, else appropriate error value.
	 *//**
	 * stop() - Stop the remoteproc device (optional)
	 *
	 * @dev:	Remote proc device
	 * @return 0 if all ok, else appropriate error value.
	 *//**
	 * start() - Start the remoteproc device (mandatory)
	 *
	 * @dev:	Remote proc device
	 * @return 0 if all ok, else appropriate error value.
	 *//**
	 * load() - Load the remoteproc device using data provided (mandatory)
	 *
	 * Load the remoteproc device with an image, do not start the device.
	 *
	 * @dev:	Remote proc device
	 * @addr:	Address of the image to be loaded
	 * @size:	Size of the image to be loaded
	 * @return 0 if all ok, else appropriate error value.
	 *//**
	 * init() - Initialize the remoteproc device (optional)
	 *
	 * This is called after the probe is completed allowing the remote
	 * processor drivers to split up the initializations between probe and
	 * init if needed.
	 *
	 * @dev:	Remote proc device
	 * @return 0 if all ok, else appropriate error value.
	 *//**
 * struct dm_rproc_ops - Driver model remote proc operations.
 *
 * This defines the operations provided by remote proc driver.
 *//**
 * struct dm_rproc_uclass_pdata - platform data for a CPU
 * @name: Platform-specific way of naming the Remote proc
 * @mem_type: one of 'enum rproc_mem_type'
 * @driver_plat_data: driver specific platform data that may be needed.
 *
 * This can be accessed with dev_get_uclass_platdata() for any UCLASS_REMOTEPROC
 * device.
 *
 *//**
 * enum rproc_mem_type - What type of memory model does the rproc use
 * @RPROC_INTERNAL_MEMORY_MAPPED: Remote processor uses own memory and is memory
 *	mapped to the host processor over an address range.
 *
 * Please note that this is an enumeration of memory model of different types
 * of remote processors. Few of the remote processors do have own internal
 * memories, while others use external memory for instruction and data.
 *//* For platform data support - non dt world *//*
 * Note: The platform data support is not meant for use with newer
 * platforms. This is meant only for legacy devices. This mode of
 * initialization *will* be eventually removed once all necessary
 * platforms have moved to dm/fdt.
 *//*
 * (C) Copyright 2015
 * Texas Instruments Incorporated - http://www.ti.com/
 *//opt/src/cmd/remoteproc.cdo_remoteproccmd_remoteproc_subARRAY_SIZE(cmd_remoteproc_sub)do_remoteproc_wrapper"stop""is_running"Remote processor is Running
"Remote processor is Running\n"Remote processor is NOT Running
"Remote processor is NOT Running\n""ping"Remote processor responds 'Pong'
"Remote processor responds 'Pong'\n"No response from Remote processor
"No response from Remote processor\n"Operation Failed with error (%d)
"Operation Failed with error (%d)\n"do_remoteproc_load	 Expect some size??
"\t Expect some size??\n"Load Remote Processor %d with data@addr=0x%08lx %lu bytes:%s
"Load Remote Processor %d with data@addr=0x%08lx %lu bytes:%s\n" Failed!" Failed!" Success!" Success!"do_remoteproc_listdo_rproc_init	Remote Processors are already initialized
"\tRemote Processors are already initialized\n"Few Remote Processors failed to be initialized
"Few Remote Processors failed to be initialized\n"Remote Processor %d failed to be initialized
"Remote Processor %d failed to be initialized\n"print_remoteproc_listUCLASS_REMOTEPROCCannot find Remote processor class
"Cannot find Remote processor class\n"<remoteproc.h>dm_rproc_uclass_pdata *const dm_rproc_opsconst dm_rproc_ops *dm_rproc_ops *internal memory mapped"internal memory mapped"%d - Name:'%s' type:'%s' supports: %s%s%s%s%s%s
"%d - Name:'%s' type:'%s' supports: %s%s%s%s%s%s\n"load "load "start "start "stop "stop "reset "reset "is_running "is_running "ping "ping "typeof(*dev)uclass_foreach_dev(dev, uc)dev->uclass_node.nextrproc"Control operation of remote processors in an SoC"" [init|list|load|start|stop|reset|is_running|ping]\n" "\t\t Where:\n" "\t\t[addr] is a memory address\n" "\t\t<id> is a numerical identifier for the remote processor\n" "\t\t     provided by 'list' command.\n" "\t\tNote: Remote processors must be initalized prior to usage\n" "\t\tNote: Services are dependent on the driver capability\n" "\t\t      'list' command shows the capability of each device\n" "\n\tSubcommands:\n" "\tinit <id> - Enumerate and initalize the remote processor.\n" "\t		  if id is not passed, initialize all the remote prcessors\n" "\tlist   - list available remote processors\n" "\tload <id> [addr] [size]- Load the remote processor with binary\n" "\t		  image stored at address [addr] in memory\n" "\tstart <id>	- Start the remote processor(must be loaded)\n" "\tstop <id>	- Stop the remote processor\n" "\treset <id>	- Reset the remote processor\n" "\tis_running <id> - Reports if the remote processor is running\n" "\tping <id>	- Ping the remote processor for communication\n"Control operation of remote processors in an SoC [init|list|load|start|stop|reset|is_running|ping]
		 Where:
		[addr] is a memory address
		<id> is a numerical identifier for the remote processor
		     provided by 'list' command.
		Note: Remote processors must be initalized prior to usage
		Note: Services are dependent on the driver capability
		      'list' command shows the capability of each device

	Subcommands:
	init <id> - Enumerate and initalize the remote processor.
			  if id is not passed, initialize all the remote prcessors
	list   - list available remote processors
	load <id> [addr] [size]- Load the remote processor with binary
			  image stored at address [addr] in memory
	start <id>	- Start the remote processor(must be loaded)
	stop <id>	- Stop the remote processor
	reset <id>	- Reset the remote processor
	is_running <id> - Reports if the remote processor is running
	ping <id>	- Ping the remote processor for communication
" [init|list|load|start|stop|reset|is_running|ping]\n"
	   "\t\t Where:\n"
	   "\t\t[addr] is a memory address\n"
	   "\t\t<id> is a numerical identifier for the remote processor\n"
	   "\t\t     provided by 'list' command.\n"
	   "\t\tNote: Remote processors must be initalized prior to usage\n"
	   "\t\tNote: Services are dependent on the driver capability\n"
	   "\t\t      'list' command shows the capability of each device\n"
	   "\n\tSubcommands:\n"
	   "\tinit <id> - Enumerate and initalize the remote processor.\n"
	   "\t		  if id is not passed, initialize all the remote prcessors\n"
	   "\tlist   - list available remote processors\n"
	   "\tload <id> [addr] [size]- Load the remote processor with binary\n"
	   "\t		  image stored at address [addr] in memory\n"
	   "\tstart <id>	- Start the remote processor(must be loaded)\n"
	   "\tstop <id>	- Stop the remote processor\n"
	   "\treset <id>	- Reset the remote processor\n"
	   "\tis_running <id> - Reports if the remote processor is running\n"
	   "\tping <id>	- Ping the remote processor for communication\n"char[904]U_BOOT_CMD(rproc, 5, 1, do_remoteproc,
	   "Control operation of remote processors in an SoC",
	   " [init|list|load|start|stop|reset|is_running|ping]\n"
	   "\t\t Where:\n"
	   "\t\t[addr] is a memory address\n"
	   "\t\t<id> is a numerical identifier for the remote processor\n"
	   "\t\t     provided by 'list' command.\n"
	   "\t\tNote: Remote processors must be initalized prior to usage\n"
	   "\t\tNote: Services are dependent on the driver capability\n"
	   "\t\t      'list' command shows the capability of each device\n"
	   "\n\tSubcommands:\n"
	   "\tinit <id> - Enumerate and initalize the remote processor.\n"
	   "\t		  if id is not passed, initialize all the remote prcessors\n"
	   "\tlist   - list available remote processors\n"
	   "\tload <id> [addr] [size]- Load the remote processor with binary\n"
	   "\t		  image stored at address [addr] in memory\n"
	   "\tstart <id>	- Start the remote processor(must be loaded)\n"
	   "\tstop <id>	- Stop the remote processor\n"
	   "\treset <id>	- Reset the remote processor\n"
	   "\tis_running <id> - Reports if the remote processor is running\n"
	   "\tping <id>	- Ping the remote processor for communication\n")_u_boot_list_2_cmd_2_rproc.u_boot_list_2_cmd_2_rproc"Enumerate and initialize the remote processor(s)""id - ID of the remote processor\n" "If id is not passed, initialize all the remote processors""list remote processors""Load remote processor with provided image""<id> [addr] [size]\n" "- id: ID of the remote processor(see 'list' cmd)\n" "- addr: Address in memory of the image to loadup\n" "- size: Size of the image to loadup\n""Start remote processor""id - ID of the remote processor (see 'list' cmd)\n""Stop remote processor""Reset remote processor""Check to see if remote processor is running\n""Ping to communicate with remote processor\n"Enumerate and initialize the remote processor(s)id - ID of the remote processor
If id is not passed, initialize all the remote processors"id - ID of the remote processor\n"
			 "If id is not passed, initialize all the remote processors"U_BOOT_CMD_MKENT(init, 1, 1, do_rproc_init,
			 "Enumerate and initialize the remote processor(s)",
			 "id - ID of the remote processor\n"
			 "If id is not passed, initialize all the remote processors")list remote processorsU_BOOT_CMD_MKENT(list, 0, 1, do_remoteproc_list,
			 "list remote processors", "")Load remote processor with provided image<id> [addr] [size]
- id: ID of the remote processor(see 'list' cmd)
- addr: Address in memory of the image to loadup
- size: Size of the image to loadup
"<id> [addr] [size]\n"
			 "- id: ID of the remote processor(see 'list' cmd)\n"
			 "- addr: Address in memory of the image to loadup\n"
			 "- size: Size of the image to loadup\n"char[154]U_BOOT_CMD_MKENT(load, 5, 1, do_remoteproc_load,
			 "Load remote processor with provided image",
			 "<id> [addr] [size]\n"
			 "- id: ID of the remote processor(see 'list' cmd)\n"
			 "- addr: Address in memory of the image to loadup\n"
			 "- size: Size of the image to loadup\n")Start remote processorid - ID of the remote processor (see 'list' cmd)
U_BOOT_CMD_MKENT(start, 1, 1, do_remoteproc_wrapper,
			 "Start remote processor",
			 "id - ID of the remote processor (see 'list' cmd)\n")Stop remote processorU_BOOT_CMD_MKENT(stop, 1, 1, do_remoteproc_wrapper,
			 "Stop remote processor",
			 "id - ID of the remote processor (see 'list' cmd)\n")Reset remote processorU_BOOT_CMD_MKENT(reset, 1, 1, do_remoteproc_wrapper,
			 "Reset remote processor",
			 "id - ID of the remote processor (see 'list' cmd)\n")Check to see if remote processor is running
U_BOOT_CMD_MKENT(is_running, 1, 1, do_remoteproc_wrapper,
			 "Check to see if remote processor is running\n",
			 "id - ID of the remote processor (see 'list' cmd)\n")Ping to communicate with remote processor
U_BOOT_CMD_MKENT(ping, 1, 1, do_remoteproc_wrapper,
			 "Ping to communicate with remote processor\n",
			 "id - ID of the remote processor (see 'list' cmd)\n")/* Strip off leading 'rproc' command argument *//**
 * do_remoteproc() - (replace: short desc)
 * @cmdtp:	unused
 * @flag:	unused
 * @argc:	argument count
 * @argv:	argument list
 *
 * parses up the command table to invoke the correct command.
 *
 * Return: 0 if no error, else returns appropriate error value.
 *//* Else error.. *//**
 * do_remoteproc_wrapper() - wrapper for various  rproc commands
 * @cmdtp:	unused
 * @flag:	unused
 * @argc:	argument count for the rproc command
 * @argv:	arguments for the rproc command
 *
 * Most of the commands just take id as a parameter andinvoke various
 * helper routines in remote processor core. by using a set of
 * common checks, we can reduce the amount of code used for this.
 *
 * Return: 0 if no error, else returns appropriate error value.
 *//**
 * do_remoteproc_load() - Load a remote processor with binary image
 * @cmdtp:	unused
 * @flag:	unused
 * @argc:	argument count for the load function
 * @argv:	arguments for the load function
 *
 * Return: 0 if no error, else returns appropriate error value.
 *//**
 * do_remoteproc_list() - print list of remote proc devices.
 * @cmdtp:	unused
 * @flag:	unused
 * @argc:	unused
 * @argv:	unused
 *
 * Return: 0 if no error, else returns appropriate error value.
 *//**
 * do_rproc_init() - do basic initialization
 * @cmdtp:	unused
 * @flag:	unused
 * @argc:	unused
 * @argv:	unused
 *
 * Return: 0 if no error, else returns appropriate error value.
 *//* Do not print if rproc is not probed *//**
 * print_remoteproc_list() - print all the remote processor devices
 *
 * Return: 0 if no error, else returns appropriate error value.
 *//opt/src/include/ahci.hahciahci_probe_scsi_pciahci_probe_scsiahci_bind_scsiahci_init_dmahci_start_ports_dmahci_init_one_dmahci_resetahci_initsata_scansata_dm_port_statussata_resetahci_opsahci_uc_privahci_ioportsahci_sgahci_cmd_hdrport_statuslink_port_mapport_mapudma_maskpio_maskmmio_basehost_set_flagshost_flagshard_port_non_portsu16 *[32]unsigned short *[32]AHCI_MAX_PORTSataidahci_ioports[32]rx_fiscmd_tblahci_sg *cmd_tbl_sgahci_cmd_hdr *cmd_slotport_mmioflags_sizeaddr_hitbl_addr_hitbl_addrahci_get_ops(dev)((struct ahci_ops *)(dev)->driver->ops)ATA_FLAG_NO_ATAPIATA_FLAG_PIO_DMAATA_FLAG_SATA_RESETATA_FLAG_MMIOATA_FLAG_NO_LEGACYATA_FLAG_SATAPORT_CMD_ICC_SLUMBER(0x6 << 28)PORT_CMD_ICC_PARTIAL(0x2 << 28)PORT_CMD_ICC_ACTIVE(0x1 << 28)PORT_CMD_STARTPORT_CMD_SPIN_UPPORT_CMD_POWER_ONPORT_CMD_CLOPORT_CMD_FIS_RXPORT_CMD_FIS_ONPORT_CMD_LIST_ONPORT_CMD_ATAPIPORT_SCR_STAT_DET_PHYRDYPORT_SCR_STAT_DET_COMINITPORT_SCR_STAT_DET_MASKDEF_PORT_IRQPORT_IRQ_FATAL | PORT_IRQ_PHYRDY | PORT_IRQ_CONNECT | PORT_IRQ_SG_DONE | PORT_IRQ_UNK_FIS | PORT_IRQ_SDB_FIS | PORT_IRQ_DMAS_FIS | PORT_IRQ_PIOS_FIS | PORT_IRQ_D2H_REG_FISPORT_IRQ_FATALPORT_IRQ_TF_ERR | PORT_IRQ_HBUS_ERR | PORT_IRQ_HBUS_DATA_ERR | PORT_IRQ_IF_ERRPORT_IRQ_D2H_REG_FISPORT_IRQ_PIOS_FISPORT_IRQ_DMAS_FISPORT_IRQ_SDB_FISPORT_IRQ_UNK_FISPORT_IRQ_SG_DONEPORT_IRQ_CONNECTPORT_IRQ_DEV_ILCKPORT_IRQ_PHYRDYPORT_IRQ_BAD_PMPPORT_IRQ_OVERFLOWPORT_IRQ_IF_NONFATALPORT_IRQ_IF_ERRPORT_IRQ_HBUS_DATA_ERRPORT_IRQ_HBUS_ERRPORT_IRQ_TF_ERRPORT_IRQ_COLD_PRESPORT_SCR_ACTPORT_SCR_ERRPORT_SCR_CTLPORT_SCR_STATPORT_SCRPORT_CMD_ISSUEPORT_SIGPORT_TFDATAPORT_CMDPORT_IRQ_MASKPORT_IRQ_STATPORT_FIS_ADDR_HIPORT_FIS_ADDRPORT_LST_ADDR_HIPORT_LST_ADDRHOST_AHCI_ENHOST_IRQ_ENHOST_RESETHOST_CAP2HOST_VERSIONHOST_PORTS_IMPLHOST_IRQ_STATHOST_CTLHOST_CAPRX_FIS_D2H_REGAHCI_CMD_CLR_BUSYAHCI_CMD_RESETAHCI_CMD_PREFETCHAHCI_CMD_WRITEAHCI_CMD_ATAPIAHCI_PORT_PRIV_DMA_SZ(AHCI_CMD_SLOT_SZ * AHCI_MAX_CMD_SLOT + AHCI_CMD_TBL_SZ + AHCI_RX_FIS_SZ)AHCI_CMD_TBL_SZAHCI_CMD_TBL_HDR + (AHCI_MAX_SG * 16)AHCI_CMD_TBL_CDBAHCI_CMD_TBL_HDRAHCI_RX_FIS_SZAHCI_MAX_CMD_SLOTAHCI_CMD_SLOT_SZAHCI_MAX_SGAHCI_PCI_BAR_AHCI_H_CONFIG_SUNXI_AHCIdefined(CONFIG_DM_PCI) || defined(CONFIG_DM_SCSI)/**
 * ahci_probe_scsi_pci() - probe and scan the attached SCSI bus on PCI
 *
 * Note that the SCSI device will itself bind block devices for any storage
 * devices it finds.
 *
 * @ahci_dev: AHCI parent device
 * @return 0 if OK, -ve on error
 *//**
 * ahci_probe_scsi() - probe and scan the attached SCSI bus
 *
 * Note that the SCSI device will itself bind block devices for any storage
 * devices it finds.
 *
 * @ahci_dev: AHCI parent device
 * @base: Base address of AHCI port
 * @return 0 if OK, -ve on error
 *//**
 * ahci_bind_scsi() - bind a new SCSI bus as a child
 *
 * Note that the SCSI bus device will itself bind block devices
 *
 * @ahci_dev: AHCI parent device
 * @devp: Returns new SCSI bus device
 * @return 0 if OK, -ve on error
 *//**
 * ahci_init_dm() - init AHCI for a controller, finding all ports
 *
 * @dev: Device to init
 *//**
 * ahci_start_ports_dm() - start all AHCI ports for a controller
 *
 * @dev: Controller containing ports to start
 *//**
 * ahci_init_one_dm() - set up a single AHCI port
 *
 * @dev: Controller to init
 *//**
 * sata_scan() - scan SATA ports
 *
 * @dev:	Controller to scan
 * @return 0 if OK, -ve on error
 *//**
 * sata_port_status() - get the status of a SATA port
 *
 * @dev:	Controller to reset
 * @port:	Port number to check (0 for first)
 * @return 0 if detected, -ENXIO if nothin on port, other -ve on error
 *//**
 * sata_reset() - reset the controller
 *
 * @dev:	Controller to reset
 * @return 0 if OK, -ve on error
 *//**
	 * scan() - scan SATA ports
	 *
	 * @dev:	Controller to scan
	 * @return 0 if OK, -ve on error
	 *//**
	 * port_status() - get the status of a SATA port
	 *
	 * @dev:	Controller to reset
	 * @port:	Port number to check (0 for first)
	 * @return 0 if detected, -ENXIO if nothing on port, other -ve on error
	 *//**
	 * reset() - reset the controller
	 *
	 * @dev:	Controller to reset
	 * @return 0 if OK, -ve on error
	 *//*linkup port map*//* cache of HOST_PORTS_IMPL reg *//* cache of HOST_CAP register *//*
	 * TODO(sjg@chromium.org): Drop this once this structure is only used
	 * in a driver-model context (i.e. attached to a device with
	 * dev_get_uclass_priv()
	 *//**
 * struct ahci_uc_priv - information about an AHCI controller
 *
 * When driver model is used, this is accessible using dev_get_uclass_priv(dev)
 * where dev is the controller (although at present it sometimes stands alone).
 *//* No ATAPI support *//* PIO cmds via DMA *//* (obsolete) use COMRESET *//* use MMIO, not PIO *//* no legacy mode check *//* Put i/f in slumber state *//* Put i/f in partial state *//* Put i/f in active state *//* Enable port DMA engine *//* Spin up device *//* Power up device *//* Command list override *//* Enable FIS receive DMA engine *//* FIS DMA engine running *//* cmd list DMA engine running *//* Device is ATAPI *//* PORT_CMD bits *//* PORT_SCR_STAT bits *//* D2H Register FIS rx'd *//* PIO Setup FIS rx'd *//* DMA Setup FIS rx'd *//* Set Device Bits FIS rx'd *//* unknown FIS rx'd *//* descriptor processed *//* port connect change status *//* device interlock *//* PhyRdy changed *//* incorrect port multiplier *//* xfer exhausted available S/G *//* interface non-fatal error *//* interface fatal error *//* host bus data error *//* host bus fatal error *//* task file error *//* cold presence detect *//* PORT_IRQ_{STAT,MASK} bits *//* SUNXI specific "DMA register" *//* SATA phy register: SActive *//* SATA phy register: SError *//* SATA phy register: SControl *//* SATA phy register: SStatus *//* SATA phy register block *//* command issue *//* device TF signature *//* taskfile data *//* port command *//* interrupt enable/disable mask *//* interrupt status *//* FIS rx buf addr hi *//* FIS rx buf addr *//* command list DMA addr hi *//* command list DMA addr *//* Registers for each SATA port *//* AHCI enabled *//* global IRQ enable *//* reset controller; self-clear *//* HOST_CTL bits *//* host capabilities, extended *//* AHCI spec. version compliancy *//* bitmap of implemented ports *//* global host control *//* host capabilities *//* Global controller registers *//* offset of D2H Register FIS data *//* hardware max is 64K *//*
 * Copyright (C) Freescale Semiconductor, Inc. 2006.
 * Author: Jason Jin<Jason.jin@freescale.com>
 *         Zhang Wei<wei.zhang@freescale.com>
 */ahci_dev/opt/src/include/sata.hsatasata_port_status__sata_stopsata_stop__sata_initializesata_initializesata_writesata_readscan_satareset_satainit_satablk_desc[]__SATA_H__!defined(CONFIG_DM_SCSI) && !defined(CONFIG_AHCI)sata_removesata_probesata_dev_descblknr/opt/src/cmd/sata.cdo_sata"SATA sub system""init - init SATA sub system\n" "sata stop [dev] - disable SATA sub system or device\n" "sata info - show available SATA devices\n" "sata device [dev] - show or set current device\n" "sata part [dev] - print partition table\n" "sata read addr blk# cnt\n" "sata write addr blk# cnt"SATA sub systeminit - init SATA sub system
sata stop [dev] - disable SATA sub system or device
sata info - show available SATA devices
sata device [dev] - show or set current device
sata part [dev] - print partition table
sata read addr blk# cnt
sata write addr blk# cnt"init - init SATA sub system\n"
	"sata stop [dev] - disable SATA sub system or device\n"
	"sata info - show available SATA devices\n"
	"sata device [dev] - show or set current device\n"
	"sata part [dev] - print partition table\n"
	"sata read addr blk# cnt\n"
	"sata write addr blk# cnt"U_BOOT_CMD(
	sata, 5, 1, do_sata,
	"SATA sub system",
	"init - init SATA sub system\n"
	"sata stop [dev] - disable SATA sub system or device\n"
	"sata info - show available SATA devices\n"
	"sata device [dev] - show or set current device\n"
	"sata part [dev] - print partition table\n"
	"sata read addr blk# cnt\n"
	"sata write addr blk# cnt"
)_u_boot_list_2_cmd_2_sata.u_boot_list_2_cmd_2_satasata_curr_deviceCONFIG_AHCI/* If the user has not yet run `sata init`, do it now *//*
 * Copyright (C) 2000-2005, DENX Software Engineering
 *		Wolfgang Denk <wd@denx.de>
 * Copyright (C) Procsys. All rights reserved.
 *		Mushtaq Khan <mushtaq_k@procsys.com>
 *			<mushtaqk_921@yahoo.co.in>
 * Copyright (C) 2008 Freescale Semiconductor, Inc.
 *		Dave Liu <daveliu@freescale.com>
 */<sata.h><ahci.h>/opt/src/include/binman_sym.hbinman_symbinman_sym(_type,_entry_name,_prop_name)BINMAN_SYM_MISSINGbinman_sym_extern(_type,_entry_name,_prop_name)binman_sym_declare_optional(_type,_entry_name,_prop_name)binman_sym_declare(_type,_entry_name,_prop_name)(-1UL)__BINMAN_SYM_HCONFIG_BINMAN/* BINMAN *//* !BINMAN *//**
 * binman_sym() - Access a previously declared symbol
 *
 * This is used to get the value of a symbol. E.g.:
 *
 *    ulong address = binman_sym(ulong, u_boot_spl, pos);
 *
 * @_type: Type f the symbol (e.g. unsigned long)
 * @entry_name: Name of the entry to look for (e.g. 'u_boot_spl')
 * @_prop_name: Property value to get from that entry (e.g. 'pos')
 * @returns value of that property (filled in by binman)
 *//**
 * binman_sym_declare_optional() - Declare an optional symbol
 *
 * If this symbol cannot be provided by binman, an error will not be generated.
 * Instead the image will be assigned the value BINMAN_SYM_MISSING.
 *
 * @_type: Type f the symbol (e.g. unsigned long)
 * @entry_name: Name of the entry to look for (e.g. 'u_boot_spl')
 * @_prop_name: Property value to get from that entry (e.g. 'pos')
 *//**
 * binman_sym_extern() - Declare a extern symbol that will be used at run-time
 *
 * @_type: Type f the symbol (e.g. unsigned long)
 * @entry_name: Name of the entry to look for (e.g. 'u_boot_spl')
 * @_prop_name: Property value to get from that entry (e.g. 'pos')
 *//**
 * binman_sym_declare() - Declare a symbol that will be used at run-time
 *
 * @_type: Type f the symbol (e.g. unsigned long)
 * @entry_name: Name of the entry to look for (e.g. 'u_boot_spl')
 * @_prop_name: Property value to get from that entry (e.g. 'pos')
 *//**
 * binman_symname() - Internal fnuction to get a binman symbol name
 *
 * @entry_name: Name of the entry to look for (e.g. 'u_boot_spl')
 * @_prop_name: Property value to get from that entry (e.g. 'pos')
 * @returns name of the symbol for that entry and property
 *//*
 * Symbol access for symbols set up by binman as part of the build.
 *
 * This allows C code to access the position of a particular part of the image
 * assembled by binman.
 *
 * Copyright (c) 2017 Google, Inc
 *//opt/src/arch/sandbox/include/asm/spl.hsplBOOT_DEVICE_BOARDCONFIG_SPL_BOARD_LOAD_IMAGE__asm_spl_h/*
 * Copyright (c) 2016 Google, Inc
 *//opt/src/include/handoff.hhandoff__HANDOFF_HCONFIG_IS_ENABLED(HANDOFF)HANDOFFCONFIG_VAL(HANDOFF_MODULE)CONFIG_HANDOFF_MODULE__ARG_PLACEHOLDER_CONFIG_HANDOFF_MODULE__ARG_PLACEHOLDER_CONFIG_HANDOFF_MODULE 1HANDOFF_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_HANDOFF_MODULECONFIG_VAL(HANDOFF)CONFIG_HANDOFF__ARG_PLACEHOLDER_CONFIG_HANDOFF__ARG_PLACEHOLDER_CONFIG_HANDOFF 1__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_HANDOFF/**
 * struct spl_handoff - information passed from SPL to U-Boot proper
 *
 * @ram_size: Value to use for gd->ram_size
 *//*
 * Passing basic information from SPL to U-Boot proper
 *
 * Copyright 2018 Google, Inc
 *//opt/src/include/spl.hspl_get_load_bufferspl_perform_fixupsspl_image_info *board_spl_fit_size_alignboard_spl_fit_post_loadboard_return_to_bootromspl_optee_entryspl_invoke_atfspl_mmc_loadspl_boot_device *spl_mmc_load_imagespl_dfu_cmdspl_was_boot_sourcespl_initspl_early_initspl_load_image_ext_osspl_load_image_extjump_to_image_no_argsspl_load_image_fat_osspl_load_image_fatspl_display_printspl_start_ubootjump_to_image_linuxspl_board_ubi_load_imagespl_board_prepare_for_bootspl_board_prepare_for_linuxspl_parse_image_headerconst image_headerconst image_header *spl_set_header_raw_ubootspl_set_bdspl_boot_partitionspl_boot_modespl_boot_devicepreloader_console_initspl_load_simple_fitspl_load_info *spl_load_simple_fit_skip_processingu_boot_first_phaseCONFIG_TPL__ARG_PLACEHOLDER_CONFIG_TPLIS_ENABLED(CONFIG_TPL)CONFIG_TPL_MODULE__ARG_PLACEHOLDER_CONFIG_TPL_MODULE__ARG_PLACEHOLDER_CONFIG_TPL_MODULE 1__ARG_PLACEHOLDER_CONFIG_TPL 1CONFIG_TPL_BUILD__ARG_PLACEHOLDER_CONFIG_TPL_BUILDIS_ENABLED(CONFIG_TPL_BUILD)CONFIG_TPL_BUILD_MODULE__ARG_PLACEHOLDER_CONFIG_TPL_BUILD_MODULE__ARG_PLACEHOLDER_CONFIG_TPL_BUILD_MODULE 1__ARG_PLACEHOLDER_CONFIG_TPL_BUILD 1__ARG_PLACEHOLDER_CONFIG_SPLIS_ENABLED(CONFIG_SPL)CONFIG_SPL_MODULE__ARG_PLACEHOLDER_CONFIG_SPL_MODULE__ARG_PLACEHOLDER_CONFIG_SPL_MODULE 1__ARG_PLACEHOLDER_CONFIG_SPL 1__ARG_PLACEHOLDER_CONFIG_SPL_BUILDIS_ENABLED(CONFIG_SPL_BUILD)CONFIG_SPL_BUILD_MODULE__ARG_PLACEHOLDER_CONFIG_SPL_BUILD_MODULE__ARG_PLACEHOLDER_CONFIG_SPL_BUILD_MODULE 1__ARG_PLACEHOLDER_CONFIG_SPL_BUILD 1spl_image_loaderspl_load_infospl_image_infoboot_device_namebl_lenentry_pointSPL_LOAD_IMAGE_METHOD(_name,_priority,_boot_device,_method)SPL_LOAD_IMAGE(_method ## _priority ## _boot_device) = { .boot_device = _boot_device, .load_image = _method, }SPL_LOAD_IMAGE(__name)ll_entry_declare(struct spl_image_loader, __name, spl_image_loader)SPL_FIT_FOUNDSPL_COPY_PAYLOAD_ONLYSPL_TPL_PROMPTSPL_TPL_NAMEMMCSD_MODE_EMMCBOOTMMCSD_MODE_FSMMCSD_MODE_RAWMMCSD_MODE_UNDEFINEDUBOOT_NOT_LOADED_FROM_SPL0x13578642_SPL_H_CONFIG_IS_ENABLED(LOAD_FIT) || CONFIG_IS_ENABLED(LOAD_FIT_FULL)CONFIG_SPL_LEGACY_IMAGE_CRC_CHECKCONFIG_SPL_LIBCOMMON_SUPPORTCONFIG_SPL_BOARD_INITu_boot_anyimage_posLOAD_FIT_FULLCONFIG_VAL(LOAD_FIT_FULL_MODULE)CONFIG_LOAD_FIT_FULL_MODULE__ARG_PLACEHOLDER_CONFIG_LOAD_FIT_FULL_MODULE__ARG_PLACEHOLDER_CONFIG_LOAD_FIT_FULL_MODULE 1LOAD_FIT_FULL_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_LOAD_FIT_FULL_MODULECONFIG_VAL(LOAD_FIT_FULL)CONFIG_LOAD_FIT_FULL__ARG_PLACEHOLDER_CONFIG_LOAD_FIT_FULL__ARG_PLACEHOLDER_CONFIG_LOAD_FIT_FULL 1__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_LOAD_FIT_FULLLOAD_FITCONFIG_VAL(LOAD_FIT_MODULE)CONFIG_LOAD_FIT_MODULE__ARG_PLACEHOLDER_CONFIG_LOAD_FIT_MODULE__ARG_PLACEHOLDER_CONFIG_LOAD_FIT_MODULE 1LOAD_FIT_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_LOAD_FIT_MODULECONFIG_VAL(LOAD_FIT)CONFIG_LOAD_FIT__ARG_PLACEHOLDER_CONFIG_LOAD_FIT__ARG_PLACEHOLDER_CONFIG_LOAD_FIT 1__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_LOAD_FIT/*
 * spl_get_load_buffer() - get buffer for loading partial image data
 *
 * Returns memory area which can be populated by partial image data,
 * ie. uImage or fitImage header.
 *//**
 * spl_perform_fixups() - arch/board-specific callback before processing
 *                        the boot-payload
 *//**
 * board_spl_fit_size_align - specific size align before processing payload
 *
 *//**
 * board_spl_fit_post_load - allow process images after loading finished
 *
 *//**
 * board_return_to_bootrom - allow for boards to continue with the boot ROM
 *
 * If a board (e.g. the Rockchip RK3368 boards) provide some
 * supporting functionality for SPL in their boot ROM and the SPL
 * stage wants to return to the ROM code to continue booting, boards
 * can implement 'board_return_to_bootrom'.
 *//**
 * spl_optee_entry - entry function for optee
 *
 * args defind in op-tee project
 * https://github.com/OP-TEE/optee_os/
 * core/arch/arm/kernel/generic_entry_a32.S
 * @arg0: pagestore
 * @arg1: (ARMv7 standard bootarg #1)
 * @arg2: device tree address, (ARMv7 standard bootarg #2)
 * @arg3: non-secure entry address (ARMv7 bootarg #0)
 *//**
 * spl_invoke_atf - boot using an ARM trusted firmware image
 *//**
 * spl_mmc_load() - Load an image file from MMC/SD media
 *
 * @param spl_image	Image data filled in by loading process
 * @param bootdev	Describes which device to load from
 * @param filename	Name of file to load (in FS mode)
 * @param raw_part	Partition to load from (in RAW mode)
 * @param raw_sect	Sector to load from (in RAW mode)
 *
 * @return 0 on success, otherwise error code
 *//**
 * spl_dfu_cmd- run dfu command with chosen mmc device interface
 * @param usb_index - usb controller number
 * @param mmc_dev -  mmc device nubmer
 *
 * @return 0 on success, otherwise error code
 *//**
 * spl_was_boot_source() - check if U-Boot booted from SPL
 *
 * This will normally be true, but if U-Boot jumps to second U-Boot, it will
 * be false. This should be implemented by board-specific code.
 *
 * @return true if U-Boot booted from SPL, else false
 *//**
 * spl_init() - Set up device tree and driver model in SPL if enabled
 *
 * You can optionally call spl_early_init(), then optionally call spl_init().
 * This function will be called from board_init_r() if not called earlier.
 *
 * Both spl_early_init() and spl_init() perform a similar function except that
 * the latter will not set up the malloc() area if
 * CONFIG_SPL_STACK_R_MALLOC_SIMPLE_LEN is enabled, since it is assumed to
 * already be done by a calll to spl_relocate_stack_gd() before board_init_r()
 * is reached.
 *
 * This function will be called from board_init_r() if not called earlier.
 *
 * If this is not called, then driver model will be inactive in SPL's
 * board_init_f(), and no device tree will be available.
 *//**
 * spl_early_init() - Set up device tree and driver model in SPL if enabled
 *
 * Call this function in board_init_f() if you want to use device tree and
 * driver model early, before board_init_r() is called.
 *
 * If this is not called, then driver model will be inactive in SPL's
 * board_init_f(), and no device tree will be available.
 *//* SPL EXT image functions *//* SPL FAT image functions *//*
 * _priority is the priority of this method, 0 meaning it will be the top
 * choice for this device, 9 meaning it is the bottom choice.
 * _boot_device is the BOOT_DEVICE_... value
 * _method is the load_image function to call
 *//* Declare an SPL image loader *//**
	 * load_image() - Load an SPL image
	 *
	 * @spl_image: place to put image information
	 * @bootdev: describes the boot device to load from
	 *//**
 * Holds information about a way of loading an SPL image
 *
 * @name: User-friendly name for this method (e.g. "MMC")
 * @boot_device: Boot device that this loader supports
 * @load_image: Function to call to load image
 *//**
 * struct spl_boot_device - Describes a boot device used by SPL
 *
 * @boot_device: A number indicating the BOOT_DEVICE type. There are various
 * BOOT_DEVICE... #defines and enums in U-Boot and they are not consistently
 * numbered.
 * @boot_device_name: Named boot device, or NULL if none.
 *
 * Note: Additional fields can be added here, bearing in mind that SPL is
 * size-sensitive and common fields will be present on all boards. This
 * struct can also be used to return additional information about the load
 * process if that becomes useful.
 *//**
 * spl_display_print() - Display a board-specific message in SPL
 *
 * If CONFIG_SPL_DISPLAY_PRINT is enabled, U-Boot will call this function
 * immediately after displaying the SPL console banner ("U-Boot SPL ...").
 * This function should be provided by the board.
 *//**
 * spl_start_uboot() - Check if SPL should start the kernel or U-Boot
 *
 * This is called by the various SPL loaders to determine whether the board
 * wants to load the kernel or U-Boot. This function should be provided by
 * the board.
 *
 * @return 0 if SPL should start the kernel, 1 if U-Boot must be started
 *//**
 * jump_to_image_linux() - Jump to a Linux kernel from SPL
 *
 * This jumps into a Linux kernel using the information in @spl_image.
 *
 * @spl_image: Image description to set up
 *//**
 * spl_parse_image_header() - parse the image header and set up info
 *
 * This parses the legacy image header information at @header and sets up
 * @spl_image according to what is found. If no image header is found, then
 * a raw image or bootz is assumed. If CONFIG_SPL_PANIC_ON_RAW_IMAGE is
 * enabled, then this causes a panic. If CONFIG_SPL_RAW_IMAGE_SUPPORT is not
 * enabled then U-Boot gives up. Otherwise U-Boot sets up the image using
 * spl_set_header_raw_uboot(), or possibly the bootz header.
 *
 * @spl_image: Image description to set up
 * @header image header to parse
 * @return 0 if a header was correctly parsed, -ve on error
 *//**
 * spl_set_header_raw_uboot() - Set up a standard SPL image structure
 *
 * This sets up the given spl_image which the standard values obtained from
 * config options: CONFIG_SYS_MONITOR_LEN, CONFIG_SYS_UBOOT_START,
 * CONFIG_SYS_TEXT_BASE.
 *
 * @spl_image: Image description to set up
 *//* SPL common functions *//**
 * spl_load_simple_fit() - Loads a fit image from a device.
 * @spl_image:	Image description to set up
 * @info:	Structure containing the information required to load data.
 * @sector:	Sector number where FIT image is located in the device
 * @fdt:	Pointer to the copied FIT header.
 *
 * Reads the FIT image @sector in the device. Loads u-boot image to
 * specified load address and copies the dtb to end of u-boot image.
 * Returns 0 on success.
 *//**
 * spl_load_simple_fit_skip_processing() - Hook to allow skipping the FIT
 *	image processing during spl_load_simple_fit().
 *
 * Return true to skip FIT processing, false to preserve the full code flow
 * of spl_load_simple_fit().
 *//*
 * We need to know the position of U-Boot in memory so we can jump to it. We
 * allow any U-Boot binary to be used (u-boot.bin, u-boot-nodtb.bin,
 * u-boot.img), hence the '_any'. These is no checking here that the correct
 * image is found. For * example if u-boot.img is used we don't check that
 * spl_parse_image_header() can parse a valid header.
 *//*
 * Information required to load data from a device
 *
 * @dev: Pointer to the device, e.g. struct mmc *
 * @priv: Private data for the device
 * @bl_len: Block length for reading in bytes
 * @filename: Name of the fit image file.
 * @read: Function to call to read from the device
 *//* A string name for SPL or TPL *//*
 * u_boot_first_phase() - check if this is the first U-Boot phase
 *
 * U-Boot has up to three phases: TPL, SPL and U-Boot proper. Depending on the
 * build flags we can determine whether the current build is for the first
 * phase of U-Boot or not. If there is no SPL, then this is U-Boot proper. If
 * there is SPL but no TPL, the the first phase is SPL. If there is TPL, then
 * it is the first phase.
 *
 * @returns true if this is the first phase of U-Boot
 *
 *//* Boot type *//* Value in r0 indicates we booted from U-Boot *//* Platform-specific defines *//*
 * (C) Copyright 2012
 * Texas Instruments, <www.ti.com>
 */<handoff.h><asm/spl.h><binman_sym.h>spl_imagearg0arg3bootdevraw_partraw_sectusbctrldfu_alt_infodevstr/opt/src/cmd/sb.cdo_sbcmd_sb_subARRAY_SIZE(cmd_sb_sub)do_sb_statedo_sb_handoffCommand not supported
"Command not supported\n""Sandbox status commands""handoff     - Show handoff data received from SPL\n" "sb state       - Show sandbox state"Sandbox status commandshandoff     - Show handoff data received from SPL
sb state       - Show sandbox state"handoff     - Show handoff data received from SPL\n"
	"sb state       - Show sandbox state"char[86]U_BOOT_CMD(
	sb,	8,	1,	do_sb,
	"Sandbox status commands",
	"handoff     - Show handoff data received from SPL\n"
	"sb state       - Show sandbox state"
)_u_boot_list_2_cmd_2_sb.u_boot_list_2_cmd_2_sbU_BOOT_CMD_MKENT(handoff, 1, 0, do_sb_handoff, "", "")U_BOOT_CMD_MKENT(state, 1, 0, do_sb_state, "", "")/* Skip past 'sb' *//*
 * Copyright 2018, Google Inc.
 * Written by Simon Glass <sjg@chromium.org>
 */<spl.h>/opt/src/include/scsi.hscsiscsi_initscsi_low_level_initscsi_scan_devscsi_scanscsi_bus_resetscsi_execscsi_cmd *scsi_opsscsi_platdatascsi_cmdbus_resetexecmax_idmax_luntrans_bytescontr_statsensecmdsensedatalensensecmdlenmsginmsgoutcmdlensense_bufSCSI_INT_STATESCSI_UNEXP_DIS0x00000104SCSI_MA_TIME_OUT0x00000103SCSI_HNS_TIME_OUT0x00000102SCSI_SEL_TIME_OUT0x00000101SCSI_IDENTIFYscsi_get_ops(dev)((struct scsi_ops *)(dev)->driver->ops)SCSI_WRITE_SAMESCSI_WRITE_LONG0x3FSCSI_WRT_VERIFY0x2ESCSI_WRITE100x2ASCSI_WRITE6SCSI_VERIFY0x2FSCSI_SYNC_CACHESCSI_START_STPSCSI_SET_LIMITSCSI_SEND_DIAGSCSI_SEEK100x2BSCSI_SEEK6SCSI_SRCH_DAT_LSCSI_SRCH_DAT_HSCSI_SRCH_DAT_ESCSI_REZEROSCSI_RELEASESCSI_RCV_DIAGSCSI_REASS_BLKSCSI_READ_LONG0x3ESCSI_RD_DEFECTSCSI_RD_CAPAC160x9eSCSI_RD_CAPAC10SCSI_RD_CAPACSCSI_READ16SCSI_READ10SCSI_READ6SCSI_MED_REMOVLSCSI_PREFETCHSCSI_LCK_UN_CACSCSI_FORMATSCSI_COMPARESCSI_WRITE_BUFF0x3BSCSI_TST_U_RDYSCSI_REQ_SENSESCSI_READ_BUFF0x3CSCSI_MODE_SEN100x5ASCSI_MODE_SEN6SCSI_MODE_SEL10SCSI_MODE_SEL6SCSI_LOG_SENSE0x4DSCSI_LOG_SELECT0x4CSCSI_INQUIRYSCSI_COP_VERIFY0x3ASCSI_COPYSCSI_CHANGE_DEFSENSE_MISCOMPARE0xESENSE_VOLUME_OVERFLOW0xDSENSE_ABORTED_COMMAND0xBSENSE_COPY_ABORTED0xASENSE_VENDOR_SPECIFIC0x9SENSE_BLANK_CHECKSENSE_DATA_PROTECTSENSE_UNIT_ATTENTIONSENSE_ILLEGAL_REQUESTSENSE_HARDWARE_ERRORSENSE_MEDIUM_ERRORSENSE_NOT_READYSENSE_RECOVERED_ERRORSENSE_NO_SENSES_SENSE(0x80)S_ILLEGALS_QUEUE_FULL(0x28)S_TERMINATED(0x20)S_CONFLICT(0x18)S_INT_COND_MET(0x14)S_INT(0x10)S_BUSY(0x08)S_COND_MET(0x04)S_CHECK_COND(0x02)S_GOOD(0x00)M_X_PPR_REQM_X_WIDE_REQ(0x03)M_X_SYNC_REQ(0x01)M_X_MODIFY_DPM_IDENTIFYM_IGN_RESIDUE(0x23)M_ORDERED_TAG(0x22)M_HEAD_TAG(0x21)M_SIMPLE_TAGM_TERMINATE(0x11)M_REL_RECM_INIT_REC(0x0f)M_CLEAR_QUEUE(0x0e)M_ABORT_TAG(0x0d)M_RESET(0x0c)M_FCOMPLETE(0x0b)M_LCOMPLETE(0x0a)M_PARITY(0x09)M_NOOPM_REJECT(0x07)M_ABORT(0x06)M_ID_ERROR(0x05)M_DISCONNECTM_RESTORE_DPM_SAVE_DPM_EXTENDEDM_COMPLETE_SCSI_HCONFIG_DM_SCSI/* _SCSI_H *//* unknown Interrupt number is stored in 16 LSB *//* unexpected disconnect *//* Phase error *//* Handshake *//* Selection time out *//* Hardware errors  *//* not used *//**
 * scsi_scan_dev() - scan a SCSI bus and create devices
 *
 * @dev:	SCSI bus
 * @verbose:	true to show information about each device found
 *//**
 * scsi_scan() - Scan all SCSI controllers for available devices
 *
 * @vebose: true to show information about each device found
 *//**
 * scsi_bus_reset() - reset the bus
 *
 * @dev:	SCSI bus to reset
 * @return 0 if OK, -ve on error
 *//**
 * scsi_exec() - execute a command
 *
 * @dev:	SCSI bus
 * @cmd:	Command to execute
 * @return 0 if OK, -ve on error
 *//**
	 * bus_reset() - reset the bus
	 *
	 * @dev:	SCSI bus to reset
	 * @return 0 if OK, -ve on error
	 *//**
	 * exec() - execute a command
	 *
	 * @dev:	SCSI bus
	 * @cmd:	Command to execute
	 * @return 0 if OK, -ve on error
	 *//* Operations for SCSI *//**
 * struct scsi_platdata - stores information about SCSI controller
 *
 * @base: Controller base address
 * @max_lun: Maximum number of logical units
 * @max_id: Maximum number of target ids
 *//* Write Same (O) *//* Write Long (O) *//* Write and Verify (O) *//* Write 10-Byte (MANDATORY) *//* Write 6-Byte (MANDATORY) *//* Verify (O) *//* Synchronize Cache (O) *//* Start/Stop Unit (O) *//* Set Limits (O) *//* Send Diagnostics (MANDATORY) *//* Seek 10-Byte (O) *//* Seek 6-Byte (O) *//* Search Data Low (O) *//* Search Data High (O) *//* Search Data Equal (O) *//* Rezero Unit (O) *//* Release Unit (MANDATORY) *//* Receive Diagnostic Results (O) *//* Reassign Blocks (O) *//* Read Long (O) *//* Read Defect Data (O) *//* Read Capacity (16) *//* Read Capacity (10) *//* Read Capacity (MANDATORY) *//* Read 10-byte (MANDATORY) *//* Read 6-byte (MANDATORY) *//* Prevent/Allow medium Removal (O) *//* Prefetch (O) *//* Lock Unlock Cache (O) *//* Format Unit (MANDATORY) *//* Compare (O) *//***************************************************************************
 *			  %%% Commands Unique to Direct Access Devices %%%
 ***************************************************************************//* Write Buffer (O) *//* Test Unit Ready (MANDATORY) *//* Send Diagnostic (O) *//* Request Sense (MANDATORY) *//* Read Buffer (O) *//* Mode Sense 10-byte (Device Specific) *//* Mode Sense 6-byte (Device Specific) *//* Mode Select 10-byte (Device Specific) *//* Mode Select 6-byte (Device Specific) *//* Log Sense (O) *//* Log Select (O) *//* Inquiry (MANDATORY) *//* Copy and Verify (O) *//* Copy (O) *//* Change Definition (Optional) *//*
 * Sense_keys
 *//*
**	Status
*//*
**	Messages
*//*-----------------------------------------------------------
**
**	SCSI  constants.
**
**-----------------------------------------------------------
*//* tranfered bytes		*//* Controller Status	*//* Sense command			*//* Sense data len			*//* Sense command len	*//* Message in buffer	*//* Messge out buffer (NOT USED) *//* pointer to data		*//* Total data length	*//* command len				*//* Target LUN        *//* Target ID				 *//* SCSI Status			 *//* for request sense *//* command				   *//*
 * (C) Copyright 2001
 * Denis Peter, MPL AG Switzerland
 */busdevfunc/opt/src/cmd/scsi.cdo_scsi
Reset SCSI
"\nReset SCSI\n"do_scsiboot"scsi"scsiboot"boot from SCSI device"boot from SCSI deviceU_BOOT_CMD(
	scsiboot, 3, 1, do_scsiboot,
	"boot from SCSI device",
	"loadAddr dev:part"
)_u_boot_list_2_cmd_2_scsiboot.u_boot_list_2_cmd_2_scsiboot"SCSI sub-system""reset - reset SCSI controller\n" "scsi info  - show available SCSI devices\n" "scsi scan  - (re-)scan SCSI bus\n" "scsi device [dev] - show or set current device\n" "scsi part [dev] - print partition table of one or all SCSI devices\n" "scsi read addr blk# cnt - read `cnt' blocks starting at block `blk#'\n" "     to memory address `addr'\n" "scsi write addr blk# cnt - write `cnt' blocks starting at block\n" "     `blk#' from memory address `addr'"SCSI sub-systemreset - reset SCSI controller
scsi info  - show available SCSI devices
scsi scan  - (re-)scan SCSI bus
scsi device [dev] - show or set current device
scsi part [dev] - print partition table of one or all SCSI devices
scsi read addr blk# cnt - read `cnt' blocks starting at block `blk#'
     to memory address `addr'
scsi write addr blk# cnt - write `cnt' blocks starting at block
     `blk#' from memory address `addr'"reset - reset SCSI controller\n"
	"scsi info  - show available SCSI devices\n"
	"scsi scan  - (re-)scan SCSI bus\n"
	"scsi device [dev] - show or set current device\n"
	"scsi part [dev] - print partition table of one or all SCSI devices\n"
	"scsi read addr blk# cnt - read `cnt' blocks starting at block `blk#'\n"
	"     to memory address `addr'\n"
	"scsi write addr blk# cnt - write `cnt' blocks starting at block\n"
	"     `blk#' from memory address `addr'"char[419]U_BOOT_CMD(
	scsi, 5, 1, do_scsi,
	"SCSI sub-system",
	"reset - reset SCSI controller\n"
	"scsi info  - show available SCSI devices\n"
	"scsi scan  - (re-)scan SCSI bus\n"
	"scsi device [dev] - show or set current device\n"
	"scsi part [dev] - print partition table of one or all SCSI devices\n"
	"scsi read addr blk# cnt - read `cnt' blocks starting at block `blk#'\n"
	"     to memory address `addr'\n"
	"scsi write addr blk# cnt - write `cnt' blocks starting at block\n"
	"     `blk#' from memory address `addr'"
)_u_boot_list_2_cmd_2_scsi.u_boot_list_2_cmd_2_scsiscsi_curr_dev/*
 * scsi command intepreter
 *//*
 * scsi boot command intepreter. Derived from diskboot
 *//* current device *//*
 * SCSI support.
 */<scsi.h>/opt/src/include/slre.hslreslre_matchconst slreconst slre *slre *cap *slre_compileerr_stranchorednum_capscode_sizeunsigned char[256]SLRE_HEADER_DEFINEDSLRE_TEST/* SLRE_HEADER_DEFINED *//* SLRE_TEST *//*
 * Return 1 if match, 0 if no match.
 * If `captured_substrings' array is not NULL, then it is filled with the
 * values of captured substrings. captured_substrings[0] element is always
 * a full matched substring. The round bracket captures start from
 * captured_substrings[1].
 * It is assumed that the size of captured_substrings array is enough to
 * hold all captures. The caller function must make sure it is! So, the
 * array_size = number_of_round_bracket_pairs + 1
 *//*
 * Compile regular expression. If success, 1 is returned.
 * If error, 0 is returned and slre.err_str points to the error message.
 *//* Substring length		*//* Pointer to the substring	*//*
 * Captured substring
 *//* Error string			*//* Must match from string start	*//* Number of bracket pairs	*//*
 * Compiled regular expression
 *//*
 * This is a regular expression library that implements a subset of Perl RE.
 * Please refer to http://slre.sourceforge.net for detailed description.
 *
 * Usage example (parsing HTTP request):
 *
 * struct slre	slre;
 * struct cap	captures[4 + 1];  // Number of braket pairs + 1
 * ...
 *
 * slre_compile(&slre,"^(GET|POST) (\S+) HTTP/(\S+?)\r\n");
 *
 * if (slre_match(&slre, buf, len, captures)) {
 *	printf("Request line length: %d\n", captures[0].len);
 *	printf("Method: %.*s\n", captures[1].len, captures[1].ptr);
 *	printf("URI: %.*s\n", captures[2].len, captures[2].ptr);
 * }
 *
 * Supported syntax:
 *	^		Match beginning of a buffer
 *	$		Match end of a buffer
 *	()		Grouping and substring capturing
 *	[...]		Match any character from set
 *	[^...]		Match any character but ones from set
 *	\s		Match whitespace
 *	\S		Match non-whitespace
 *	\d		Match decimal digit
 *	\r		Match carriage return
 *	\n		Match newline
 *	+		Match one or more times (greedy)
 *	+?		Match one or more times (non-greedy)
 *	*		Match zero or more times (greedy)
 *	*?		Match zero or more times (non-greedy)
 *	?		Match zero or once
 *	\xDD		Match byte with hex value 0xDD
 *	\meta		Match one of the meta character: ^$().[*+?\
 *//*
 * Downloaded Sat Nov  5 17:42:08 CET 2011 at
 * http://slre.sourceforge.net/1.0/slre.h
 *//*
 * Copyright (c) 2004-2005 Sergey Lyubka <valenok@gmail.com>
 * All rights reserved
 *
 * "THE BEER-WARE LICENSE" (Revision 42):
 * Sergey Lyubka wrote this file.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy me a beer in return.
 */buf_lencaptured_substrings/opt/src/cmd/setexpr.csetexprdo_setexprgsub"gsub"sub"sub"'&''+''^''%'invalid op
"invalid op\n"regex_subError compiling regex: %s
"Error compiling regex: %s\n"## Error: variable "%s" not defined
"## Error: variable \"%s\" not defined\n""REGEX on %s=%s\n"name, tdebug("REGEX on %s=%s\n", name, t)cmd/setexpr.cconst char[10]REGEX on %s=%s
"REGEX=\"%s\", SUBST=\"%s\", GLOBAL=%d\n"r, s ? s : "<NULL>", globaldebug("REGEX=\"%s\", SUBST=\"%s\", GLOBAL=%d\n",
		r, s ? s : "<NULL>", global)REGEX="%s", SUBST="%s", GLOBAL=%d
<NULL>"<NULL>"SLRE_BUFSZ<slre.h>global## error: subst buffer overflow: have %d, need %d
"## error: subst buffer overflow: have %d, need %d\n"char[16384]nlencap[]char[4096]SLRE_PATSZnbuf"Result: %d\n"debug("Result: %d\n", res)Result: %d
"Substring %d: [%.*s]\n"i, caps[i].len, caps[i].ptrdebug("Substring %d: [%.*s]\n", i,
					caps[i].len, caps[i].ptr)Substring %d: [%.*s]
%s: No match
"%s: No match\n""## MATCH ## %s\n"debug("## MATCH ## %s\n", data)## MATCH ## %s
## error: pattern buffer overflow: have %d, need %d
"## error: pattern buffer overflow: have %d, need %d\n""## SUBST(1) ## %s\n"debug("## SUBST(1) ## %s\n", nbuf)## SUBST(1) ## %s
backref"## BACKREF %d: replace \"%.*s\" by \"%.*s\" in \"%s\"\n"i, 2, backref, caps[i].len, caps[i].ptr, nbufdebug("## BACKREF %d: replace \"%.*s\" by \"%.*s\" in \"%s\"\n",
				i,
				2, backref,
				caps[i].len, caps[i].ptr,
				nbuf)## BACKREF %d: replace "%.*s" by "%.*s" in "%s"
"## SUBST(2) ## %s\n"debug("## SUBST(2) ## %s\n", nbuf)## SUBST(2) ## %s
"## REMAINDER: %s\n"debug("## REMAINDER: %s\n", datap)## REMAINDER: %s
"## RESULT: %s\n"debug("## RESULT: %s\n", data)## RESULT: %s
"## FINAL (now env_set()) :  %s\n"debug("## FINAL (now env_set()) :  %s\n", data)## FINAL (now env_set()) :  %s
substitute"## Match at pos %ld: match len %d, subst len %d\n"(long)(p - string), olen, nlendebug("## Match at pos %ld: match len %d, subst len %d\n",
		(long)(p - string), olen, nlen)## Match at pos %ld: match len %d, subst len %d
## error: substitution buffer overflow
"## error: substitution buffer overflow\n"tail"## tail len %d\n"debug("## tail len %d\n", tail)## tail len %d
slenssizememstrget_argsizeof(uchar)sizeof(ushort)"set environment variable as the result of eval expression""[.b, .w, .l] name [*]value1 <op> [*]value2\n" "    - set environment variable 'name' to the result of the evaluated\n" "      expression specified by <op>.  <op> can be &, |, ^, +, -, *, /, %\n" "      size argument is only meaningful if value1 and/or value2 are\n" "      memory addresses (*)\n" "setexpr[.b, .w, .l] name [*]value\n" "    - load a value into a variable" "\n" "setexpr name gsub r s [t]\n" "    - For each substring matching the regular expression <r> in the\n" "      string <t>, substitute the string <s>.  The result is\n" "      assigned to <name>.  If <t> is not supplied, use the old\n" "      value of <name>\n" "setexpr name sub r s [t]\n" "    - Just like gsub(), but replace only the first matching substring"set environment variable as the result of eval expression[.b, .w, .l] name [*]value1 <op> [*]value2
    - set environment variable 'name' to the result of the evaluated
      expression specified by <op>.  <op> can be &, |, ^, +, -, *, /, %
      size argument is only meaningful if value1 and/or value2 are
      memory addresses (*)
setexpr[.b, .w, .l] name [*]value
    - load a value into a variable
setexpr name gsub r s [t]
    - For each substring matching the regular expression <r> in the
      string <t>, substitute the string <s>.  The result is
      assigned to <name>.  If <t> is not supplied, use the old
      value of <name>
setexpr name sub r s [t]
    - Just like gsub(), but replace only the first matching substring"[.b, .w, .l] name [*]value1 <op> [*]value2\n"
	"    - set environment variable 'name' to the result of the evaluated\n"
	"      expression specified by <op>.  <op> can be &, |, ^, +, -, *, /, %\n"
	"      size argument is only meaningful if value1 and/or value2 are\n"
	"      memory addresses (*)\n"
	"setexpr[.b, .w, .l] name [*]value\n"
	"    - load a value into a variable"
#ifdef CONFIG_REGEX
	"\n"
	"setexpr name gsub r s [t]\n"
	"    - For each substring matching the regular expression <r> in the\n"
	"      string <t>, substitute the string <s>.  The result is\n"
	"      assigned to <name>.  If <t> is not supplied, use the old\n"
	"      value of <name>\n"
	"setexpr name sub r s [t]\n"
	"    - Just like gsub(), but replace only the first matching substring"char[681]U_BOOT_CMD(
	setexpr, 6, 0, do_setexpr,
	"set environment variable as the result of eval expression",
	"[.b, .w, .l] name [*]value1 <op> [*]value2\n"
	"    - set environment variable 'name' to the result of the evaluated\n"
	"      expression specified by <op>.  <op> can be &, |, ^, +, -, *, /, %\n"
	"      size argument is only meaningful if value1 and/or value2 are\n"
	"      memory addresses (*)\n"
	"setexpr[.b, .w, .l] name [*]value\n"
	"    - load a value into a variable"
#ifdef CONFIG_REGEX
	"\n"
	"setexpr name gsub r s [t]\n"
	"    - For each substring matching the regular expression <r> in the\n"
	"      string <t>, substitute the string <s>.  The result is\n"
	"      assigned to <name>.  If <t> is not supplied, use the old\n"
	"      value of <name>\n"
	"setexpr name sub r s [t]\n"
	"    - Just like gsub(), but replace only the first matching substring"
#endif
)_u_boot_list_2_cmd_2_setexpr.u_boot_list_2_cmd_2_setexpr/* standard operators: "setexpr name val1 op val2" *//*
	 * rexep handling: "setexpr name [g]sub r s [t]"
	 * with 5 args, "t" will be NULL
	 *//* 5 or 6 args (6 args only with [g]sub) *//* plain assignment: "setexpr name value" *//* > 6 already tested by max command args *//*
	 * We take 3, 5, or 6 arguments:
	 * 3 : setexpr name value
	 * 5 : setexpr name val1 op val2
	 *     setexpr name [g]sub r s
	 * 6 : setexpr name [g]sub r s t
	 *//*
		 * Handle back references
		 *
		 * Support for \0 ... \9, where \0 is the
		 * whole matched pattern (similar to &).
		 *
		 * Implementation is a bit simpleminded as
		 * backrefs are substituted sequentially, one
		 * by one.  This will lead to somewhat
		 * unexpected results if the replacement
		 * strings contain any \N strings then then
		 * may get substitued, too.  We accept this
		 * restriction for the sake of simplicity.
		 *//*
 * Perform regex operations on a environment variable
 *
 * Returns 0 if OK, 1 in case of errors.
 *//* insert substitue *//* move tail if needed *//* make sure replacement matches *//* length of new string *//* new (replacement) string *//* length of old string *//* old (replaced) string *//* string bufer size *//* current string length *//* string buffer *//*
 * memstr - Find the first substring in memory
 * @s1: The string to be searched
 * @s2: The string to search for
 *
 * Similar to and based on strstr(),
 * but strings do not need to be NUL terminated.
 *//*
	 * If the parameter starts with a '*' then assume it is a pointer to
	 * the value we want.
	 *//*
 * This file provides a shell like 'expr' function to return.
 *//*
 * Copyright 2008 Freescale Semiconductor, Inc.
 * Copyright 2013 Wolfgang Denk <wd@denx.de>
 */l1l2/opt/src/include/spi.hdm_spi_xferdm_spi_release_busdm_spi_claim_bussandbox_spi_get_emulspi_cs_infospi_cs_info *spi_slave_ofdata_to_platdatadm_spi_slave_platdata *spi_find_chip_selectspi_chip_selectspi_get_bus_and_csspi_slave **spi_find_bus_and_csspi_w8r8SPI_XFER_BEGINSPI_XFER_ENDSPI_XFER_BEGIN | SPI_XFER_ENDspi_cs_is_validspi_flash_copy_mmapspi_set_wordlenspi_do_alloc_slavedm_spi_emul_opsdm_spi_opsspi_controller_mem_opsdm_spi_slave_platdatadm_spi_buscs_infoset_speedconst spi_controller_mem_opsconst spi_controller_mem_ops *spi_controller_mem_ops *mem_opsset_wordlenrelease_busclaim_busmax_write_sizemax_read_sizewordlenmax_hzspi_emul_get_ops(dev)((struct dm_spi_emul_ops *)(dev)->driver->ops)spi_get_ops(dev)((struct dm_spi_ops *)(dev)->driver->ops)spi_alloc_slave_base(bus,cs)spi_do_alloc_slave(0, sizeof(struct spi_slave), bus, cs)spi_alloc_slave(_struct,bus,cs)spi_do_alloc_slave(offsetof(_struct, slave), sizeof(_struct), bus, cs)SPI_XFER_MMAP_ENDBIT(3)SPI_XFER_MMAPSPI_XFER_ONCE(SPI_XFER_BEGIN | SPI_XFER_END)SPI_DEFAULT_WORDLENSPI_PREAMBLE_END_BYTESPI_RX_QUADBIT(13)SPI_RX_DUALBIT(12)SPI_RX_SLOWBIT(11)SPI_TX_QUADBIT(10)SPI_TX_DUALBIT(9)SPI_TX_BYTEBIT(8)SPI_PREAMBLESPI_SLAVESPI_LOOPSPI_3WIRESPI_LSB_FIRSTSPI_CS_HIGHSPI_MODE_3(SPI_CPOL|SPI_CPHA)SPI_MODE_2(SPI_CPOL|0)SPI_MODE_1(0|SPI_CPHA)SPI_MODE_0(0|0)SPI_CPOLSPI_CPHA_SPI_H_CONFIG_DM_SPI/* _SPI_H_ *//* CONFIG_DM_SPI *//* Access the operations for a SPI device *//**
 * SPI transfer
 *
 * This writes "bitlen" bits out the SPI MOSI port and simultaneously clocks
 * "bitlen" bits in the SPI MISO port.  That's just the way SPI works.
 *
 * The source of the outgoing bits is the "dout" parameter and the
 * destination of the input bits is the "din" parameter.  Note that "dout"
 * and "din" can point to the same memory location, in which case the
 * input data overwrites the output data (since both are buffered by
 * temporary variables, this is OK).
 *
 * dm_spi_xfer() interface:
 * @dev:	The SPI slave device which will be sending/receiving the data.
 * @bitlen:	How many bits to write and read.
 * @dout:	Pointer to a string of bits to send out.  The bits are
 *		held in a byte array and are sent MSB first.
 * @din:	Pointer to a string of bits that will be filled in.
 * @flags:	A bitwise combination of SPI_XFER_* flags.
 *
 * Returns: 0 on success, not 0 on failure
 *//**
 * Release the SPI bus
 *
 * This must be called once for every call to dm_spi_claim_bus() after
 * all transfers have finished. It may disable any SPI hardware as
 * appropriate.
 *
 * @slave:	The SPI slave device
 *//**
 * Claim the bus and prepare it for communication with a given slave.
 *
 * This must be called before doing any transfers with a SPI slave. It
 * will enable and initialize any SPI hardware as necessary, and make
 * sure that the SCK line is in the correct idle state. It is not
 * allowed to claim the same bus for several slaves without releasing
 * the bus in between.
 *
 * @dev:	The SPI slave device
 *
 * Returns: 0 if the bus was claimed successfully, or a negative value
 * if it wasn't.
 *//**
 * sandbox_spi_get_emul() - get an emulator for a SPI slave
 *
 * This provides a way to attach an emulated SPI device to a particular SPI
 * slave, so that xfer() operations on the slave will be handled by the
 * emulator. If a emulator already exists on that chip select it is returned.
 * Otherwise one is created.
 *
 * @state:	Sandbox state
 * @bus:	SPI bus requesting the emulator
 * @slave:	SPI slave device requesting the emulator
 * @emuip:	Returns pointer to emulator
 * @return 0 if OK, -ve on error
 *//**
 * spi_cs_info() - Check information on a chip select
 *
 * This checks a particular chip select on a bus to see if it has a device
 * attached, or is even valid.
 *
 * @bus:	The SPI bus
 * @cs:		The chip select (0..n-1)
 * @info:	Returns information about the chip select, if valid
 * @return 0 if OK (and @info is set up), -ENODEV if the chip select
 *	   is invalid, other -ve value on error
 *//**
 * spi_slave_ofdata_to_platdata() - decode standard SPI platform data
 *
 * This decodes the speed and mode for a slave from a device tree node
 *
 * @blob:	Device tree blob
 * @node:	Node offset to read from
 * @plat:	Place to put the decoded information
 *//**
 * spi_find_chip_select() - Find the slave attached to chip select
 *
 * @bus:	SPI bus to search
 * @cs:		Chip select to look for
 * @devp:	Returns the slave device if found
 * @return 0 if found, -ENODEV on error
 *//**
 * spi_chip_select() - Get the chip select for a slave
 *
 * @return the chip select this slave is attached to
 *//**
 * spi_get_bus_and_cs() - Find and activate bus and slave devices by number
 *
 * Given a bus number and chip select, this finds the corresponding bus
 * device and slave device.
 *
 * If no such slave exists, and drv_name is not NULL, then a new slave device
 * is automatically bound on this chip select with requested speed and mode.
 *
 * Ths new slave device is probed ready for use with the speed and mode
 * from platdata when available or the requested values.
 *
 * @busnum:	SPI bus number
 * @cs:		Chip select to look for
 * @speed:	SPI speed to use for this slave when not available in platdata
 * @mode:	SPI mode to use for this slave when not available in platdata
 * @drv_name:	Name of driver to attach to this chip select
 * @dev_name:	Name of the new device thus created
 * @busp:	Returns bus device
 * @devp:	Return slave device
 * @return 0 if found, -ve on error
 *//**
 * spi_find_bus_and_cs() - Find bus and slave devices by number
 *
 * Given a bus number and chip select, this finds the corresponding bus
 * device and slave device. Neither device is activated by this function,
 * although they may have been activated previously.
 *
 * @busnum:	SPI bus number
 * @cs:		Chip select to look for
 * @busp:	Returns bus device
 * @devp:	Return slave device
 * @return 0 if found, -ENODEV on error
 *//**
	 * SPI transfer
	 *
	 * This writes "bitlen" bits out the SPI MOSI port and simultaneously
	 * clocks "bitlen" bits in the SPI MISO port.  That's just the way SPI
	 * works. Here the device is a slave.
	 *
	 * The source of the outgoing bits is the "dout" parameter and the
	 * destination of the input bits is the "din" parameter.  Note that
	 * "dout" and "din" can point to the same memory location, in which
	 * case the input data overwrites the output data (since both are
	 * buffered by temporary variables, this is OK).
	 *
	 * spi_xfer() interface:
	 * @slave:	The SPI slave which will be sending/receiving the data.
	 * @bitlen:	How many bits to write and read.
	 * @dout:	Pointer to a string of bits sent to the device. The
	 *		bits are held in a byte array and are sent MSB first.
	 * @din:	Pointer to a string of bits that will be sent back to
	 *		the master.
	 * @flags:	A bitwise combination of SPI_XFER_* flags.
	 *
	 * Returns: 0 on success, not -1 on failure
	 *//**
	 * Get information on a chip select
	 *
	 * This is only called when the SPI uclass does not know about a
	 * chip select, i.e. it has no attached device. It gives the driver
	 * a chance to allow activity on that chip select even so.
	 *
	 * @bus:	The SPI bus
	 * @cs:		The chip select (0..n-1)
	 * @info:	Returns information about the chip select, if valid.
	 *		On entry info->dev is NULL
	 * @return 0 if OK (and @info is set up), -ENODEV if the chip select
	 *	   is invalid, other -ve value on error
	 *//**
	 * Set the SPI mode/flags
	 *
	 * It is unclear if we want to set speed and mode together instead
	 * of separately.
	 *
	 * @bus:	The SPI bus
	 * @mode:	Requested SPI mode (SPI_... flags)
	 * @return 0 if OK, -ve on error
	 *//**
	 * Set transfer speed.
	 * This sets a new speed to be applied for next spi_xfer().
	 * @bus:	The SPI bus
	 * @hz:		The transfer speed
	 * @return 0 if OK, -ve on error
	 *//**
	 * Optimized handlers for SPI memory-like operations.
	 *
	 * Optimized/dedicated operations for interactions with SPI memory. This
	 * field is optional and should only be implemented if the controller
	 * has native support for memory like operations.
	 *//**
	 * SPI transfer
	 *
	 * This writes "bitlen" bits out the SPI MOSI port and simultaneously
	 * clocks "bitlen" bits in the SPI MISO port.  That's just the way SPI
	 * works.
	 *
	 * The source of the outgoing bits is the "dout" parameter and the
	 * destination of the input bits is the "din" parameter.  Note that
	 * "dout" and "din" can point to the same memory location, in which
	 * case the input data overwrites the output data (since both are
	 * buffered by temporary variables, this is OK).
	 *
	 * spi_xfer() interface:
	 * @dev:	The slave device to communicate with
	 * @bitlen:	How many bits to write and read.
	 * @dout:	Pointer to a string of bits to send out.  The bits are
	 *		held in a byte array and are sent MSB first.
	 * @din:	Pointer to a string of bits that will be filled in.
	 * @flags:	A bitwise combination of SPI_XFER_* flags.
	 *
	 * Returns: 0 on success, not -1 on failure
	 *//**
	 * Set the word length for SPI transactions
	 *
	 * Set the word length (number of bits per word) for SPI transactions.
	 *
	 * @bus:	The SPI slave
	 * @wordlen:	The number of bits in a word
	 *
	 * Returns: 0 on success, -ve on failure.
	 *//**
	 * Release the SPI bus
	 *
	 * This must be called once for every call to spi_claim_bus() after
	 * all transfers have finished. It may disable any SPI hardware as
	 * appropriate.
	 *
	 * @dev:	The SPI slave
	 *//**
	 * Claim the bus and prepare it for communication.
	 *
	 * The device provided is the slave device. It's parent controller
	 * will be used to provide the communication.
	 *
	 * This must be called before doing any transfers with a SPI slave. It
	 * will enable and initialize any SPI hardware as necessary, and make
	 * sure that the SCK line is in the correct idle state. It is not
	 * allowed to claim the same bus for several slaves without releasing
	 * the bus in between.
	 *
	 * @dev:	The SPI slave
	 *
	 * Returns: 0 if the bus was claimed successfully, or a negative value
	 * if it wasn't.
	 *//**
 * struct struct dm_spi_ops - Driver model SPI operations
 *
 * The uclass interface is implemented by all SPI devices which use
 * driver model.
 *//**
 * struct spi_cs_info - Information about a bus chip select
 *
 * @dev:	Connected device, or NULL if none
 *//**
 * Write 8 bits, then read 8 bits.
 * @slave:	The SPI slave we're communicating with
 * @byte:	Byte to be written
 *
 * Returns: The value that was read, or a negative value on error.
 *
 * TODO: This function probably shouldn't be inlined.
 *//**
 * Set transfer speed.
 * This sets a new speed to be applied for next spi_xfer().
 * @slave:	The SPI slave
 * @hz:		The transfer speed
 *//**
 * Deactivate a SPI chipselect.
 * This function is provided by the board code when using a driver
 * that can't control its chipselects automatically (e.g.
 * common/soft_spi.c). When called, it should deactivate the chip
 * select to the device identified by "slave".
 *//**
 * Activate a SPI chipselect.
 * This function is provided by the board code when using a driver
 * that can't control its chipselects automatically (e.g.
 * common/soft_spi.c). When called, it should activate the chip select
 * to the device identified by "slave".
 *//**
 * Determine if a SPI chipselect is valid.
 * This function is provided by the board if the low-level SPI driver
 * needs it to determine if a given chipselect is actually valid.
 *
 * Returns: 1 if bus:cs identifies a valid chip on this board, 0
 * otherwise.
 *//* Copy memory mapped data *//**
 * SPI transfer
 *
 * This writes "bitlen" bits out the SPI MOSI port and simultaneously clocks
 * "bitlen" bits in the SPI MISO port.  That's just the way SPI works.
 *
 * The source of the outgoing bits is the "dout" parameter and the
 * destination of the input bits is the "din" parameter.  Note that "dout"
 * and "din" can point to the same memory location, in which case the
 * input data overwrites the output data (since both are buffered by
 * temporary variables, this is OK).
 *
 * spi_xfer() interface:
 * @slave:	The SPI slave which will be sending/receiving the data.
 * @bitlen:	How many bits to write and read.
 * @dout:	Pointer to a string of bits to send out.  The bits are
 *		held in a byte array and are sent MSB first.
 * @din:	Pointer to a string of bits that will be filled in.
 * @flags:	A bitwise combination of SPI_XFER_* flags.
 *
 * Returns: 0 on success, not 0 on failure
 *//**
 * Set the word length for SPI transactions
 *
 * Set the word length (number of bits per word) for SPI transactions.
 *
 * @slave:	The SPI slave
 * @wordlen:	The number of bits in a word
 *
 * Returns: 0 on success, -1 on failure.
 *//**
 * Release the SPI bus
 *
 * This must be called once for every call to spi_claim_bus() after
 * all transfers have finished. It may disable any SPI hardware as
 * appropriate.
 *
 * @slave:	The SPI slave
 *//**
 * Claim the bus and prepare it for communication with a given slave.
 *
 * This must be called before doing any transfers with a SPI slave. It
 * will enable and initialize any SPI hardware as necessary, and make
 * sure that the SCK line is in the correct idle state. It is not
 * allowed to claim the same bus for several slaves without releasing
 * the bus in between.
 *
 * @slave:	The SPI slave
 *
 * Returns: 0 if the bus was claimed successfully, or a negative value
 * if it wasn't.
 *//**
 * Free any memory associated with a SPI slave.
 *
 * @slave:	The SPI slave
 *//**
 * Set up communications parameters for a SPI slave.
 *
 * This must be called once for each slave. Note that this function
 * usually doesn't touch any actual hardware, it only initializes the
 * contents of spi_slave so that the hardware can be easily
 * initialized later.
 *
 * @bus:	Bus ID of the slave chip.
 * @cs:		Chip select ID of the slave chip on the specified bus.
 * @max_hz:	Maximum SCK rate in Hz.
 * @mode:	Clock polarity, clock phase and other parameters.
 *
 * Returns: A spi_slave reference that can be used in subsequent SPI
 * calls, or NULL if one or more of the parameters are not supported.
 *//**
 * spi_alloc_slave_base - Allocate a new SPI slave with no private data
 *
 * Allocate and zero all fields in the spi slave, and set the bus/chip
 * select.
 *
 * @bus:	Bus ID of the slave chip.
 * @cs:		Chip select ID of the slave chip on the specified bus.
 *//**
 * spi_alloc_slave - Allocate a new SPI slave
 *
 * Allocate and zero all fields in the spi slave, and set the bus/chip
 * select.
 *
 * @_struct:	Name of structure to allocate (e.g. struct tegra_spi).
 *		This structure must contain a member 'struct spi_slave *slave'.
 * @bus:	Bus ID of the slave chip.
 * @cs:		Chip select ID of the slave chip on the specified bus.
 *//**
 * spi_do_alloc_slave - Allocate a new SPI slave (internal)
 *
 * Allocate and zero all fields in the spi slave, and set the bus/chip
 * select. Use the helper macro spi_alloc_slave() to call this.
 *
 * @offset:	Offset of struct spi_slave within slave structure.
 * @size:	Size of slave structure.
 * @bus:	Bus ID of the slave chip.
 * @cs:		Chip select ID of the slave chip on the specified bus.
 *//* Memory Mapped End *//* Memory Mapped start *//* Deassert CS after transfer *//* Assert CS before transfer *//* struct spi_slave is dev->parentdata *//**
 * struct spi_slave - Representation of a SPI slave
 *
 * For driver model this is the per-child data used by the SPI bus. It can
 * be accessed using dev_get_parent_priv() on the slave device. The SPI uclass
 * sets uip per_child_auto_alloc_size to sizeof(struct spi_slave), and the
 * driver should not override it. Two platform data fields (max_hz and mode)
 * are copied into this structure to provide an initial value. This allows
 * them to be changed, since we should never change platform data in drivers.
 *
 * If not using driver model, drivers are expected to extend this with
 * controller-specific data.
 *
 * @dev:		SPI slave device
 * @max_hz:		Maximum speed for this slave
 * @speed:		Current bus speed. This is 0 until the bus is first
 *			claimed.
 * @bus:		ID of the bus that the slave is attached to. For
 *			driver model this is the sequence number of the SPI
 *			bus (bus->seq) so does not need to be stored
 * @cs:			ID of the chip select connected to the slave.
 * @mode:		SPI mode to use for this slave (see SPI mode flags)
 * @wordlen:		Size of SPI word in number of bits
 * @max_read_size:	If non-zero, the maximum number of bytes which can
 *			be read at once.
 * @max_write_size:	If non-zero, the maximum number of bytes which can
 *			be written at once.
 * @memory_map:		Address of read-only SPI flash access.
 * @flags:		Indication of SPI flags.
 *//**
 * struct dm_spi_platdata - platform data for all SPI slaves
 *
 * This describes a SPI slave, a child device of the SPI bus. To obtain this
 * struct from a spi_slave, use dev_get_parent_platdata(dev) or
 * dev_get_parent_platdata(slave->dev).
 *
 * This data is immuatable. Each time the device is probed, @max_hz and @mode
 * will be copied to struct spi_slave.
 *
 * @cs:		Chip select number (0..n-1)
 * @max_hz:	Maximum bus speed that this slave can tolerate
 * @mode:	SPI mode to use for this device (see SPI mode flags)
 *//* TODO(sjg@chromium.org): Remove this and use max_hz from struct spi_slave *//* Header byte that marks the start of the message *//* receive with 4 wires *//* receive with 2 wires *//* receive with 1 wire slow *//* transmit with 4 wires *//* transmit with 2 wires *//* transmit with 1 wire byte *//* Skip preamble bytes *//* slave mode *//* loopback mode *//* SI/SO signals shared *//* per-word bits-on-wire *//* CS active high *//* (original MicroWire) *//* clock polarity *//* clock phase *//* SPI mode flags *//*
 * Common SPI Interface: Controller-specific definitions
 *
 * (C) Copyright 2001
 * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com.
 */slavebitlen/opt/src/include/linux/mtd/cfi.hcfiCFI_MFR_WINBOND0x00DACFI_MFR_TOSHIBACFI_MFR_MICRONCFI_MFR_STCFI_MFR_SST0x00BFCFI_MFR_SHARPCFI_MFR_SAMSUNG0x00ECCFI_MFR_PMCCFI_MFR_NECCFI_MFR_MACRONIX0x00C2CFI_MFR_INTELCFI_MFR_HYUNDAI0x00ADCFI_MFR_FUJITSUCFI_MFR_EONCFI_MFR_ATMEL0x001FCFI_MFR_AMIC0x0037CFI_MFR_AMDCFI_MFR_CONTINUATION0x007FCFI_ID_ANYCFI_MFR_ANY__MTD_CFI_H__/* __MTD_CFI_H__ *//* Micron *//* STMicroelectronics *//*
 * Copyright  2000-2010 David Woodhouse <dwmw2@infradead.org> et al.
 *
 *//opt/src/include/linux/mtd/spi-nor.hspi-norspi_nor_scanspi_nor *spi_nor_get_flash_nodespi_nor_set_flash_nodespi_nor_get_protocol_widthspi_nor_get_protocol_data_nbitsSNOR_PROTO_DATA_MASKSNOR_PROTO_DATA_SHIFTspi_nor_get_protocol_addr_nbitsSNOR_PROTO_ADDR_MASK18446744073709551360SNOR_PROTO_ADDR_SHIFTspi_nor_get_protocol_inst_nbitsSNOR_PROTO_INST_MASK1844674407370948608016777215SNOR_PROTO_INST_SHIFTspi_nor_protocol_is_dtrSNOR_PROTO_IS_DTRspi_nor_hwcapsspi_norflash_infospi_nor_option_flagsSNOR_F_USE_FSRSNOR_F_HAS_SR_TBSNOR_F_NO_OP_CHIP_ERASESNOR_F_S3AN_ADDR_DEFAULTSNOR_F_READY_XSR_RDYSNOR_F_USE_CLSRSNOR_F_BROKEN_RESETspi_nor_opsSPI_NOR_OPS_READSPI_NOR_OPS_WRITESPI_NOR_OPS_ERASESPI_NOR_OPS_LOCKSPI_NOR_OPS_UNLOCKspi_nor_protocolSNOR_PROTO_1_1_1SNOR_PROTO_STR(1, 1, 1)6579265793SNOR_PROTO_1_1_2SNOR_PROTO_STR(1, 1, 2)<linux/mtd/cfi.h>65794SNOR_PROTO_1_1_4SNOR_PROTO_STR(1, 1, 4)65796SNOR_PROTO_1_1_8SNOR_PROTO_STR(1, 1, 8)65800SNOR_PROTO_1_2_2SNOR_PROTO_STR(1, 2, 2)6604866050SNOR_PROTO_1_4_4SNOR_PROTO_STR(1, 4, 4)6656066564SNOR_PROTO_1_8_8SNOR_PROTO_STR(1, 8, 8)6758467592SNOR_PROTO_2_2_2SNOR_PROTO_STR(2, 2, 2)131584131586SNOR_PROTO_4_4_4SNOR_PROTO_STR(4, 4, 4)263168263172SNOR_PROTO_8_8_8SNOR_PROTO_STR(8, 8, 8)526336526344SNOR_PROTO_1_1_1_DTRSNOR_PROTO_DTR(1, 1, 1)16843009SNOR_PROTO_1_2_2_DTRSNOR_PROTO_DTR(1, 2, 2)16843266SNOR_PROTO_1_4_4_DTRSNOR_PROTO_DTR(1, 4, 4)16843780SNOR_PROTO_1_8_8_DTRSNOR_PROTO_DTR(1, 8, 8)16844808erase_sizequad_enableflash_is_lockedflash_unlockflash_lockwrite_regread_regunprepareprepareSPI_NOR_MAX_CMD_SIZEcmd_bufsst_write_secondreg_protowrite_protoread_protoprogram_opcoderead_dummyread_opcodeerase_opcodeaddr_widthconst flash_infoconst flash_info *flash_info *SNOR_HWCAPS_PP_8_8_8BIT(22)SNOR_HWCAPS_PP_1_8_8BIT(21)SNOR_HWCAPS_PP_1_1_8BIT(20)SNOR_HWCAPS_PP_OCTOGENMASK(22, 20)SNOR_HWCAPS_PP_4_4_4BIT(19)SNOR_HWCAPS_PP_1_4_4BIT(18)SNOR_HWCAPS_PP_1_1_4BIT(17)SNOR_HWCAPS_PP_QUADGENMASK(19, 17)SNOR_HWCAPS_PPSNOR_HWCAPS_PP_MASKGENMASK(22, 16)SNOR_HWCAPS_READ_1_8_8_DTRSNOR_HWCAPS_READ_8_8_8SNOR_HWCAPS_READ_1_8_8SNOR_HWCAPS_READ_1_1_8SNOR_HWCPAS_READ_OCTOGENMASK(14, 11)SNOR_HWCAPS_READ_1_4_4_DTRSNOR_HWCAPS_READ_4_4_4SNOR_HWCAPS_READ_1_4_4SNOR_HWCAPS_READ_1_1_4SNOR_HWCAPS_READ_QUADGENMASK(10, 7)SNOR_HWCAPS_READ_1_2_2_DTRSNOR_HWCAPS_READ_2_2_2SNOR_HWCAPS_READ_1_2_2SNOR_HWCAPS_READ_1_1_2SNOR_HWCAPS_READ_DUALGENMASK(6, 3)SNOR_HWCAPS_READ_1_1_1_DTRSNOR_HWCAPS_READ_FASTSNOR_HWCAPS_READSNOR_HWCAPS_READ_MASKGENMASK(14, 0)spi_flashSNOR_PROTO_DTR(_inst_nbits,_addr_nbits,_data_nbits)(SNOR_PROTO_IS_DTR | SNOR_PROTO_STR(_inst_nbits, _addr_nbits, _data_nbits))SNOR_PROTO_STR(_inst_nbits,_addr_nbits,_data_nbits)(SNOR_PROTO_INST(_inst_nbits) | SNOR_PROTO_ADDR(_addr_nbits) | SNOR_PROTO_DATA(_data_nbits))BIT(24)SNOR_PROTO_DATA(_nbits)((((unsigned long)(_nbits)) << SNOR_PROTO_DATA_SHIFT) & SNOR_PROTO_DATA_MASK)GENMASK(7, 0)SNOR_PROTO_ADDR(_nbits)((((unsigned long)(_nbits)) << SNOR_PROTO_ADDR_SHIFT) & SNOR_PROTO_ADDR_MASK)GENMASK(15, 8)SNOR_PROTO_INST(_nbits)((((unsigned long)(_nbits)) << SNOR_PROTO_INST_SHIFT) & SNOR_PROTO_INST_MASK)GENMASK(23, 16)SR2_QUAD_EN_BIT7CR_QUAD_EN_SPANFSR_PT_ERRFSR_P_ERRFSR_E_ERRFSR_READYEVCR_QUAD_EN_MICRONSR_QUAD_EN_MXSR_P_ERRSR_E_ERRSR_SRWDSR_TBSR_BP2SR_BP1SR_BP0SR_WELSR_WIPSPINOR_OP_WD_EVCRSPINOR_OP_RD_EVCR0x65SPINOR_OP_CLSRSPINOR_OP_BRRDSPINOR_OP_BRWRSPINOR_OP_EX4B0xe9SPINOR_OP_EN4B0xb7XSR_RDYXSR_PAGESIZESPINOR_OP_XRDSR0xd7SPINOR_OP_XPPSPINOR_OP_XSESPINOR_OP_AAI_WPSPINOR_OP_WRDISPINOR_OP_BPSPINOR_OP_READ_1_4_4_DTR_4BSPINOR_OP_READ_1_2_2_DTR_4B0xbeSPINOR_OP_READ_1_1_1_DTR_4BSPINOR_OP_READ_1_4_4_DTRSPINOR_OP_READ_1_2_2_DTR0xbdSPINOR_OP_READ_1_1_1_DTRSPINOR_OP_SE_4B0xdcSPINOR_OP_BE_32K_4BSPINOR_OP_BE_4K_4BSPINOR_OP_PP_1_4_4_4BSPINOR_OP_PP_1_1_4_4BSPINOR_OP_PP_4BSPINOR_OP_READ_1_4_4_4BSPINOR_OP_READ_1_1_4_4B0x6cSPINOR_OP_READ_1_2_2_4B0xbcSPINOR_OP_READ_1_1_2_4BSPINOR_OP_READ_FAST_4BSPINOR_OP_READ_4BSPINOR_OP_WREAR0xc5SPINOR_OP_RDEAR0xc8SPINOR_OP_CLFSRSPINOR_OP_RDFSRSPINOR_OP_RDCRSPINOR_OP_RDSFDPSPINOR_OP_RDID0x9fSPINOR_OP_SE0xd8SPINOR_OP_CHIP_ERASE0xc7SPINOR_OP_BE_32KSPINOR_OP_BE_4K_PMCSPINOR_OP_BE_4KSPINOR_OP_PP_1_4_4SPINOR_OP_PP_1_1_4SPINOR_OP_PPSPINOR_OP_READ_1_4_40xebSPINOR_OP_READ_1_1_40x6bSPINOR_OP_READ_1_2_20xbbSPINOR_OP_READ_1_1_2SPINOR_OP_READ_FASTSPINOR_OP_READSPINOR_OP_WRSR2SPINOR_OP_RDSR2SPINOR_OP_WRSRSPINOR_OP_RDSRSPINOR_OP_WRENSNOR_MFR_WINBONDSNOR_MFR_SSTSNOR_MFR_SPANSIONSNOR_MFR_MACRONIXSNOR_MFR_MICRONSNOR_MFR_STSNOR_MFR_INTELSNOR_MFR_GIGADEVICESNOR_MFR_ATMEL__LINUX_MTD_SPI_NOR_HCONFIG_SPI_FLASH_BAR/**
 * spi_nor_scan() - scan the SPI NOR
 * @nor:	the spi_nor structure
 *
 * The drivers can use this function to scan the SPI NOR.
 * In the scanning, it will try to get all the necessary information to
 * fill the mtd_info{} and the spi_nor{}.
 *
 * Return: 0 for success, others for failure.
 *//*
 * Page Program capabilities.
 * MUST be ordered by priority: the higher bit position, the higher priority.
 * Like (Fast) Read capabilities, Octo/Quad SPI protocols are preferred to the
 * legacy SPI 1-1-1 protocol.
 * Note that Dual Page Programs are not supported because there is no existing
 * JEDEC/SFDP standard to define them. Also at this moment no SPI flash memory
 * implements such commands.
 *//*
 *(Fast) Read capabilities.
 * MUST be ordered by priority: the higher bit position, the higher priority.
 * As a matter of performances, it is relevant to use Octo SPI protocols first,
 * then Quad SPI protocols before Dual SPI protocols, Fast Read and lastly
 * (Slow) Read.
 *//**
 * struct spi_nor_hwcaps - Structure for describing the hardware capabilies
 * supported by the SPI controller (bus master).
 * @mask:		the bitmask listing all the supported hw capabilies
 *//* Compatibility for spi_flash, remove once sf layer is merged with mtd *//**
 * struct spi_nor - Structure for defining a the SPI NOR layer
 * @mtd:		point to a mtd_info structure
 * @lock:		the lock for the read/write/erase/lock/unlock operations
 * @dev:		point to a spi device, or a spi nor controller device.
 * @info:		spi-nor part JDEC MFR id and other info
 * @page_size:		the page size of the SPI NOR
 * @addr_width:		number of address bytes
 * @erase_opcode:	the opcode for erasing a sector
 * @read_opcode:	the read opcode
 * @read_dummy:		the dummy needed by the read operation
 * @program_opcode:	the program opcode
 * @bank_read_cmd:	Bank read cmd
 * @bank_write_cmd:	Bank write cmd
 * @bank_curr:		Current flash bank
 * @sst_write_second:	used by the SST write operation
 * @flags:		flag options for the current SPI-NOR (SNOR_F_*)
 * @read_proto:		the SPI protocol for read operations
 * @write_proto:	the SPI protocol for write operations
 * @reg_proto		the SPI protocol for read_reg/write_reg/erase operations
 * @cmd_buf:		used by the write_reg
 * @prepare:		[OPTIONAL] do some preparations for the
 *			read/write/erase/lock/unlock operations
 * @unprepare:		[OPTIONAL] do some post work after the
 *			read/write/erase/lock/unlock operations
 * @read_reg:		[DRIVER-SPECIFIC] read out the register
 * @write_reg:		[DRIVER-SPECIFIC] write data to the register
 * @read:		[DRIVER-SPECIFIC] read data from the SPI NOR
 * @write:		[DRIVER-SPECIFIC] write data to the SPI NOR
 * @erase:		[DRIVER-SPECIFIC] erase a sector of the SPI NOR
 *			at the offset @offs; if not provided by the driver,
 *			spi-nor will send the erase opcode via write_reg()
 * @flash_lock:		[FLASH-SPECIFIC] lock a region of the SPI NOR
 * @flash_unlock:	[FLASH-SPECIFIC] unlock a region of the SPI NOR
 * @flash_is_locked:	[FLASH-SPECIFIC] check if a region of the SPI NOR is
 * @quad_enable:	[FLASH-SPECIFIC] enables SPI NOR quad mode
 *			completely locked
 * @priv:		the private data
 *//* TODO: Remove, once all users of spi_flash interface are moved to MTD *//**
 * struct flash_info - Forward declaration of a structure used internally by
 *		       spi_nor_scan()
 *//* Double Transfer Rate *//* Supported SPI protocols *//* Status Register 2 bits. *//* Spansion Quad I/O *//* Configuration Register bits. *//* Protection error bit *//* Program operation status *//* Erase operation status *//* Device status, 0 = Busy, 1 = Ready *//* Flag Status Register bits *//* Micron Quad I/O *//* Enhanced Volatile Configuration Register bits *//* Macronix Quad I/O *//* Spansion/Cypress specific status bits *//* SR write protect *//* Top/Bottom protect *//* Block protect 2 *//* Block protect 1 *//* Block protect 0 *//* meaning of other SR_* bits may differ between vendors *//* Write enable latch *//* Write in progress *//* Status Register bits. *//* Write EVCR register *//* Read EVCR register *//* Used for Micron flashes only. *//* Clear status register 1 *//* Bank register read *//* Bank register write *//* Used for Spansion flashes only. *//* Exit 4-byte mode *//* Enter 4-byte mode *//* Used for Macronix and Winbond flashes. *//* Ready *//* Page size in Po2 or Linear *//* Read status register *//* Page program *//* Sector erase *//* Used for S3AN flashes only *//* Auto address increment word program *//* Write disable *//* Byte program *//* Used for SST flashes only. *//* Double Transfer Rate opcodes - defined in JEDEC JESD216B. *//* Sector erase (usually 64KiB) *//* Erase 32KiB block *//* Erase 4KiB block *//* Quad page program *//* Page program (up to 256 bytes) *//* Read data bytes (Quad I/O SPI) *//* Read data bytes (Quad Output SPI) *//* Read data bytes (Dual I/O SPI) *//* Read data bytes (Dual Output SPI) *//* Read data bytes (high frequency) *//* Read data bytes (low frequency) *//* 4-byte address opcodes - used on Spansion and some Macronix flashes. *//* Write Extended Address Register *//* Read Extended Address Register *//* Clear flag status register *//* Read flag status register *//* Read configuration register *//* Read SFDP *//* Read JEDEC ID *//* Erase whole flash chip *//* Erase 4KiB block on PMC chips *//* Write status register 2 *//* Read status register 2 *//* Write status register 1 byte *//* Write enable *//* Flash opcodes. *//*
 * Note on opcode nomenclature: some opcodes have a format like
 * SPINOR_OP_FUNCTION{4,}_x_y_z. The numbers x, y, and z stand for the number
 * of I/O lines used for the opcode, address, and data (respectively). The
 * FUNCTION has an optional suffix of '4', to represent an opcode which
 * requires a 4-byte (32-bit) address.
 *//* Also used by some Spansion *//* ST Micro <--> Micron *//*
 * Manufacturer IDs
 *
 * The first byte returned from the flash after sending opcode SPINOR_OP_RDID.
 * Sometimes these are the same as CFI IDs, but sometimes they aren't.
 *//*
 * Copyright (C) 2014 Freescale Semiconductor, Inc.
 * Synced from Linux v4.19
 *//opt/src/include/spi_flash.hspi_flash_protectsandbox_sf_unbind_emulsandbox_sf_bind_emulspi_flash_erasespi_flash_writespi_flash_readspi_flash_freespi_flash_probespi_flash_probe_bus_csspl_flash_get_sw_write_protspi_flash_erase_dmspi_flash_write_dmspi_flash_read_dmdm_spi_flash_opsget_sw_write_protsf_get_ops(dev)((struct dm_spi_flash_ops *)(dev)->driver->ops)CONFIG_ENV_SPI_MODECONFIG_SF_DEFAULT_MODECONFIG_ENV_SPI_MAX_HZCONFIG_SF_DEFAULT_SPEEDCONFIG_ENV_SPI_CSCONFIG_SF_DEFAULT_CSCONFIG_ENV_SPI_BUSCONFIG_SF_DEFAULT_BUS_SPI_FLASH_H_CONFIG_DM_SPI_FLASH/* _SPI_FLASH_H_ *//* Compatibility function - this is the old U-Boot API *//**
 * spl_flash_get_sw_write_prot() - Check state of software write-protect feature
 *
 * SPI flash chips can lock a region of the flash defined by a
 * 'protected area'. This function checks if this protected area is
 * defined.
 *
 * @dev:	SPI flash device
 * @return 0 if no region is write-protected, 1 if a region is
 *	write-protected, -ENOSYS if the driver does not implement this,
 *	other -ve value on error
 *//**
 * spi_flash_erase_dm() - Erase blocks of the SPI flash
 *
 * Note that @len must be a muiltiple of the flash sector size.
 *
 * @dev:	SPI flash device
 * @offset:	Offset into device in bytes to start erasing
 * @len:	Number of bytes to erase
 * @return 0 if OK, -ve on error
 *//**
 * spi_flash_write_dm() - Write data to SPI flash
 *
 * @dev:	SPI flash device
 * @offset:	Offset into device in bytes to write to
 * @len:	Number of bytes to write
 * @buf:	Buffer containing bytes to write
 * @return 0 if OK, -ve on error
 *//**
 * spi_flash_read_dm() - Read data from SPI flash
 *
 * @dev:	SPI flash device
 * @offset:	Offset into device in bytes to read from
 * @len:	Number of bytes to read
 * @buf:	Buffer to put the data that is read
 * @return 0 if OK, -ve on error
 *//* Access the serial operations for a device *//**
	 * get_sw_write_prot() - Check state of software write-protect feature
	 *
	 * SPI flash chips can lock a region of the flash defined by a
	 * 'protected area'. This function checks if this protected area is
	 * defined.
	 *
	 * @dev:	SPI flash device
	 * @return 0 if no region is write-protected, 1 if a region is
	 *	write-protected, -ENOSYS if the driver does not implement this,
	 *	other -ve value on error
	 *//* by default ENV use the same parameters than SF command *//* Because we dereference struct udevice here *//*
 * Common SPI flash Interface
 *
 * Copyright (C) 2008 Atmel Corporation
 * Copyright (C) 2013 Jagannadha Sutradharudu Teki, Xilinx Inc.
 */<linux/mtd/spi-nor.h>spi_mode/opt/src/cmd/sf.csfdo_spi_flash"probe"No SPI flash selected. Please run `sf probe'
"No SPI flash selected. Please run `sf probe'\n"update"update""protect"do_spi_flash_testCannot allocate memory (%lu bytes)
"Cannot allocate memory (%lu bytes)\n"CONFIG_SYS_TEXT_BASETest failed
"Test failed\n"spi_flash_testSPI flash test:
"SPI flash test:\n"test_info *sizeof(test)Erase failed
"Erase failed\n"Check read failed
"Check read failed\n"Check failed at %d
"Check failed at %d\n"__min1len - i__min2min_t(uint, len - i, 0x40)<spi_flash.h><spi.h>Write failed
"Write failed\n"Read failed
"Read failed\n"Verify failed at %d, good data:
"Verify failed at %d, good data:\n"Bad data:
"Bad data:\n"STAGE_COUNTspi_test_next_stageshow_timetest->time_ms[stage] * 1024do_div(speed, test->time_ms[stage] * 1024)((speed) >> 32) == 0bps%d %s: %u ticks, %d KiB/s %d.%03d Mbps
"%d %s: %u ticks, %d KiB/s %d.%03d Mbps\n"do_spi_protectstart sector is not a valid number
"start sector is not a valid number\n"len is not a valid number
"len is not a valid number\n""lock""unlock"do_spi_flash_eraseERROR: attempting %s past flash size (%#x)
"ERROR: attempting %s past flash size (%#x)\n"SF: %zu bytes @ %#x Erased: %s
"SF: %zu bytes @ %#x Erased: %s\n"do_spi_flash_read_writeSF: %zu bytes @ %#x %s: "SF: %zu bytes @ %#x %s: ""Read"Written"Written"ERROR %d
"ERROR %d\n"OK
"OK\n"spi_flash_updatescalecmp_buflast_updateerr_opertodoend - bufflash->sector_size   Updating, %zu%% %lu B/s"   \rUpdating, %zu%% %lu B/s"start_bufstart_timeskipped"malloc"SPI flash failed in %s step
"SPI flash failed in %s step\n"delta%zu bytes written, %zu bytes skipped"%zu bytes written, %zu bytes skipped" in %ld.%lds, speed %ld B/s
" in %ld.%lds, speed %ld B/s\n"spi_flash_update_block"offset=%#x, sector_size=%#x, len=%#zx\n"offset, flash->sector_size, lendebug("offset=%#x, sector_size=%#x, len=%#zx\n",
	      offset, flash->sector_size, len)cmd/sf.coffset=%#x, sector_size=%#x, len=%#zx
"Skip region %x size %zx: no change\n"offset, lendebug("Skip region %x size %zx: no change\n",
		      offset, len)Skip region %x size %zx: no change
do_spi_flash_probe1000000bus_devFailed to initialize SPI flash at %u:%u (error %d)
"Failed to initialize SPI flash at %u:%u (error %d)\n"bytes_per_second(unsigned int) -1((unsigned int) -1)4194303((unsigned int) -1) / 1024get_timer(start_ms) / 1024max(get_timer(start_ms) / 1024, 1UL)get_timer(start_ms)max(get_timer(start_ms), 1UL)sf_parse_len_arground_up_lenlen_argROUND(len_arg, flash->sector_size)test_infoSTAGE_ERASESTAGE_CHECKSTAGE_WRITESTAGE_READtime_msbase_ms"SPI flash sub-system""probe [[bus:]cs] [hz] [mode]	- init flash device on given SPI bus\n" "				  and chip select\n" "sf read addr offset|partition len	- read `len' bytes starting at\n" "				          `offset' or from start of mtd\n" "					  `partition'to memory at `addr'\n" "sf write addr offset|partition len	- write `len' bytes from memory\n" "				          at `addr' to flash at `offset'\n" "					  or to start of mtd `partition'\n" "sf erase offset|partition [+]len	- erase `len' bytes from `offset'\n" "					  or from start of mtd `partition'\n" "					 `+len' round up `len' to block size\n" "sf update addr offset|partition len	- erase and write `len' bytes from memory\n" "					  at `addr' to flash at `offset'\n" "					  or to start of mtd `partition'\n" "sf protect lock/unlock sector len	- protect/unprotect 'len' bytes starting\n" "					  at address 'sector'\n" SF_TEST_HELP"probe [[bus:]cs] [hz] [mode]	- init flash device on given SPI bus\n" "				  and chip select\n" "sf read addr offset|partition len	- read `len' bytes starting at\n" "				          `offset' or from start of mtd\n" "					  `partition'to memory at `addr'\n" "sf write addr offset|partition len	- write `len' bytes from memory\n" "				          at `addr' to flash at `offset'\n" "					  or to start of mtd `partition'\n" "sf erase offset|partition [+]len	- erase `len' bytes from `offset'\n" "					  or from start of mtd `partition'\n" "					 `+len' round up `len' to block size\n" "sf update addr offset|partition len	- erase and write `len' bytes from memory\n" "					  at `addr' to flash at `offset'\n" "					  or to start of mtd `partition'\n" "sf protect lock/unlock sector len	- protect/unprotect 'len' bytes starting\n" "					  at address 'sector'\n" "\nsf test offset len		" "- run a very basic destructive test"SPI flash sub-systemprobe [[bus:]cs] [hz] [mode]	- init flash device on given SPI bus
				  and chip select
sf read addr offset|partition len	- read `len' bytes starting at
				          `offset' or from start of mtd
					  `partition'to memory at `addr'
sf write addr offset|partition len	- write `len' bytes from memory
				          at `addr' to flash at `offset'
					  or to start of mtd `partition'
sf erase offset|partition [+]len	- erase `len' bytes from `offset'
					  or from start of mtd `partition'
					 `+len' round up `len' to block size
sf update addr offset|partition len	- erase and write `len' bytes from memory
					  at `addr' to flash at `offset'
					  or to start of mtd `partition'
sf protect lock/unlock sector len	- protect/unprotect 'len' bytes starting
					  at address 'sector'

sf test offset len		- run a very basic destructive test"probe [[bus:]cs] [hz] [mode]	- init flash device on given SPI bus\n"
	"				  and chip select\n"
	"sf read addr offset|partition len	- read `len' bytes starting at\n"
	"				          `offset' or from start of mtd\n"
	"					  `partition'to memory at `addr'\n"
	"sf write addr offset|partition len	- write `len' bytes from memory\n"
	"				          at `addr' to flash at `offset'\n"
	"					  or to start of mtd `partition'\n"
	"sf erase offset|partition [+]len	- erase `len' bytes from `offset'\n"
	"					  or from start of mtd `partition'\n"
	"					 `+len' round up `len' to block size\n"
	"sf update addr offset|partition len	- erase and write `len' bytes from memory\n"
	"					  at `addr' to flash at `offset'\n"
	"					  or to start of mtd `partition'\n"
	"sf protect lock/unlock sector len	- protect/unprotect 'len' bytes starting\n"
	"					  at address 'sector'\n"
	SF_TEST_HELP
)char[847]U_BOOT_CMD(
	sf,	5,	1,	do_spi_flash,
	"SPI flash sub-system",
	"probe [[bus:]cs] [hz] [mode]	- init flash device on given SPI bus\n"
	"				  and chip select\n"
	"sf read addr offset|partition len	- read `len' bytes starting at\n"
	"				          `offset' or from start of mtd\n"
	"					  `partition'to memory at `addr'\n"
	"sf write addr offset|partition len	- write `len' bytes from memory\n"
	"				          at `addr' to flash at `offset'\n"
	"					  or to start of mtd `partition'\n"
	"sf erase offset|partition [+]len	- erase `len' bytes from `offset'\n"
	"					  or from start of mtd `partition'\n"
	"					 `+len' round up `len' to block size\n"
	"sf update addr offset|partition len	- erase and write `len' bytes from memory\n"
	"					  at `addr' to flash at `offset'\n"
	"					  or to start of mtd `partition'\n"
	"sf protect lock/unlock sector len	- protect/unprotect 'len' bytes starting\n"
	"					  at address 'sector'\n"
	SF_TEST_HELP
)_u_boot_list_2_cmd_2_sf.u_boot_list_2_cmd_2_sf"check"stage_nameSF_TEST_HELP"\nsf test offset len		" "- run a very basic destructive test"CONFIG_CMD_SF_TEST/* The remaining commands require a selected device *//* need at least two arguments *//* CONFIG_CMD_SF_TEST *//**
 * Run a test on the SPI flash
 *
 * @param flash		SPI flash to use
 * @param buf		Source buffer for data to write
 * @param len		Size of data to read/write
 * @param offset	Offset within flash to check
 * @param vbuf		Verification buffer
 * @return 0 if ok, -1 on error
 *//* Bits per second *//* KiB/s *//* Unknown parameter *//* Consistency checking *//* statistics *//* number of bytes to do in this pass *//**
 * Update an area of SPI flash by erasing and writing any blocks which need
 * to change. Existing blocks with the correct data are left unchanged.
 *
 * @param flash		flash context pointer
 * @param offset	flash offset to write
 * @param len		number of bytes to write
 * @param buf		buffer to write from
 * @return 0 if ok, 1 on error
 *//* Write one complete sector *//* If it's a partial sector, copy the data into the temp-buffer *//* Erase the entire sector *//* Compare only what is meaningful (len) *//* Read the entire sector so to allow for rewriting *//**
 * Write a block of data to SPI flash, first checking if it is different from
 * what is already there.
 *
 * If the data being written is the same, then *skipped is incremented by len.
 *
 * @param flash		flash context pointer
 * @param offset	flash offset to write
 * @param len		number of bytes to write
 * @param buf		buffer to write from
 * @param cmp_buf	read buffer to use to compare data
 * @param skipped	Count of skipped data (incremented by this function)
 * @return NULL if OK, else a string containing the stage which failed
 *//* Remove the old device, otherwise probe will just be a nop *//* In DM mode, defaults speed and mode will be taken from DT *//* less accurate but avoids overflow *//**
 * This function takes a byte length and a delta unit of time to compute the
 * approximate bytes per second
 *
 * @param len		amount of bytes currently processed
 * @param start_ms	start time of processing in ms
 * @return bytes per second if OK, 0 on error
 *//* indicates if the "+length" form used *//*
 * This function computes the length argument for the erase command.
 * The length on which the command is to operate can be given in two forms:
 * 1. <cmd> offset len  - operate on <'offset',  'len')
 * 2. <cmd> offset +len - operate on <'offset',  'round_up(len)')
 * If the second form is used and the length doesn't fall on the
 * sector boundary, than it will be adjusted to the next sector boundary.
 * If it isn't in the flash, the function will fail (return -1).
 * Input:
 *    arg: length specification (i.e. both command arguments)
 * Output:
 *    len: computed length for operation
 * Return:
 *    1: success
 *   -1: failure (bad format, bad address).
 *//*
 * Command for accessing SPI flash.
 *
 * Copyright (C) 2008 Atmel Corporation
 */start_ms/opt/src/include/sound.hsoundsound_find_codec_i2ssound_stop_beepsound_start_beepsound_beepsound_setupsound_create_square_wavesound_opssound_uc_privsound_codec_infosound_compatAUDIO_COMPAT_SPIAUDIO_COMPAT_I2Cstop_beepstart_beepplaysetup_donei2scodeci2c_dev_addri2c_bussound_get_ops(dev)((struct sound_ops *)(dev)->driver->ops)__SOUND_H__/* __SOUND__H__ *//**
 * sound_find_codec_i2s() - Called by sound drivers to locate codec and i2s
 *
 * This finds the audio codec and i2s devices and puts them in the uclass's
 * private data for this device.
 *//**
 * sound_stop_beep() - Stop beeping
 *
 * This tells the sound hardware to stop a previously started beep.
 *
 * @dev: Sound device
 * @return if OK, -ve on error
 *//**
 * sound_start_beep() - Start beeping
 *
 * This tells the sound hardware to start a beep. It will continue until stopped
 * by sound_stop_beep().
 *
 * @dev: Sound device
 * @frequency_hz: Beep frequency in hertz
 * @return if OK, -ve on error
 *//**
 * play() - Play a beep
 *
 * @dev: Sound device
 * @msecs: Duration of beep in milliseconds
 * @frequency_hz: Frequency of the beep in Hertz
 * @return 0 if OK, -ve on error
 *//**
 * setup() - Set up to play a sound
 *//**
	 * stop_beep() - Stop beeping (optional)
	 *
	 * This tells the sound hardware to stop a previously started beep.
	 *
	 * @dev: Sound device
	 * @return if OK, -ve on error
	 *//**
	 * start_beep() - Start beeping (optional)
	 *
	 * This tells the sound hardware to start a beep. It will continue until
	 * stopped by sound_stop_beep().
	 *
	 * @dev: Sound device
	 * @frequency_hz: Beep frequency in hertz
	 * @return if OK, -ENOSYS if not supported, -ve on error
	 *//**
	 * play() - Play a beep
	 *
	 * @dev: Sound device
	 * @data: Data buffer to play
	 * @data_size: Size of data buffer in bytes
	 * @return 0 if OK, -ve on error
	 *//**
	 * setup() - Set up to play a sound (optional)
	 *//* Operations for sound *//*
 * The sound uclass brings together a data transport (currently only I2C) and a
 * codec (currently connected over I2C).
 *//**
 * Generates square wave sound data for 1 second
 *
 * @sample_rate: Sample rate in Hz
 * @data: data buffer pointer
 * @size: size of the buffer in bytes
 * @freq: frequency of the wave
 * @channels: Number of channels to use
 *//**
 * struct sound_uc_priv - private uclass information about each sound device
 *
 * This is used to line the codec and i2s together
 *
 * @codec: Codec that is used for this sound device
 * @i2s: I2S bus that is used for this sound device
 * @setup_done: true if setup() has been called
 *//* Codec information structure to store the info from device tree *//* sound codec enum *//*
 * Copyright (C) 2012 Samsung Electronics
 * R. Chandrasekar < rcsekar@samsung.com>
 */frequency_hz/opt/src/cmd/sound.cdo_soundcmd_sound_subARRAY_SIZE(cmd_sound_sub)do_playmsec 1000 400UCLASS_SOUNDSound device failed to play (err=%d)
"Sound device failed to play (err=%d)\n"do_initInitialise Audio driver failed (ret=%d)
"Initialise Audio driver failed (ret=%d)\n""sound sub-system""init - initialise the sound driver\n" "sound play [len] [freq] - play a sound for len ms at freq hz\n"sound sub-systeminit - initialise the sound driver
sound play [len] [freq] - play a sound for len ms at freq hz
"init - initialise the sound driver\n"
	"sound play [len] [freq] - play a sound for len ms at freq hz\n"U_BOOT_CMD(
	sound, 4, 1, do_sound,
	"sound sub-system",
	"init - initialise the sound driver\n"
	"sound play [len] [freq] - play a sound for len ms at freq hz\n"
)_u_boot_list_2_cmd_2_sound.u_boot_list_2_cmd_2_soundU_BOOT_CMD_MKENT(init, 0, 1, do_init, "", "")U_BOOT_CMD_MKENT(play, 2, 1, do_play, "", "")/* Strip off leading 'sound' command argument *//* process sound command *//* play sound from buffer *//* Initilaise sound subsystem *//*
 * Copyright (C) 2012 Samsung Electronics
 * Rajeshwari Shinde <rajeshwari.s@samsung.com>
 */<sound.h>mapmem__MAPMEM_HCONFIG_ARCH_MAP_SYSMEM/* __MAPMEM_H *//* Define a null map_sysmem() if the architecture doesn't use it *//opt/src/cmd/source.cdo_source"*  source: default load address = 0x%08lx\n"debug ("*  source: default load address = 0x%08lx\n", addr)cmd/source.c*  source: default load address = 0x%08lx
"*  source: subimage '%s' from FIT image at 0x%08lx\n"fit_uname, addrdebug ("*  source: subimage '%s' from FIT image at 0x%08lx\n",
				fit_uname, addr)*  source: subimage '%s' from FIT image at 0x%08lx
"*  source: cmdline image address = 0x%08lx\n"debug ("*  source: cmdline image address = 0x%08lx\n", addr)*  source: cmdline image address = 0x%08lx
## Executing script at %08lx
"## Executing script at %08lx\n"Bad FIT image format
"Bad FIT image format\n"No FIT subimage unit name
"No FIT subimage unit name\n"noffsetCan't find '%s' FIT subimage
"Can't find '%s' FIT subimage\n"IH_TYPE_SCRIPTNot a image image
"Not a image image\n"Bad Data Hash
"Bad Data Hash\n"fit_datafit_lenCould not find script subimage data
"Could not find script subimage data\n"Wrong image format for "source" command
"Wrong image format for \"source\" command\n""** Script length: %ld\n"debug ("** Script length: %ld\n", len)** Script length: %ld
get_default_imageimages_noffset/imagesFIT_IMAGES_PATHFIT_DEFAULT_PROP"run script from memory"source_help_textrun script from memorychar[172]U_BOOT_CMD(
	source, 2, 0,	do_source,
	"run script from memory", source_help_text
)_u_boot_list_2_cmd_2_source.u_boot_list_2_cmd_2_source[addr]
	- run script starting at addr
	- A valid image header must be present
For FIT format uImage addr must include subimage
unit name in the form of addr:<subimg_uname>defined(CONFIG_CMD_SOURCE)/* Find script image *//* get script subimage data address and length *//* verify integrity *//* get script component image node offset *//*
		 * scripts are just multi-image files with one component, seek
		 * past the zero-terminated sequence of image lengths to get
		 * to the actual image data
		 *//* get length of script *//**
 * get_default_image() - Return default property from /images
 *
 * Return: Pointer to value of default property (or NULL)
 *//* #define DEBUG *//*
 * The "source" command allows to define "script images", i. e. files
 * that contain command sequences that can be executed by the command
 * interpreter. It returns the exit status of the last command
 * executed from the script. This is very similar to running a shell
 * script in a UNIX shell, hence the name for the command.
 *//*
 * (C) Copyright 2001
 * Kyle Harris, kharris@nexus-tech.net
 *//opt/src/cmd/spi.cdo_spiCONFIG_DEFAULT_SPI_MODECONFIG_DEFAULT_SPI_BUS'A' - '0'('A' - '0')('A' - '0') - 10'a' - 'A'('a' - 'A')Hex conversion error on %c
"Hex conversion error on %c\n"MAX_SPI_BYTESMAX_SPI_BYTES * 8(MAX_SPI_BYTES * 8)Invalid bitlen %d
"Invalid bitlen %d\n"do_spi_xfersizeof(name)generic_%d:%d"generic_%d:%d"spi_generic_drv"spi_generic_drv"Error %d during SPI transaction
"Error %d during SPI transaction\n"sspi"SPI utility command""[<bus>:]<cs>[.<mode>] <bit_len> <dout> - Send and receive bits\n" "<bus>     - Identifies the SPI bus\n" "<cs>      - Identifies the chip select\n" "<mode>    - Identifies the SPI mode to use\n" "<bit_len> - Number of bits to send (base 10)\n" "<dout>    - Hexadecimal string that gets sent"SPI utility command[<bus>:]<cs>[.<mode>] <bit_len> <dout> - Send and receive bits
<bus>     - Identifies the SPI bus
<cs>      - Identifies the chip select
<mode>    - Identifies the SPI mode to use
<bit_len> - Number of bits to send (base 10)
<dout>    - Hexadecimal string that gets sent"[<bus>:]<cs>[.<mode>] <bit_len> <dout> - Send and receive bits\n"
	"<bus>     - Identifies the SPI bus\n"
	"<cs>      - Identifies the chip select\n"
	"<mode>    - Identifies the SPI mode to use\n"
	"<bit_len> - Number of bits to send (base 10)\n"
	"<dout>    - Hexadecimal string that gets sent"char[271]U_BOOT_CMD(
	sspi,	5,	1,	do_spi,
	"SPI utility command",
	"[<bus>:]<cs>[.<mode>] <bit_len> <dout> - Send and receive bits\n"
	"<bus>     - Identifies the SPI bus\n"
	"<cs>      - Identifies the chip select\n"
	"<mode>    - Identifies the SPI mode to use\n"
	"<bit_len> - Number of bits to send (base 10)\n"
	"<dout>    - Hexadecimal string that gets sent"
)_u_boot_list_2_cmd_2_sspi.u_boot_list_2_cmd_2_sspi/*
 * SPI read/write
 *
 * Syntax:
 *   spi {dev} {num_bits} {dout}
 *     {dev} is the device number for controlling chip select (see TBD)
 *     {num_bits} is the number of bits to send & receive (base 10)
 *     {dout} is a hexadecimal string of data to send
 * The command prints out the hexadecimal string received via SPI.
 *//* We don't get an error code in this case *//*
 * Values from last command.
 *//* Maximum number of bytes we can handle *//*-----------------------------------------------------------------------
 * Definitions
 *//*
 * SPI Read/Write Utilities
 *//*
 * (C) Copyright 2002
 * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
 *//opt/src/cmd/test.cdo_truedo_falsedo_testleftexprlast_unopOP_INVALIDlast_binoplast_exprconst struct <unnamed>[16]struct <unnamed>[16]op_advARRAY_SIZE(op_adv)advOP_STR_EMPTYOP_STR_NEMPTYOP_STR_EQOP_STR_NEQOP_STR_LTOP_STR_GTOP_INT_EQOP_INT_NEQOP_INT_LTOP_INT_LEOP_INT_GTOP_INT_GEOP_FILE_EXISTSOP_OROP_ANDOP_NOT": returns %d\n"debug (": returns %d\n", expr)cmd/test.cconst char[8]: returns %d
"do nothing, successfully"U_BOOT_CMD(
	true,	CONFIG_SYS_MAXARGS,	1,	do_true,
	"do nothing, successfully",
	NULL
)do nothing, successfully_u_boot_list_2_cmd_2_true.u_boot_list_2_cmd_2_true"do nothing, unsuccessfully"U_BOOT_CMD(
	false,	CONFIG_SYS_MAXARGS,	1,	do_false,
	"do nothing, unsuccessfully",
	NULL
)do nothing, unsuccessfully_u_boot_list_2_cmd_2_false.u_boot_list_2_cmd_2_false"minimal test like /bin/sh""[args..]"U_BOOT_CMD(
	test,	CONFIG_SYS_MAXARGS,	1,	do_test,
	"minimal test like /bin/sh",
	"[args..]"
)minimal test like /bin/sh[args..]_u_boot_list_2_cmd_2_test.u_boot_list_2_cmd_2_test!"!"-o"-o"-z"-z"-n"-n"-e"-e"/* args? *//opt/src/cmd/time.cdo_timerepeatablecyclesreport_timetotal_secondsremainderminutesmillisecondsCONFIG_SYS_HZ / 2
time:"\ntime:" %lu minutes," %lu minutes," %lu.%03lu seconds
" %lu.%03lu seconds\n""run commands and summarize execution time""command [args...]\n"U_BOOT_CMD(time, CONFIG_SYS_MAXARGS, 0, do_time,
		"run commands and summarize execution time",
		"command [args...]\n")run commands and summarize execution timecommand [args...]
_u_boot_list_2_cmd_2_time.u_boot_list_2_cmd_2_time/* approximate millisecond value *//opt/src/include/tpm-common.htpm-commontpm_get_versionget_tpm2_commandsget_tpm1_commandstpm_inittpm_xfertpm_get_desctpm_clear_and_reenabletpm_closetpm_opentpm_opstpm_chip_privtpm_versionTPM_V1TPM_V2tpm_durationTPM_SHORTTPM_MEDIUMTPM_LONGTPM_UNDEFINEDTPM_DURATION_COUNTpcr_select_minpcr_countu8[1261]unsigned char[1261]1260TPM_DEV_BUFSIZEsizeof(u8)1261TPM_DEV_BUFSIZE + sizeof(u8)retry_time_msduration_msTPM_COMMAND_NO_ARG(cmd)int do_ ## cmd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]) { struct udevice *dev; int rc; rc = get_tpm(&dev); if (rc) return rc; if (argc != 1) return CMD_RET_USAGE; return report_return_code(cmd(dev)); }MAKE_TPM_CMD_ENTRY(cmd)U_BOOT_CMD_MKENT(cmd, 0, 1, do_tpm_ ## cmd, "", "")tpm_get_ops(dev)((struct tpm_ops *)device_get_ops(dev))TPM_PCR_MINIMUM_DIGEST_SIZETPM_HEADER_SIZE__TPM_COMMON_Hdefined(CONFIG_TPM_V1)defined(CONFIG_TPM_V2)/* __TPM_COMMON_H *//**
 * tpm_get_version() - Find the version of a TPM
 *
 * This checks the uclass data for a TPM device and returns the version number
 * it supports.
 *
 * @dev: TPM device
 * @return version number (TPM_V1 or TPMV2)
 *//**
 * Retrieve the array containing all the v1 (resp. v2) commands.
 *
 * @return a cmd_tbl_t array.
 *//**
 * Initialize TPM device.  It must be called before any TPM commands.
 *
 * @dev - TPM device
 * @return 0 on success, non-0 on error.
 *//**
 * tpm_xfer() - send data to the TPM and get response
 *
 * This first uses the device's send() method to send the bytes. Then it calls
 * recv() to get the reply. If recv() returns -EAGAIN then it will delay a
 * short time and then call recv() again.
 *
 * Regardless of whether recv() completes successfully, it will then call
 * cleanup() to finish the transaction.
 *
 * Note that the outgoing data is inspected to determine command type
 * (ordinal) and a timeout is used for that command type.
 *
 * @dev - TPM device
 * @sendbuf - buffer of the data to send
 * @send_size size of the data to send
 * @recvbuf - memory to save the response to
 * @recv_len - pointer to the size of the response buffer
 *
 * Returns 0 on success (and places the number of response bytes at
 * recv_len) or -ve on failure.
 *//**
 * tpm_get_desc() - Get a text description of the TPM
 *
 * @dev:	Device to check
 * @buf:	Buffer to put the string
 * @size:	Maximum size of buffer
 * @return length of string, or -ENOSPC it no space
 *//**
 * tpm_clear_and_reenable() - Force clear the TPM and reenable it
 *
 * @dev: TPM device
 * @return 0 on success, -ve on failure
 *//**
 * tpm_close() - Close the current session
 *
 * Releasing the locked locality. Returns 0 on success, -ve 1 on
 * failure (in case lock removal did not succeed).
 *
 * @dev - TPM device
 * Returns 0 on success, -ve on failure.
 *//**
 * tpm_open() - Request access to locality 0 for the caller
 *
 * After all commands have been completed the caller is supposed to
 * call tpm_close().
 *
 * @dev - TPM device
 * Returns 0 on success, -ve on failure.
 *//**
	 * xfer() - send data to the TPM and get response
	 *
	 * This method is optional. If it exists it is used in preference
	 * to send(), recv() and cleanup(). It should handle all aspects of
	 * TPM communication for a single transfer.
	 *
	 * @dev:	Device to talk to
	 * @sendbuf:	Buffer of the data to send
	 * @send_size:	Size of the data to send
	 * @recvbuf:	Buffer to save the response to
	 * @recv_size:	Pointer to the size of the response buffer
	 *
	 * Returns 0 on success (and places the number of response bytes at
	 * recv_size) or -ve on failure.
	 *//**
	 * cleanup() - clean up after an operation in progress
	 *
	 * This is called if receiving times out. The TPM may need to abort
	 * the current transaction if it did not complete, and make itself
	 * ready for another.
	 *
	 * @dev:	Device to talk to
	 *//**
	 * recv() - receive a response from the TPM
	 *
	 * @dev:	Device to talk to
	 * @recvbuf:	Buffer to save the response to
	 * @max_size:	Maximum number of bytes to receive
	 *
	 * Returns number of bytes received on success, -EAGAIN if the TPM
	 * response is not ready, -EINTR if cancelled, or other -ve value on
	 * failure.
	 *//**
	 * send() - send data to the TPM
	 *
	 * @dev:	Device to talk to
	 * @sendbuf:	Buffer of the data to send
	 * @send_size:	Size of the data to send
	 *
	 * Returns 0 on success or -ve on failure.
	 *//**
	 * get_desc() - Get a text description of the TPM
	 *
	 * @dev:	Device to check
	 * @buf:	Buffer to put the string
	 * @size:	Maximum size of buffer
	 * @return length of string, or -ENOSPC it no space
	 *//**
	 * close() - Close the current session
	 *
	 * Releasing the locked locality. Returns 0 on success, -ve 1 on
	 * failure (in case lock removal did not succeed).
	 *
	 * @dev:	Device to close
	 * @return 0 ok OK, -ve on error
	 *//**
	 * open() - Request access to locality 0 for the caller
	 *
	 * After all commands have been completed the caller should call
	 * close().
	 *
	 * @dev:	Device to open
	 * @return 0 ok OK, -ve on error
	 *//**
 * struct tpm_ops - low-level TPM operations
 *
 * These are designed to avoid loops and delays in the driver itself. These
 * should be handled in the uclass.
 *
 * In gneral you should implement everything except xfer(). Where you need
 * complete control of the transfer, then xfer() can be provided and will
 * override the other methods.
 *
 * This interface is for low-level TPM access. It does not understand the
 * concept of localities or the various TPM messages. That interface is
 * defined in the functions later on in this file, but they all translate
 * to bytes which are sent and received.
 *//* TPM v2 specific data *//* Max buffer size + addr *//**
 * struct tpm_chip_priv - Information about a TPM, stored by the uclass
 *
 * These values must be set up by the device's probe() method before
 * communcation is attempted. If the device has an xfer() method, this is
 * not needed. There is no need to set up @buf.
 *
 * @version:		TPM stack to be used
 * @duration_ms:	Length of each duration type in milliseconds
 * @retry_time_ms:	Time to wait before retrying receive
 * @buf:		Buffer used during the exchanges with the chip
 * @pcr_count:		Number of PCR per bank
 * @pcr_select_min:	Minimum size in bytes of the pcrSelect array
 *//**
 * enum tpm_version - The version of the TPM stack to be used
 * @TPM_V1:		Use TPM v1.x stack
 * @TPM_V2:		Use TPM v2.x stack
 *//* Max buffer size supported by our tpm *//*
 * Here is a partial implementation of TPM commands.  Please consult TCG Main
 * Specification for definitions of TPM commands.
 *//*
 * Copyright (c) 2013 The Chromium OS Authors.
 * Coypright (c) 2013 Guntermann & Drunck GmbH
 */sendbufsend_sizerecvbufrecv_size/opt/src/cmd/tpm-user-utils.htpm-user-utils__TPM_USER_UTILS_Hdo_tpmdo_tpm_infodo_tpm_initget_tpmtype_string_write_varstype_string_packtype_string_alloctype_string_get_space_sizetype_string_get_num_valuesreport_return_codeparse_byte_stringprint_byte_string/* __TPM_USER_UTILS_H */type_strvaluesreturn_codecount_ptr/opt/src/cmd/tpm-common.ctpm_chip_priv *tpm_commandsCouldn't get TPM info (%d)
"Couldn't get TPM info (%d)\n"UCLASS_TPMCould not find TPM (ret=%d)
"Could not find TPM (ret=%d)\n""tpm-user-utils.h"<tpm-common.h>Error: %d
"Error: %d\n"print_newline/* Below getters return NULL if the desired stack is not built *//**
 * Read values defined by a type string from a buffer, and write these values
 * to environment variables.
 *
 * @param type_str	type string
 * @param data		input buffer of values
 * @param vars		names of environment variables
 * @return 0 on success, non-0 on error
 *//**
 * Pack values defined by a type string into a buffer.  The buffer must have
 * large enough space.
 *
 * @param type_str	type string
 * @param values	text strings of values to be packed
 * @param data		output buffer of values
 * @return 0 on success, non-0 on error
 *//**
 * Allocate a buffer large enough to hold values defined by a type
 * string.  The caller has to free the buffer.
 *
 * @param type_str	type string
 * @param count		pointer for storing size of buffer
 * @return pointer to buffer or NULL on error
 *//**
 * Return total size of values defined by a type string.
 *
 * @param type_str	type string
 * @return total size of values of type string, or 0 if type string
 *  contains illegal type character.
 *//**
 * Return number of values defined by a type string.
 *
 * @param type_str	type string
 * @return number of values of type string
 *//**
 * report_return_code() - Report any error and return failure or success
 *
 * @param return_code	TPM command return code
 * @return value of enum command_ret_t
 *//**
 * Convert a text string of hexdecimal values into a byte string.
 *
 * @param bytes		text string of hexdecimal values with no space
 *			between them
 * @param data		output buffer for byte string.  The caller has to make
 *			sure it is large enough for storing the output.  If
 *			NULL is passed, a large enough buffer will be allocated,
 *			and the caller must free it.
 * @param count_ptr	output variable for the length of byte string
 * @return pointer to output buffer
 *//* Avoid duplicated newline at the end *//**
 * Print a byte string in hexdecimal format, 16-bytes per line.
 *
 * @param data		byte string to be printed
 * @param count		number of bytes to be printed
 *//*
 * Copyright (c) 2013 The Chromium OS Authors.
 *//opt/src/include/tpm-v1.htpm-v1tpm_resumetpm_set_global_locktpm_nv_set_lockedtpm_finalise_physical_presencetpm_get_randomtpm_flush_specifictpm_get_permissionstpm_get_permanent_flagstpm_permanent_flags *tpm_get_pub_key_oiaptpm_load_key2_oiaptpm_end_oiaptpm_oiaptpm_terminate_auth_sessiontpm_get_capabilitytpm_physical_set_deactivatedtpm_physical_disabletpm_physical_enabletpm_force_cleartpm_read_pubektpm_tsc_physical_presencetpm_pcr_readtpm_extendtpm_nv_write_valuetpm_nv_read_valuetpm_nv_define_spacetpm_continue_self_testtpm_self_test_fulltpm_startuptpm_nv_data_publictpm_nv_attributestpm_pcr_info_shorttpm_pcr_selectiontpm_composite_hashtpm_permanent_flagstpm_return_codeTPM_BASETPM_NON_FATALTPM_SUCCESSTPM_AUTHFAILTPM_BASE +  1TPM_BADINDEXTPM_BASE +  2TPM_BAD_PARAMETERTPM_BASE +  3TPM_AUDITFAILURETPM_BASE +  4TPM_CLEAR_DISABLEDTPM_BASE +  5TPM_DEACTIVATEDTPM_BASE +  6TPM_DISABLEDTPM_BASE +  7TPM_DISABLED_CMDTPM_BASE +  8TPM_FAILTPM_BASE +  9TPM_BAD_ORDINALTPM_BASE + 10TPM_INSTALL_DISABLEDTPM_BASE + 11TPM_INVALID_KEYHANDLETPM_BASE + 12TPM_KEYNOTFOUNDTPM_BASE + 13TPM_INAPPROPRIATE_ENCTPM_BASE + 14TPM_MIGRATE_FAILTPM_BASE + 15TPM_INVALID_PCR_INFOTPM_BASE + 16TPM_NOSPACETPM_BASE + 17TPM_NOSRKTPM_BASE + 18TPM_NOTSEALED_BLOBTPM_BASE + 19TPM_OWNER_SETTPM_BASE + 20TPM_RESOURCESTPM_BASE + 21TPM_SHORTRANDOMTPM_BASE + 22TPM_SIZETPM_BASE + 23TPM_WRONGPCRVALTPM_BASE + 24TPM_BAD_PARAM_SIZETPM_BASE + 25TPM_SHA_THREADTPM_BASE + 26TPM_SHA_ERRORTPM_BASE + 27TPM_FAILEDSELFTESTTPM_BASE + 28TPM_AUTH2FAILTPM_BASE + 29TPM_BADTAGTPM_BASE + 30TPM_IOERRORTPM_BASE + 31TPM_ENCRYPT_ERRORTPM_BASE + 32TPM_DECRYPT_ERRORTPM_BASE + 33TPM_INVALID_AUTHHANDLETPM_BASE + 34TPM_NO_ENDORSEMENTTPM_BASE + 35TPM_INVALID_KEYUSAGETPM_BASE + 36TPM_WRONG_ENTITYTYPETPM_BASE + 37TPM_INVALID_POSTINITTPM_BASE + 38TPM_INAPPROPRIATE_SIGTPM_BASE + 39TPM_BAD_KEY_PROPERTYTPM_BASE + 40TPM_BAD_MIGRATIONTPM_BASE + 41TPM_BAD_SCHEMETPM_BASE + 42TPM_BAD_DATASIZETPM_BASE + 43TPM_BAD_MODETPM_BASE + 44TPM_BAD_PRESENCETPM_BASE + 45TPM_BAD_VERSIONTPM_BASE + 46TPM_NO_WRAP_TRANSPORTTPM_BASE + 47TPM_AUDITFAIL_UNSUCCESSFULTPM_BASE + 48TPM_AUDITFAIL_SUCCESSFULTPM_BASE + 49TPM_NOTRESETABLETPM_BASE + 50TPM_NOTLOCALTPM_BASE + 51TPM_BAD_TYPETPM_BASE + 52TPM_INVALID_RESOURCETPM_BASE + 53TPM_NOTFIPSTPM_BASE + 54TPM_INVALID_FAMILYTPM_BASE + 55TPM_NO_NV_PERMISSIONTPM_BASE + 56TPM_REQUIRES_SIGNTPM_BASE + 57TPM_KEY_NOTSUPPORTEDTPM_BASE + 58TPM_AUTH_CONFLICTTPM_BASE + 59TPM_AREA_LOCKEDTPM_BASE + 60TPM_BAD_LOCALITYTPM_BASE + 61TPM_READ_ONLYTPM_BASE + 62TPM_PER_NOWRITETPM_BASE + 63TPM_FAMILY_COUNTTPM_BASE + 64TPM_WRITE_LOCKEDTPM_BASE + 65TPM_BAD_ATTRIBUTESTPM_BASE + 66TPM_INVALID_STRUCTURETPM_BASE + 67TPM_KEY_OWNER_CONTROLTPM_BASE + 68TPM_BAD_COUNTERTPM_BASE + 69TPM_NOT_FULLWRITETPM_BASE + 70TPM_CONTEXT_GAPTPM_BASE + 71TPM_MAXNVWRITESTPM_BASE + 72TPM_NOOPERATORTPM_BASE + 73TPM_RESOURCEMISSINGTPM_BASE + 74TPM_DELEGATE_LOCKTPM_BASE + 75TPM_DELEGATE_FAMILYTPM_BASE + 76TPM_DELEGATE_ADMINTPM_BASE + 77TPM_TRANSPORT_NOTEXCLUSIVETPM_BASE + 78TPM_OWNER_CONTROLTPM_BASE + 79TPM_DAA_RESOURCESTPM_BASE + 80TPM_DAA_INPUT_DATA0TPM_BASE + 81TPM_DAA_INPUT_DATA1TPM_BASE + 82TPM_DAA_ISSUER_SETTINGSTPM_BASE + 83TPM_DAA_TPM_SETTINGSTPM_BASE + 84TPM_DAA_STAGETPM_BASE + 85TPM_DAA_ISSUER_VALIDITYTPM_BASE + 86TPM_DAA_WRONG_WTPM_BASE + 87TPM_BAD_HANDLETPM_BASE + 88TPM_BAD_DELEGATETPM_BASE + 89TPM_BADCONTEXTTPM_BASE + 90TPM_TOOMANYCONTEXTSTPM_BASE + 91TPM_MA_TICKET_SIGNATURETPM_BASE + 92TPM_MA_DESTINATIONTPM_BASE + 93TPM_MA_SOURCETPM_BASE + 94TPM_MA_AUTHORITYTPM_BASE + 95TPM_PERMANENTEKTPM_BASE + 97TPM_BAD_SIGNATURETPM_BASE + 98TPM_NOCONTEXTSPACETPM_BASE + 99TPM_RETRYTPM_BASE + TPM_NON_FATALTPM_NEEDS_SELFTEST2049TPM_BASE + TPM_NON_FATAL + 1TPM_DOING_SELFTEST2050TPM_BASE + TPM_NON_FATAL + 2TPM_DEFEND_LOCK_RUNNING2051TPM_BASE + TPM_NON_FATAL + 3TPM_CMD_EXTENDTPM_CMD_GET_CAPABILITYTPM_CMD_NV_DEFINE_SPACE0xccTPM_CMD_NV_WRITE_VALUE0xcdTPM_CMD_NV_READ_VALUE0xcfTPM_PUBEK_SIZEtmp_cap_flagTPM_CAP_FLAG_PERMANENTtpm_capability_areasTPM_CAP_ORDTPM_CAP_ALGTPM_CAP_PIDTPM_CAP_FLAGTPM_CAP_PROPERTYTPM_CAP_VERSIONTPM_CAP_KEY_HANDLETPM_CAP_CHECK_LOADEDTPM_CAP_SYM_MODETPM_CAP_KEY_STATUS0x0000000CTPM_CAP_NV_LIST0x0000000DTPM_CAP_MFRTPM_CAP_NV_INDEXTPM_CAP_TRANS_ALGTPM_CAP_HANDLETPM_CAP_TRANS_ESTPM_CAP_AUTH_ENCRYPTTPM_CAP_SELECT_SIZETPM_CAP_DA_LOGICTPM_CAP_VERSION_VAL0x0000001Atpm_resource_typeTPM_RT_KEYTPM_RT_AUTHTPM_RT_HASHTPM_RT_TRANSTPM_RT_CONTEXTTPM_RT_COUNTERTPM_RT_DELEGATETPM_RT_DAA_TPMTPM_RT_DAA_V0TPM_RT_DAA_V1tpm_nv_indexTPM_NV_INDEX_LOCKTPM_NV_INDEX_0TPM_NV_INDEX_DIR2684354570x10000001tpm_physical_presenceTPM_PHYSICAL_PRESENCE_HW_DISABLETPM_PHYSICAL_PRESENCE_CMD_DISABLETPM_PHYSICAL_PRESENCE_LIFETIME_LOCKTPM_PHYSICAL_PRESENCE_HW_ENABLETPM_PHYSICAL_PRESENCE_CMD_ENABLETPM_PHYSICAL_PRESENCE_NOTPRESENTTPM_PHYSICAL_PRESENCE_PRESENTTPM_PHYSICAL_PRESENCE_LOCKtpm_startup_typeTPM_ST_CLEARTPM_ST_STATETPM_ST_DEACTIVATEDTPM_REQUEST_HEADER_LENGTHTPM_RESPONSE_HEADER_LENGTHPCR_DIGEST_LENGTHDIGEST_LENGTHTPM_REQUEST_AUTH_LENGTHTPM_RESPONSE_AUTH_LENGTHTPM_KEY12_MAX_LENGTHTPM_PUBKEY_MAX_LENGTHwrite_definewrite_st_clearread_st_clearpermissionpcr_info_writepcr_info_readnv_indexdigest_at_releaselocality_at_releasepcr_selectionpcr_selectsize_of_selectu8[20]TPM_SHA1_160_HASH_LENdigestdisable_full_da_logic_infomaintenance_donetpm_establishedread_srk_pubnv_lockedenable_revoke_ekoperatorfipstpm_post_locktpm_postcekp_usedphysical_presence_cmd_enablephysical_presence_hw_enablephysical_presence_lifetime_lockallow_maintenancedisable_owner_clearread_pubekdeactivatedownershipTPM_NV_PER_WRITEALLTPM_NV_PER_WRITEDEFINETPM_NV_PER_WRITE_STCLEARTPM_NV_PER_READ_STCLEARBIT(31)TPM_NV_PER_PPWRITETPM_NV_PER_PPREADTPM_NV_PER_GLOBALLOCKTPM_TAG_PERMANENT_FLAGS__TPM_V1_HCONFIG_TPM_LOAD_KEY_BY_SHA1/* __TPM_V1_H *//**
 * tpm_resume() - start up the TPM from resume (after suspend)
 *
 * @param dev		TPM device
 * @return return code of the operation (0 = success)
 *//**
 * tpm_set_global_lock() - set the global lock
 *
 * @param dev		TPM device
 * @return return code of the operation (0 = success)
 *//**
 * tpm_nv_set_locked() - lock the non-volatile space
 *
 * @param dev		TPM device
 * @return return code of the operation (0 = success)
 *//**
 * tpm_finalise_physical_presence() - Finalise physical presence
 *
 * @param dev		TPM device
 * @return return code of the operation (0 = success)
 *//**
 * Read random bytes from the TPM RNG. The implementation deals with the fact
 * that the TPM may legally return fewer bytes than requested by retrying
 * until @p count bytes have been received.
 *
 * @param dev		TPM device
 * @param data		output buffer for the random bytes
 * @param count		size of output buffer
 * @return return code of the operation
 *//* CONFIG_TPM_LOAD_KEY_BY_SHA1 *//**
 * Search for a key by usage AuthData and the hash of the parent's pub key.
 *
 * @param dev		TPM device
 * @param auth	        Usage auth of the key to search for
 * @param pubkey_digest	SHA1 hash of the pub key structure of the key
 * @param[out] handle	The handle of the key (Non-null iff found)
 * @return 0 if key was found in TPM; != 0 if not.
 *//**
 * Flush a resource with a given handle and type from the TPM
 *
 * @param dev		TPM device
 * @param key_handle           handle of the resource
 * @param resource_type                type of the resource
 * @return return code of the operation
 *//**
 * Get the TPM permissions
 *
 * @param dev		TPM device
 * @param perm		Returns permissions value
 * @return return code of the operation
 *//**
 * Get the TPM permanent flags value
 *
 * @param dev		TPM device
 * @param pflags	Place to put permanent flags
 * @return return code of the operation
 *//**
 * Issue a TPM_GetPubKey (Auth1) command using an OIAP session for
 * authenticating the usage of the key.
 *
 * @param dev		TPM device
 * @param key_handle	handle of the key
 * @param usage_auth	usage auth for the key
 * @param pubkey	pointer to the pub key buffer; may be NULL if the pubkey
 *			should not be stored.
 * @param pubkey_len	pointer to the pub key buffer len. On entry: the size of
 *			the provided pubkey buffer. On successful exit: the size
 *			of the stored TPM_PUBKEY structure (iff pubkey != NULL).
 * @return return code of the operation
 *//**
 * Issue a TPM_LoadKey2 (Auth1) command using an OIAP session for authenticating
 * the usage of the parent key.
 *
 * @param dev		TPM device
 * @param parent_handle	handle of the parent key.
 * @param key		pointer to the key structure (TPM_KEY or TPM_KEY12).
 * @param key_length	size of the key structure
 * @param parent_key_usage_auth	usage auth for the parent key
 * @param key_handle	pointer to the key handle
 * @return return code of the operation
 *//**
 * Ends an active OIAP session.
 *
 * @param dev		TPM device
 * @return return code of the operation
 *//**
 * Issue a TPM_OIAP command to setup an object independent authorization
 * session.
 * Information about the session is stored internally.
 * If there was already an OIAP session active it is terminated and a new
 * session is set up.
 *
 * @param dev		TPM device
 * @param auth_handle	pointer to the (new) auth handle or NULL.
 * @return return code of the operation
 *//**
 * Issue a TPM_FlushSpecific command for a AUTH resource.
 *
 * @param dev		TPM device
 * @param auth_handle	handle of the auth session
 * @return return code of the operation
 *//**
 * Issue a TPM_GetCapability command.  This implementation is limited
 * to query sub_cap index that is 4-byte wide.
 *
 * @param dev		TPM device
 * @param cap_area	partition of capabilities
 * @param sub_cap	further definition of capability, which is
 *			limited to be 4-byte wide
 * @param cap		output buffer for capability information
 * @param count		size of output buffer
 * @return return code of the operation
 *//**
 * Issue a TPM_PhysicalSetDeactivated command.
 *
 * @param dev		TPM device
 * @param state		boolean state of the deactivated flag
 * @return return code of the operation
 *//**
 * Issue a TPM_PhysicalDisable command.
 *
 * @param dev		TPM device
 * @return return code of the operation
 *//**
 * Issue a TPM_PhysicalEnable command.
 *
 * @param dev		TPM device
 * @return return code of the operation
 *//**
 * Issue a TPM_ForceClear command.
 *
 * @param dev		TPM device
 * @return return code of the operation
 *//**
 * Issue a TPM_ReadPubek command.
 *
 * @param dev		TPM device
 * @param data		output buffer for the public endorsement key
 * @param count		size of output buffer
 * @return return code of the operation
 *//**
 * Issue a TSC_PhysicalPresence command.  TPM physical presence flag
 * is bit-wise OR'ed of flags listed in enum tpm_physical_presence.
 *
 * @param dev		TPM device
 * @param presence	TPM physical presence flag
 * @return return code of the operation
 *//**
 * Issue a TPM_PCRRead command.
 *
 * @param dev		TPM device
 * @param index		index of the PCR
 * @param data		output buffer for contents of the named PCR
 * @param count		size of output buffer
 * @return return code of the operation
 *//**
 * Issue a TPM_Extend command.
 *
 * @param dev		TPM device
 * @param index		index of the PCR
 * @param in_digest	160-bit value representing the event to be
 *			recorded
 * @param out_digest	160-bit PCR value after execution of the
 *			command
 * @return return code of the operation
 *//**
 * Issue a TPM_NV_WriteValue command.  This implementation is limited
 * to write the area from offset 0.  The area index could be one of
 * the special value listed in enum tpm_nv_index.
 *
 * @param dev		TPM device
 * @param index		index of the area
 * @param data		input buffer to be wrote to the area
 * @param length	length of data bytes of input buffer
 * @return return code of the operation
 *//**
 * Issue a TPM_NV_ReadValue command.  This implementation is limited
 * to read the area from offset 0.  The area index could be one of
 * the special value listed in enum tpm_nv_index.
 *
 * @param dev		TPM device
 * @param index		index of the area
 * @param data		output buffer of the area contents
 * @param count		size of output buffer
 * @return return code of the operation
 *//**
 * Issue a TPM_NV_DefineSpace command.  The implementation is limited
 * to specify TPM_NV_ATTRIBUTES and size of the area.  The area index
 * could be one of the special value listed in enum tpm_nv_index.
 *
 * @param dev		TPM device
 * @param index		index of the area
 * @param perm		TPM_NV_ATTRIBUTES of the area
 * @param size		size of the area
 * @return return code of the operation
 *//**
 * Issue a TPM_ContinueSelfTest command.
 *
 * @param dev		TPM device
 * @return return code of the operation
 *//**
 * Issue a TPM_SelfTestFull command.
 *
 * @param dev		TPM device
 * @return return code of the operation
 *//**
 * Issue a TPM_Startup command.
 *
 * @param dev		TPM device
 * @param mode		TPM startup mode
 * @return return code of the operation
 *//* matches vboot's struct *//* TPM-defined non-fatal errors *//* TPM-defined fatal error codes *//**
 * TPM return codes as defined in the TCG Main specification
 * (TPM Main Part 2 Structures; Specification version 1.2)
 *//* some max lengths, valid for RSA keys <= 2048 bits *//* Useful constants */key_handleresource_typepermpflagsusage_authpubkeypubkey_lenkey_lengthparent_key_usage_authauth_handlecap_areasub_cappresencein_digest/opt/src/cmd/tpm-v1.ccmd_tbl_t[21]cmd_tbl_s[21]tpm1_commands1176ARRAY_SIZE(tpm1_commands)do_tpm_physical_disableTPM_COMMAND_NO_ARG(tpm_physical_disable)do_tpm_physical_enableTPM_COMMAND_NO_ARG(tpm_physical_enable)do_tpm_force_clearTPM_COMMAND_NO_ARG(tpm_force_clear)do_tpm_continue_self_testTPM_COMMAND_NO_ARG(tpm_continue_self_test)do_tpm_self_test_fullTPM_COMMAND_NO_ARG(tpm_self_test_full)do_tpm_nv_writeCouldn't parse arguments
"Couldn't parse arguments\n"do_tpm_nv_readCouldn't write to variables
"Couldn't write to variables\n"do_tpm_nv_define<tpm-v1.h>do_tpm_raw_transferCouldn't parse byte string %s
"Couldn't parse byte string %s\n"u8[1024]unsigned char[1024]response_lengthsizeof(response)tpm response:
"tpm response:\n"do_tpm_get_capabilitycapability information:
"capability information:\n"do_tpm_physical_set_deactivateddo_tpm_read_pubekpubek value:
"pubek value:\n"do_tpm_tsc_physical_presencedo_tpm_pcr_readNamed PCR content:
"Named PCR content:\n"do_tpm_extendPCR value after execution of the command:
"PCR value after execution of the command:\n"sizeof(out_digest)do_tpm_nv_write_valuedo_tpm_nv_read_valuearea content:
"area content:\n"do_tpm_nv_define_spacedo_tpm_startup"TPM_ST_CLEAR""TPM_ST_STATE""TPM_ST_DEACTIVATED"Couldn't recognize mode string: %s
"Couldn't recognize mode string: %s\n"tpm"Issue a TPMv1.x command""cmd args...\n" "    - Issue TPM command <cmd> with arguments <args...>.\n" "Admin Startup and State Commands:\n" "  info - Show information about the TPM\n" "  init\n" "    - Put TPM into a state where it waits for 'startup' command.\n" "  startup mode\n" "    - Issue TPM_Starup command.  <mode> is one of TPM_ST_CLEAR,\n" "      TPM_ST_STATE, and TPM_ST_DEACTIVATED.\n" "Admin Testing Commands:\n" "  self_test_full\n" "    - Test all of the TPM capabilities.\n" "  continue_self_test\n" "    - Inform TPM that it should complete the self-test.\n" "Admin Opt-in Commands:\n" "  physical_enable\n" "    - Set the PERMANENT disable flag to FALSE using physical presence as\n" "      authorization.\n" "  physical_disable\n" "    - Set the PERMANENT disable flag to TRUE using physical presence as\n" "      authorization.\n" "  physical_set_deactivated 0|1\n" "    - Set deactivated flag.\n" "Admin Ownership Commands:\n" "  force_clear\n" "    - Issue TPM_ForceClear command.\n" "  tsc_physical_presence flags\n" "    - Set TPM device's Physical Presence flags to <flags>.\n" "The Capability Commands:\n" "  get_capability cap_area sub_cap addr count\n" "    - Read <count> bytes of TPM capability indexed by <cap_area> and\n" "      <sub_cap> to memory address <addr>.\n" "Endorsement Key Handling Commands:\n" "  read_pubek addr count\n" "    - Read <count> bytes of the public endorsement key to memory\n" "      address <addr>\n" "Integrity Collection and Reporting Commands:\n" "  extend index digest_hex_string\n" "    - Add a new measurement to a PCR.  Update PCR <index> with the 20-bytes\n" "      <digest_hex_string>\n" "  pcr_read index addr count\n" "    - Read <count> bytes from PCR <index> to memory address <addr>.\n" "Non-volatile Storage Commands:\n" "  nv_define_space index permission size\n" "    - Establish a space at index <index> with <permission> of <size> bytes.\n" "  nv_read_value index addr count\n" "    - Read <count> bytes from space <index> to memory address <addr>.\n" "  nv_write_value index addr count\n" "    - Write <count> bytes from memory address <addr> to space <index>.\n" "Miscellaneous helper functions:\n" "  raw_transfer byte_string\n" "    - Send a byte string <byte_string> to TPM and print the response.\n" " Non-volatile storage helper functions:\n" "    These helper functions treat a non-volatile space as a non-padded\n" "    sequence of integer values.  These integer values are defined by a type\n" "    string, which is a text string of 'bwd' characters: 'b' means a 8-bit\n" "    value, 'w' 16-bit value, 'd' 32-bit value.  All helper functions take\n" "    a type string as their first argument.\n" "  nv_define type_string index perm\n" "    - Define a space <index> with permission <perm>.\n" "  nv_read types_string index vars...\n" "    - Read from space <index> to environment variables <vars...>.\n" "  nv_write types_string index values...\n" "    - Write to space <index> from values <values...>.\n"U_BOOT_CMD(tpm, CONFIG_SYS_MAXARGS, 1, do_tpm,
"Issue a TPMv1.x command",
"cmd args...\n"
"    - Issue TPM command <cmd> with arguments <args...>.\n"
"Admin Startup and State Commands:\n"
"  info - Show information about the TPM\n"
"  init\n"
"    - Put TPM into a state where it waits for 'startup' command.\n"
"  startup mode\n"
"    - Issue TPM_Starup command.  <mode> is one of TPM_ST_CLEAR,\n"
"      TPM_ST_STATE, and TPM_ST_DEACTIVATED.\n"
"Admin Testing Commands:\n"
"  self_test_full\n"
"    - Test all of the TPM capabilities.\n"
"  continue_self_test\n"
"    - Inform TPM that it should complete the self-test.\n"
"Admin Opt-in Commands:\n"
"  physical_enable\n"
"    - Set the PERMANENT disable flag to FALSE using physical presence as\n"
"      authorization.\n"
"  physical_disable\n"
"    - Set the PERMANENT disable flag to TRUE using physical presence as\n"
"      authorization.\n"
"  physical_set_deactivated 0|1\n"
"    - Set deactivated flag.\n"
"Admin Ownership Commands:\n"
"  force_clear\n"
"    - Issue TPM_ForceClear command.\n"
"  tsc_physical_presence flags\n"
"    - Set TPM device's Physical Presence flags to <flags>.\n"
"The Capability Commands:\n"
"  get_capability cap_area sub_cap addr count\n"
"    - Read <count> bytes of TPM capability indexed by <cap_area> and\n"
"      <sub_cap> to memory address <addr>.\n"
#if defined(CONFIG_TPM_FLUSH_RESOURCES) || defined(CONFIG_TPM_LIST_RESOURCES)
"Resource management functions\n"
#endif
#ifdef CONFIG_TPM_FLUSH_RESOURCES
"  flush resource_type id\n"
"    - flushes a resource of type <resource_type> (may be one of key, auth,\n"
"      hash, trans, context, counter, delegate, daa_tpm, daa_v0, daa_v1),\n"
"      and id <id> from the TPM. Use an <id> of \"all\" to flush all\n"
"      resources of that type.\n"
#endif /* CONFIG_TPM_FLUSH_RESOURCES */
#ifdef CONFIG_TPM_LIST_RESOURCES
"  list resource_type\n"
"    - lists resources of type <resource_type> (may be one of key, auth,\n"
"      hash, trans, context, counter, delegate, daa_tpm, daa_v0, daa_v1),\n"
"      contained in the TPM.\n"
#endif /* CONFIG_TPM_LIST_RESOURCES */
#ifdef CONFIG_TPM_AUTH_SESSIONS
"Storage functions\n"
"  loadkey2_oiap parent_handle key_addr key_len usage_auth\n"
"    - loads a key data from memory address <key_addr>, <key_len> bytes\n"
"      into TPM using the parent key <parent_handle> with authorization\n"
"      <usage_auth> (20 bytes hex string).\n"
#ifdef CONFIG_TPM_LOAD_KEY_BY_SHA1
"  load_key_by_sha1 parent_hash key_addr key_len usage_auth\n"
"    - loads a key data from memory address <key_addr>, <key_len> bytes\n"
"      into TPM using the parent hash <parent_hash> (20 bytes hex string)\n"
"      with authorization <usage_auth> (20 bytes hex string).\n"
#endif /* CONFIG_TPM_LOAD_KEY_BY_SHA1 */
"  get_pub_key_oiap key_handle usage_auth\n"
"    - get the public key portion of a loaded key <key_handle> using\n"
"      authorization <usage auth> (20 bytes hex string)\n"
#endif /* CONFIG_TPM_AUTH_SESSIONS */
"Endorsement Key Handling Commands:\n"
"  read_pubek addr count\n"
"    - Read <count> bytes of the public endorsement key to memory\n"
"      address <addr>\n"
"Integrity Collection and Reporting Commands:\n"
"  extend index digest_hex_string\n"
"    - Add a new measurement to a PCR.  Update PCR <index> with the 20-bytes\n"
"      <digest_hex_string>\n"
"  pcr_read index addr count\n"
"    - Read <count> bytes from PCR <index> to memory address <addr>.\n"
#ifdef CONFIG_TPM_AUTH_SESSIONS
"Authorization Sessions\n"
"  oiap\n"
"    - setup an OIAP session\n"
"  end_oiap\n"
"    - terminates an active OIAP session\n"
#endif /* CONFIG_TPM_AUTH_SESSIONS */
"Non-volatile Storage Commands:\n"
"  nv_define_space index permission size\n"
"    - Establish a space at index <index> with <permission> of <size> bytes.\n"
"  nv_read_value index addr count\n"
"    - Read <count> bytes from space <index> to memory address <addr>.\n"
"  nv_write_value index addr count\n"
"    - Write <count> bytes from memory address <addr> to space <index>.\n"
"Miscellaneous helper functions:\n"
"  raw_transfer byte_string\n"
"    - Send a byte string <byte_string> to TPM and print the response.\n"
" Non-volatile storage helper functions:\n"
"    These helper functions treat a non-volatile space as a non-padded\n"
"    sequence of integer values.  These integer values are defined by a type\n"
"    string, which is a text string of 'bwd' characters: 'b' means a 8-bit\n"
"    value, 'w' 16-bit value, 'd' 32-bit value.  All helper functions take\n"
"    a type string as their first argument.\n"
"  nv_define type_string index perm\n"
"    - Define a space <index> with permission <perm>.\n"
"  nv_read types_string index vars...\n"
"    - Read from space <index> to environment variables <vars...>.\n"
"  nv_write types_string index values...\n"
"    - Write to space <index> from values <values...>.\n"
)Issue a TPMv1.x commandcmd args...
    - Issue TPM command <cmd> with arguments <args...>.
Admin Startup and State Commands:
  info - Show information about the TPM
  init
    - Put TPM into a state where it waits for 'startup' command.
  startup mode
    - Issue TPM_Starup command.  <mode> is one of TPM_ST_CLEAR,
      TPM_ST_STATE, and TPM_ST_DEACTIVATED.
Admin Testing Commands:
  self_test_full
    - Test all of the TPM capabilities.
  continue_self_test
    - Inform TPM that it should complete the self-test.
Admin Opt-in Commands:
  physical_enable
    - Set the PERMANENT disable flag to FALSE using physical presence as
      authorization.
  physical_disable
    - Set the PERMANENT disable flag to TRUE using physical presence as
      authorization.
  physical_set_deactivated 0|1
    - Set deactivated flag.
Admin Ownership Commands:
  force_clear
    - Issue TPM_ForceClear command.
  tsc_physical_presence flags
    - Set TPM device's Physical Presence flags to <flags>.
The Capability Commands:
  get_capability cap_area sub_cap addr count
    - Read <count> bytes of TPM capability indexed by <cap_area> and
      <sub_cap> to memory address <addr>.
Endorsement Key Handling Commands:
  read_pubek addr count
    - Read <count> bytes of the public endorsement key to memory
      address <addr>
Integrity Collection and Reporting Commands:
  extend index digest_hex_string
    - Add a new measurement to a PCR.  Update PCR <index> with the 20-bytes
      <digest_hex_string>
  pcr_read index addr count
    - Read <count> bytes from PCR <index> to memory address <addr>.
Non-volatile Storage Commands:
  nv_define_space index permission size
    - Establish a space at index <index> with <permission> of <size> bytes.
  nv_read_value index addr count
    - Read <count> bytes from space <index> to memory address <addr>.
  nv_write_value index addr count
    - Write <count> bytes from memory address <addr> to space <index>.
Miscellaneous helper functions:
  raw_transfer byte_string
    - Send a byte string <byte_string> to TPM and print the response.
 Non-volatile storage helper functions:
    These helper functions treat a non-volatile space as a non-padded
    sequence of integer values.  These integer values are defined by a type
    string, which is a text string of 'bwd' characters: 'b' means a 8-bit
    value, 'w' 16-bit value, 'd' 32-bit value.  All helper functions take
    a type string as their first argument.
  nv_define type_string index perm
    - Define a space <index> with permission <perm>.
  nv_read types_string index vars...
    - Read from space <index> to environment variables <vars...>.
  nv_write types_string index values...
    - Write to space <index> from values <values...>.
"cmd args...\n"
"    - Issue TPM command <cmd> with arguments <args...>.\n"
"Admin Startup and State Commands:\n"
"  info - Show information about the TPM\n"
"  init\n"
"    - Put TPM into a state where it waits for 'startup' command.\n"
"  startup mode\n"
"    - Issue TPM_Starup command.  <mode> is one of TPM_ST_CLEAR,\n"
"      TPM_ST_STATE, and TPM_ST_DEACTIVATED.\n"
"Admin Testing Commands:\n"
"  self_test_full\n"
"    - Test all of the TPM capabilities.\n"
"  continue_self_test\n"
"    - Inform TPM that it should complete the self-test.\n"
"Admin Opt-in Commands:\n"
"  physical_enable\n"
"    - Set the PERMANENT disable flag to FALSE using physical presence as\n"
"      authorization.\n"
"  physical_disable\n"
"    - Set the PERMANENT disable flag to TRUE using physical presence as\n"
"      authorization.\n"
"  physical_set_deactivated 0|1\n"
"    - Set deactivated flag.\n"
"Admin Ownership Commands:\n"
"  force_clear\n"
"    - Issue TPM_ForceClear command.\n"
"  tsc_physical_presence flags\n"
"    - Set TPM device's Physical Presence flags to <flags>.\n"
"The Capability Commands:\n"
"  get_capability cap_area sub_cap addr count\n"
"    - Read <count> bytes of TPM capability indexed by <cap_area> and\n"
"      <sub_cap> to memory address <addr>.\n"
#if defined(CONFIG_TPM_FLUSH_RESOURCES) || defined(CONFIG_TPM_LIST_RESOURCES)
"Resource management functions\n"
#endif
#ifdef CONFIG_TPM_FLUSH_RESOURCES
"  flush resource_type id\n"
"    - flushes a resource of type <resource_type> (may be one of key, auth,\n"
"      hash, trans, context, counter, delegate, daa_tpm, daa_v0, daa_v1),\n"
"      and id <id> from the TPM. Use an <id> of \"all\" to flush all\n"
"      resources of that type.\n"
#endif /* CONFIG_TPM_FLUSH_RESOURCES */
#ifdef CONFIG_TPM_LIST_RESOURCES
"  list resource_type\n"
"    - lists resources of type <resource_type> (may be one of key, auth,\n"
"      hash, trans, context, counter, delegate, daa_tpm, daa_v0, daa_v1),\n"
"      contained in the TPM.\n"
#endif /* CONFIG_TPM_LIST_RESOURCES */
#ifdef CONFIG_TPM_AUTH_SESSIONS
"Storage functions\n"
"  loadkey2_oiap parent_handle key_addr key_len usage_auth\n"
"    - loads a key data from memory address <key_addr>, <key_len> bytes\n"
"      into TPM using the parent key <parent_handle> with authorization\n"
"      <usage_auth> (20 bytes hex string).\n"
#ifdef CONFIG_TPM_LOAD_KEY_BY_SHA1
"  load_key_by_sha1 parent_hash key_addr key_len usage_auth\n"
"    - loads a key data from memory address <key_addr>, <key_len> bytes\n"
"      into TPM using the parent hash <parent_hash> (20 bytes hex string)\n"
"      with authorization <usage_auth> (20 bytes hex string).\n"
#endif /* CONFIG_TPM_LOAD_KEY_BY_SHA1 */
"  get_pub_key_oiap key_handle usage_auth\n"
"    - get the public key portion of a loaded key <key_handle> using\n"
"      authorization <usage auth> (20 bytes hex string)\n"
#endif /* CONFIG_TPM_AUTH_SESSIONS */
"Endorsement Key Handling Commands:\n"
"  read_pubek addr count\n"
"    - Read <count> bytes of the public endorsement key to memory\n"
"      address <addr>\n"
"Integrity Collection and Reporting Commands:\n"
"  extend index digest_hex_string\n"
"    - Add a new measurement to a PCR.  Update PCR <index> with the 20-bytes\n"
"      <digest_hex_string>\n"
"  pcr_read index addr count\n"
"    - Read <count> bytes from PCR <index> to memory address <addr>.\n"
#ifdef CONFIG_TPM_AUTH_SESSIONS
"Authorization Sessions\n"
"  oiap\n"
"    - setup an OIAP session\n"
"  end_oiap\n"
"    - terminates an active OIAP session\n"
#endif /* CONFIG_TPM_AUTH_SESSIONS */
"Non-volatile Storage Commands:\n"
"  nv_define_space index permission size\n"
"    - Establish a space at index <index> with <permission> of <size> bytes.\n"
"  nv_read_value index addr count\n"
"    - Read <count> bytes from space <index> to memory address <addr>.\n"
"  nv_write_value index addr count\n"
"    - Write <count> bytes from memory address <addr> to space <index>.\n"
"Miscellaneous helper functions:\n"
"  raw_transfer byte_string\n"
"    - Send a byte string <byte_string> to TPM and print the response.\n"
" Non-volatile storage helper functions:\n"
"    These helper functions treat a non-volatile space as a non-padded\n"
"    sequence of integer values.  These integer values are defined by a type\n"
"    string, which is a text string of 'bwd' characters: 'b' means a 8-bit\n"
"    value, 'w' 16-bit value, 'd' 32-bit value.  All helper functions take\n"
"    a type string as their first argument.\n"
"  nv_define type_string index perm\n"
"    - Define a space <index> with permission <perm>.\n"
"  nv_read types_string index vars...\n"
"    - Read from space <index> to environment variables <vars...>.\n"
"  nv_write types_string index values...\n"
"    - Write to space <index> from values <values...>.\n"char[2715]_u_boot_list_2_cmd_2_tpm.u_boot_list_2_cmd_2_tpmself_test_fullcontinue_self_testforce_clearphysical_enablephysical_disablenv_define_spacenv_read_valuenv_write_valueextendpcr_readtsc_physical_presencephysical_set_deactivatedget_capabilityraw_transfernv_definenv_readnv_writeU_BOOT_CMD_MKENT(info, 0, 1, do_tpm_info, "", "")U_BOOT_CMD_MKENT(init, 0, 1, do_tpm_init, "", "")U_BOOT_CMD_MKENT(startup, 0, 1,
			 do_tpm_startup, "", "")U_BOOT_CMD_MKENT(self_test_full, 0, 1,
			 do_tpm_self_test_full, "", "")U_BOOT_CMD_MKENT(continue_self_test, 0, 1,
			 do_tpm_continue_self_test, "", "")U_BOOT_CMD_MKENT(force_clear, 0, 1,
			 do_tpm_force_clear, "", "")U_BOOT_CMD_MKENT(physical_enable, 0, 1,
			 do_tpm_physical_enable, "", "")U_BOOT_CMD_MKENT(physical_disable, 0, 1,
			 do_tpm_physical_disable, "", "")U_BOOT_CMD_MKENT(nv_define_space, 0, 1,
			 do_tpm_nv_define_space, "", "")U_BOOT_CMD_MKENT(nv_read_value, 0, 1,
			 do_tpm_nv_read_value, "", "")U_BOOT_CMD_MKENT(nv_write_value, 0, 1,
			 do_tpm_nv_write_value, "", "")U_BOOT_CMD_MKENT(extend, 0, 1,
			 do_tpm_extend, "", "")U_BOOT_CMD_MKENT(pcr_read, 0, 1,
			 do_tpm_pcr_read, "", "")U_BOOT_CMD_MKENT(tsc_physical_presence, 0, 1,
			 do_tpm_tsc_physical_presence, "", "")U_BOOT_CMD_MKENT(read_pubek, 0, 1,
			 do_tpm_read_pubek, "", "")U_BOOT_CMD_MKENT(physical_set_deactivated, 0, 1,
			 do_tpm_physical_set_deactivated, "", "")U_BOOT_CMD_MKENT(get_capability, 0, 1,
			 do_tpm_get_capability, "", "")U_BOOT_CMD_MKENT(raw_transfer, 0, 1,
			 do_tpm_raw_transfer, "", "")U_BOOT_CMD_MKENT(nv_define, 0, 1,
			 do_tpm_nv_define, "", "")U_BOOT_CMD_MKENT(nv_read, 0, 1,
			 do_tpm_nv_read, "", "")U_BOOT_CMD_MKENT(nv_write, 0, 1,
			 do_tpm_nv_write, "", "")CONFIG_TPM_AUTH_SESSIONSCONFIG_TPM_FLUSH_RESOURCESCONFIG_TPM_LIST_RESOURCESdefined(CONFIG_TPM_FLUSH_RESOURCES) || defined(CONFIG_TPM_LIST_RESOURCES)/* CONFIG_TPM_AUTH_SESSIONS *//* CONFIG_TPM_LIST_RESOURCES *//* CONFIG_TPM_FLUSH_RESOURCES *//* fetch list of already loaded resources in the TPM *//opt/src/include/tpm-v2.htpm-v2tpm2_pcr_setauthvalueconst ssize_ttpm2_pcr_setauthpolicytpm2_change_authtpm2_dam_parameterstpm2_dam_resettpm2_get_capabilitytpm2_pcr_readtpm2_pcr_extendtpm2_cleartpm2_self_testtpm2_startuptpm_index_attrsTPMA_NV_PPWRITE1UL << 0TPMA_NV_OWNERWRITE1UL << 1TPMA_NV_AUTHWRITE1UL << 2TPMA_NV_POLICYWRITE1UL << 3TPMA_NV_COUNTER1UL << 4TPMA_NV_BITS1UL << 5TPMA_NV_EXTEND1UL << 6TPMA_NV_POLICY_DELETE1UL << 10TPMA_NV_WRITELOCKED1UL << 11TPMA_NV_WRITEALL1UL << 12TPMA_NV_WRITEDEFINE1UL << 13TPMA_NV_WRITE_STCLEAR1UL << 14TPMA_NV_GLOBALLOCK1UL << 15TPMA_NV_PPREAD1UL << 16TPMA_NV_OWNERREAD1UL << 17TPMA_NV_AUTHREAD1UL << 18TPMA_NV_POLICYREAD1UL << 19TPMA_NV_NO_DA1UL << 25TPMA_NV_ORDERLY1UL << 26TPMA_NV_CLEAR_STCLEAR1UL << 27TPMA_NV_READLOCKED1UL << 28TPMA_NV_WRITTEN1UL << 29TPMA_NV_PLATFORMCREATE1UL << 30TPMA_NV_READ_STCLEAR1UL << 31TPMA_NV_MASK_READ196608TPMA_NV_PPREAD | TPMA_NV_OWNERREAD458752TPMA_NV_PPREAD | TPMA_NV_OWNERREAD |
				TPMA_NV_AUTHREAD983040TPMA_NV_PPREAD | TPMA_NV_OWNERREAD |
				TPMA_NV_AUTHREAD | TPMA_NV_POLICYREADTPMA_NV_MASK_WRITETPMA_NV_PPWRITE | TPMA_NV_OWNERWRITETPMA_NV_PPWRITE | TPMA_NV_OWNERWRITE |
					TPMA_NV_AUTHWRITETPMA_NV_PPWRITE | TPMA_NV_OWNERWRITE |
					TPMA_NV_AUTHWRITE | TPMA_NV_POLICYWRITEtpm2_algorithmsTPM2_ALG_XORTPM2_ALG_SHA256TPM2_ALG_SHA384TPM2_ALG_SHA512TPM2_ALG_NULLtpm2_return_codesTPM2_RC_SUCCESSTPM2_RC_BAD_TAG0x001ETPM2_RC_FMT1TPM2_RC_HASHTPM2_RC_FMT1 + 0x0003TPM2_RC_VALUETPM2_RC_FMT1 + 0x0004TPM2_RC_SIZETPM2_RC_FMT1 + 0x0015TPM2_RC_BAD_AUTHTPM2_RC_FMT1 + 0x0022TPM2_RC_HANDLETPM2_RC_FMT1 + 0x000BTPM2_RC_VER1TPM2_RC_INITIALIZETPM2_RC_VER1 + 0x0000TPM2_RC_FAILURETPM2_RC_VER1 + 0x0001TPM2_RC_DISABLEDTPM2_RC_VER1 + 0x0020TPM2_RC_AUTH_MISSINGTPM2_RC_VER1 + 0x0025TPM2_RC_COMMAND_CODE0x0043TPM2_RC_VER1 + 0x0043TPM2_RC_AUTHSIZE324TPM2_RC_VER1 + 0x0044TPM2_RC_AUTH_CONTEXT325TPM2_RC_VER1 + 0x0045TPM2_RC_NEEDS_TEST339TPM2_RC_VER1 + 0x0053TPM2_RC_WARN23040x0900TPM2_RC_TESTING2314TPM2_RC_WARN + 0x000ATPM2_RC_REFERENCE_H02320TPM2_RC_WARN + 0x0010TPM2_RC_LOCKOUT2337TPM2_RC_WARN + 0x0021tpm2_command_codesTPM2_CC_STARTUP0x0144TPM2_CC_SELF_TEST0x0143TPM2_CC_CLEAR0x0126TPM2_CC_CLEARCONTROL0x0127TPM2_CC_HIERCHANGEAUTH0x0129TPM2_CC_PCR_SETAUTHPOL0x012CTPM2_CC_DAM_RESET0x0139TPM2_CC_DAM_PARAMETERS0x013ATPM2_CC_NV_READ3340x014ETPM2_CC_GET_CAPABILITY3780x017ATPM2_CC_PCR_READ3820x017ETPM2_CC_PCR_EXTEND3860x0182TPM2_CC_PCR_SETAUTHVAL3870x0183tpm2_handlesTPM2_RH_OWNER10737418250x40000001TPM2_RS_PW10737418330x40000009TPM2_RH_LOCKOUT10737418340x4000000ATPM2_RH_ENDORSEMENT10737418350x4000000BTPM2_RH_PLATFORM10737418360x4000000Ctpm2_startup_typesTPM2_SU_CLEARTPM2_SU_STATEtpm2_yes_noTPMI_YESTPMI_NOtpm2_structuresTPM2_ST_NO_SESSIONS32769TPM2_ST_SESSIONS327700x8002TPM2_DIGEST_LEN__TPM_V2_H/* __TPM_V2_H *//**
 * Issue a TPM_PCR_SetAuthValue command.
 *
 * @dev		TPM device
 * @pw		Platform password
 * @pw_sz	Length of the password
 * @index	Index of the PCR
 * @digest	New key to access the PCR
 * @key_sz	Length of the new key
 *
 * @return code of the operation
 *//**
 * Issue a TPM_PCR_SetAuthPolicy command.
 *
 * @dev		TPM device
 * @pw		Platform password
 * @pw_sz	Length of the password
 * @index	Index of the PCR
 * @digest	New key to access the PCR
 *
 * @return code of the operation
 *//**
 * Issue a TPM2_HierarchyChangeAuth command.
 *
 * @dev		TPM device
 * @handle	Handle
 * @newpw	New password
 * @newpw_sz	Length of the new password
 * @oldpw	Old password
 * @oldpw_sz	Length of the old password
 *
 * @return code of the operation
 *//**
 * Issue a TPM2_DictionaryAttackParameters command.
 *
 * @dev		TPM device
 * @pw		Password
 * @pw_sz	Length of the password
 * @max_tries	Count of authorizations before lockout
 * @recovery_time Time before decrementation of the failure count
 * @lockout_recovery Time to wait after a lockout
 *
 * @return code of the operation
 *//**
 * Issue a TPM2_DictionaryAttackLockReset command.
 *
 * @dev		TPM device
 * @pw		Password
 * @pw_sz	Length of the password
 *
 * @return code of the operation
 *//**
 * Issue a TPM2_GetCapability command.  This implementation is limited
 * to query property index that is 4-byte wide.
 *
 * @dev		TPM device
 * @capability	Partition of capabilities
 * @property	Further definition of capability, limited to be 4 bytes wide
 * @buf		Output buffer for capability information
 * @prop_count	Size of output buffer
 *
 * @return code of the operation
 *//**
 * Issue a TPM2_PCR_Read command.
 *
 * @dev		TPM device
 * @idx		Index of the PCR
 * @idx_min_sz	Minimum size in bytes of the pcrSelect array
 * @data	Output buffer for contents of the named PCR
 * @updates	Optional out parameter: number of updates for this PCR
 *
 * @return code of the operation
 *//**
 * Issue a TPM2_PCR_Extend command.
 *
 * @dev		TPM device
 * @index	Index of the PCR
 * @digest	Value representing the event to be recorded
 *
 * @return code of the operation
 *//**
 * Issue a TPM2_Clear command.
 *
 * @dev		TPM device
 * @handle	Handle
 * @pw		Password
 * @pw_sz	Length of the password
 *
 * @return code of the operation
 *//**
 * Issue a TPM2_SelfTest command.
 *
 * @dev		TPM device
 * @full_test	Asking to perform all tests or only the untested ones
 *
 * @return code of the operation
 *//**
 * Issue a TPM2_Startup command.
 *
 * @dev		TPM device
 * @mode	TPM startup mode
 *
 * @return code of the operation
 *//* NV index attributes *//**
 * TPM2 algorithms.
 *//**
 * TPM2 return codes.
 *//**
 * TPM2 command codes used at the beginning of a buffer, gives the command.
 *
 * @TPM2_CC_STARTUP: TPM2_Startup().
 * @TPM2_CC_SELF_TEST: TPM2_SelfTest().
 * @TPM2_CC_CLEAR: TPM2_Clear().
 * @TPM2_CC_CLEARCONTROL: TPM2_ClearControl().
 * @TPM2_CC_HIERCHANGEAUTH: TPM2_HierarchyChangeAuth().
 * @TPM2_CC_PCR_SETAUTHPOL: TPM2_PCR_SetAuthPolicy().
 * @TPM2_CC_DAM_RESET: TPM2_DictionaryAttackLockReset().
 * @TPM2_CC_DAM_PARAMETERS: TPM2_DictionaryAttackParameters().
 * @TPM2_CC_GET_CAPABILITY: TPM2_GetCapibility().
 * @TPM2_CC_PCR_READ: TPM2_PCR_Read().
 * @TPM2_CC_PCR_EXTEND: TPM2_PCR_Extend().
 * @TPM2_CC_PCR_SETAUTHVAL: TPM2_PCR_SetAuthValue().
 *//**
 * TPM2 permanent handles.
 *
 * @TPM2_RH_OWNER: refers to the 'owner' hierarchy.
 * @TPM2_RS_PW: indicates a password.
 * @TPM2_RH_LOCKOUT: refers to the 'lockout' hierarchy.
 * @TPM2_RH_ENDORSEMENT: refers to the 'endorsement' hierarchy.
 * @TPM2_RH_PLATFORM: refers to the 'platform' hierarchy.
 *//**
 * TPM2 startup values.
 *
 * @TPM2_SU_CLEAR: reset the internal state.
 * @TPM2_SU_STATE: restore saved state (if any).
 *//**
 * TPM2 type of boolean.
 *//**
 * TPM2 Structure Tags for command/response buffers.
 *
 * @TPM2_ST_NO_SESSIONS: the command does not need an authentication.
 * @TPM2_ST_SESSIONS: the command needs an authentication.
 *//*
 * Copyright (c) 2018 Bootlin
 * Author: Miquel Raynal <miquel.raynal@bootlin.com>
 */pwpw_szkey_sznewpwnewpw_szoldpwoldpw_szmax_triesrecovery_timelockout_recoveryprop_countidx_min_szupdatesfull_test/opt/src/cmd/tpm-v2.ctpm2_commandsARRAY_SIZE(tpm2_commands)do_tpm_pcr_setauthvaluedo_tpm_pcr_setauthpolicydo_tpm_change_auth"TPM2_RH_LOCKOUT""TPM2_RH_ENDORSEMENT""TPM2_RH_OWNER""TPM2_RH_PLATFORM"do_tpm_dam_parameters<tpm-v2.h>LOGL_INFO"Changing dictionary attack parameters:\n"log(LOGC_NONE, LOGL_INFO, "Changing dictionary attack parameters:\n")cmd/tpm-v2.cChanging dictionary attack parameters:
"- maxTries: %lu"log(LOGC_NONE, LOGL_INFO, "- maxTries: %lu", max_tries)- maxTries: %lu"- recoveryTime: %lu\n"log(LOGC_NONE, LOGL_INFO, "- recoveryTime: %lu\n", recovery_time)- recoveryTime: %lu
"- lockoutRecovery: %lu\n"log(LOGC_NONE, LOGL_INFO, "- lockoutRecovery: %lu\n", lockout_recovery)- lockoutRecovery: %lu
do_tpm_dam_resetCapabilities read from TPM:
"Capabilities read from TPM:\n"Property 0x"Property 0x": 0x": 0x"unmap_dataPCR #%u content (%u known updates):
"PCR #%u content (%u known updates):\n"do_tpm2_pcr_extenddo_tpm2_cleardo_tpm2_self_testcontinue"continue"Couldn't recognize test mode: %s
"Couldn't recognize test mode: %s\n"do_tpm2_startup"TPM2_SU_CLEAR""TPM2_SU_STATE"tpm2"Issue a TPMv2.x command""<command> [<arguments>]\n" "\n" "info\n" "    Show information about the TPM.\n" "init\n" "    Initialize the software stack. Always the first command to issue.\n" "startup <mode>\n" "    Issue a TPM2_Startup command.\n" "    <mode> is one of:\n" "        * TPM2_SU_CLEAR (reset state)\n" "        * TPM2_SU_STATE (preserved state)\n" "self_test <type>\n" "    Test the TPM capabilities.\n" "    <type> is one of:\n" "        * full (perform all tests)\n" "        * continue (only check untested tests)\n" "clear <hierarchy>\n" "    Issue a TPM2_Clear command.\n" "    <hierarchy> is one of:\n" "        * TPM2_RH_LOCKOUT\n" "        * TPM2_RH_PLATFORM\n" "pcr_extend <pcr> <digest_addr>\n" "    Extend PCR #<pcr> with digest at <digest_addr>.\n" "    <pcr>: index of the PCR\n" "    <digest_addr>: address of a 32-byte SHA256 digest\n" "pcr_read <pcr> <digest_addr>\n" "    Read PCR #<pcr> to memory address <digest_addr>.\n" "    <pcr>: index of the PCR\n" "    <digest_addr>: address to store the a 32-byte SHA256 digest\n" "get_capability <capability> <property> <addr> <count>\n" "    Read and display <count> entries indexed by <capability>/<property>.\n" "    Values are 4 bytes long and are written at <addr>.\n" "    <capability>: capability\n" "    <property>: property\n" "    <addr>: address to store <count> entries of 4 bytes\n" "    <count>: number of entries to retrieve\n" "dam_reset [<password>]\n" "    If the TPM is not in a LOCKOUT state, reset the internal error counter.\n" "    <password>: optional password\n" "dam_parameters <max_tries> <recovery_time> <lockout_recovery> [<password>]\n" "    If the TPM is not in a LOCKOUT state, set the DAM parameters\n" "    <maxTries>: maximum number of failures before lockout,\n" "                0 means always locking\n" "    <recoveryTime>: time before decrement of the error counter,\n" "                    0 means no lockout\n" "    <lockoutRecovery>: time of a lockout (before the next try),\n" "                       0 means a reboot is needed\n" "    <password>: optional password of the LOCKOUT hierarchy\n" "change_auth <hierarchy> <new_pw> [<old_pw>]\n" "    <hierarchy>: the hierarchy\n" "    <new_pw>: new password for <hierarchy>\n" "    <old_pw>: optional previous password of <hierarchy>\n" "pcr_setauthpolicy|pcr_setauthvalue <pcr> <key> [<password>]\n" "    Change the <key> to access PCR #<pcr>.\n" "    hierarchy and may be empty.\n" "    /!\\WARNING: untested function, use at your own risks !\n" "    <pcr>: index of the PCR\n" "    <key>: secret to protect the access of PCR #<pcr>\n" "    <password>: optional password of the PLATFORM hierarchy\n"U_BOOT_CMD(tpm2, CONFIG_SYS_MAXARGS, 1, do_tpm, "Issue a TPMv2.x command",
"<command> [<arguments>]\n"
"\n"
"info\n"
"    Show information about the TPM.\n"
"init\n"
"    Initialize the software stack. Always the first command to issue.\n"
"startup <mode>\n"
"    Issue a TPM2_Startup command.\n"
"    <mode> is one of:\n"
"        * TPM2_SU_CLEAR (reset state)\n"
"        * TPM2_SU_STATE (preserved state)\n"
"self_test <type>\n"
"    Test the TPM capabilities.\n"
"    <type> is one of:\n"
"        * full (perform all tests)\n"
"        * continue (only check untested tests)\n"
"clear <hierarchy>\n"
"    Issue a TPM2_Clear command.\n"
"    <hierarchy> is one of:\n"
"        * TPM2_RH_LOCKOUT\n"
"        * TPM2_RH_PLATFORM\n"
"pcr_extend <pcr> <digest_addr>\n"
"    Extend PCR #<pcr> with digest at <digest_addr>.\n"
"    <pcr>: index of the PCR\n"
"    <digest_addr>: address of a 32-byte SHA256 digest\n"
"pcr_read <pcr> <digest_addr>\n"
"    Read PCR #<pcr> to memory address <digest_addr>.\n"
"    <pcr>: index of the PCR\n"
"    <digest_addr>: address to store the a 32-byte SHA256 digest\n"
"get_capability <capability> <property> <addr> <count>\n"
"    Read and display <count> entries indexed by <capability>/<property>.\n"
"    Values are 4 bytes long and are written at <addr>.\n"
"    <capability>: capability\n"
"    <property>: property\n"
"    <addr>: address to store <count> entries of 4 bytes\n"
"    <count>: number of entries to retrieve\n"
"dam_reset [<password>]\n"
"    If the TPM is not in a LOCKOUT state, reset the internal error counter.\n"
"    <password>: optional password\n"
"dam_parameters <max_tries> <recovery_time> <lockout_recovery> [<password>]\n"
"    If the TPM is not in a LOCKOUT state, set the DAM parameters\n"
"    <maxTries>: maximum number of failures before lockout,\n"
"                0 means always locking\n"
"    <recoveryTime>: time before decrement of the error counter,\n"
"                    0 means no lockout\n"
"    <lockoutRecovery>: time of a lockout (before the next try),\n"
"                       0 means a reboot is needed\n"
"    <password>: optional password of the LOCKOUT hierarchy\n"
"change_auth <hierarchy> <new_pw> [<old_pw>]\n"
"    <hierarchy>: the hierarchy\n"
"    <new_pw>: new password for <hierarchy>\n"
"    <old_pw>: optional previous password of <hierarchy>\n"
"pcr_setauthpolicy|pcr_setauthvalue <pcr> <key> [<password>]\n"
"    Change the <key> to access PCR #<pcr>.\n"
"    hierarchy and may be empty.\n"
"    /!\\WARNING: untested function, use at your own risks !\n"
"    <pcr>: index of the PCR\n"
"    <key>: secret to protect the access of PCR #<pcr>\n"
"    <password>: optional password of the PLATFORM hierarchy\n"
)Issue a TPMv2.x command<command> [<arguments>]

info
    Show information about the TPM.
init
    Initialize the software stack. Always the first command to issue.
startup <mode>
    Issue a TPM2_Startup command.
    <mode> is one of:
        * TPM2_SU_CLEAR (reset state)
        * TPM2_SU_STATE (preserved state)
self_test <type>
    Test the TPM capabilities.
    <type> is one of:
        * full (perform all tests)
        * continue (only check untested tests)
clear <hierarchy>
    Issue a TPM2_Clear command.
    <hierarchy> is one of:
        * TPM2_RH_LOCKOUT
        * TPM2_RH_PLATFORM
pcr_extend <pcr> <digest_addr>
    Extend PCR #<pcr> with digest at <digest_addr>.
    <pcr>: index of the PCR
    <digest_addr>: address of a 32-byte SHA256 digest
pcr_read <pcr> <digest_addr>
    Read PCR #<pcr> to memory address <digest_addr>.
    <pcr>: index of the PCR
    <digest_addr>: address to store the a 32-byte SHA256 digest
get_capability <capability> <property> <addr> <count>
    Read and display <count> entries indexed by <capability>/<property>.
    Values are 4 bytes long and are written at <addr>.
    <capability>: capability
    <property>: property
    <addr>: address to store <count> entries of 4 bytes
    <count>: number of entries to retrieve
dam_reset [<password>]
    If the TPM is not in a LOCKOUT state, reset the internal error counter.
    <password>: optional password
dam_parameters <max_tries> <recovery_time> <lockout_recovery> [<password>]
    If the TPM is not in a LOCKOUT state, set the DAM parameters
    <maxTries>: maximum number of failures before lockout,
                0 means always locking
    <recoveryTime>: time before decrement of the error counter,
                    0 means no lockout
    <lockoutRecovery>: time of a lockout (before the next try),
                       0 means a reboot is needed
    <password>: optional password of the LOCKOUT hierarchy
change_auth <hierarchy> <new_pw> [<old_pw>]
    <hierarchy>: the hierarchy
    <new_pw>: new password for <hierarchy>
    <old_pw>: optional previous password of <hierarchy>
pcr_setauthpolicy|pcr_setauthvalue <pcr> <key> [<password>]
    Change the <key> to access PCR #<pcr>.
    hierarchy and may be empty.
    /!\WARNING: untested function, use at your own risks !
    <pcr>: index of the PCR
    <key>: secret to protect the access of PCR #<pcr>
    <password>: optional password of the PLATFORM hierarchy
"<command> [<arguments>]\n"
"\n"
"info\n"
"    Show information about the TPM.\n"
"init\n"
"    Initialize the software stack. Always the first command to issue.\n"
"startup <mode>\n"
"    Issue a TPM2_Startup command.\n"
"    <mode> is one of:\n"
"        * TPM2_SU_CLEAR (reset state)\n"
"        * TPM2_SU_STATE (preserved state)\n"
"self_test <type>\n"
"    Test the TPM capabilities.\n"
"    <type> is one of:\n"
"        * full (perform all tests)\n"
"        * continue (only check untested tests)\n"
"clear <hierarchy>\n"
"    Issue a TPM2_Clear command.\n"
"    <hierarchy> is one of:\n"
"        * TPM2_RH_LOCKOUT\n"
"        * TPM2_RH_PLATFORM\n"
"pcr_extend <pcr> <digest_addr>\n"
"    Extend PCR #<pcr> with digest at <digest_addr>.\n"
"    <pcr>: index of the PCR\n"
"    <digest_addr>: address of a 32-byte SHA256 digest\n"
"pcr_read <pcr> <digest_addr>\n"
"    Read PCR #<pcr> to memory address <digest_addr>.\n"
"    <pcr>: index of the PCR\n"
"    <digest_addr>: address to store the a 32-byte SHA256 digest\n"
"get_capability <capability> <property> <addr> <count>\n"
"    Read and display <count> entries indexed by <capability>/<property>.\n"
"    Values are 4 bytes long and are written at <addr>.\n"
"    <capability>: capability\n"
"    <property>: property\n"
"    <addr>: address to store <count> entries of 4 bytes\n"
"    <count>: number of entries to retrieve\n"
"dam_reset [<password>]\n"
"    If the TPM is not in a LOCKOUT state, reset the internal error counter.\n"
"    <password>: optional password\n"
"dam_parameters <max_tries> <recovery_time> <lockout_recovery> [<password>]\n"
"    If the TPM is not in a LOCKOUT state, set the DAM parameters\n"
"    <maxTries>: maximum number of failures before lockout,\n"
"                0 means always locking\n"
"    <recoveryTime>: time before decrement of the error counter,\n"
"                    0 means no lockout\n"
"    <lockoutRecovery>: time of a lockout (before the next try),\n"
"                       0 means a reboot is needed\n"
"    <password>: optional password of the LOCKOUT hierarchy\n"
"change_auth <hierarchy> <new_pw> [<old_pw>]\n"
"    <hierarchy>: the hierarchy\n"
"    <new_pw>: new password for <hierarchy>\n"
"    <old_pw>: optional previous password of <hierarchy>\n"
"pcr_setauthpolicy|pcr_setauthvalue <pcr> <key> [<password>]\n"
"    Change the <key> to access PCR #<pcr>.\n"
"    hierarchy and may be empty.\n"
"    /!\\WARNING: untested function, use at your own risks !\n"
"    <pcr>: index of the PCR\n"
"    <key>: secret to protect the access of PCR #<pcr>\n"
"    <password>: optional password of the PLATFORM hierarchy\n"char[2406]_u_boot_list_2_cmd_2_tpm2.u_boot_list_2_cmd_2_tpm2self_testpcr_extenddam_resetdam_parameterschange_authpcr_setauthpolicypcr_setauthvalueU_BOOT_CMD_MKENT(startup, 0, 1, do_tpm2_startup, "", "")U_BOOT_CMD_MKENT(self_test, 0, 1, do_tpm2_self_test, "", "")U_BOOT_CMD_MKENT(clear, 0, 1, do_tpm2_clear, "", "")U_BOOT_CMD_MKENT(pcr_extend, 0, 1, do_tpm2_pcr_extend, "", "")U_BOOT_CMD_MKENT(pcr_read, 0, 1, do_tpm_pcr_read, "", "")U_BOOT_CMD_MKENT(get_capability, 0, 1, do_tpm_get_capability, "", "")U_BOOT_CMD_MKENT(dam_reset, 0, 1, do_tpm_dam_reset, "", "")U_BOOT_CMD_MKENT(dam_parameters, 0, 1, do_tpm_dam_parameters, "", "")U_BOOT_CMD_MKENT(change_auth, 0, 1, do_tpm_change_auth, "", "")U_BOOT_CMD_MKENT(pcr_setauthpolicy, 0, 1,
			 do_tpm_pcr_setauthpolicy, "", "")U_BOOT_CMD_MKENT(pcr_setauthvalue, 0, 1,
			 do_tpm_pcr_setauthvalue, "", "")/*
	 * No Dictionary Attack Mitigation (DAM) means:
	 * maxtries = 0xFFFFFFFF, recovery_time = 1, lockout_recovery = 0
	 *//opt/src/cmd/tpm_test.ctpm_testdo_tpmtestargc = %d, argv = "argc = %d, argv = " %s" %s"
------
"\n------\n"cmd_tbl_t[14]cmd_tbl_s[14]cmd_cros_tpm_subARRAY_SIZE(cmd_cros_tpm_sub)do_test_timerdo_test_write_limitwrite_limitdo_test_timingdo_test_startupdo_test_space_permspace_permdo_test_redefine_unownedredefine_unowneddo_test_readonlydo_test_lockdo_test_global_lockglobal_lockdo_test_fast_enablefast_enabledo_test_enabledo_test_early_nvram2early_nvram2do_test_early_nvramearly_nvramdo_test_early_extendearly_extendtest_write_limitTesting writelimit ...
"Testing writelimit ...\n"TlclStartupIfNeeded(dev)TPM_CHECK(TlclStartupIfNeeded(dev))TEST FAILED: line %d: TlclStartupIfNeeded(dev): 0x%x
452tpm_self_test_full(dev)TPM_CHECK(tpm_self_test_full(dev))TEST FAILED: line %d: tpm_self_test_full(dev): 0x%x
453tpm_tsc_physical_presence(dev, PRESENCE)tpm_tsc_physical_presence(dev, 8)TPM_CHECK(tpm_tsc_physical_presence(dev, PRESENCE))TEST FAILED: line %d: tpm_tsc_physical_presence(dev, PRESENCE): 0x%x
454tpm_force_clear(dev)TPM_CHECK(tpm_force_clear(dev))TEST FAILED: line %d: tpm_force_clear(dev): 0x%x
455tpm_physical_enable(dev)TPM_CHECK(tpm_physical_enable(dev))TEST FAILED: line %d: tpm_physical_enable(dev): 0x%x
456tpm_physical_set_deactivated(dev, 0)TPM_CHECK(tpm_physical_set_deactivated(dev, 0))TEST FAILED: line %d: tpm_physical_set_deactivated(dev, 0): 0x%x
457TPM_MAX_NV_WRITES_NOOWNERTPM_MAX_NV_WRITES_NOOWNER + 2	writing %d
"\twriting %d\n"55920INDEX0sizeof(i)i >= TPM_MAX_NV_WRITES_NOOWNERi >= 64assert(i >= TPM_MAX_NV_WRITES_NOOWNER)cmd/tpm_test.c467"\tunexpected error code %d (0x%x)\n"result, resultpr_err("\tunexpected error code %d (0x%x)\n",
			      result, result)pr_fmt("\tunexpected error code %d (0x%x)\n")	unexpected error code %d (0x%x)
475476477tpm_nv_write_value(dev, INDEX0, (uint8_t *)&i, sizeof(i))tpm_nv_write_value(dev, 0xda70, (uint8_t *)&i, sizeof(i))TPM_CHECK(tpm_nv_write_value(dev, INDEX0, (uint8_t *)&i, sizeof(i)))TEST FAILED: line %d: tpm_nv_write_value(dev, INDEX0, (uint8_t *)&i, sizeof(i)): 0x%x
char[87]480	done
"\tdone\n"test_timingTesting timing ..."Testing timing ..."TTPM_CHECK(TlclStartupIfNeeded(dev), 50)	TlclStartupIfNeeded(dev): error 0x%x
	TlclStartupIfNeeded(dev): %lu ms
TTPM_CHECK(TlclStartupIfNeeded(dev), 50	TlclStartupIfNeeded(dev) exceeded 50 ms
tpm_continue_self_test(dev)TTPM_CHECK(tpm_continue_self_test(dev), 100)	tpm_continue_self_test(dev): error 0x%x
	tpm_continue_self_test(dev): %lu ms
TTPM_CHECK(tpm_continue_self_test(dev), 100	tpm_continue_self_test(dev) exceeded 100 ms
TTPM_CHECK(tpm_self_test_full(dev), 1000)	tpm_self_test_full(dev): error 0x%x
	tpm_self_test_full(dev): %lu ms
TTPM_CHECK(tpm_self_test_full(dev), 1000	tpm_self_test_full(dev) exceeded 1000 ms
TTPM_CHECK(tpm_tsc_physical_presence(dev, PRESENCE), 100)	tpm_tsc_physical_presence(dev, PRESENCE): error 0x%x
	tpm_tsc_physical_presence(dev, PRESENCE): %lu ms
TTPM_CHECK(tpm_tsc_physical_presence(dev, PRESENCE), 100	tpm_tsc_physical_presence(dev, PRESENCE) exceeded 100 ms
tpm_nv_write_value(dev, INDEX0, (uint8_t *)&x, sizeof(x))tpm_nv_write_value(dev, 0xda70, (uint8_t *)&x, sizeof(x))TTPM_CHECK(tpm_nv_write_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)),
		   100)sizeof(x)	tpm_nv_write_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)): error 0x%x
	tpm_nv_write_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)): %lu ms
TTPM_CHECK(tpm_nv_write_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)),
		   100	tpm_nv_write_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)) exceeded 100 ms
tpm_nv_read_value(dev, INDEX0, (uint8_t *)&x, sizeof(x))tpm_nv_read_value(dev, 0xda70, (uint8_t *)&x, sizeof(x))TTPM_CHECK(tpm_nv_read_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)),
		   100)	tpm_nv_read_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)): error 0x%x
	tpm_nv_read_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)): %lu ms
char[67]TTPM_CHECK(tpm_nv_read_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)),
		   100	tpm_nv_read_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)) exceeded 100 ms
char[75]tpm_extend(dev, 0, in, out)TTPM_CHECK(tpm_extend(dev, 0, in, out), 200)	tpm_extend(dev, 0, in, out): error 0x%x
	tpm_extend(dev, 0, in, out): %lu ms
TTPM_CHECK(tpm_extend(dev, 0, in, out), 200	tpm_extend(dev, 0, in, out) exceeded 200 ms
tpm_set_global_lock(dev)TTPM_CHECK(tpm_set_global_lock(dev), 50)	tpm_set_global_lock(dev): error 0x%x
	tpm_set_global_lock(dev): %lu ms
TTPM_CHECK(tpm_set_global_lock(dev), 50	tpm_set_global_lock(dev) exceeded 50 ms
tpm_tsc_physical_presence(dev, PHYS_PRESENCE)tpm_tsc_physical_presence(dev, 4)TTPM_CHECK(tpm_tsc_physical_presence(dev, PHYS_PRESENCE), 100)	tpm_tsc_physical_presence(dev, PHYS_PRESENCE): error 0x%x
	tpm_tsc_physical_presence(dev, PHYS_PRESENCE): %lu ms
TTPM_CHECK(tpm_tsc_physical_presence(dev, PHYS_PRESENCE), 100	tpm_tsc_physical_presence(dev, PHYS_PRESENCE) exceeded 100 ms
done
"done\n"test_startupTesting startup ...
"Testing startup ...\n"	tpm startup failed with 0x%x
"\ttpm startup failed with 0x%x\n"	tpm getflags failed with 0x%x
"\ttpm getflags failed with 0x%x\n"	executing SelfTestFull
"\texecuting SelfTestFull\n"test_space_permTesting spaceperm ..."Testing spaceperm ..."366TPM_CHECK(tpm_continue_self_test(dev))TEST FAILED: line %d: tpm_continue_self_test(dev): 0x%x
367368tpm_get_permissions(dev, INDEX0, &perm)tpm_get_permissions(dev, 0xda70, &perm)TPM_CHECK(tpm_get_permissions(dev, INDEX0, &perm))TEST FAILED: line %d: tpm_get_permissions(dev, INDEX0, &perm): 0x%x
369(perm & PERMPPGL) == PERMPPGL(perm & ((1UL << (0)) | (1UL << (15)))) == ((1UL << (0)) | (1UL << (15)))assert((perm & PERMPPGL) == PERMPPGL)370tpm_get_permissions(dev, INDEX1, &perm)tpm_get_permissions(dev, 0xda71, &perm)TPM_CHECK(tpm_get_permissions(dev, INDEX1, &perm))55921TEST FAILED: line %d: tpm_get_permissions(dev, INDEX1, &perm): 0x%x
371(perm & PERMPP) == PERMPP(perm & (1UL << (0))) == (1UL << (0))assert((perm & PERMPP) == PERMPP)372test_redefine_unownedTesting redefine_unowned ..."Testing redefine_unowned ..."!tpm_is_owned(dev)assert(!tpm_is_owned(dev))TPM_CHECK(tpm_nv_read_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)))TEST FAILED: line %d: tpm_nv_read_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)): 0x%x
tpm_nv_read_value(dev, INDEX1, (uint8_t *)&x, sizeof(x))tpm_nv_read_value(dev, 0xda71, (uint8_t *)&x, sizeof(x))TPM_CHECK(tpm_nv_read_value(dev, INDEX1, (uint8_t *)&x, sizeof(x)))TEST FAILED: line %d: tpm_nv_read_value(dev, INDEX1, (uint8_t *)&x, sizeof(x)): 0x%x
TPM_NV_PER_PPWRITE | TPM_NV_PER_GLOBALLOCKtpm_nv_define_space(dev, INDEX0, perm, 2 * sizeof(uint32_t))tpm_nv_define_space(dev, 0xda70, perm, 2 * sizeof(uint32_t))TPM_CHECK(tpm_nv_define_space(dev, INDEX0, perm, 2 * sizeof(uint32_t)))sizeof(uint32_t)2 * sizeof(uint32_t)TEST FAILED: line %d: tpm_nv_define_space(dev, INDEX0, perm, 2 * sizeof(uint32_t)): 0x%x
327tpm_nv_define_space(dev, INDEX0, perm, sizeof(uint32_t))tpm_nv_define_space(dev, 0xda70, perm, sizeof(uint32_t))TPM_CHECK(tpm_nv_define_space(dev, INDEX0, perm, sizeof(uint32_t)))TEST FAILED: line %d: tpm_nv_define_space(dev, INDEX0, perm, sizeof(uint32_t)): 0x%x
328tpm_nv_define_space(dev, INDEX1, perm, 2 * sizeof(uint32_t))tpm_nv_define_space(dev, 0xda71, perm, 2 * sizeof(uint32_t))TPM_CHECK(tpm_nv_define_space(dev, INDEX1, perm, 2 * sizeof(uint32_t)))TEST FAILED: line %d: tpm_nv_define_space(dev, INDEX1, perm, 2 * sizeof(uint32_t)): 0x%x
330tpm_nv_define_space(dev, INDEX1, perm, sizeof(uint32_t))tpm_nv_define_space(dev, 0xda71, perm, sizeof(uint32_t))TPM_CHECK(tpm_nv_define_space(dev, INDEX1, perm, sizeof(uint32_t)))TEST FAILED: line %d: tpm_nv_define_space(dev, INDEX1, perm, sizeof(uint32_t)): 0x%x
331result == TPM_AREA_LOCKEDassert(result == TPM_AREA_LOCKED)338341342PHYS_PRESENCEresult == TPM_BAD_PRESENCEassert(result == TPM_BAD_PRESENCE)INDEX1351test_readonlyTesting readonly ...
"Testing readonly ...\n"PRESENCE55936INDEX_INITIALISEDread0index_0sizeof(index_0)read1index_1sizeof(index_1)read255922INDEX2index_2sizeof(index_2)read355923INDEX3index_3sizeof(index_3)Invalid contents
"Invalid contents\n"sizeof(index_0) !=
		TPM_SUCCESS"\tcould not write index 0\n"pr_err("\tcould not write index 0\n")pr_fmt("\tcould not write index 0\n")	could not write index 0
"\tindex 0 is not locked\n"pr_err("\tindex 0 is not locked\n")pr_fmt("\tindex 0 is not locked\n")	index 0 is not locked
initialise_spaces	Initialising spaces
"\tInitialising spaces\n"16385TPM_NV_PER_WRITE_STCLEAR | TPM_NV_PER_PPWRITE2147500032TPM_NV_PER_READ_STCLEAR | TPM_NV_PER_WRITE_STCLEAR2147500033TPM_NV_PER_READ_STCLEAR | TPM_NV_PER_WRITE_STCLEAR |
		TPM_NV_PER_PPWRITEtest_lockTesting lock ...
"Testing lock ...\n"	Locked 0x%x
"\tLocked 0x%x\n"test_global_lockTesting globallock ...
"Testing globallock ...\n"tpm_nv_write_value(dev, INDEX0, (uint8_t *)&zero, sizeof(uint32_t))tpm_nv_write_value(dev, 0xda70, (uint8_t *)&zero, sizeof(uint32_t))TPM_CHECK(tpm_nv_write_value(dev, INDEX0, (uint8_t *)&zero,
				     sizeof(uint32_t)))TEST FAILED: line %d: tpm_nv_write_value(dev, INDEX0, (uint8_t *)&zero, sizeof(uint32_t)): 0x%x
tpm_nv_write_value(dev, INDEX1, (uint8_t *)&zero, sizeof(uint32_t))tpm_nv_write_value(dev, 0xda71, (uint8_t *)&zero, sizeof(uint32_t))TPM_CHECK(tpm_nv_write_value(dev, INDEX1, (uint8_t *)&zero,
				     sizeof(uint32_t)))TEST FAILED: line %d: tpm_nv_write_value(dev, INDEX1, (uint8_t *)&zero, sizeof(uint32_t)): 0x%x
TPM_CHECK(tpm_set_global_lock(dev))TEST FAILED: line %d: tpm_set_global_lock(dev): 0x%x
x == 0assert(x == 0)tpm_nv_write_value(dev, INDEX1, (uint8_t *)&x, sizeof(x))tpm_nv_write_value(dev, 0xda71, (uint8_t *)&x, sizeof(x))TPM_CHECK(tpm_nv_write_value(dev, INDEX1, (uint8_t *)&x, sizeof(x)))TEST FAILED: line %d: tpm_nv_write_value(dev, INDEX1, (uint8_t *)&x, sizeof(x)): 0x%x
x == 2assert(x == 2)test_fast_enableTesting fastenable ...
"Testing fastenable ...\n"tpm_get_flags(dev, &disable, &deactivated, NULL)tpm_get_flags(dev, &disable, &deactivated, ((void *)0))TPM_CHECK(tpm_get_flags(dev, &disable, &deactivated, NULL))TEST FAILED: line %d: tpm_get_flags(dev, &disable, &deactivated, NULL): 0x%x
	disable is %d, deactivated is %d
"\tdisable is %d, deactivated is %d\n"disable == 1 && deactivated == 1assert(disable == 1 && deactivated == 1)disable == 0 && deactivated == 0assert(disable == 0 && deactivated == 0)test_enableTesting enable ...
"Testing enable ...\n"	failed to enable or activate
"\tfailed to enable or activate\n"test_early_nvram2Testing earlynvram2 ..."Testing earlynvram2 ..."tpm_startup(dev, TPM_ST_CLEAR)TPM_CHECK(tpm_startup(dev, TPM_ST_CLEAR))TEST FAILED: line %d: tpm_startup(dev, TPM_ST_CLEAR): 0x%x
TPM_CHECK(tpm_nv_write_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)))TEST FAILED: line %d: tpm_nv_write_value(dev, INDEX0, (uint8_t *)&x, sizeof(x)): 0x%x
test_early_nvramTesting earlynvram ..."Testing earlynvram ..."test_early_extendTesting earlyextend ..."Testing earlyextend ..."tpm_extend(dev, 1, value_in, value_out)TPM_CHECK(tpm_extend(dev, 1, value_in, value_out))value_invalue_outTEST FAILED: line %d: tpm_extend(dev, 1, value_in, value_out): 0x%x
tpm_is_owneduint8_t[256]tpm_nv_write_value_lock"TPM: Write lock 0x%x\n"debug("TPM: Write lock 0x%x\n", index)const char[24]TPM: Write lock 0x%x
tpm_get_flags"TPM: Got flags disable=%d, deactivated=%d, nvlocked=%d\n"pflags.disable, pflags.deactivated, pflags.nv_lockeddebug("TPM: Got flags disable=%d, deactivated=%d, nvlocked=%d\n",
	      pflags.disable, pflags.deactivated, pflags.nv_locked)TPM: Got flags disable=%d, deactivated=%d, nvlocked=%d
nvlockedtest_timerget_timer(0) = %lu
"get_timer(0) = %lu\n"TlclStartupIfNeededtpmtest"TPM tests""\n\tearly_extend\n" "\tearly_nvram\n" "\tearly_nvram2\n" "\tenable\n" "\tfast_enable\n" "\tglobal_lock\n" "\tlock\n" "\treadonly\n" "\tredefine_unowned\n" "\tspace_perm\n" "\tstartup\n" "\ttiming\n" "\twrite_limit\n"TPM tests
	early_extend
	early_nvram
	early_nvram2
	enable
	fast_enable
	global_lock
	lock
	readonly
	redefine_unowned
	space_perm
	startup
	timing
	write_limit
"\n\tearly_extend\n"
	"\tearly_nvram\n"
	"\tearly_nvram2\n"
	"\tenable\n"
	"\tfast_enable\n"
	"\tglobal_lock\n"
	"\tlock\n"
	"\treadonly\n"
	"\tredefine_unowned\n"
	"\tspace_perm\n"
	"\tstartup\n"
	"\ttiming\n"
	"\twrite_limit\n"U_BOOT_CMD(tpmtest, 2, 1, do_tpmtest, "TPM tests",
	"\n\tearly_extend\n"
	"\tearly_nvram\n"
	"\tearly_nvram2\n"
	"\tenable\n"
	"\tfast_enable\n"
	"\tglobal_lock\n"
	"\tlock\n"
	"\treadonly\n"
	"\tredefine_unowned\n"
	"\tspace_perm\n"
	"\tstartup\n"
	"\ttiming\n"
	"\twrite_limit\n")_u_boot_list_2_cmd_2_tpmtest.u_boot_list_2_cmd_2_tpmtestVOIDENT(early_extend)VOIDENT(early_nvram)VOIDENT(early_nvram2)VOIDENT(enable)VOIDENT(fast_enable)VOIDENT(global_lock)VOIDENT(lock)VOIDENT(readonly)VOIDENT(redefine_unowned)VOIDENT(space_perm)VOIDENT(startup)VOIDENT(timing)VOIDENT(write_limit)VOIDENT(timer)VOIDENT(XNAME)U_BOOT_CMD_MKENT(XNAME, 0, 1, do_test_ ## XNAME, "", ""),VOIDTEST(XFUNC)int do_test_ ## XFUNC(cmd_tbl_t *cmd_tbl, int flag, int argc, char * const argv[]) { struct udevice *dev; int ret; ret = get_tpm(&dev); if (ret) return ret; return test_ ## XFUNC(dev); }TTPM_CHECK(op,time_limit)do { ulong start, time; uint32_t __result; start = get_timer(0); __result = op; if (__result != TPM_SUCCESS) { printf("\t" #op ": error 0x%x\n", __result); return -1; } time = get_timer(start); printf("\t" #op ": %lu ms\n", time); if (time > (ulong)time_limit) { printf("\t" #op " exceeded " #time_limit " ms\n"); } } while (0)PERMPPPERMPPGL(TPM_NV_PER_PPWRITE | TPM_NV_PER_GLOBALLOCK)reboot()do { printf("\trebooting...\n"); reset_cpu(0); } while (0)0xda800xda730xda720xda710xda70TPM_CHECK(tpm_command)do { uint32_t result; result = (tpm_command); if (result != TPM_SUCCESS) { printf("TEST FAILED: line %d: " #tpm_command ": 0x%x\n", __LINE__, result); return result; } } while (0)/* Try writing again. *//* Reset write count *//*
 * Runs [op] and ensures it returns success and doesn't run longer than
 * [time_limit] in milliseconds.
 *//* Verifies that neither index0 nor index1 can be redefined *//* Turns off PP *//* Checks that index1 can *//* Verifies that index0 cannot be redefined *//* Sets the global lock *//* Redefines spaces a couple of times. *//* Ensures spaces exist. *//*
	 * Writes space, and locks it.  Then attempts to write again.
	 * I really wish I could use the imperative.
	 *//* Checks if spaces are OK or messed up *//* The initialisation did not complete *//*
	 * Checks if initialisation has completed by trying to read-lock a
	 * space that's created at the end of initialisation
	 *//* useful only the first time *//* Verifies that write to index1 fails *//* Verifies that write to index1 is still possible *//* Verifies that write to index0 fails *//* Prints error and returns on failure *//opt/src/cmd/usb.cdo_usbstarting USB...
"starting USB...\n"resetting USB...
"resetting USB...\n""serial"stopping USB..
"stopping USB..\n"USB is stopped. Please issue 'usb start' first.
"USB is stopped. Please issue 'usb start' first.\n""tree"USB device tree:
"USB device tree:\n"config for device %d
"config for device %d\n"*** No device available ***
"*** No device available ***\n"Device %d does not exist.
"Device %d does not exist.\n"stor"stor"usb_show_infodevice_active(child)UCLASS_USB_EMULUCLASS_BLKdo_usb_startBOOTSTAGE_ID_USB_STARTusb_start"usb_start"do_usb_stop_keyboarddo_usbbootusb_testDevice is no hub or does not have %d ports.
"Device is no hub or does not have %d ports.\n"'J'Setting Test_J mode"Setting Test_J mode"Setting Test_K mode"Setting Test_K mode"Setting Test_SE0_NAK mode"Setting Test_SE0_NAK mode"'P'Setting Test_Packet mode"Setting Test_Packet mode"'F'Setting Test_Force_Enable mode"Setting Test_Force_Enable mode"Unrecognized test mode: %s
Available modes: J, K, S[E0_NAK], P[acket], F[orce_Enable]
"Unrecognized test mode: %s\nAvailable modes: "
		       "J, K, S[E0_NAK], P[acket], F[orce_Enable]\n" on downstream facing port %d...
" on downstream facing port %d...\n" on upstream facing port...
" on upstream facing port...\n"usb_sndctrlpipe(dev, 0)Error during SET_FEATURE.
"Error during SET_FEATURE.\n"Test mode successfully set. Use 'usb start' to return to normal operation.
"Test mode successfully set. Use 'usb start' "
		       "to return to normal operation.\n"usb_for_each_root_devUCLASS_USBusb_show_subtreepreamblesizeof(preamble)usb_show_tree_graphhas_childUCLASS_MASS_STORAGElast_child+-"\b+-"%d "%d " %s (%s, %dmA)
" %s (%s, %dmA)\n"usb_interface * %s  %s %s %s
" %s  %s %s %s\n" %s
" %s\n"preportspeed5 Gb/s"5 Gb/s"480 Mb/s"480 Mb/s"1.5 Mb/s"1.5 Mb/s"12 Mb/s"12 Mb/s"usb_find_deviceUCLASS_USB_HUBdevice_active(hub)typeof(*hub)uclass_foreach_dev(hub, uc)hub->uclass_node.nextusb_display_configusb_config *ifdescusb_interface_descriptor *iiepdescusb_display_ep_desc     - Endpoint %d %s "     - Endpoint %d %s "In"In"Out"Out"Control"Control"Isochronous"Isochronous"Bulk"Bulk"Interrupt"Interrupt" MaxPacket %d" MaxPacket %d"&epdesc->wMaxPacketSize__le16 * Interval %dms" Interval %dms"usb_display_if_desc     Interface: %d
"     Interface: %d\n"     - Alternate Setting %d, Endpoints: %d
"     - Alternate Setting %d, Endpoints: %d\n"     - Class "     - Class "     - "     - "usb_display_conf_desc   Configuration: %d
"   Configuration: %d\n"   - Interfaces: %d %s%s%dmA
"   - Interfaces: %d %s%s%dmA\n"Self Powered "Self Powered "Bus Powered "Bus Powered "Remote Wakeup "Remote Wakeup "   - "   - "usb_display_desc%d: %s,  USB Revision %x.%x
"%d: %s,  USB Revision %x.%x\n" - %s %s %s
" - %s %s %s\n" - Class: " - Class: " - Class: (from Interface) %s
" - Class: (from Interface) %s\n"cpu_to_le16packet_size - PacketSize: %d  Configurations: %d
" - PacketSize: %d  Configurations: %d\n" - Vendor: 0x%04x  Product 0x%04x Version %d.%d
" - Vendor: 0x%04x  Product 0x%04x Version %d.%d\n"usb_display_stringPAD_SIZE((256) * sizeof(char), 1)(((((256) * sizeof(char)) - 1) / (1) + 1) * 1)(256) * sizeof(char)(uintptr_t)__buffer((uintptr_t)__buffer)(typeof((uintptr_t)__buffer))(16)-1ALLOC_CACHE_ALIGN_BUFFER(char, buffer, 256)String: "%s""String: \"%s\""usb_display_class_subSee Interface"See Interface"Human Interface, Subclass: "Human Interface, Subclass: "None"None"Boot "Boot "Keyboard"Keyboard"Mouse"Mouse""reserved"Mass Storage, "Mass Storage, "RBC "RBC "SFF-8020i (ATAPI)"SFF-8020i (ATAPI)"QIC-157 (Tape)"QIC-157 (Tape)"UFI"UFI"SFF-8070"SFF-8070"Transp. SCSI"Transp. SCSI"Command/Bulk"Command/Bulk"Command/Bulk/Int"Command/Bulk/Int"Bulk only"Bulk only"usb_get_class_descAudio"Audio"Communication"Communication"Human Interface"Human Interface"Printer"Printer"Mass Storage"Mass Storage"Hub"Hub"CDC Data"CDC Data"Vendor specific"Vendor specific"usb_dev_func_tusbboot"boot from USB device"boot from USB deviceU_BOOT_CMD(
	usbboot,	3,	1,	do_usbboot,
	"boot from USB device",
	"loadAddr dev:part"
)_u_boot_list_2_cmd_2_usbboot.u_boot_list_2_cmd_2_usbboot"USB sub-system""start - start (scan) USB controller\n" "usb reset - reset (rescan) USB controller\n" "usb stop [f] - stop USB [f]=force stop\n" "usb tree - show USB device tree\n" "usb info [dev] - show available USB devices\n" "usb test [dev] [port] [mode] - set USB 2.0 test mode\n" "    (specify port 0 to indicate the device's upstream port)\n" "    Available modes: J, K, S[E0_NAK], P[acket], F[orce_Enable]\n" "usb storage - show details of USB storage devices\n" "usb dev [dev] - show or set current USB storage device\n" "usb part [dev] - print partition table of one or all USB storage" "    devices\n" "usb read addr blk# cnt - read `cnt' blocks starting at block `blk#'\n" "    to memory address `addr'\n" "usb write addr blk# cnt - write `cnt' blocks starting at block `blk#'\n" "    from memory address `addr'"dclassUSB sub-systemstart - start (scan) USB controller
usb reset - reset (rescan) USB controller
usb stop [f] - stop USB [f]=force stop
usb tree - show USB device tree
usb info [dev] - show available USB devices
usb test [dev] [port] [mode] - set USB 2.0 test mode
    (specify port 0 to indicate the device's upstream port)
    Available modes: J, K, S[E0_NAK], P[acket], F[orce_Enable]
usb storage - show details of USB storage devices
usb dev [dev] - show or set current USB storage device
usb part [dev] - print partition table of one or all USB storage    devices
usb read addr blk# cnt - read `cnt' blocks starting at block `blk#'
    to memory address `addr'
usb write addr blk# cnt - write `cnt' blocks starting at block `blk#'
    from memory address `addr'"start - start (scan) USB controller\n"
	"usb reset - reset (rescan) USB controller\n"
	"usb stop [f] - stop USB [f]=force stop\n"
	"usb tree - show USB device tree\n"
	"usb info [dev] - show available USB devices\n"
	"usb test [dev] [port] [mode] - set USB 2.0 test mode\n"
	"    (specify port 0 to indicate the device's upstream port)\n"
	"    Available modes: J, K, S[E0_NAK], P[acket], F[orce_Enable]\n"
#ifdef CONFIG_USB_STORAGE
	"usb storage - show details of USB storage devices\n"
	"usb dev [dev] - show or set current USB storage device\n"
	"usb part [dev] - print partition table of one or all USB storage"
	"    devices\n"
	"usb read addr blk# cnt - read `cnt' blocks starting at block `blk#'\n"
	"    to memory address `addr'\n"
	"usb write addr blk# cnt - write `cnt' blocks starting at block `blk#'\n"
	"    from memory address `addr'"char[748]U_BOOT_CMD(
	usb,	5,	1,	do_usb,
	"USB sub-system",
	"start - start (scan) USB controller\n"
	"usb reset - reset (rescan) USB controller\n"
	"usb stop [f] - stop USB [f]=force stop\n"
	"usb tree - show USB device tree\n"
	"usb info [dev] - show available USB devices\n"
	"usb test [dev] [port] [mode] - set USB 2.0 test mode\n"
	"    (specify port 0 to indicate the device's upstream port)\n"
	"    Available modes: J, K, S[E0_NAK], P[acket], F[orce_Enable]\n"
#ifdef CONFIG_USB_STORAGE
	"usb storage - show details of USB storage devices\n"
	"usb dev [dev] - show or set current USB storage device\n"
	"usb part [dev] - print partition table of one or all USB storage"
	"    devices\n"
	"usb read addr blk# cnt - read `cnt' blocks starting at block `blk#'\n"
	"    to memory address `addr'\n"
	"usb write addr blk# cnt - write `cnt' blocks starting at block `blk#'\n"
	"    from memory address `addr'"
#endif /* CONFIG_USB_STORAGE */
)_u_boot_list_2_cmd_2_usb.u_boot_list_2_cmd_2_usbusb_stor_curr_devdefined(CONFIG_USB_HOST_ETHER) && !defined(CONFIG_DM_ETH)!defined CONFIG_DM_USB && defined CONFIG_USB_KEYBOARDusb_started/* CONFIG_USB_STORAGE *//*
			 * With driver model this isn't right since we can
			 * have multiple controllers and the device numbering
			 * starts at 1 on each bus.
			 *//* Already started *//******************************************************************************
 * usb command intepreter
 *//* try to recognize ethernet devices immediately *//* !CONFIG_DM_USB *//* try to recognize storage devices immediately *//* Driver model will probe the devices as they are found *//******************************************************************************
 * usb boot command intepreter. Derived from diskboot
 *//* main routine for the tree command *//*
		 * Ignore emulators and block child devices, we only want
		 * real devices
		 *//* if not root hub *//* correct last child *//* for all children of the parent *//* device found *//* while *//* if *//* found a sister *//* found our pointer, see if we have a
				 * little sister
				 *//* search for children *//* not root? *//* Not the root of the usb tree? *//* check if we are the last one *//* check if the device has connected children *//* shows the device tree recursively *//* Device addresses start at 1 *//*
 * With driver model this isn't right since we can have multiple controllers
 * and the device numbering starts at 1 on each bus.
 * TODO(sjg@chromium.org): Add a way to specify the controller/bus.
 *//* main routine to diasplay the configs, interfaces and endpoints *//* some display routines (info command) *//* current ethernet device *//*
 * (C) Copyright 2001
 * Denis Peter, MPL AG Switzerland
 *
 * Adapted for U-Boot driver model
 * (C) Copyright 2015 Google, Inc
 *
 * Most of this source has been derived from the Linux USB
 * project.
 *//opt/src/include/generated/timestamp_autogenerated.htimestamp_autogeneratedU_BOOT_BUILD_DATE0x20190730U_BOOT_DMI_DATE"07/30/2019"U_BOOT_TZ"+0000"U_BOOT_TIME"09:43:04"U_BOOT_DATE"Jul 30 2019"/opt/src/include/timestamp.h__TIMESTAMP_H__/* __TIMESTAMP_H__ *//*
 * Copyright 2008 Extreme Engineering Solutions, Inc.
 */"generated/timestamp_autogenerated.h"/opt/src/include/generated/version_autogenerated.hversion_autogeneratedLD_VERSION_STRING"GNU ld (GNU Binutils for Ubuntu) 2.31.1"CC_VERSION_STRING"gcc (Ubuntu 8.3.0-6ubuntu1~18.10.1) 8.3.0"U_BOOT_VERSION"U-Boot " PLAIN_VERSIONPLAIN_VERSION"2019.10-rc1-dirty"/opt/src/include/version.hU_BOOT_VERSION_STRINGU_BOOT_VERSION " (" U_BOOT_DATE " - " U_BOOT_TIME " " U_BOOT_TZ ")" CONFIG_IDENT_STRING__VERSION_H__version_string/* __VERSION_H__ *//*
 * (C) Copyright 2000-2006
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 */"generated/version_autogenerated.h"<timestamp.h>/opt/src/cmd/version.cdo_versionchar[200]DISPLAY_OPTIONS_BANNER_LENGTHgcc (Ubuntu 8.3.0-6ubuntu1~18.10.1) 8.3.0
CC_VERSION_STRING "\n"GNU ld (GNU Binutils for Ubuntu) 2.31.1
LD_VERSION_STRING "\n""print monitor, compiler and linker version"print monitor, compiler and linker versionU_BOOT_CMD(
	version,	1,		1,	do_version,
	"print monitor, compiler and linker version",
	""
)_u_boot_list_2_cmd_2_version.u_boot_list_2_cmd_2_versionU-Boot 2019.10-rc1-dirty (Jul 30 2019 - 09:43:04 +0000)CONFIG_SYS_COREBOOT<version.h>/opt/src/include/virtio_types.hvirtio_types__virtio64__virtio32__virtio16_LINUX_VIRTIO_TYPES_H/* _LINUX_VIRTIO_TYPES_H *//*
 * __virtio{16,32,64} have the following meaning:
 * - __u{16,32,64} for virtio devices in legacy mode, accessed in native endian
 * - __le{16,32,64} for standard-compliant virtio devices
 *//*
 * Copyright (C) 2018, Tuomas Tynkkynen <tuomas.tynkkynen@iki.fi>
 * Copyright (C) 2018, Bin Meng <bmeng.cn@gmail.com>
 *
 * From Linux kernel include/uapi/linux/virtio_types.h
 *//* SPDX-License-Identifier: BSD-3-Clause *//opt/src/include/virtio.hvirtiovirtio_cwrite64sizeof(val)virtio_cread64sizeof(ret)virtio_cwrite32virtio_cread32virtio_cwrite16virtio_cread16virtio_cwrite8virtio_cread8virtio_cread_bytes__virtio_cread_manygencpu_to_virtio64virtio64_to_cpucpu_to_virtio32virtio32_to_cpucpu_to_virtio16virtio16_to_cpuvirtio_is_little_endianvirtio_dev_priv *uc_privvirtio_legacy_is_little_endianvirtio_has_feature__ret_warn_onWARN_ON(true)"WARNING at %s:%d/%s()!\n"__FILE__, __LINE__, __func__WARNING at %s:%d/%s()!
include/virtio.h492__compiletime_assert_473__virtio_clear_bitfbit >= 64"BUILD_BUG_ON failed: " "fbit >= 64"!(fbit >= 64)__compiletime_assert___LINE__473BUILD_BUG_ON(fbit >= 64)__condWARN_ON(fbit >= 64)fbitBIT_ULL(fbit)__compiletime_assert_452__virtio_set_bitvdev__compiletime_assert_431__virtio_test_bit431433__cpu_to_virtio64(val)((val))cpu_to_be6410952166604802803754650828807177611906121728018374686479671623680__virtio64_to_cpu(__force __le64)val(__le64)val(__force __be64)val(__be64)val(__force __u64)(__be64)((__be64)val)(__u64)(__be64)((__be64)val)((__u64)(__be64)((__be64)val))be64_to_cpulittle_endian__cpu_to_virtio32__virtio32_to_cpu(__force __le32)val(__le32)val(__force __be32)val(__be32)val(__force __u32)(__be32)((__be32)val)(__u32)(__be32)((__be32)val)((__u32)(__be32)((__be32)val))__cpu_to_virtio16cpu_to_be16__virtio16_to_cpu(__force __le16)val(__le16)val(__force __be16)val(__be16)val(__force __u16)(__be16)((__be16)val)(__u16)(__be16)((__be16)val)((__u16)(__be16)((__be16)val))be16_to_cpuvirtio_initvirtio_driver_features_initvirtio_finalize_featuresvirtio_add_statusvirtio_notifyvirtqueue *virtio_del_vqsvirtio_find_vqsvirtqueue *[]virtio_set_featuresvirtio_get_featuresvirtio_resetvirtio_set_statusvirtio_get_statusvirtio_generationvirtio_set_configvirtio_get_configvirtio_dev_privdm_virtio_opsvirtqueuevirtio_sgfeature_table_size_legacyfeature_table_legacyfeature_table_sizefeature_tablelegacyvqsnotifydel_vqsvirtqueue **find_vqsset_featuresget_featuresset_statusgenerationset_configget_configvirtio_cread_feature(vdev,fbit,structname,member,ptr)({ int _r = 0; if (!virtio_has_feature(vdev, fbit)) _r = -ENOENT; else virtio_cread(vdev, structname, member, ptr); _r; })virtio_cwrite(vdev,structname,member,ptr)do { if (!typecheck(typeof((((structname *)0)->member)), *(ptr))) WARN_ON((*ptr) == 1); switch (sizeof(*ptr)) { case 1: virtio_cwrite8(vdev, offsetof(structname, member), *(ptr)); break; case 2: virtio_cwrite16(vdev, offsetof(structname, member), *(ptr)); break; case 4: virtio_cwrite32(vdev, offsetof(structname, member), *(ptr)); break; case 8: virtio_cwrite64(vdev, offsetof(structname, member), *(ptr)); break; default: WARN_ON(true); } } while (0)virtio_cread(vdev,structname,member,ptr)do { if (!typecheck(typeof((((structname *)0)->member)), *(ptr))) (*ptr) = 1; switch (sizeof(*ptr)) { case 1: *(ptr) = virtio_cread8(vdev, offsetof(structname, member)); break; case 2: *(ptr) = virtio_cread16(vdev, offsetof(structname, member)); break; case 4: *(ptr) = virtio_cread32(vdev, offsetof(structname, member)); break; case 8: *(ptr) = virtio_cread64(vdev, offsetof(structname, member)); break; default: WARN_ON(true); } } while (0)virtio_get_ops(dev)((struct dm_virtio_ops *)(dev)->driver->ops)VIRTIO_F_SR_IOVVIRTIO_F_IOMMU_PLATFORMVIRTIO_F_VERSION_1VIRTIO_F_ANY_LAYOUTVIRTIO_F_NOTIFY_ON_EMPTYVIRTIO_TRANSPORT_F_ENDVIRTIO_TRANSPORT_F_STARTVIRTIO_CONFIG_S_FAILEDVIRTIO_CONFIG_S_NEEDS_RESETVIRTIO_CONFIG_S_FEATURES_OKVIRTIO_CONFIG_S_DRIVER_OKVIRTIO_CONFIG_S_DRIVERVIRTIO_CONFIG_S_ACKNOWLEDGEVIRTIO_BLK_DRV_NAME"virtio-blk"VIRTIO_NET_DRV_NAME"virtio-net"VIRTIO_ID_MAX_NUMVIRTIO_ID_BLOCKVIRTIO_ID_NET__VIRTIO_H__VIRTIO_CONFIG_NO_LEGACYBUILD_BUG_ON failed: fbit >= 64/* __VIRTIO_H__ *//* Conditional config space accessors *//* Must match the member's type, and be integer *//* Config space write accessor *//* Config space read accessor *//* no need to check return value as generation can be optional *//* Read @count fields, @bytes each *//* Memory accessors *//**
 * virtio_has_feature - helper to determine if this device has this feature
 *
 * Note this API is only usable after the virtio device driver's bind phase,
 * as the feature has been negotiated between the device and the driver.
 *
 * @vdev: the virtio device
 * @fbit: the feature bit
 *//* Did you forget to fix assumptions on max features? *//**
 * __virtio_clear_bit - helper to clear feature bits
 *
 * For use by transports.
 *
 * @vdev: the transport device
 * @fbit: the feature bit
 *//**
 * __virtio_set_bit - helper to set feature bits
 *
 * For use by transports.
 *
 * @udev: the transport device
 * @fbit: the feature bit
 *//**
 * __virtio_test_bit - helper to test feature bits
 *
 * For use by transports. Devices should normally use virtio_has_feature,
 * which includes more checks.
 *
 * @udev: the transport device
 * @fbit: the feature bit
 *//**
 * virtio_init() - helper to enumerate all known virtio devices
 *
 * @return 0 if OK, -ve on error
 *//**
 * virtio_driver_features_init() - initialize driver supported features
 *
 * This fills in the virtio device parent per child private data with the given
 * information, which contains driver supported features and legacy features.
 *
 * This API should be called in the virtio device driver's bind method, so that
 * later virtio transport uclass driver can utilize the driver supplied features
 * to negotiate with the device on the final supported features.
 *
 * @priv:		virtio uclass per device private data
 * @feature:		an array of feature supported by the driver
 * @feature_size:	number of entries in the feature table array
 * @feature_legacy:	same as feature_table but working in legacy mode
 * @feature_legacy_size:number of entries in feature table legacy array
 *//**
 * virtio_finalize_features() - helper to finalize features
 *
 * @vdev:	the real virtio device
 * @return 0 if OK, -ve on error
 *//**
 * virtio_add_status() - helper to set a new status code to the device
 *
 * @vdev:	the real virtio device
 * @status:	new status code to be added
 *//**
 * virtio_notify() - notify the device to process the queue
 *
 * @vdev:	the real virtio device
 * @vq:		virtqueue to process
 * @return 0 if OK, -ve on error
 *//**
 * virtio_del_vqs() - free virtqueues found by find_vqs()
 *
 * @vdev:	the real virtio device
 * @return 0 if OK, -ve on error
 *//**
 * virtio_find_vqs() - find virtqueues and instantiate them
 *
 * @vdev:	the real virtio device
 * @nvqs:	the number of virtqueues to find
 * @vqs:	on success, includes new virtqueues
 * @return 0 if OK, -ve on error
 *//**
 * virtio_set_features() - confirm what device features we'll be using
 *
 * @vdev:	the real virtio device
 * @return 0 if OK, -ve on error
 *//**
 * virtio_get_features() - get the array of feature bits for this device
 *
 * @vdev:	the real virtio device
 * @features:	the first 32 feature bits (all we currently need)
 * @return 0 if OK, -ve on error
 *//**
 * virtio_reset() - reset the device
 *
 * @vdev:	the real virtio device
 * @return 0 if OK, -ve on error
 *//**
 * virtio_set_status() - write the status byte
 *
 * @vdev:	the real virtio device
 * @status:	the new status byte
 * @return 0 if OK, -ve on error
 *//**
 * virtio_get_status() - read the status byte
 *
 * @vdev:	the real virtio device
 * @status:	the returned status byte
 * @return 0 if OK, -ve on error
 *//**
 * virtio_generation() - config generation counter
 *
 * @vdev:	the real virtio device
 * @counter:	the returned config generation counter
 * @return 0 if OK, -ve on error
 *//**
 * virtio_set_config() - write the value of a configuration field
 *
 * @vdev:	the real virtio device
 * @offset:	the offset of the configuration field
 * @buf:	the buffer to read the field value from
 * @len:	the length of the buffer
 * @return 0 if OK, -ve on error
 *//**
 * virtio_get_config() - read the value of a configuration field
 *
 * @vdev:	the real virtio device
 * @offset:	the offset of the configuration field
 * @buf:	the buffer to write the field value into
 * @len:	the length of the buffer
 * @return 0 if OK, -ve on error
 *//**
 * virtio uclass per device private data
 *
 * @vqs:			virtualqueue for the virtio device
 * @vdev:			the real virtio device underneath
 * @legacy:			is it a legacy device?
 * @device:			virtio device ID
 * @vendor:			virtio vendor ID
 * @features:			negotiated supported features
 * @feature_table:		an array of feature supported by the driver
 * @feature_table_size:		number of entries in the feature table array
 * @feature_table_legacy:	same as feature_table but working in legacy mode
 * @feature_table_size_legacy:	number of entries in feature table legacy array
 *//* Get access to a virtio bus' operations *//**
	 * notify() - notify the device to process the queue
	 *
	 * @vdev:	the real virtio device
	 * @vq:		virtqueue to process
	 * @return 0 if OK, -ve on error
	 *//**
	 * del_vqs() - free virtqueues found by find_vqs()
	 *
	 * @vdev:	the real virtio device
	 * @return 0 if OK, -ve on error
	 *//**
	 * find_vqs() - find virtqueues and instantiate them
	 *
	 * @vdev:	the real virtio device
	 * @nvqs:	the number of virtqueues to find
	 * @vqs:	on success, includes new virtqueues
	 * @return 0 if OK, -ve on error
	 *//**
	 * set_features() - confirm what device features we'll be using
	 *
	 * @vdev:	the real virtio device
	 * @return 0 if OK, -ve on error
	 *//**
	 * get_features() - get the array of feature bits for this device
	 *
	 * @vdev:	the real virtio device
	 * @features:	the first 32 feature bits (all we currently need)
	 * @return 0 if OK, -ve on error
	 *//**
	 * reset() - reset the device
	 *
	 * @vdev:	the real virtio device
	 * @return 0 if OK, -ve on error
	 *//**
	 * set_status() - write the status byte
	 *
	 * @vdev:	the real virtio device
	 * @status:	the new status byte
	 * @return 0 if OK, -ve on error
	 *//**
	 * get_status() - read the status byte
	 *
	 * @vdev:	the real virtio device
	 * @status:	the returned status byte
	 * @return 0 if OK, -ve on error
	 *//**
	 * generation() - config generation counter
	 *
	 * @vdev:	the real virtio device
	 * @counter:	the returned config generation counter
	 * @return 0 if OK, -ve on error
	 *//**
	 * set_config() - write the value of a configuration field
	 *
	 * @vdev:	the real virtio device
	 * @offset:	the offset of the configuration field
	 * @buf:	the buffer to read the field value from
	 * @len:	the length of the buffer
	 * @return 0 if OK, -ve on error
	 *//**
	 * get_config() - read the value of a configuration field
	 *
	 * @vdev:	the real virtio device
	 * @offset:	the offset of the configuration field
	 * @buf:	the buffer to write the field value into
	 * @len:	the length of the buffer
	 * @return 0 if OK, -ve on error
	 *//* virtio bus operations *//**
 * virtio scatter-gather struct
 *
 * @addr:		sg buffer address
 * @lengh:		sg buffer length
 *//* Does the device support Single Root I/O Virtualization? *//*
 * If clear - device has the IOMMU bypass quirk feature.
 * If set - use platform tools to detect the IOMMU.
 *
 * Note the reverse polarity (compared to most other features),
 * this is for compatibility with legacy systems.
 *//* v1.0 compliant *//* VIRTIO_CONFIG_NO_LEGACY *//* Can the device handle any descriptor layout? *//*
 * Do we get callbacks when the ring is completely used,
 * even if we've suppressed them?
 *//*
 * Virtio feature bits VIRTIO_TRANSPORT_F_START through VIRTIO_TRANSPORT_F_END
 * are reserved for the transport being used (eg: virtio_ring, virtio_pci etc.),
 * the rest are per-device feature bits.
 *//* We've given up on this device *//* Device entered invalid state, driver must reset it *//* Driver has finished configuring features *//* Driver has used its parts of the config, and is happy *//* We have found a driver for the device *//* We have seen device and processed generic fields (VIRTIO_CONFIG_F_VIRTIO) *//* Status byte for guest to report progress, and synchronize features *//* virtio block *//* virtio net *//*
 * Copyright (C) 2018, Tuomas Tynkkynen <tuomas.tynkkynen@iki.fi>
 * Copyright (C) 2018, Bin Meng <bmeng.cn@gmail.com>
 *
 * VirtIO is a virtualization standard for network and disk device drivers
 * where just the guest's device driver "knows" it is running in a virtual
 * environment, and cooperates with the hypervisor. This enables guests to
 * get high performance network and disk operations, and gives most of the
 * performance benefits of paravirtualization. In the U-Boot case, the guest
 * is U-Boot itself, while the virtual environment are normally QEMU targets
 * like ARM, RISC-V and x86.
 *
 * See http://docs.oasis-open.org/virtio/virtio/v1.0/virtio-v1.0.pdf for
 * the VirtIO specification v1.0.
 *
 * This file is largely based on Linux kernel virtio_*.h files
 */feature_sizefeature_legacyfeature_legacy_sizevqnvqs/opt/src/cmd/virtio.cdo_virtio"virtio block devices sub-system""scan - initialize virtio bus\n" "virtio info - show all available virtio block devices\n" "virtio device [dev] - show or set current virtio block device\n" "virtio part [dev] - print partition table of one or all virtio block devices\n" "virtio read addr blk# cnt - read `cnt' blocks starting at block\n" "     `blk#' to memory address `addr'\n" "virtio write addr blk# cnt - write `cnt' blocks starting at block\n" "     `blk#' from memory address `addr'"virtio block devices sub-systemscan - initialize virtio bus
virtio info - show all available virtio block devices
virtio device [dev] - show or set current virtio block device
virtio part [dev] - print partition table of one or all virtio block devices
virtio read addr blk# cnt - read `cnt' blocks starting at block
     `blk#' to memory address `addr'
virtio write addr blk# cnt - write `cnt' blocks starting at block
     `blk#' from memory address `addr'"scan - initialize virtio bus\n"
	"virtio info - show all available virtio block devices\n"
	"virtio device [dev] - show or set current virtio block device\n"
	"virtio part [dev] - print partition table of one or all virtio block devices\n"
	"virtio read addr blk# cnt - read `cnt' blocks starting at block\n"
	"     `blk#' to memory address `addr'\n"
	"virtio write addr blk# cnt - write `cnt' blocks starting at block\n"
	"     `blk#' from memory address `addr'"char[428]U_BOOT_CMD(
	virtio, 8, 1, do_virtio,
	"virtio block devices sub-system",
	"scan - initialize virtio bus\n"
	"virtio info - show all available virtio block devices\n"
	"virtio device [dev] - show or set current virtio block device\n"
	"virtio part [dev] - print partition table of one or all virtio block devices\n"
	"virtio read addr blk# cnt - read `cnt' blocks starting at block\n"
	"     `blk#' to memory address `addr'\n"
	"virtio write addr blk# cnt - write `cnt' blocks starting at block\n"
	"     `blk#' from memory address `addr'"
)_u_boot_list_2_cmd_2_virtio.u_boot_list_2_cmd_2_virtiovirtio_curr_dev/* make sure all virtio devices are enumerated *//*
 * Copyright (C) 2018, Tuomas Tynkkynen <tuomas.tynkkynen@iki.fi>
 * Copyright (C) 2018, Bin Meng <bmeng.cn@gmail.com>
 */<virtio.h><virtio_types.h>/opt/src/include/w1.hw1w1_write_bytew1_write_bufw1_reset_selectw1_read_bytew1_read_bufw1_get_device_familyw1_get_busw1_opsw1_devicetripletW1_FAMILY_EEP_SANDBOXW1_FAMILY_DS2502W1_FAMILY_DS2431W1_FAMILY_DS24B33__W1_H/* SPDX-License-Identifier:	GPL-2.0+
 *
 * Copyright (c) 2015 Free Electrons
 * Copyright (c) 2015 NextThing Co
 *
 *//opt/src/include/w1-eeprom.hw1-eepromw1_eeprom_get_idw1_eeprom_register_new_devicew1_eeprom_dm_initw1_eeprom_read_bufw1_eeprom_ops__W1_EEPROM_H/*
	 * Reads a buff from the given EEPROM memory, starting at
	 * given offset and place the results into the given buffer.
	 * Should read given count of bytes.
	 * Should return 0 on success, and normal error.h on error
	 *//* SPDX-License-Identifier:	GPL-2.0+
 *
 * Copyright (c) 2015 Free Electrons
 * Copyright (c) 2015 NextThing Co
 * Copyright (c) 2018 Microchip Technology, Inc.
 *
 *//opt/src/cmd/w1.cdo_w1"bus"w1_readbus_ndev_n 512len needs to be <= 512
"len needs to be <= 512\n"one wire interface not found
"one wire interface not found\n"invalid dev
"invalid dev\n"w1_eeprom"w1_eeprom"the device present on the interface is of unknown device class
"the device present on the interface is of unknown device class\n"u8[512]unsigned char[512]error reading device %s
"error reading device %s\n"%x"%x"w1_bus  (active)"  (active)"	%s (%d) uclass %s : "\t%s (%d) uclass %s : "device error
"device error\n"family 0x%x
"family 0x%x\n""onewire interface utility commands""bus - show onewire bus info (all)\n" "w1 read [<bus> [<dev> [offset [length]]]]" "    - read from onewire device 'dev' on onewire bus 'bus'" " starting from offset 'offset' and length 'length'\n" "      defaults: bus 0, dev 0, offset 0, length 512 bytes."onewire interface utility commandsbus - show onewire bus info (all)
w1 read [<bus> [<dev> [offset [length]]]]    - read from onewire device 'dev' on onewire bus 'bus' starting from offset 'offset' and length 'length'
      defaults: bus 0, dev 0, offset 0, length 512 bytes."bus - show onewire bus info (all)\n"
	   "w1 read [<bus> [<dev> [offset [length]]]]"
	   "    - read from onewire device 'dev' on onewire bus 'bus'"
	   " starting from offset 'offset' and length 'length'\n"
	   "      defaults: bus 0, dev 0, offset 0, length 512 bytes."char[241]U_BOOT_CMD(w1, 6, 0, do_w1,
	   "onewire interface utility commands",
	   "bus - show onewire bus info (all)\n"
	   "w1 read [<bus> [<dev> [offset [length]]]]"
	   "    - read from onewire device 'dev' on onewire bus 'bus'"
	   " starting from offset 'offset' and length 'length'\n"
	   "      defaults: bus 0, dev 0, offset 0, length 512 bytes.")_u_boot_list_2_cmd_2_w1.u_boot_list_2_cmd_2_w1/* SPDX-License-Identifier: GPL-2.0+
 *
 * (C) Copyright 2018
 * Microchip Technology, Inc.
 * Eugen Hristev <eugen.hristev@microchip.com>
 */<w1-eeprom.h><w1.h>/opt/src/include/bzlib.hbzlibBZ2_bzlibVersionBZ2_bzBuffToBuffDecompressBZ2_bzBuffToBuffCompressBZ2_bzDecompressEndbz_stream *BZ2_bzDecompressBZ2_bzDecompressInitBZ2_bzCompressEndBZ2_bzCompressBZ2_bzCompressInitbz_streambzfreebzalloctotal_out_hi32total_out_lo32total_in_hi32total_in_lo32BZ_EXTERNBZ_API(func)BZ_EXPORTBZ_CONFIG_ERROR(-9)BZ_OUTBUFF_FULL(-8)BZ_UNEXPECTED_EOF(-7)BZ_IO_ERRORBZ_DATA_ERROR_MAGICBZ_DATA_ERRORBZ_MEM_ERRORBZ_PARAM_ERRORBZ_SEQUENCE_ERRORBZ_STREAM_ENDBZ_FINISH_OKBZ_FLUSH_OKBZ_RUN_OKBZ_OKBZ_FINISHBZ_FLUSHBZ_RUNBZ_NO_STDIO_BZLIB_HBZ_IMPORTsmall/*-------------------------------------------------------------*//*--- end                                           bzlib.h ---*//*--
   Code contributed by Yoshioka Tsuneo
   (QWF00133@niftyserve.or.jp/tsuneo-y@is.aist-nara.ac.jp),
   to support better zlib compatibility.
   This code is not _officially_ part of libbzip2 (yet);
   I haven't tested it, documented it, or considered the
   threading-safeness of it.
   If this code breaks, please contact both Yoshioka and me.
--*//*-- Utility functions --*//* Need a definitition for FILE *//*-- High(er) level library functions --*//*-- Core (low-level) library functions --*//* import windows dll dynamically *//* windows.h define small to char *//* End of configuration for U-Boot environment *//* Configure for U-Boot environment *//*--
  This file is a part of bzip2 and/or libbzip2, a program and
  library for lossless, block-sorting data compression.

  Copyright (C) 1996-2002 Julian R Seward.  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. The origin of this software must not be misrepresented; you must
     not claim that you wrote the original software.  If you use this
     software in a product, an acknowledgment in the product
     documentation would be appreciated but is not required.

  3. Altered source versions must be plainly marked as such, and must
     not be misrepresented as being the original software.

  4. The name of the author may not be used to endorse or promote
     products derived from this software without specific prior written
     permission.

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  Julian Seward, Cambridge, UK.
  jseward@acm.org
  bzip2/libbzip2 version 1.0 of 21 March 2000

  This program is based on (at least) the work of:
     Mike Burrows
     David Wheeler
     Peter Fenwick
     Alistair Moffat
     Radford Neal
     Ian H. Witten
     Robert Sedgewick
     Jon L. Bentley

  For more information on these sources, see the manual.
--*//*---                                               bzlib.h ---*//*--- Public header file for the library.                   ---*//*
 * This file is a modified version of bzlib.h from the bzip2-1.0.2
 * distribution which can be found at http://sources.redhat.com/bzip2/
 */destLenverbosityblockSize100kworkFactor/opt/src/cmd/ximg.cximgdo_imgextractuname## Copying '%s' subimage from FIT image at %08lx ...
"## Copying '%s' subimage from FIT image "
			"at %08lx ...\n"IH_COMP_NONEMust specify load address for %s command with compressed image
"Must specify load address for %s command "
				"with compressed image\n"Could not find script subimage compression type
"Could not find script subimage "
				"compression type\n"Invalid image type for imxtract
"Invalid image type for imxtract\n"   Loading part %d ... "   Loading part %d ... "CHUNKSZIH_COMP_GZIP   Uncompressing part %d ... "   Uncompressing part %d ... "unc_lenCONFIG_SYS_XIMG_LENGUNZIP ERROR - image not loaded
"GUNZIP ERROR - image not loaded\n"Unimplemented compression type %d
"Unimplemented compression type %d\n"(len)(typeof(len))(16)-1ALIGN(len, ARCH_DMA_MINALIGN)fileaddr"fileaddr"<bzlib.h>imxtract"extract a part of a multi-image"imgextract_help_textextract a part of a multi-imagechar[178]U_BOOT_CMD(
	imxtract, 4, 1, do_imgextract,
	"extract a part of a multi-image", imgextract_help_text
)_u_boot_list_2_cmd_2_imxtract.u_boot_list_2_cmd_2_imxtractaddr part [dest]
    - extract <part> from legacy image at <addr> and copy to <dest>
addr uname [dest]
    - extract <uname> subimage from FIT image at <addr> and copy to <dest>0x800000defined(CONFIG_BZIP2)CONFIG_GZIPdefined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)defined(CONFIG_BZIP2) && defined(CONFIG_LEGACY_IMAGE_FORMAT)/* CONFIG_BZIP2 *//*
				 * If we've got less than 4 MB of malloc()
				 * space, use slower decompression algorithm
				 * which requires at most 2300 KB of memory.
				 *//* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG *//* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) *//* get subimage/external data address and length *//* get subimage node offset *//* use 8MByte as default max gunzip size *//*
 * Multi Image extract
 *//*
 * (C) Copyright 2000-2004
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *
 * (C) Copyright 2003
 * Kai-Uwe Bloem, Auerswald GmbH & Co KG, <linux-development@auerswald.de>
 *//opt/src/include/android_bootloader_message.handroid_bootloader_messagebootloader_controlslot_metadatabootloader_message_abbootloader_messagecrc32_leslot_metadata[4]slot_inforecovery_tries_remainingnb_slotslot_suffixverity_corruptedsuccessful_boottries_remainingprioritychar[1888]1888update_channelchar[1184]1184char[768]recovery16 * 1024WIPE_PACKAGE_OFFSET_IN_MISCBOOTLOADER_MESSAGE_OFFSET_IN_MISCBOOT_CTRL_VERSIONBOOT_CTRL_MAGIC0x42414342__ANDROID_BOOTLOADER_MESSAGE_H(__STDC_VERSION__ >= 201112L) || defined(__cplusplus)/* __ANDROID_BOOTLOADER_MESSAGE_H *//* __UBOOT__ */// ifdef __cplusplus// C Interface.// Write the wipe package into BCB (to offset WIPE_PACKAGE_OFFSET_IN_MISC).// Read the wipe package from BCB (from offset WIPE_PACKAGE_OFFSET_IN_MISC).// Writes the reboot-bootloader reboot reason to the bootloader_message.// Clear BCB.// the command and recovery fields.// Update bootloader message (boots into recovery with the |options|) in |boot|. Will only update// only update the command and recovery fields.// Update bootloader message (boots into recovery with the options) to BCB. Will// set the command and recovery fields, and reset the rest.// Write bootloader message (boots into recovery with the options) to the specific BCB device. Will// Write bootloader message (boots into recovery with the options) to BCB. Will// Write bootloader message to the specified BCB device.// Write bootloader message to BCB.// Read bootloader message from the specified misc device into boot.// Read bootloader message into boot. Error message will be set in err.// string.// for the device for up to 10 seconds. In case of error returns the empty// Return the block device name for the bootloader message partition and waits// format).// CRC32 of all 28 bytes preceding this field (little endian// Reserved for further use.// Per-slot information.  Up to 4 slots.// Ensure 4-bytes alignment for slot_info field.// Number of times left attempting to boot recovery.// Number of slots being managed.// Version of struct being used (see BOOT_CTRL_VERSION).// Bootloader Control AB magic number (see BOOT_CTRL_MAGIC).// NUL terminated active slot suffix./* Bootloader Control AB
 *
 * This struct can be used to manage A/B metadata. It is designed to
 * be put in the 'slot_suffix' field of the 'bootloader_message'
 * structure described above. It is encouraged to use the
 * 'bootloader_control' structure to store the A/B metadata, but not
 * mandatory.
 */// otherwise.// 1 if this slot is corrupted from a dm-verity corruption, 0// 1 if this slot has booted successfully, 0 otherwise.// Number of times left attempting to boot this slot.// priority and 0 the slot is unbootable.// Slot priority with 15 meaning highest priority, 1 lowest/* Bootloader Control AB *//**
 * Be cautious about the struct size change, in case we put anything post
 * bootloader_message_ab struct (b/29159185).
 */// Round up the entire struct to 4096-byte./**
 * The A/B-specific bootloader message structure (4-KiB).
 *
 * We separate A/B boot control metadata from the regular bootloader
 * message struct and keep it here. Everything that's A/B-specific
 * stays after struct bootloader_message, which should be managed by
 * the A/B-bootloader or boot control HAL.
 *
 * The slot_suffix field is used for A/B implementations where the
 * bootloader does not set the androidboot.ro.boot.slot_suffix kernel
 * commandline parameter. This is used by fs_mgr to mount /system and
 * other partitions with the slotselect flag set in fstab. A/B
 * implementations are free to use all 32 bytes and may store private
 * data past the first NUL-byte in this field. It is encouraged, but
 * not mandatory, to use 'struct bootloader_control' described below.
 *
 * The update_channel field is used to store the Omaha update channel
 * if update_engine is compiled with Omaha support.
 *//**
 * We must be cautious when changing the bootloader_message struct size,
 * because A/B-specific fields may end up with different offsets.
 */// to 2048-byte.// 1184-byte so that the entire bootloader_message struct rounds up// carved off from the 1024-byte recovery field. Bump it up to// The 'reserved' field used to be 224 bytes when it was initially// expansion.// stage string (for multistage packages) and possible future// should be plenty.  We carve off the last 256 bytes to store the// been used to store the recovery command line, so 768 bytes// The 'recovery' field used to be 1024 bytes.  It has only ever/* Bootloader Message (2-KiB)
 *
 * This structure describes the content of a block in flash
 * that is used for recovery and the bootloader to talk to
 * each other.
 *
 * The command field is updated by linux when it wants to
 * reboot into recovery or to update radio or bootloader firmware.
 * It is also updated by the bootloader when firmware update
 * is complete (to boot into recovery for any final cleanup)
 *
 * The status field was used by the bootloader after the completion
 * of an "update-radio" or "update-hboot" command, which has been
 * deprecated since Froyo.
 *
 * The recovery field is only written by linux and used
 * for the system to send a message to recovery or the
 * other way around.
 *
 * The stage field is written by packages which restart themselves
 * multiple times, so that the UI can reflect which invocation of the
 * package it is.  If the value is of the format "#/#" (eg, "1/3"),
 * the UI will add a simple indicator of that status.
 *
 * We used to have slot_suffix field for A/B boot control metadata in
 * this struct, which gets unintentionally cleared by recovery or
 * uncrypt. Move it into struct bootloader_message_ab to avoid the
 * issue.
 */// are not configurable without changing all of them.// Note that these offsets are admitted by bootloader,recovery and uncrypt, so they// 16K - 64K    Used by uncrypt and recovery to store wipe_package for A/B devices//              as bootloader_message_ab struct)// 2K  - 16K    Used by Vendor's bootloader (the 2K - 4K range may be optionally used// 0   - 2K     For bootloader_message// Spaces used by misc partition are as below:/* compiler.h defines the types that otherwise are included from stdint.h and
 * stddef.h
 *//*
 * This is from the Android Project,
 * Repository: https://android.googlesource.com/platform/bootable/recovery
 * File: bootloader_message/include/bootloader_message/bootloader_message.h
 * Commit: See U-Boot commit description
 *
 * Copyright (C) 2008 The Android Open Source Project
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *//opt/src/common/android_ab.cconst disk_partition_tconst disk_partition_t *bootloader_control *bootloader_control **abc"ANDROID: Invalid CRC-32 (expected %.8x, found %.8x),", crc32_le, abc->crc32_leLOGL_ERR"ANDROID: Invalid CRC-32 (expected %.8x, found %.8x),"crc32_le, abc->crc32_lelog_err("ANDROID: Invalid CRC-32 (expected %.8x, found %.8x),",
			crc32_le, abc->crc32_le)common/android_ab.cANDROID: Invalid CRC-32 (expected %.8x, found %.8x),"re-initializing A/B metadata.\n"log_err("re-initializing A/B metadata.\n")re-initializing A/B metadata.
ENODATA-61-ENODATAstore_needed1111573314"ANDROID: Unknown A/B metadata: %.8x\n", abc->magic"ANDROID: Unknown A/B metadata: %.8x\n"abc->magiclog_err("ANDROID: Unknown A/B metadata: %.8x\n", abc->magic)ANDROID: Unknown A/B metadata: %.8x
"ANDROID: Unsupported A/B metadata version: %.8x\n", abc->version"ANDROID: Unsupported A/B metadata version: %.8x\n"abc->versionlog_err("ANDROID: Unsupported A/B metadata version: %.8x\n",
			abc->version)ANDROID: Unsupported A/B metadata version: %.8x
abc->slot_infoARRAY_SIZE(abc->slot_info)slot_metadata *"ANDROID: unbootable slot %d tries: %d, ", i, abc->slot_info[i].tries_remaining"ANDROID: unbootable slot %d tries: %d, "i, abc->slot_info[i].tries_remaininglog_debug("ANDROID: unbootable slot %d tries: %d, ",
				  i, abc->slot_info[i].tries_remaining)ANDROID: unbootable slot %d tries: %d, /opt/src/common<android_bootloader_message.h>"corrupt: %d\n", abc->slot_info[i].verity_corrupted"corrupt: %d\n"abc->slot_info[i].verity_corruptedlog_debug("corrupt: %d\n",
				  abc->slot_info[i].verity_corrupted)corrupt: %d
"ANDROID: bootable slot %d pri: %d, tries: %d, ", i, abc->slot_info[i].priority, abc->slot_info[i].tries_remaining"ANDROID: bootable slot %d pri: %d, tries: %d, "i, abc->slot_info[i].priority, abc->slot_info[i].tries_remaininglog_debug("ANDROID: bootable slot %d pri: %d, tries: %d, ",
			  i, abc->slot_info[i].priority,
			  abc->slot_info[i].tries_remaining)ANDROID: bootable slot %d pri: %d, tries: %d, "corrupt: %d, successful: %d\n", abc->slot_info[i].verity_corrupted, abc->slot_info[i].successful_boot"corrupt: %d, successful: %d\n"abc->slot_info[i].verity_corrupted, abc->slot_info[i].successful_bootlog_debug("corrupt: %d, successful: %d\n",
			  abc->slot_info[i].verity_corrupted,
			  abc->slot_info[i].successful_boot)corrupt: %d, successful: %d
const slot_metadataconst slot_metadata *"ANDROID: Attempting slot %c, tries remaining %d\n", BOOT_SLOT_NAME(slot), abc->slot_info[slot].tries_remaining"ANDROID: Attempting slot %c, tries remaining %d\n"BOOT_SLOT_NAME(slot), abc->slot_info[slot].tries_remaininglog_err("ANDROID: Attempting slot %c, tries remaining %d\n",
			BOOT_SLOT_NAME(slot),
			abc->slot_info[slot].tries_remaining)ANDROID: Attempting slot %c, tries remaining %d
sizeof(slot_suffix)BOOT_SLOT_NAME(slot)ab_compare_slotsab_control_storeabc_offsetbootloader_message_ab *struct bootloader_message_aboffsetof(struct bootloader_message_ab, slot_suffix)abc_blockssizeof(struct bootloader_control)part_info->blkszDIV_ROUND_UP(sizeof(struct bootloader_control),
				  part_info->blksz)(ret) >= (unsigned long)-MAX_ERRNO(ret) >= (unsigned long)-4095IS_ERR_VALUE(ret)"ANDROID: Could not write back the misc partition\n"log_err("ANDROID: Could not write back the misc partition\n")ANDROID: Could not write back the misc partition
ab_control_create_from_disk"ANDROID: Boot control block not block aligned.\n"log_err("ANDROID: Boot control block not block aligned.\n")const char[28]ANDROID: Boot control block not block aligned.
"ANDROID: boot control partition too small. Need at"log_err("ANDROID: boot control partition too small. Need at")ANDROID: boot control partition too small. Need at" least %lu blocks but have %lu blocks.\n", abc_offset + abc_blocks, part_info->size" least %lu blocks but have %lu blocks.\n"abc_offset + abc_blocks, part_info->sizelog_err(" least %lu blocks but have %lu blocks.\n",
			abc_offset + abc_blocks, part_info->size) least %lu blocks but have %lu blocks.
"ANDROID: Could not read from boot ctrl partition\n"log_err("ANDROID: Could not read from boot ctrl partition\n")ANDROID: Could not read from boot ctrl partition
"ANDROID: Loaded ABC, %lu blocks\n", abc_blocks"ANDROID: Loaded ABC, %lu blocks\n"log_debug("ANDROID: Loaded ABC, %lu blocks\n", abc_blocks)ANDROID: Loaded ABC, %lu blocks
ab_control_defaulta   "a\0\0\0"sizeof(abc->reserved0)metadatasizeof(abc->reserved1)ab_control_compute_crctypeof(*abc)offsetof(typeof(*abc), crc32_le)/*
		 * Legacy user-space requires this field to be set in the BCB.
		 * Newer releases load this slot suffix from the command line
		 * or the device tree.
		 *//* Safety check: limit the number of slots. *//*
	 * At this point a valid boot control metadata is stored in abc,
	 * followed by other reserved data in the same block. We select a with
	 * the higher priority slot that
	 *  - is not marked as corrupted and
	 *  - either has tries_remaining > 0 or successful_boot is true.
	 * If the selected slot has a false successful_boot, we also decrement
	 * the tries_remaining until it eventually becomes unbootable because
	 * tries_remaining reaches 0. This mechanism produces a bootloader
	 * induced rollback, typically right after a failed update.
	 *//*
		 * This condition represents an actual problem with the code or
		 * the board setup, like an invalid partition information.
		 * Signal a repair mode and do not try to boot from either slot.
		 *//* Higher tries_remaining is better to ensure round-robin *//* Higher successful_boot value is better, in case of same priority *//* Higher priority is better *//**
 * Compare two slots.
 *
 * The function determines slot which is should we boot from among the two.
 *
 * @param[in] a The first bootable slot metadata
 * @param[in] b The second bootable slot metadata
 * @return Negative if the slot "a" is better, positive of the slot "b" is
 *         better or 0 if they are equally good.
 *//**
 * Store the loaded boot_control block.
 *
 * Store back to the same location it was read from with
 * ab_control_create_from_misc().
 *
 * @param[in] dev_desc Device where we should write the boot_control struct
 * @param[in] part_info Partition on the 'dev_desc' where to write
 * @param[in] abc Pointer to the boot control struct and the extra bytes after
 *                it up to the nearest block boundary
 * @return 0 on success and a negative on error
 *//**
 * Load the boot_control struct from disk into newly allocated memory.
 *
 * This function allocates and returns an integer number of disk blocks,
 * based on the block size of the passed device to help performing a
 * read-modify-write operation on the boot_control struct.
 * The boot_control struct offset (2 KiB) must be a multiple of the device
 * block size, for simplicity.
 *
 * @param[in] dev_desc Device where to read the boot_control struct from
 * @param[in] part_info Partition in 'dev_desc' where to read from, normally
 *			the "misc" partition should be used
 * @param[out] pointer to pointer to bootloader_control data
 * @return 0 on success and a negative on error
 *//**
 * Initialize bootloader_control to the default value.
 *
 * It allows us to boot all slots in order from the first one. This value
 * should be used when the bootloader message is corrupted, but not when
 * a valid message indicates that all slots are unbootable.
 *
 * @param[in] abc bootloader control block
 *
 * @return 0 on success and a negative on error
 *//**
 * Compute the CRC-32 of the bootloader control struct.
 *
 * Only the bytes up to the crc32_le field are considered for the CRC-32
 * calculation.
 *
 * @param[in] abc bootloader control block
 *
 * @return crc32 sum
 *//opt/src/include/post.hpost_POST_HCONFIG_POST_EXTERNAL_WORD_FUNCSCONFIG_SYS_POST_WORD_ADDRdefined(CONFIG_ARCH_MPC8360)defined (CONFIG_MPC85xx)defined (CONFIG_MPC86xx)_POST_WORD_ADDR(__GNUC__ >= 4 && __GNUC_MINOR__ >= 3)/* _POST_H *//* CONFIG_POST *//* __GNUC__ *//* Tag_GNU_Power_ABI_FP/soft-float *//*
 *  If GCC is configured to use a version of GAS that supports
 * the .gnu_attribute directive, it will use that directive to
 * record certain properties of the output code.
 *  This feature is new to GCC 4.3.0.
 *  .gnu_attribute is new to GAS 2.18.
 *//* Interrupt POST sequence on fail *//* Use failbootcmd if test failed *//* test runs before relocation *//* test may cause rebooting *//* test runs on diag command *//* test runs in RAM *//* test runs in ROM *//* first boot after power-on *//* test runs after watchdog reset *//* test is slow, enabled by key press *//* test runs on normal booting *//* test runs on power-on booting *//* defined (CONFIG_POST) *//* CONFIG_POST_EXTERNAL_WORD_FUNCS *//* CONFIG_SYS_POST_WORD_ADDR *//*
 * (C) Copyright 2002
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *
 * (C) Copyright 2010
 * Michael Zaidman, Kodak, michael.zaidman@kodak.com
 * post_word_{load|store} cleanup.
 *//opt/src/common/autoboot.cautobootautoboot_command"### main_loop: bootcmd=\"%s\"\n"s ? s : "<UNDEFINED>"debug("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>")common/autoboot.c### main_loop: bootcmd="%s"
<UNDEFINED>"<UNDEFINED>"bootdelay_processbootdelay"bootdelay"CONFIG_BOOTDELAY"### main_loop entered: bootdelay=%d\n\n"debug("### main_loop entered: bootdelay=%d\n\n", bootdelay)### main_loop entered: bootdelay=%d

altbootcmd"altbootcmd"process_fdt_optionskernel-offset"kernel-offset"kernaddr"kernaddr"rootdisk-offset"rootdisk-offset"rootaddr"rootaddr"abortboot__abortbootHit any key to stop autoboot: %2d "Hit any key to stop autoboot: %2d " 0"\b\b\b 0"ts%2d "\b\b\b%2d "stored_bootdelaydebug_bootkeys(fmt,args...)debug_cond(DEBUG_BOOTKEYS, fmt, ## args)DEBUG_BOOTKEYSMAX_DELAY_STOP_STRdefined(CONFIG_AUTOBOOT_KEYED)defined(CONFIG_AUTOBOOT_STOP_STR_SHA256)CONFIG_AUTOBOOT_DELAY_STRCONFIG_AUTOBOOT_STOP_STRCONFIG_AUTOBOOT_PROMPTCONFIG_MENUKEYCONFIG_MENUPROMPTdefined(CONFIG_OF_CONTROL) && defined(CONFIG_SYS_TEXT_BASE)defined(CONFIG_AUTOBOOT_KEYED) && !defined(CONFIG_AUTOBOOT_KEYED_CTRLC)/* CONFIG_MENUKEY *//* restore Control C checking *//* disable Control C checking *//* CONFIG_OF_CONTROL && CONFIG_SYS_TEXT_BASE *//* Add an env variable to point to a root disk, if available *//* Add an env variable to point to a kernel payload, if available *//* CONFIG_AUTOBOOT_KEYED *//* consume input	*//* no more delay	*//* don't auto boot	*//* we got a key press	*//* delay 1000 ms *//*
	 * Check if key already pressed
	 *//* !defined(CONFIG_AUTOBOOT_KEYED) *//*
	 * CONFIG_AUTOBOOT_PROMPT includes the %d for all boards.
	 * To print the bootdelay value upon bootup.
	 *//***************************************************************************
 * Watch for 'delay' seconds for autoboot stop or autoboot delay string.
 * returns: 0 -  no key string, allow autoboot 1 - got key string, abort
 *//* don't retry auto boot *//* In order to keep up with incoming data, check timeout only
	 * when catch up.
	 *//* And check if sha matches saved value in env *//* Calculate sha256 upon each new char *//* Check for input string overflow *//*
	 * We don't know how long the stop-string is, so we need to
	 * generate the sha256 hash upon each input character and
	 * compare the value with the one saved in the environment
	 *//*
	 * Generate the binary value from the environment hash value
	 * so that we can compare this value with the computed hash
	 * from the user input
	 *//*
 * Use a "constant-length" time compare function for this
 * hash compare:
 *
 * https://crackstation.net/hashing-security.htm
 *//* Stored value of bootdelay, used by autoboot_command() *//opt/src/include/autoboot.h<u-boot/sha256.h><post.h><menu.h><autoboot.h>/opt/src/include/tee.htee_optee_ta_uuid_to_octetsTEE_UUID_LENconst tee_optee_ta_uuidconst tee_optee_ta_uuid *tee_optee_ta_uuid *tee_optee_ta_uuid_from_octetsconst u8[16]tee_invoke_functee_invoke_arg *tee_param *tee_close_sessiontee_open_sessiontee_open_session_arg *tee_get_versiontee_version_data *tee_find_devicetee_shm_is_registeredtee_shm *tee_shm_freetee_shm_registertee_shm **tee_shm_alloc__tee_shm_addtee_driver_opstee_version_datatee_invoke_argtee_open_session_argtee_paramtee_param_valuetee_param_memreftee_shmtee_optee_ta_uuidshm_unregistershm_registerinvoke_funcclose_sessionopen_sessiongen_capsret_originclnt_loginclnt_uuidmemrefshmshm_offsclock_seq_and_nodetime_hi_and_versiontime_midtime_lowTEE_ORIGIN_TRUSTED_APPTEE_ORIGIN_TEETEE_ORIGIN_COMMSTEE_ERROR_STORAGE_NO_SPACE0xffff3041TEE_ERROR_TARGET_DEAD0xffff3024TEE_ERROR_OVERFLOW0xffff300fTEE_ERROR_OUT_OF_MEMORY0xffff000cTEE_ERROR_SECURITY0xffff000fTEE_ERROR_COMMUNICATION0xffff000eTEE_ERROR_NOT_SUPPORTED0xffff000aTEE_ERROR_NOT_IMPLEMENTED0xffff0009TEE_ERROR_ITEM_NOT_FOUND0xffff0008TEE_ERROR_BAD_PARAMETERS0xffff0006TEE_ERROR_GENERICTEE_ERROR_STORAGE_NOT_AVAILABLE0xf0100003TEE_SUCCESSTEE_PARAM_ATTR_MASK(TEE_PARAM_ATTR_TYPE_MASK | TEE_PARAM_ATTR_META)TEE_PARAM_ATTR_METATEE_PARAM_ATTR_TYPE_MASKTEE_PARAM_ATTR_TYPE_MEMREF_INOUTTEE_PARAM_ATTR_TYPE_MEMREF_OUTPUTTEE_PARAM_ATTR_TYPE_MEMREF_INPUTTEE_PARAM_ATTR_TYPE_VALUE_INOUTTEE_PARAM_ATTR_TYPE_VALUE_OUTPUTTEE_PARAM_ATTR_TYPE_VALUE_INPUTTEE_PARAM_ATTR_TYPE_NONETEE_SHM_ALLOCTEE_SHM_SEC_REGISTERTEE_SHM_REGISTERTEE_GEN_CAP_REG_MEMTEE_GEN_CAP_GP__TEE_H/* __TEE_H *//**
 * tee_optee_ta_uuid_to_octets() - Converts from struct tee_optee_ta_uuid
 * @d:	Destination UUID octets
 * @s:	Source struct
 *
 * Conversion from a struct tee_optee_ta_uuid represantion to binary octet
 * representation.
 *//**
 * tee_optee_ta_uuid_from_octets() - Converts to struct tee_optee_ta_uuid
 * @d:	Destination struct
 * @s:	Source UUID octets
 *
 * Conversion to a struct tee_optee_ta_uuid represantion from binary octet
 * representation.
 *//**
 * tee_invoke_func() - Invoke a function in a Trusted Application
 * @dev:	The TEE device
 * @arg:	Invoke arguments
 * @num_param:	Number of elements in @param
 * @param:	Parameters for Trusted Application
 *
 * Returns < 0 on error else see @arg->ret for result.
 *//**
 * tee_close_session() - Close a session to a Trusted Application
 * @dev:	The TEE device
 * @session:	Session id
 *
 * Return < 0 on error else 0, regardless the session will not be valid
 * after this function has returned.
 *//**
 * tee_open_session() - Open a session to a Trusted Application
 * @dev:	The TEE device
 * @arg:	Open session arguments
 * @num_param:	Number of elements in @param
 * @param:	Parameters for Trusted Application
 *
 * Returns < 0 on error else see @arg->ret for result. If @arg->ret is
 * TEE_SUCCESS the session identifier is available in @arg->session.
 *//**
 * tee_get_version() - Query capabilities of TEE device
 * @dev:	The TEE device
 * @vers:	Pointer to version data
 *//**
 * tee_find_device() - Look up a TEE device
 * @start:	if not NULL, continue search after this device
 * @match:	function to check TEE device, returns != 0 if the device
 *		matches
 * @data:	data for match function
 * @vers:	if not NULL, version data of TEE device of the device returned
 *
 * Returns a probed TEE device of the first TEE device matched by the
 * match() callback or NULL.
 *//**
 * tee_shm_is_registered() - Check register status of shared memory object
 * @shm:	Pointer to shared memory object
 * @dev:	The TEE device
 *
 * Returns true if the shared memory object is registered for the supplied
 * TEE device
 *//**
 * tee_shm_free() - Frees shared memory
 * @shm:	Shared memory object
 *//**
 * tee_shm_register() - Registers shared memory
 * @dev:	The TEE device
 * @addr:	Address of memory block
 * @size:	Size of memory block
 * @flags:	TEE_SHM_* above
 * @shmp:	If the function return 0, this holds the allocated
 *		struct tee_shm
 *
 * returns 0 on success or < 0 on failure.
 *//**
 * tee_shm_alloc() - Allocate shared memory
 * @dev:	The TEE device
 * @size:	Size of memory block
 * @flags:	TEE_SHM_* above
 * @shmp:	If the function return 0, this holds the allocated
 *		struct tee_shm
 *
 * returns 0 on success or < 0 on failure.
 *//**
 * __tee_shm_add() - Internal helper function to register shared memory
 * @dev:	The TEE device
 * @align:	Required alignment of allocated memory block if
 *		(@flags & TEE_SHM_ALLOC)
 * @addr:	Address of memory block, ignored if (@flags & TEE_SHM_ALLOC)
 * @size:	Size of memory block
 * @flags:	TEE_SHM_* above
 * @shmp:	If the function return 0, this holds the allocated
 *		struct tee_shm
 *
 * returns 0 on success or < 0 on failure.
 *//**
	 * shm_unregister() - Unregisters memory shared with the TEE
	 * @dev:	The TEE device
	 * @shm:	Pointer to a shared memory object
	 * Returns 0 on success or < 0 on failure.
	 *//**
	 * shm_register() - Registers memory shared with the TEE
	 * @dev:	The TEE device
	 * @shm:	Pointer to a shared memory object
	 * Returns 0 on success or < 0 on failure.
	 *//**
	 * tee_invoke_func() - Invoke a function in a Trusted Application
	 * @dev:	The TEE device
	 * @arg:	Invoke arguments
	 * @num_param:	Number of elements in @param
	 * @param:	Parameters for Trusted Application
	 *
	 * Returns < 0 on error else see @arg->ret for result.
	 *//**
	 * close_session() - Close a session to a Trusted Application
	 * @dev:	The TEE device
	 * @session:	Session id
	 *
	 * Return < 0 on error else 0, regardless the session will not be valid
	 * after this function has returned.
	 *//**
	 * open_session() - Open a session to a Trusted Application
	 * @dev:	The TEE device
	 * @arg:	Open session arguments
	 * @num_param:	Number of elements in @param
	 * @param:	Parameters for Trusted Application
	 *
	 * Returns < 0 on error else see @arg->ret for result. If @arg->ret is
	 * TEE_SUCCESS the session identifier is available in @arg->session.
	 *//**
	 * get_version() - Query capabilities of TEE device
	 * @dev:	The TEE device
	 * @vers:	Pointer to version data
	 *//**
 * struct tee_driver_ops - TEE driver operations
 * @get_version:	Query capabilities of TEE device,
 * @open_session:	Opens a session to a Trusted Application in the TEE,
 * @close_session:	Closes a session to Trusted Application,
 * @invoke_func:	Invokes a function in a Trusted Application,
 * @shm_register:	Registers memory shared with the TEE
 * @shm_unregister:	Unregisters memory shared with the TEE
 *//**
 * struct tee_version_data - description of TEE
 * @gen_caps:	Generic capabilities, TEE_GEN_CAP_* above
 *//**
 * struct tee_invoke_arg - extra arguments for tee_invoke_func()
 * @func:	[in] Trusted Application function, specific to the TA
 * @session:	[in] Session id, from open session
 * @ret:	[out] return value
 * @ret_origin:	[out] origin of the return value
 *//**
 * struct tee_open_session_arg - extra arguments for tee_open_session()
 * @uuid:	[in] UUID of the Trusted Application
 * @clnt_uuid:	[in] Normally zeroes
 * @clnt_login:	[in] Normally 0
 * @session:	[out] Session id
 * @ret:	[out] return value
 * @ret_origin:	[out] origin of the return value
 *//**
 * struct tee_param - invoke parameter for a Trusted Application
 * @attr:	Attributes
 * @u.memref:	Memref parameter if (@attr & TEE_PARAM_ATTR_MASK) is one of
 *		TEE_PARAM_ATTR_TYPE_MEMREF_* above
 * @u.value:	Value parameter if (@attr & TEE_PARAM_ATTR_MASK) is one of
 *		TEE_PARAM_ATTR_TYPE_VALUE_* above
 *
 * Parameters to TA are passed using an array of this struct, for
 * flexibility both value parameters and memory refereces can be used.
 *//**
 * struct tee_param_value - value parameter for a Trusted Application
 * @a, @b, @c:	Parameters passed by value
 *
 * Used as a part of struct tee_param, see that for more information.
 *//**
 * struct tee_param_memref - memory reference for a Trusted Application
 * @shm_offs:	Offset in bytes into the shared memory object @shm
 * @size:	Size in bytes of the memory reference
 * @shm:	Pointer to a shared memory object for the buffer
 *
 * Used as a part of struct tee_param, see that for more information.
 *//**
 * struct tee_shm - memory shared with the TEE
 * @dev:	The TEE device
 * @link:	List node in the list in struct struct tee_uclass_priv
 * @addr:	Pointer to the shared memory
 * @size:	Size of the the shared memory
 * @flags:	TEE_SHM_* above
 *//**
 * struct tee_optee_ta_uuid - OP-TEE Trusted Application (TA) UUID format
 *
 * Used to identify an OP-TEE TA and define suitable to initialize structs
 * of this format is distributed with the interface of the TA. The
 * individual fields of this struct doesn't have any special meaning in
 * OP-TEE. See RFC4122 for details on the format.
 *//*
 * Some Global Platform error codes which has a meaning if the
 * TEE_GEN_CAP_GP bit is returned by the driver in
 * struct tee_version_data::gen_caps
 *//* input and output *//* parameter not used *//* be freed() *//* The memory is malloced() and must *//* TEE notified of this memory *//* In list of shared memory *//* Supports registering shared memory *//* GlobalPlatform compliant TEE *//*
 * Copyright (c) 2018 Linaro Limited
 */num_paramversshmp/opt/src/include/tee/optee_ta_avb.hoptee_ta_avbTA_AVB_CMD_WRITE_PERSIST_VALUETA_AVB_CMD_READ_PERSIST_VALUETA_AVB_CMD_WRITE_LOCK_STATETA_AVB_CMD_READ_LOCK_STATETA_AVB_CMD_WRITE_ROLLBACK_INDEXTA_AVB_CMD_READ_ROLLBACK_INDEXTA_AVB_MAX_ROLLBACK_LOCATIONSTA_AVB_UUID{ 0x023f8f1a, 0x292a, 0x432b, { 0x8f, 0xc4, 0xde, 0x84, 0x71, 0x35, 0x80, 0x67 } }__TA_AVB_H/* __TA_AVB_H *//*
 * Writes a persistent value corresponding to the given name.
 *
 * in	params[0].u.memref:	persistent value name
 * in	params[1].u.memref:	persistent value buffer to write
 *//*
 * Reads a persistent value corresponding to the given name.
 *
 * in	params[0].u.memref:	persistent value name
 * out	params[1].u.memref:	read persistent value buffer
 *//*
 * Sets the lock state of the device.
 *
 * If the lock state is changed all rollback slots will be reset to 0
 *
 * in	params[0].value.a:	lock state
 *//*
 * Gets the lock state of the device.
 *
 * out	params[0].value.a:	lock state
 *//*
 * Updates the rollback index corresponding to the given rollback index slot.
 *
 * Will refuse to update a slot with a lower value.
 *
 * in	params[0].value.a:	rollback index slot
 * in	params[1].value.a:	upper 32 bits of rollback index
 * in	params[1].value.b:	lower 32 bits of rollback index
 *//*
 * Gets the rollback index corresponding to the given rollback index slot.
 *
 * in	params[0].value.a:	rollback index slot
 * out	params[1].value.a:	upper 32 bits of rollback index
 * out	params[1].value.b:	lower 32 bits of rollback index
 *//* Copyright (c) 2018, Linaro Limited *//opt/src/include/tee/opt/src/common/avb_verify.cops_datasizeof(struct AvbOpsData)name_sizeshm_nameshm_buftee_param[2]sizeof(param)<tee/optee_ta_avb.h><tee.h>value_sizefree_namebuffer_sizeout_bufferout_num_bytes_readuuid_sizesizeof(part->info.uuid)ARRAY_SIZE(param)sizeof(arg)4294901772429491411342949017684294914084get_open_session377198341053817195out_size_num_bytesguid_bufguid_buf_sizeout_is_unlockedrollback_index_slotout_rollback_indexconst unsigned char[1032]unsigned char[1032]sizeof(avb_root_pub)mmc_byte_iostart_offsetstart_sectorresidue%s: read error (%ld, %lld)
"%s: read error (%ld, %lld)\n"%s: write error (%ld, %lld)
"%s: write error (%ld, %lld)\n"io_cnt%s: sector read error
"%s: sector read error\n"public_key_datapublic_key_lengthpublic_key_metadatapublic_key_metadata_lengthout_key_is_trustedoffset_from_partitionout_num_readio_typeget_partitionsizeof(struct mmc_part)No MMC device at slot %x
"No MMC device at slot %x\n"MMC initialization failed
"MMC initialization failed\n"Error - failed to obtain block descriptor
"Error - failed to obtain block descriptor\n"Can't find partition '%s'
"Can't find partition '%s'\n"mmc_write%s: partition start out of bounds
"%s: partition start out of bounds\n"%s: sector aligned to partition bounds (%ld)
"%s: sector aligned to partition bounds (%ld)\n"Handling unaligned wrire buffer..
"Handling unaligned wrire buffer..\n"mmc_read_and_flush%s: read sector aligned to partition bounds (%ld)
"%s: read sector aligned to partition bounds (%ld)\n"Handling unaligned read buffer..
"Handling unaligned read buffer..\n"blksnewargsrestart_on_corruptionandroidboot.veritymode=enforcing"androidboot.veritymode=enforcing"ignore_corruptionandroidboot.veritymode=eio"androidboot.veritymode=eio"avb_set_enforce_optionchar *[1024]sizeof(cmdarg)%s: Can't handle more then %d args
"%s: Can't handle more then %d args\n"total_args%s: No verity options found
"%s: No verity options found\n"avb_find_dm_argscmd_lineandroidboot.verifiedbootstate=green"androidboot.verifiedbootstate=green"androidboot.verifiedbootstate=yellow"androidboot.verifiedbootstate=yellow"androidboot.verifiedbootstate=orange"androidboot.verifiedbootstate=orange"avb_root_pub/**
 * ============================================================================
 * AVB2.0 AvbOps alloc/initialisation/free
 * ============================================================================
 *//**
 * get_size_of_partition() - gets the size of a partition identified
 * by a string name
 *
 * @ops: contains AVB ops handlers
 * @partition: partition name (NUL-terminated UTF-8 string)
 * @out_size_num_bytes: returns the value of a partition size
 *
 * @return:
 *      AVB_IO_RESULT_OK, on success (GUID found)
 *      AVB_IO_RESULT_ERROR_INSUFFICIENT_SPACE, out_size_num_bytes is NULL
 *      AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION, if partition was not found
 *//**
 * get_unique_guid_for_partition() - gets the GUID for a partition identified
 * by a string name
 *
 * @ops: contains AVB ops handlers
 * @partition: partition name (NUL-terminated UTF-8 string)
 * @guid_buf: buf, used to copy in GUID string. Example of value:
 *      527c1c6d-6361-4593-8842-3c78fcd39219
 * @guid_buf_size: @guid_buf buffer size
 *
 * @return:
 *      AVB_IO_RESULT_OK, on success (GUID found)
 *      AVB_IO_RESULT_ERROR_IO, if incorrect buffer size (@guid_buf_size) was
 *             provided
 *      AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION, if partition was not found
 *//* For now we always return that the device is unlocked. *//**
 * read_is_device_unlocked() - gets whether the device is unlocked
 *
 * @ops: contains AVB ops handlers
 * @out_is_unlocked: device unlock state is stored here, true if unlocked,
 *       false otherwise
 *
 * @return:
 *       AVB_IO_RESULT_OK: state is retrieved successfully
 *       AVB_IO_RESULT_ERROR_IO: an error occurred
 *//* For now this is a no-op. *//**
 * write_rollback_index() - sets the rollback index corresponding to the
 * location of given by @out_rollback_index.
 *
 * @ops: contains AvbOps handlers
 * @rollback_index_slot:
 * @rollback_index: rollback index to write.
 *
 * @return
 *       AVB_IO_RESULT_OK, if the roolback index was retrieved
 *//* For now we always return 0 as the stored rollback index. *//**
 * read_rollback_index() - gets the rollback index corresponding to the
 * location of given by @out_rollback_index.
 *
 * @ops: contains AvbOps handlers
 * @rollback_index_slot:
 * @out_rollback_index: used to write a retrieved rollback index.
 *
 * @return
 *       AVB_IO_RESULT_OK, if the roolback index was retrieved
 *//*
		 * The TA has paniced, close the session to reload the TA
		 * for the next request.
		 *//**
 * validate_vmbeta_public_key() - checks if the given public key used to sign
 * the vbmeta partition is trusted
 *
 * @ops: AvbOps, contains AVB ops handlers
 * @public_key_data: public key for verifying vbmeta partition signature
 * @public_key_length: length of public key
 * @public_key_metadata:
 * @public_key_metadata_length:
 * @out_key_is_trusted:
 *
 * @return:
 *      AVB_IO_RESULT_OK, if partition was found and read operation succeed
 *//**
 * write_to_partition() - writes N bytes to a partition identified by a string
 * name
 *
 * @ops: AvbOps, contains AVB ops handlers
 * @partition_name: partition name
 * @offset_from_partition: offset from the beginning of partition
 * @num_bytes: amount of bytes to write
 * @buf: data to write
 * @out_num_read:
 *
 * @return:
 *      AVB_IO_RESULT_OK, if partition was found and read operation succeed
 *      AVB_IO_RESULT_ERROR_IO, if input/output error occurred
 *      AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION, if partition, specified in
 *            @partition_name was not found
 *//**
 * read_from_partition() - reads @num_bytes from  @offset from partition
 * identified by a string name
 *
 * @ops: contains AVB ops handlers
 * @partition_name: partition name, NUL-terminated UTF-8 string
 * @offset: offset from the beginning of partition
 * @num_bytes: amount of bytes to read
 * @buffer: destination buffer to store data
 * @out_num_read:
 *
 * @return:
 *      AVB_IO_RESULT_OK, if partition was found and read operation succeed
 *      AVB_IO_RESULT_ERROR_IO, if i/o error occurred from the underlying i/o
 *            subsystem
 *      AVB_IO_RESULT_ERROR_NO_SUCH_PARTITION, if there is no partition with
 *      the given name
 *//**
 * ============================================================================
 * AVB 2.0 operations
 * ============================================================================
 *//* Set counter for read operation *//*
				 * if this is not aligned at sector start,
				 * we have to adjust the tmp buffer
				 *//* handle non block-aligned reads *//* flush cache after read *//*
	 * Reading fails on unaligned buffers, so we have to
	 * use aligned temporary buffer and then copy to destination
	 *//**
 * ============================================================================
 * IO(mmc) auxiliary functions
 * ============================================================================
 *//**
 * ============================================================================
 * Boot states support (GREEN, YELLOW, ORANGE, RED) and dm_verity
 * ============================================================================
 *//opt/src/common/bloblist.cbloblist_initexpectedCONFIG_BLOBLIST_ADDRCONFIG_BLOBLIST_SIZELOGC_BLOBLISTexpected ? LOGL_WARNING : LOGL_DEBUG"Existing bloblist not found: creating new bloblist\n"LOGL_WARNINGlog(LOGC_BLOBLIST, expected ? LOGL_WARNING : LOGL_DEBUG,
		    "Existing bloblist not found: creating new bloblist\n")common/bloblist.cExisting bloblist not found: creating new bloblist
"Found existing bloblist\n"log(LOGC_BLOBLIST, LOGL_DEBUG, "Found existing bloblist\n")Found existing bloblist
bloblist_finishbloblist_checksizeof(*hdr)2953271203BLOBLIST_MAGIC__ret"Bad magic"log_msg_ret("Bad magic", -ENOENT)-ENOENT)"%s: returning err=%d\n""Bad magic", __ret%s: returning err=%d
Bad magicBLOBLIST_VERSION"Bad version"-EPROTONOSUPPORT-93log_msg_ret("Bad version", -EPROTONOSUPPORT)-EPROTONOSUPPORT)"Bad version", __retBad version"Bad size"-EFBIG-27log_msg_ret("Bad size", -EFBIG)-EFBIG)"Bad size", __retBad sizechksum"Checksum %x != %x\n"hdr->chksum, chksumlog(LOGC_BLOBLIST, LOGL_ERR, "Checksum %x != %x\n", hdr->chksum,
		    chksum)/opt/src/include/bloblist.h<bloblist.h>Checksum %x != %x
"Bad checksum"log_msg_ret("Bad checksum", -EIO)-EIO)"Bad checksum", __retBad checksumbloblist_newlog_ret(-ENOSPC)-ENOSPC)"returning err=%d\n"returning err=%d
BLOBLIST_ALIGNBLOBLIST_ALIGN - 1(BLOBLIST_ALIGN - 1)log_ret(-EFAULT)-EFAULT)bloblist_calc_chksumstruct bloblist_hdroffsetof(struct bloblist_hdr, chksum)bloblist_rec *bloblist_ensurebloblist_rec **bloblist_ensure_sizebloblist_addbloblist_findbloblist_ensurerecESPIPE-29-ESPIPErecpbloblist_addrecnew_allocedsizeof(*rec)(typeof(size))(BLOBLIST_ALIGN)-1ALIGN(size, BLOBLIST_ALIGN)"Failed to allocate %x bytes size=%x, need size>=%x\n"size, hdr->size, new_allocedlog(LOGC_BLOBLIST, LOGL_ERR,
		    "Failed to allocate %x bytes size=%x, need size>=%x\n",
		    size, hdr->size, new_alloced)Failed to allocate %x bytes size=%x, need size>=%x
"bloblist add"log_msg_ret("bloblist add", -ENOSPC)"bloblist add", __retbloblist addbloblist_findrecbloblist_next_blobrec->size(rec->size)(typeof(rec->size))(BLOBLIST_ALIGN)-1ALIGN(rec->size, BLOBLIST_ALIGN)bloblist_first_blobforeach_rec(_rec,_hdr)for (_rec = bloblist_first_blob(_hdr); _rec; _rec = bloblist_next_blob(_hdr, _rec))/**
	 * Wed expect to find an existing bloblist in the first phase of U-Boot
	 * that runs
	 *//*
 * Copyright 2018 Google, Inc
 * Written by Simon Glass <sjg@chromium.org>
 */bloblist_recbloblist_tag_tBLOBLISTT_NONEBLOBLISTT_EC_HOSTEVENTBLOBLISTT_SPL_HANDOFFBLOBLISTT_VBOOT_CTXBLOBLISTT_VBOOT_HANDOFF0xb00757a3__BLOBLIST_H/* __BLOBLIST_H *//**
 * bloblist_init() - Init the bloblist system with a single bloblist
 *
 * This uses CONFIG_BLOBLIST_ADDR and CONFIG_BLOBLIST_SIZE to set up a bloblist
 * for use by U-Boot.
 *//**
 * bloblist_finish() - Set up the bloblist for the next U-Boot part
 *
 * This sets the correct checksum for the bloblist. This ensures that the
 * bloblist will be detected correctly by the next phase of U-Boot.
 *
 * @return 0
 *//**
 * bloblist_check() - Check if a bloblist exists
 *
 * @addr: Address of bloblist
 * @size: Expected size of blobsize, or 0 to detect the size
 * @return 0 if OK, -ENOENT if the magic number doesn't match (indicating that
 *	there problem is no bloblist at the given address), -EPROTONOSUPPORT
 *	if the version does not match, -EIO if the checksum does not match,
 *	-EFBIG if the expected size does not match the detected size
 *//**
 * bloblist_new() - Create a new, empty bloblist of a given size
 *
 * @addr: Address of bloblist
 * @size: Initial size for bloblist
 * @flags: Flags to use for bloblist
 * @return 0 if OK, -EFAULT if addr is not aligned correctly, -ENOSPC is the
 *	area is not large enough
 *//**
 * bloblist_ensure() - Find or add a blob
 *
 * Find an existing blob, or add a new one if not found
 *
 * @tag:	Tag to add (enum bloblist_tag_t)
 * @size:	Size of the blob
 * @return pointer to blob, or NULL if it is missing and could not be added due
 *	to lack of space, or it exists but has the wrong size
 *//**
 * bloblist_ensure_size() - Find or add a blob
 *
 * Find an existing blob, or add a new one if not found
 *
 * @tag:	Tag to add (enum bloblist_tag_t)
 * @size:	Size of the blob
 * @blobp:	Returns a pointer to blob on success
 * @return 0 if OK, -ENOSPC if it is missing and could not be added due to lack
 *	of space, or -ESPIPE it exists but has the wrong size
 *//**
 * bloblist_add() - Add a new blob
 *
 * Add a new blob to the bloblist
 *
 * This should only be called if you konw there is no existing blob for a
 * particular tag. It is typically safe to call in the first phase of U-Boot
 * (e.g. TPL or SPL). After that, bloblist_ensure() should be used instead.
 *
 * @tag:	Tag to add (enum bloblist_tag_t)
 * @size:	Size of the blob
 * @return pointer to the newly added block, or NULL if there is not enough
 *	space for the blob
 *//**
 * bloblist_find() - Find a blob
 *
 * Searches the bloblist and returns the blob with the matching tag
 *
 * @tag:	Tag to search for (enum bloblist_tag_t)
 * @size:	Expected size of the blob
 * @return pointer to blob if found, or NULL if not found, or a blob was found
 *	but it is the wrong size
 *//**
 * struct bloblist_rec - record for the bloblist
 *
 * NOTE: Only exported for testing purposes. Do not use this struct.
 *
 * The bloblist contains a number of records each consisting of this record
 * structure followed by the data contained. Each records is 16-byte aligned.
 *
 * @tag: Tag indicating what the record contains
 * @hdr_size: Size of this header, normally sizeof(struct bloblist_rec). The
 *	record's data starts at this offset from the start of the record
 * @size: Size of record in bytes, excluding the header size. This does not
 *	need to be aligned (e.g. 3 is OK).
 * @spare: Spare space for other things
 *//**
 * struct bloblist_hdr - header for the bloblist
 *
 * This is stored at the start of the bloblist which is always on a 16-byte
 * boundary. Records follow this header. The bloblist normally stays in the
 * same place in memory as SPL and U-Boot execute, but it can be safely moved
 * around.
 *
 * None of the bloblist structures contain pointers but it is possible to put
 * pointers inside a bloblist record if desired. This is not encouraged,
 * since it can make part of the bloblist inaccessible if the pointer is
 * no-longer valid. It is better to just store all the data inside a bloblist
 * record.
 *
 * Each bloblist record is aligned to a 16-byte boundary and follows immediately
 * from the last.
 *
 * @version: BLOBLIST_VERSION
 * @hdr_size: Size of this header, normally sizeof(struct bloblist_hdr). The
 *	first bloblist_rec starts at this offset from the start of the header
 * @flags: Space for BLOBLISTF_... flags (none yet)
 * @magic: BLOBLIST_MAGIC
 * @size: Total size of all records (non-zero if valid) including this header.
 *	The bloblist extends for this many bytes from the start of this header.
 * @alloced: Total size allocated for this bloblist. When adding new records,
 *	the bloblist can grow up to this size. This starts out as
 *	sizeof(bloblist_hdr) since we need at least that much space to store a
 *	valid bloblist
 * @spare: Space space
 * @chksum: CRC32 for the entire bloblist allocated area. Since any of the
 *	blobs can be altered after being created, this checksum is only valid
 *	when the bloblist is finalised before jumping to the next stage of boot.
 *	Note: @chksum is last to make it easier to exclude it from the checksum
 *	calculation.
 *//* Chromium OS internal handoff info *//* Chromium OS verified boot context *//* Hand-off info from SPL *//* Chromium OS EC host-event mask *//* Vendor-specific tags are permitted here *//*
 * This provides a standard way of passing information between boot phases
 * (TPL -> SPL -> U-Boot proper.)
 *
 * A list of blobs of data, tagged with their owner. The list resides in memory
 * and can be updated by SPL, U-Boot, etc.
 *
 * Copyright 2018 Google, Inc
 * Written by Simon Glass <sjg@chromium.org>
 *//opt/src/include/initcall.hinitcallinitcall_run_listconst init_fnc_tconst init_fnc_t[]..(*[])(..)const init_fnc_t *..(**)(..)init_fnc_ptrreloc_ofsIS_ENABLED(CONFIG_SANDBOX)CONFIG_SANDBOX_MODULE__ARG_PLACEHOLDER_CONFIG_SANDBOX_MODULE__ARG_PLACEHOLDER_CONFIG_SANDBOX_MODULE 1"initcall: %p"(char *)*init_fnc_ptr - reloc_ofsdebug("initcall: %p", (char *)*init_fnc_ptr - reloc_ofs)include/initcall.hinitcall: %p" (relocated to %p)\n"(char *)*init_fnc_ptrdebug(" (relocated to %p)\n", (char *)*init_fnc_ptr) (relocated to %p)
initcall sequence %p failed at call %p (err=%d)
"initcall sequence %p failed at call %p (err=%d)\n"init_fnc_t__INITCALL_HCONFIG_EFI_APP/*
		 * Sandbox is relocated by the OS, so symbols always appear at
		 * the relocated address.
		 *//*
 * To enable debugging. add #define DEBUG at the top of the including file.
 *
 * To find a symbol, use grep on u-boot.map
 */init_sequence/opt/src/include/relocate.hrelocatedo_elf_reloc_fixupsclear_bsscopy_uboot_to_ram_RELOCATE_H_/* _RELOCATE_H_ *//**
 * do_elf_reloc_fixups() - Fix up ELF relocations in the relocated code
 *
 * This processes the relocation tables to ensure that the code can run in its
 * new location.
 *
 * @return 0 if OK, -ve on error
 *//**
 * clear_bss() - Clear the BSS (Blocked Start by Symbol) segment
 *
 * This clears the memory used by global variables
 *
 * @return 0 if OK, -ve on error
 *//**
 * copy_uboot_to_ram() - Copy U-Boot to its new relocated position
 *
 * @return 0 if OK, -ve on error
 *//*
 * (C) Copyright 2011
 * Graeme Russ, <graeme.russ@gmail.com>
 *//opt/src/include/status_led.hstatus_led_STATUS_LED_H_CONFIG_LED_STATUS1CONFIG_LED_STATUS2CONFIG_LED_STATUS3CONFIG_LED_STATUS4CONFIG_LED_STATUS5(defined(CONFIG_MVS) && CONFIG_MVS < 2)defined(STATUS_LED_PAR)defined(CONFIG_LED_STATUS_BOARD_SPECIFIC)CONFIG_LED_STATUS_BOARD_SPECIFICblue_led_offblue_led_onyellow_led_offyellow_led_ongreen_led_offgreen_led_onred_led_offred_led_oncoloured_LED_init/* _STATUS_LED_H_	*//*
 * Coloured LEDs API
 *//* CONFIG_LED_STATUS	*//* led_id_t is unsigned long mask *//*
   * ADVICE: Define in your board configuration file rather than
   * filling this file up with lots of custom board stuff.
   *//*****  Someone else defines these  *************************************//* LED on for bit == 1	*//*****  MVS v1  **********************************************************//* CONFIG_LED_STATUS5 *//* CONFIG_LED_STATUS4 *//* CONFIG_LED_STATUS3 *//* CONFIG_LED_STATUS2 *//* CONFIG_LED_STATUS1 *//*
 * The purpose of this code is to signal the operational status of a
 * target which usually boots over the network; while running in
 * PCBoot, a status LED is blinking. As soon as a valid BOOTP reply
 * message has been received, the LED is turned off. The Linux
 * kernel, once it is running, will start blinking the LED again,
 * with another frequency.
 *//opt/src/include/timer.htimer_early_get_ratetimer_early_get_counttimer_get_ratetimer_get_counttimer_conv_64dm_timer_inittimer_dev_privtimer_opsclock_rate_TIMER_H_/* _TIMER_H_ *//**
 * timer_early_get_rate() - Get the timer rate before driver model
 *
 * If CONFIG_TIMER_EARLY is enabled, this function wil be called to return
 * the current timer rate in Hz before the proper driver model timer is ready.
 * It should be implemented by one of the timer values. This is mostly useful
 * for tracing. This corresponds to the clock_rate value in struct
 * timer_dev_priv.
 *//**
 * timer_early_get_count() - Implement timer_get_count() before driver model
 *
 * If CONFIG_TIMER_EARLY is enabled, this function wil be called to return
 * the current timer value before the proper driver model timer is ready.
 * It should be implemented by one of the timer values. This is mostly useful
 * for tracing.
 *//*
 * struct timer_dev_priv - information about a device used by the uclass
 *
 * @clock_rate: the timer input clock frequency
 *//*
	 * Get the current timer count
	 *
	 * @dev: The timer device
	 * @count: pointer that returns the current 64-bit timer count
	 * @return: 0 if OK, -ve on error
	 *//*
 * struct timer_ops - Driver model timer operations
 *
 * The uclass interface is implemented by all timer devices which use
 * driver model.
 *//*
 * Get the timer input clock frequency
 *
 * @dev: The timer device
 * @return: the timer input clock frequency
 *//*
 * Get the current timer count
 *
 * @dev: The timer device
 * @count: pointer that returns the current timer count
 * @return: 0 if OK, -ve on error
 *//*
 * timer_conv_64 - convert 32-bit counter value to 64-bit
 *
 * @count: 32-bit counter value
 * @return: 64-bit counter value
 *//*
 * dm_timer_init - initialize a timer for time keeping. On success
 * initializes gd->timer so that lib/timer can use it for future
 * referrence.
 *
 * @return - 0 on success or error number
 *//*
 * Copyright (C) 2015 Thomas Chou <thomas@wytron.com.tw>
 *//opt/src/include/trace.htracetrace_inittrace_early_inittrace_set_enabledtrace_list_callstrace_list_functionstrace_print_statstrace_callftrace_flagsFUNCF_EXIT0UL << 30FUNCF_ENTRYFUNCF_TEXTBASE2UL2UL << 30FUNCF_TIMESTAMP_MASK10737418230x3ffffffftrace_output_hdrtrace_output_functrace_chunk_typeTRACE_CHUNK_FUNCSTRACE_CHUNK_CALLSFUNC_SITE_SIZEcallerrec_countcall_countTRACE_CALL_TYPE(call)((call)->flags & 0xc0000000UL)__TRACE_H/**
 * Init the trace system
 *
 * This should be called after relocation with a suitably large buffer
 * (typically as large as the U-Boot text area)
 *
 * @param buff		Pointer to trace buffer
 * @param buff_size	Size of trace buffer
 *//**
 * Turn function tracing on and off
 *
 * Don't enable trace if it has not been initialised.
 *
 * @param enabled	1 to enable trace, 0 to disable
 *//* Flags and timestamp *//* Caller function offset *//* Function offset *//* Information about a single function entry/exit *//* Flags for ftrace_record *//**
 * Dump a list of functions and call counts into a buffer
 *
 * Each record in the buffer is a struct trace_func_stats. The 'needed'
 * parameter returns the number of bytes needed to complete the operation,
 * which may be more than buff_size if your buffer is too small.
 *
 * @param buff		Buffer in which to place data, or NULL to count size
 * @param buff_size	Size of buffer
 * @param needed	Returns number of bytes used / needed
 * @return 0 if ok, -1 on error (buffer exhausted)
 *//* Print statistics about traced function calls *//* Number of records *//* Record type *//* A header at the start of the trace output buffer *//* Number of times called *//* Function offset into code *//* A trace record for a function, as written to the profile output file *//* distance between function sites *//*
	 * This affects the granularity of our trace. We can bin function
	 * entry points into groups on the basis that functions typically
	 * have a minimum size, so entry points can't appear any closer
	 * than this to each other.
	 *
	 * The value here assumes a minimum instruction size of 4 bytes,
	 * or that instructions are 2 bytes but there are at least 2 of
	 * them in every function.
	 *
	 * Increasing this value reduces the number of functions we can
	 * resolve, but reduces the size of the uintptr_t array used for
	 * our function list, which is the length of the code divided by
	 * this value.
	 */buffbuff_size/opt/src/common/board_f.cboard_fboard_init_fconst init_fnc_t[52]..(*[52])(..)X86_64CONFIG_VAL(X86_64)CONFIG_X86_64__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_X86_64__ARG_PLACEHOLDER_CONFIG_X86_64__ARG_PLACEHOLDER_CONFIG_X86_64 1CONFIG_VAL(X86_64_MODULE)CONFIG_X86_64_MODULEX86_64_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_X86_64_MODULE__ARG_PLACEHOLDER_CONFIG_X86_64_MODULE__ARG_PLACEHOLDER_CONFIG_X86_64_MODULE 1arch_cpu_init_dmreserve_archinitf_dmBOOTSTATE_ID_ACCUM_DM_Fdm_f"dm_f"initf_console_recordinitf_bootstageCONFIG_SPL_BOOTSTAGE__ARG_PLACEHOLDER_CONFIG_SPL_BOOTSTAGE__ARG_PLACEHOLDER_CONFIG_SPL_BOOTSTAGE 1CONFIG_SPL_BOOTSTAGE_MODULE__ARG_PLACEHOLDER_CONFIG_SPL_BOOTSTAGE_MODULE__ARG_PLACEHOLDER_CONFIG_SPL_BOOTSTAGE_MODULE 1CONFIG_BOOTSTAGE_STASHCONFIG_BOOTSTAGE_STASH_MODULE__ARG_PLACEHOLDER_CONFIG_BOOTSTAGE_STASH_MODULE__ARG_PLACEHOLDER_CONFIG_BOOTSTAGE_STASH_MODULE 1from_splIS_ENABLED(CONFIG_SPL_BOOTSTAGE)IS_ENABLED(CONFIG_BOOTSTAGE_STASH)IS_ENABLED(CONFIG_SPL_BOOTSTAGE) &&
			IS_ENABLED(CONFIG_BOOTSTAGE_STASH)"Failed to unstash bootstage: err=%d\n"debug("Failed to unstash bootstage: err=%d\n", ret)common/board_f.c787Failed to unstash bootstage: err=%d
BOOTSTAGE_ID_START_UBOOT_F"board_init_f"setup_reloc"Skipping relocation due to flag\n"debug("Skipping relocation due to flag\n")Skipping relocation due to flag
sizeof(gd_t)"Relocation Offset is: %08lx\n"gd->reloc_offdebug("Relocation Offset is: %08lx\n", gd->reloc_off)723Relocation Offset is: %08lx
"Relocating to %08lx, new gd at %08lx, sp at %08lx\n"gd->relocaddr, (ulong)map_to_sysmem(gd->new_gd), gd->start_addr_spdebug("Relocating to %08lx, new gd at %08lx, sp at %08lx\n",
	      gd->relocaddr, (ulong)map_to_sysmem(gd->new_gd),
	      gd->start_addr_sp)<trace.h><timer.h><status_led.h><relocate.h><initcall.h>boot_flags726Relocating to %08lx, new gd at %08lx, sp at %08lx
reloc_bloblist CONFIG_BLOBLIST_SIZE"Copying bloblist from %p to %p, size %x\n"gd->bloblist, gd->new_bloblist, sizedebug("Copying bloblist from %p to %p, size %x\n",
		      gd->bloblist, gd->new_bloblist, size)692Copying bloblist from %p to %p, size %x
reloc_bootstage"Copying bootstage from %p to %p, size %x\n"gd->bootstage, gd->new_bootstage, sizedebug("Copying bootstage from %p to %p, size %x\n",
		      gd->bootstage, gd->new_bootstage, size)674Copying bootstage from %p to %p, size %x
reloc_fdtdisplay_new_sp"New Stack Pointer is: %08lx\n"gd->start_addr_spdebug("New Stack Pointer is: %08lx\n", gd->start_addr_sp)579New Stack Pointer is: %08lx
reserve_bloblistreserve_stacksarch_reserve_stacksreserve_bootstage"Reserving %#x Bytes for bootstage at: %08lx\n"size, gd->start_addr_spdebug("Reserving %#x Bytes for bootstage at: %08lx\n", size,
	      gd->start_addr_sp)543Reserving %#x Bytes for bootstage at: %08lx
reserve_fdtfdt_totalsize(gd->fdt_blob) + 0x1000(((__builtin_constant_p((__u32)((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) ? ((__u32)( (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) & (__u32)0x000000ffUL) << 24) | (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) & (__u32)0x0000ff00UL) << 8) | (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) & (__u32)0xff000000UL) >> 24) )) : __fswab32(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize)))))) + 0x1000gd->fdt_blob((const struct fdt_header *)(gd->fdt_blob))->totalsize(__force __u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize)(__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize)((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))ALIGN(fdt_totalsize(gd->fdt_blob) + 0x1000, 32)((((__builtin_constant_p((__u32)((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) ? ((__u32)( (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) & (__u32)0x000000ffUL) << 24) | (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) & (__u32)0x0000ff00UL) << 8) | (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) & (__u32)0xff000000UL) >> 24) )) : __fswab32(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize)))))) + 0x1000)(typeof((((__builtin_constant_p((__u32)((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) ? ((__u32)( (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) & (__u32)0x000000ffUL) << 24) | (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) & (__u32)0x0000ff00UL) << 8) | (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize))) & (__u32)0xff000000UL) >> 24) )) : __fswab32(((__u32)(__be32)(((const struct fdt_header *)(gd->fdt_blob))->totalsize)))))) + 0x1000))(32)-14294967264"Reserving %lu Bytes for FDT at: %08lx\n"gd->fdt_size, gd->start_addr_spdebug("Reserving %lu Bytes for FDT at: %08lx\n",
		      gd->fdt_size, gd->start_addr_sp)528Reserving %lu Bytes for FDT at: %08lx
reserve_global_data"Reserving %zu Bytes for Global Data at: %08lx\n"sizeof(gd_t), gd->start_addr_spdebug("Reserving %zu Bytes for Global Data at: %08lx\n",
	      sizeof(gd_t), gd->start_addr_sp)510Reserving %zu Bytes for Global Data at: %08lx
setup_machinereserve_boardsizeof(bd_t)"Reserving %zu Bytes for Board Info at: %08lx\n"sizeof(bd_t), gd->start_addr_spdebug("Reserving %zu Bytes for Board Info at: %08lx\n",
		      sizeof(bd_t), gd->start_addr_sp)Reserving %zu Bytes for Board Info at: %08lx
reserve_malloc33562624"Reserving %dk for malloc() at: %08lx\n"TOTAL_MALLOC_LEN >> 10, gd->start_addr_spdebug("Reserving %dk for malloc() at: %08lx\n",
	      TOTAL_MALLOC_LEN >> 10, gd->start_addr_sp)Reserving %dk for malloc() at: %08lx
32776debug("Reserving %dk for malloc() at: %08lx\n",
	      TOTAL_MALLOC_LEN >> 10reserve_uboot4096 - 1(4096 - 1)~(4096 - 1)"Reserving %ldk for U-Boot at: %08lx\n"gd->mon_len >> 10, gd->relocaddrdebug("Reserving %ldk for U-Boot at: %08lx\n",
		      gd->mon_len >> 10, gd->relocaddr)Reserving %ldk for U-Boot at: %08lx
reserve_tracereserve_videoreserve_round_4ksetup_dest_addr"Monitor len: %08lX\n"gd->mon_lendebug("Monitor len: %08lX\n", gd->mon_len)Monitor len: %08lX
"Ram size: %08lX\n"(ulong)gd->ram_sizedebug("Ram size: %08lX\n", (ulong)gd->ram_size)326Ram size: %08lX
CONFIG_SYS_SDRAM_BASE"Ram top: %08lX\n"(ulong)gd->ram_topdebug("Ram top: %08lX\n", (ulong)gd->ram_top)346Ram top: %08lX
mach_cpu_initarch_cpu_initsetup_spl_handoffsetup_mon_lenchar(*)[]dram_init_banksizeshow_dram_config"\nRAM Configuration:\n"debug("\nRAM Configuration:\n")
RAM Configuration:
"Bank #%d: %llx "i, (unsigned long long)(gd->bd->bi_dram[i].start)debug("Bank #%d: %llx ", i,
		      (unsigned long long)(gd->bd->bi_dram[i].start))Bank #%d: %llx "\nDRAM:  "debug("\nDRAM:  ")
DRAM:  announce_dram_initprint_resetinfoUCLASS_SYSRESET"%s: No sysreset device found (error: %d)\n"__func__, retdebug("%s: No sysreset device found (error: %d)\n",
		      __func__, ret)%s: No sysreset device found (error: %d)
sizeof(status)display_text_infoinit_baud_rate"baudrate"115200CONFIG_BAUDRATEboard_add_ram_infoinit_func_watchdog_initinit_sequence_fCONFIG_MACH_TYPEdefined(CONFIG_MP) && defined(CONFIG_PPC)XTRN_DECLARE_GLOBAL_DATA_PTRdefined(CONFIG_HW_WATCHDOG) && \!defined(CONFIG_SANDBOX) && !defined(CONFIG_EFI_APP)CONFIG_SYSRESETdefined(CONFIG_DISPLAY_CPUINFO) && CONFIG_IS_ENABLED(CPU)defined(CONFIG_NR_DRAM_BANKS) && defined(CONFIG_SYS_SDRAM_BASE)defined(CONFIG_VID)defined(__ARM__) || defined(__MICROBLAZE__)defined(CONFIG_SANDBOX) || defined(CONFIG_EFI_APP)defined(CONFIG_NIOS2) || defined(CONFIG_XTENSA)defined(CONFIG_NDS32) || defined(CONFIG_SH) || defined(CONFIG_RISCV)defined(CONFIG_SYS_MONITOR_BASE)defined(CONFIG_SYS_MEM_TOP_HIDE)defined(CONFIG_MP) && (defined(CONFIG_MPC86xx) || defined(CONFIG_E500))CONFIG_PRAMCONFIG_FB_ADDRdefined(CONFIG_VIDEO) && \defined(CONFIG_E500) || defined(CONFIG_MIPS)CONFIG_OF_EMBEDdefined(CONFIG_M68K) || defined(CONFIG_MIPS) || defined(CONFIG_PPC) || \CONFIG_SYS_SRAM_BASEdefined(CONFIG_E500) || defined(CONFIG_MPC86xx)defined(CONFIG_MPC83xx)defined(CONFIG_PPC) || defined(CONFIG_M68K)defined(CONFIG_M68K) && defined(CONFIG_PCI)defined(CONFIG_EXTRA_CLOCK)ARM!defined(CONFIG_SANDBOX)CONFIG_OF_BOARD_FIXUP!defined(CONFIG_ARM) && !defined(CONFIG_SANDBOX) && \defined(CONFIG_X86) || defined(CONFIG_ARC)defined(CONFIG_CONSOLE_RECORD) && CONFIG_VAL(SYS_MALLOC_F_LEN)defined(CONFIG_DM) && CONFIG_VAL(SYS_MALLOC_F_LEN)CONFIG_TIMER_EARLYCONFIG_TRACE_EARLYdefined(CONFIG_HAVE_FSP)defined(CONFIG_BOARD_EARLY_INIT_F)defined(CONFIG_PPC) || defined(CONFIG_SYS_FSL_CLK) || defined(CONFIG_M68K)!defined(CONFIG_M68K)defined(CONFIG_BOARD_POSTCLK_INIT)defined(CONFIG_PPC) || defined(CONFIG_SH) || defined(CONFIG_X86)defined(CONFIG_SYSRESET)defined(CONFIG_DISPLAY_CPUINFO)defined(CONFIG_DTB_RESELECT)defined(CONFIG_DISPLAY_BOARDINFO)defined(CONFIG_MISC_INIT_F)defined(CONFIG_VID) && !defined(CONFIG_SPL)!CONFIG_IS_ENABLED(X86_64)CPUCONFIG_VAL(CPU_MODULE)CONFIG_CPU_MODULE__ARG_PLACEHOLDER_CONFIG_CPU_MODULE__ARG_PLACEHOLDER_CONFIG_CPU_MODULE 1CPU_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_CPU_MODULECONFIG_VAL(CPU)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_CPUCONFIG_CPU/* CONFIG_X86 *//*
	 * U-Boot has been copied into SDRAM, the BSS has been cleared etc.
	 * Transfer execution from Flash to RAM by calculating the address
	 * of the in-RAM copy of board_init_r() and calling it
	 *//*
	 * The pre-relocation drivers may be using memory that has now gone
	 * away. Mark serial as unavailable - this will fall back to the debug
	 * UART if available.
	 *
	 * Do the same with log drivers since the memory may not be available.
	 *//*
 * For now this code is only used on x86.
 *
 * init_sequence_f_r is the list of init functions which are run when
 * U-Boot is executing from Flash with a semi-limited 'C' environment.
 * The following limitations must be considered when implementing an
 * '_f_r' function:
 *  - 'static' variables are read-only
 *  - Global Data (gd->xxx) is read/write
 *
 * The '_f_r' sequence must, as a minimum, copy U-Boot to RAM (if
 * supported).  It _should_, if possible, copy global data to RAM and
 * initialise the CPU caches (to speed up the relocation process)
 *
 * NOTE: At present only x86 uses this route, but it is intended that
 * all archs will move to this when generic relocation is implemented.
 *//* NOTREACHED - jump_to_copy() does not return *//*
	 * Now that we have DRAM mapped and working, we can
	 * relocate the code and continue running from DRAM.
	 *
	 * Reserve memory at end of RAM for (top down in that order):
	 *  - area that won't get touched by U-Boot and Linux (optional)
	 *  - kernel log buffer
	 *  - protected RAM
	 *  - LCD framebuffer
	 *  - monitor code
	 *  - board info struct
	 *//* configure available RAM banks *//* display cpu info (and speed) *//* show debugging info if required *//* say that we are here *//* stage 1 init of console *//* serial communications setup *//* initialze baudrate settings *//* initialize environment *//* initialize timer *//* get CPU and bus clocks (etc.) *//* get CPU and bus clocks according to the environment variable *//* SoC/machine dependent CPU setup *//* basic arch cpu dependent setup *//* uses its own timer, so does not need DM *//* Architecture-specific memory reservation *//* Record the board_init_f() bootstage (after arch_cpu_init()) *//*
	 * SDRAM and console are now initialised. The final stack can now
	 * be setup in SDRAM. Code execution will continue in Flash, but
	 * with the stack in SDRAM and Global Data in temporary memory
	 * (CPU cache)
	 *//*
	 * x86 is special, but in a nice way. It uses a trampoline which
	 * enables the dcache if possible.
	 *
	 * For now, other archs use relocate_code(), which is implemented
	 * similarly for all archs. When we do generic relocation, hopefully
	 * we can make all archs enable the dcache prior to relocation.
	 *//* ARM calls relocate_code from its crt0.S *//*
	 * On all ColdFire arch cpu, monitor code starts always
	 * just after the default vector table location, so at 0x400
	 *//* flexbus Freq in Hz *//* vco Freq in Hz *//* input Freq in Hz *//* CONFIG_CPM2 *//* Bus Freq,      in Hz *//* Internal Freq, in Hz *//* base of internal registers *//* base  of IMMR register     *//* size  of SRAM *//* start of SRAM *//* start of memory *//*
	 * Save local variables to board info struct
	 *//*
	 * let the architecture-specific code tailor gd->start_addr_sp and
	 * gd->irq_sp
	 *//* make stack pointer 16-byte aligned *//*
	 * If the device tree is sitting immediately above our image then we
	 * must relocate it. If it is embedded in the data section, then it
	 * will be relocated with other data.
	 *//* board id for Linux *//* (permanently) allocate a Board Info struct *//* reserve memory for malloc() area *//* round down to next 64 kB limit so that IVPR stays aligned *//*
		 * reserve memory for U-Boot code, data & bss
		 * round down to next 4 kB limit
		 *//* reserve memory for video display (always full pages) *//* CONFIG_FB_ADDR *//* reserve memory for LCD display (always full pages) *//*
	 * Record allocated tlb_addr in case gd->tlb_addr to be overwritten
	 * with location within secure ram.
	 *//* round down to next 64 kB limit *//* reserve TLB table *//* Round memory pointer down to next 4 kB limit *//* CONFIG_PRAM *//* size is in kB *//* reserve protected RAM *//*
	 * We need to make sure the location we intend to put secondary core
	 * boot code is reserved and not used by any part of u-boot
	 *//*
	 * Subtract specified amount of memory to hide so that it won't
	 * get "touched" at all by U-Boot. By fixing up gd->ram_size
	 * the Linux kernel should now get passed the now "corrected"
	 * memory size and won't touch it either. This should work
	 * for arch/ppc and arch/powerpc. Only Linux board ports in
	 * arch/powerpc with bootwrapper support, that recalculate the
	 * memory size from the SDRAM controller setup will have to
	 * get fixed.
	 *//*
	 * Ram is setup, size stored in gd !!
	 *//*
		 * Will wrap back to top of 32-bit space when reservations
		 * are made.
		 *//*
	 * Detect whether we have so much RAM that it goes past the end of our
	 * 32-bit address space. If so, clip the usable RAM so it doesn't.
	 *//* Get the top of usable RAM *//* TODO: use (ulong)&__bss_end - (ulong)&__text_start; ? *//* Not all boards have sysreset drivers available during early
		 * boot, so don't fail if one can't be found.
		 *//* please define platform specific board_add_ram_info() *//* CONFIG_WATCHDOG *//*
 * Why is gd allocated a register? Prior to reloc it might be better to
 * just pass it around to each function in this file?
 *
 * After reloc one could argue that it is hardly used and doesn't need
 * to be in a register. Or if it is it should perhaps hold pointers to all
 * global data for all modules, so that post-reloc we can avoid the massive
 * literal pool we get on ARM. Or perhaps just encourage each module to use
 * a structure...
 *//************************************************************************
 * Coloured LED functionality
 ************************************************************************
 * May be supplied by boards if desired
 *//*
 * TODO(sjg@chromium.org): IMO this code should be
 * refactored to a single function, something like:
 *
 * void led_set_state(enum led_colour_t colour, int on);
 *//* empty = allocate here *//*
 * Pointer to initial global data area
 *
 * Here we initialize it if needed.
 *//*
 * Copyright (c) 2011 The Chromium OS Authors.
 * (C) Copyright 2002-2006
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *
 * (C) Copyright 2002
 * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
 * Marius Groeger <mgroeger@sysgo.de>
 */use_default/opt/src/common/board_info.cboard_infoshow_board_info"model"Model: %s
"Model: %s\n"checkboard/*
 * If the root node of the DTB has a "model" property, show it.
 * Then call checkboard().
 *//opt/src/include/api.hapiapi_init__API_H/opt/src/include/of_live.hof_live_builddevice_node **_OF_LIVE_H/**
 * of_live_build() - build a live (hierarchical) tree from a flat DT
 *
 * @fdt_blob: Input tree to convert
 * @rootp: Returns live tree that was created
 * @return 0 if OK, -ve on error
 *//*
 * Copyright (c) 2017 Google, Inc
 * Written by Simon Glass <sjg@chromium.org>
 *
 * Support for a 'live' (as opposed to flat) device tree
 */rootp/opt/src/include/onenand_uboot.honenand_ubootonenand_spl_load_imageonenand_spl_read_blockflexonenand_set_boundaryflexonenand_regiononenand_addronenand_chip *onenand_blockonenand_print_device_infoonenand_eraseonenand_writeonenand_read_oobonenand_readonenand_initonenand_board_initonenand_chip__UBOOT_ONENAND_Honenand_mtd/* __UBOOT_ONENAND_H *//* SPL *//* Functions *//* board *//* Forward declarations *//*
 *  Header file for OneNAND support for U-Boot
 *
 *  Adaptation from kernel to U-Boot
 *
 *  Copyright (C) 2005-2007 Samsung Electronics
 *  Kyungmin Park <kyungmin.park@samsung.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */dieboundarythis/opt/src/include/serial.hsh_serial_initializepxa_serial_initializepl01x_serial_initializens16550_serial_initializemxc_serial_initializempc85xx_serial_initializemcf_serial_initializeatmel_serial_initializeserial_getinfoserial_device_info *serial_setconfigserial_getconfigserial_reinit_allserial_assignserial_stdio_initserial_initializeserial_registerserial_device *default_serial_consoledefault_serial_putsserial_dev_privdm_serial_opsserial_device_infoadr_space_typeSERIAL_ADDRESS_SPACE_MEMORYSERIAL_ADDRESS_SPACE_IOserial_chip_typeSERIAL_CHIP_UNKNOWNSERIAL_CHIP_16550_COMPATIBLEserial_stopSERIAL_HALF_STOPSERIAL_ONE_STOPSERIAL_ONE_HALF_STOPSERIAL_TWO_STOPserial_bitsSERIAL_5_BITSSERIAL_6_BITSSERIAL_7_BITSSERIAL_8_BITSserial_parSERIAL_PAR_NONESERIAL_PAR_ODDSERIAL_PAR_EVENserial_devicewr_ptrrd_ptrsdevsetconfiggetconfigpendingsetbrgreg_shiftreg_offsetreg_widthaddr_spaceserial_get_ops(dev)((struct dm_serial_ops *)(dev)->driver->ops)SERIAL_DEFAULT_ADDRESS0xBADACCE5SERIAL_DEFAULT_CONFIG(SERIAL_PAR_NONE << SERIAL_PAR_SHIFT | SERIAL_8_BITS << SERIAL_BITS_SHIFT | SERIAL_ONE_STOP << SERIAL_STOP_SHIFT)SERIAL_CONFIG(par,bits,stop)(par << SERIAL_PAR_SHIFT | bits << SERIAL_BITS_SHIFT | stop << SERIAL_STOP_SHIFT)SERIAL_GET_STOP(config)((config & SERIAL_STOP_MASK) >> SERIAL_STOP_SHIFT)SERIAL_SET_STOP(stop)((stop << SERIAL_STOP_SHIFT) & SERIAL_STOP_MASK)SERIAL_STOP_MASK(0x3 << SERIAL_STOP_SHIFT)SERIAL_STOP_SHIFTSERIAL_GET_BITS(config)((config & SERIAL_BITS_MASK) >> SERIAL_BITS_SHIFT)SERIAL_SET_BITS(bits)((bits << SERIAL_BITS_SHIFT) & SERIAL_BITS_MASK)SERIAL_BITS_MASK(0x3 << SERIAL_BITS_SHIFT)SERIAL_BITS_SHIFTSERIAL_GET_PARITY(config)((config & SERIAL_PAR_MASK) >> SERIAL_PAR_SHIFT)SERIAL_SET_PARITY(parity)((parity << SERIAL_PAR_SHIFT) & SERIAL_PAR_MASK)SERIAL_PAR_MASK(0x03 << SERIAL_PAR_SHIFT)SERIAL_PAR_SHIFTusbtty_tstc()usbtty_puts(a)usbtty_putc(a)usbtty_getc()__SERIAL_H__CONFIG_POST & CONFIG_SYS_POST_UARTdefined(CONFIG_MPC83xx) || defined(CONFIG_MPC85xx) || \eserial6_deviceeserial5_deviceeserial4_deviceeserial3_deviceeserial2_deviceeserial1_deviceserial_scc_deviceserial_smc_device/**
 * serial_getinfo() - Get serial device information
 *
 * @dev: Device pointer
 * @info: struct serial_device_info to fill
 * @return 0 if OK, -ve on error
 *//**
 * serial_setconfig() - Set up the uart configuration
 * (parity, 5/6/7/8 bits word length, stop bits)
 *
 * Set up a new config for this device.
 *
 * @dev: Device pointer
 * @serial_config: number of bits, parity and number of stopbits to use
 * @return 0 if OK, -ve on error
 *//**
 * serial_getconfig() - Get the uart configuration
 * (parity, 5/6/7/8 bits word length, stop bits)
 *
 * Get a current config for this device.
 *
 * @dev: Device pointer
 * @serial_config: Returns config information (see SERIAL_... above)
 * @return 0 if OK, -ve on error
 *//**
 * struct serial_dev_priv - information about a device used by the uclass
 *
 * @sdev:	stdio device attached to this uart
 *
 * @buf:	Pointer to the RX buffer
 * @rd_ptr:	Read pointer in the RX buffer
 * @wr_ptr:	Write pointer in the RX buffer
 *//**
	 * getinfo() - Get serial device information
	 *
	 * @dev: Device pointer
	 * @info: struct serial_device_info to fill
	 * @return 0 if OK, -ve on error
	 *//**
	 * setconfig() - Set up the uart configuration
	 * (parity, 5/6/7/8 bits word length, stop bits)
	 *
	 * Set up a new config for this device.
	 *
	 * @dev: Device pointer
	 * @serial_config: number of bits, parity and number of stopbits to use
	 * @return 0 if OK, -ve on error
	 *//**
	 * getconfig() - Get the uart configuration
	 * (parity, 5/6/7/8 bits word length, stop bits)
	 *
	 * Get a current config for this device.
	 *
	 * @dev: Device pointer
	 * @serial_config: Returns config information (see SERIAL_... above)
	 * @return 0 if OK, -ve on error
	 *//**
	 * loop() - Control serial device loopback mode
	 *
	 * @dev: Device pointer
	 * @on: 1 to turn loopback on, 0 to turn if off
	 *//**
	 * clear() - Clear the serial FIFOs/holding registers
	 *
	 * This method is optional.
	 *
	 * This quickly clears any input/output characters from the UART.
	 * If this is not possible, but characters still exist, then it
	 * is acceptable to return -EAGAIN (try again) or -EINVAL (not
	 * supported).
	 *
	 * @dev: Device pointer
	 * @return 0 if OK, -ve on error
	 *//**
	 * pending() - Check if input/output characters are waiting
	 *
	 * This can be used to return an indication of the number of waiting
	 * characters if the driver knows this (e.g. by looking at the FIFO
	 * level). It is acceptable to return 1 if an indeterminant number
	 * of characters is waiting.
	 *
	 * This method is optional.
	 *
	 * @dev: Device pointer
	 * @input: true to check input characters, false for output
	 * @return number of waiting characters, 0 for none, -ve on error
	 *//**
	 * putc() - Write a character
	 *
	 * @dev: Device pointer
	 * @ch: character to write
	 * @return 0 if OK, -ve on error
	 *//**
	 * getc() - Read a character and return it
	 *
	 * If no character is available, this should return -EAGAIN without
	 * waiting.
	 *
	 * @dev: Device pointer
	 * @return character (0..255), -ve on error
	 *//**
	 * setbrg() - Set up the baud rate generator
	 *
	 * Adjust baud rate divisors to set up a new baud rate for this
	 * device. Not all devices will support all rates. If the rate
	 * cannot be supported, the driver is free to select the nearest
	 * available rate. or return -EINVAL if this is not possible.
	 *
	 * @dev: Device pointer
	 * @baudrate: New baud rate to use
	 * @return 0 if OK, -ve on error
	 *//**
 * struct struct dm_serial_ops - Driver model serial operations
 *
 * The uclass interface is implemented by all serial devices which use
 * driver model.
 *//**
 * struct serial_device_info - structure to hold serial device info
 *
 * @type:	type of the UART chip
 * @addr_space:	address space to access the registers
 * @addr:	physical address of the registers
 * @reg_width:	size (in bytes) of the IO accesses to the registers
 * @reg_offset:	offset to apply to the @addr from the start of the registers
 * @reg_shift:	quantity to shift the register offsets by
 * @baudrate:	baud rate
 *//*   2 stop bit *//* 1.5 stop bit *//*   1 stop bit *//* 0.5 stop bit *//* CONFIG_USB_TTY *//* stubs *//* For usbtty *//* enough bytes to match alignment of following func pointer *//opt/src/include/wdt.hinitr_watchdogUCLASS_WDT"WDT:   Not found by seq!\n"debug("WDT:   Not found by seq!\n")include/wdt.hWDT:   Not found by seq!
WDT:   Not found!
"WDT:   Not found!\n"WATCHDOG_TIMEOUT_SECS60000timeout-sec"timeout-sec"WDT:   Started with%s servicing (%ds timeout)
"WDT:   Started with%s servicing (%ds timeout)\n"CONFIG_WATCHDOGIS_ENABLED(CONFIG_WATCHDOG)CONFIG_WATCHDOG_MODULE__ARG_PLACEHOLDER_CONFIG_WATCHDOG_MODULE__ARG_PLACEHOLDER_CONFIG_WATCHDOG_MODULE 1"out"wdt_expire_nowwdt_resetwdt_stopwdt_startwdt_opsexpire_now(CONFIG_WATCHDOG_TIMEOUT_MSECS / 1000)CONFIG_WATCHDOG_TIMEOUT_MSECS(60 * 1000)_WDT_H_/* _WDT_H_ *//*
	 * Init watchdog: This will call the probe function of the
	 * watchdog driver, enabling the use of the device
	 *//*
	 * Expire the timer, thus executing the action immediately (optional)
	 *
	 * If this function is not provided, a default implementation
	 * will be used, which sets the counter to 1
	 * and waits forever. This is good enough for system level
	 * reset, where the function is not expected to return, but might not be
	 * good enough for other use cases.
	 *
	 * @dev: WDT Device
	 * @flags: Driver specific flags
	 * @return 0 if OK -ve on error. May not return.
	 *//*
	 * Reset the timer, typically restoring the counter to
	 * the value configured by start()
	 *
	 * @dev: WDT Device
	 * @return: 0 if OK, -ve on error
	 *//*
	 * Stop the timer
	 *
	 * @dev: WDT Device
	 * @return: 0 if OK, -ve on error
	 *//*
	 * Start the timer
	 *
	 * @dev: WDT Device
	 * @timeout_ms: Number of ticks (milliseconds) before the timer expires
	 * @flags: Driver specific flags. This might be used to specify
	 * which action needs to be executed when the timer expires
	 * @return: 0 if OK, -ve on error
	 *//*
 * struct wdt_ops - Driver model wdt operations
 *
 * The uclass interface is implemented by all wdt devices which use
 * driver model.
 *//*
 * Expire the timer, thus executing its action immediately.
 * This is typically used to reset the board or peripherals.
 *
 * @dev: WDT Device
 * @flags: Driver specific flags
 * @return 0 if OK -ve on error. If wdt action is system reset,
 * this function may never return.
 *//*
 * Reset the timer, typically restoring the counter to
 * the value configured by start()
 *
 * @dev: WDT Device
 * @return: 0 if OK, -ve on error
 *//*
 * Stop the timer, thus disabling the Watchdog. Use wdt_start to start it again.
 *
 * @dev: WDT Device
 * @return: 0 if OK, -ve on error
 *//*
 * Start the timer
 *
 * @dev: WDT Device
 * @timeout_ms: Number of ticks (milliseconds) before timer expires
 * @flags: Driver specific flags. This might be used to specify
 * which action needs to be executed when the timer expires
 * @return: 0 if OK, -ve on error
 *//*
 * Implement a simple watchdog uclass. Watchdog is basically a timer that
 * is used to detect or recover from malfunction. During normal operation
 * the watchdog would be regularly reset to prevent it from timing out.
 * If, due to a hardware fault or program error, the computer fails to reset
 * the watchdog, the timer will elapse and generate a timeout signal.
 * The timeout signal is used to initiate corrective action or actions,
 * which typically include placing the system in a safe, known state.
 *//*
 * Copyright 2017 Google, Inc
 */timeout_ms/opt/src/common/board_r.cboard_rboard_init_r18446744073709518847~GD_FLG_LOG_READYinit_fnc_t[42]..(*[42])(..)init_fnc_t *run_main_loopinitr_netNet:   "Net:   "initr_scsiSCSI:  "SCSI:  "initr_ethaddrinitr_jumptableinitr_envshould_load_envload-environment"load-environment"initr_mmcMMC:   "MMC:   "initr_announce"Now running in RAM - U-Boot at: %08lx\n"gd->relocaddrdebug("Now running in RAM - U-Boot at: %08lx\n", gd->relocaddr)common/board_r.cNow running in RAM - U-Boot at: %08lx
power_init_boardinitr_bootstageBOOTSTAGE_ID_START_UBOOT_R"board_init_r"initr_dmBOOTSTATE_ID_ACCUM_DM_Rdm_r"dm_r"initr_of_liveBOOTSTAGE_ID_ACCUM_OF_LIVE"of_live"initr_console_recordinitr_malloc"Pre-reloc malloc() used %#lx bytes (%ld KB)\n"gd->malloc_ptr, gd->malloc_ptr / 1024debug("Pre-reloc malloc() used %#lx bytes (%ld KB)\n", gd->malloc_ptr,
	      gd->malloc_ptr / 1024)Pre-reloc malloc() used %#lx bytes (%ld KB)
malloc_start<wdt.h><serial.h><onenand_uboot.h><of_live.h><api.h>dest_addrinitr_barrierinitr_pciinitr_serialinitr_reloc_global_datafixup_cpuinitr_relocGD_FLG_RELOC | GD_FLG_FULL_MALLOC_INITinitr_traceinitr_secondary_cpucpu_secondary_init_rboard_flash_wp_oninit_fnc_t[]init_sequence_rmonitor_flash_lendefined(CONFIG_CMD_BEDBUG)defined(CONFIG_CMD_KGDB)CONFIG_ADDR_MAPdefined(CONFIG_GPIO_HOG)__ARM__defined(CONFIG_NDS32) || defined(CONFIG_RISCV)!defined(CONFIG_SANDBOX) && !defined(CONFIG_NIOS2)defined(CONFIG_MPC85xx) || defined(CONFIG_MPC86xx)!defined(CONFIG_ENV_ADDR) || defined(ENV_IS_EMBEDDED)defined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_MIPS)defined(CONFIG_SYS_INIT_RAM_LOCK) && defined(CONFIG_E500)CONFIG_PPCdefined(CONFIG_CONSOLE_RECORD)CONFIG_SYS_NONCACHED_MEMORYCONFIG_SYS_FLASH_CHECKSUMCONFIG_SYS_FLASH_BASEdefined(CONFIG_SYS_UPDATE_FLASH_SIZE)defined(CONFIG_OXC) || defined(CONFIG_RMU)CONFIG_SYS_MONITOR_BASE == CONFIG_SYS_FLASH_BASECONFIG_CMD_NANDCONFIG_MMCdefined CONFIG_DELAY_ENVIRONMENTCONFIG_SYS_BOOTPARAMS_LENdefined(CONFIG_API)CONFIG_HAS_ETH1CONFIG_HAS_ETH2CONFIG_HAS_ETH3CONFIG_HAS_ETH4CONFIG_HAS_ETH5CONFIG_CMD_KGDBdefined(CONFIG_LED_STATUS)defined(CONFIG_LED_STATUS_BOOT)defined(CONFIG_SCSI) && !defined(CONFIG_DM_SCSI)defined(CONFIG_RESET_PHY_R)defined(CONFIG_CMD_PCMCIA) && !defined(CONFIG_IDE)defined(CONFIG_IDE) && !defined(CONFIG_BLK)defined(CONFIG_START_IDE)defined(CONFIG_PRAM)CONFIG_CMD_BEDBUGdefined(CONFIG_ARM) || defined(CONFIG_NDS32) || defined(CONFIG_RISCV) || \defined(CONFIG_BOARD_EARLY_INIT_R)defined(CONFIG_PCI) && defined(CONFIG_SYS_EARLY_PCI_INIT)CONFIG_ARCH_EARLY_INIT_Rdefined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_X86)CONFIG_CMD_ONENANDdefined(CONFIG_ID_EEPROM) || defined(CONFIG_SYS_I2C_MAC_OFFSET)defined(CONFIG_PCI) && !defined(CONFIG_SYS_EARLY_PCI_INIT)CONFIG_APICONFIG_DISPLAY_BOARDINFO_LATECONFIG_ARCH_MISC_INITCONFIG_MISC_INIT_Rdefined(CONFIG_MICROBLAZE) || defined(CONFIG_M68K)CONFIG_LAST_STAGE_INITCONFIG_IS_ENABLED(X86_64)!defined(CONFIG_X86) && !defined(CONFIG_ARM) && !defined(CONFIG_ARM64)/* NOTREACHED - run_main_loop() does not return *//*
	 * Set up the new global data pointer. So far only x86 does this
	 * here.
	 * TODO(sjg@chromium.org): Consider doing this for all archs, or
	 * dropping the new_gd parameter.
	 *//*
	 * Some parts can be only initialized if all others (like
	 * Interrupts) are up and running (i.e. the PC-style ISA
	 * keyboard).
	 *//* PPC has a udelay(20) here dating from 2002. Why? *//* miscellaneous platform-dependent init *//* miscellaneous arch-dependent init *//* fully init console as a device *//*
	 * Do pci configuration
	 *//* initialize higher level parts of CPU like time base and timers *//*
	 * Do early PCI configuration _before_ the flash gets initialised,
	 * because PCU resources are crucial for flash access on some boards.
	 *//* Setup clock information *//*
	 * TODO: printing of the clock inforamtion of the board is now
	 * implemented as part of bdinfo command. Currently only support for
	 * davinci SOC's is added. Remove this check once all the board
	 * implement this.
	 *//* Setup chipselects *//* Needs malloc() but has its own timer *//* Note: For Freescale LS2 SoCs, new MMU table is created in DDR.
	 *	 A temporary mapping of IFC high region is since removed,
	 *	 so environmental variables in NOR flash is not available
	 *	 until board_init() is called below to remap IFC to high
	 *	 region.
	 *//* TODO: could x86/PPC have this also perhaps? *//*
 * We hope to remove most of the driver-related init and do it if/when
 * the driver is later used.
 *
 * TODO: perhaps reset the watchdog in the initcall function after each call?
 *//* main_loop() can return to retry autoboot, if so just run it again *//*
 * Export available size of memory for Linux, taking into account the
 * protected RAM at top of memory
 *//* CONFIG_CMD_NET *//* kept around for legacy kernels only ... ignore the next section *//* enable exceptions *//* Initialize API *//* Initialize from environment *//*
 * Tell if it's OK to load the environment early in boot.
 *
 * If CONFIG_OF_CONTROL is defined, we'll check with the FDT to see
 * if this is OK (defaulting to saying it's OK).
 *
 * NOTE: Loading the environment early can be a bad idea if security is
 *       important, since no verification is done on the environment.
 *
 * @return 0 if environment should not be loaded, !=0 if it is ok to load
 *//* go init the NAND *//* reserved area for monitor *//* flash mapped at end of memory map *//* Make a update of the Memctrl. *//* size of FLASH memory (final value) *//* update start of FLASH memory    *//* CONFIG_SYS_FLASH_CHECKSUM *//*
	 * Compute and print flash CRC if flashchecksum is set to 'y'
	 *
	 * NOTE: Maybe we should add some WATCHDOG_RESET()? XXX
	 *//* Save the pre-reloc driver model and start a new one *//* The malloc area is immediately below the monitor copy in DRAM *//* TODO: Can we not use dmb() macros for this? *//* it's time to unlock D-cache in e500 *//*
	 * Setup trap handlers
	 *//*
	 * On the ARM architecture gd is mapped to a fixed register (r9 or x18).
	 * As this register may be overwritten by an EFI payload we save it here
	 * and restore it on every callback entered.
	 *//*
	 * The fdt_blob needs to be moved to new relocation address
	 * incase of FDT blob is embedded with in image
	 *//*
	 * Relocate the early env_addr pointer unless we know it is not inside
	 * the binary. Some systems need this and for the rest, it doesn't hurt.
	 *//*
	 * If we didn't know the cpu mask & # cores, we can save them of
	 * now rather than 'computing' them constantly
	 *//*
	 * The gd->cpu pointer is set to an address in flash before relocation.
	 * We need to update it to point to the same CPU entry in RAM.
	 * TODO: why not just add gd->reloc_ofs?
	 *//* Enable caches *//*
 * Some of these functions are needed purely because the functions they
 * call return void. If we change them to return 0, these stubs can go away.
 *//* tell others: relocation done *//* TODO: maybe define this for all archs? *//*
	 * after non-volatile devices & environment is setup and cpu code have
	 * another round to deal with any initialization that might require
	 * full access to the environment or loading of some image (firmware)
	 * from a non-volatile device
	 *//*
	 * Most flashes can't be detected when write protection is enabled,
	 * so provide a way to let U-Boot gracefully ignore write protected
	 * devices.
	 *//* TODO: can we just include all these headers whether needed or not? *//opt/src/common/bootm.cboot_get_kernelimg_addrfit_uname_configfit_uname_kernelBOOTSTAGE_ID_CHECK_MAGICos_noffsetIH_ARCH_DEFAULTIH_TYPE_KERNELBOOTSTAGE_ID_FIT_KERNEL_STARTFIT_LOAD_IGNORED## Booting Android Image at 0x%08lx ...
"## Booting Android Image at 0x%08lx ...\n"Wrong Image Format for %s command
"Wrong Image Format for %s command\n"BOOTSTAGE_ID_FIT_KERNEL_INFOLEGACY_IMAGE_FORMATCONFIG_VAL(LEGACY_IMAGE_FORMAT)CONFIG_LEGACY_IMAGE_FORMAT__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_LEGACY_IMAGE_FORMAT__ARG_PLACEHOLDER_CONFIG_LEGACY_IMAGE_FORMAT__ARG_PLACEHOLDER_CONFIG_LEGACY_IMAGE_FORMAT 1CONFIG_VAL(LEGACY_IMAGE_FORMAT_MODULE)CONFIG_LEGACY_IMAGE_FORMAT_MODULELEGACY_IMAGE_FORMAT_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_LEGACY_IMAGE_FORMAT_MODULE__ARG_PLACEHOLDER_CONFIG_LEGACY_IMAGE_FORMAT_MODULE__ARG_PLACEHOLDER_CONFIG_LEGACY_IMAGE_FORMAT_MODULE 1"   kernel data at 0x%08lx, len = 0x%08lx (%ld)\n"*os_data, *os_len, *os_lendebug("   kernel data at 0x%08lx, len = 0x%08lx (%ld)\n",
	      *os_data, *os_len, *os_len)common/bootm.c802   kernel data at 0x%08lx, len = 0x%08lx (%ld)
iflagBOOTM_STATE_FDTneed_boot_fnBOOTM_STATE_OS_CMDLINEBOOTM_STATE_OS_BD_TBOOTM_STATE_OS_CMDLINE |
			BOOTM_STATE_OS_BD_TBOOTM_STATE_OS_CMDLINE |
			BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP960BOOTM_STATE_OS_CMDLINE |
			BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |
			BOOTM_STATE_OS_FAKE_GO1984BOOTM_STATE_OS_CMDLINE |
			BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |
			BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO(BOOTM_STATE_OS_CMDLINE |
			BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |
			BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO)os_dataos_lenERROR: booting os '%s' (%d) is not supported
"ERROR: booting os '%s' (%d) is not supported\n"BOOTSTAGE_ID_CHECK_BOOT_OSsubcommand not supported
"subcommand not supported\n"BOOTSTAGE_ID_DECOMP_UNIMPLOF_LIBFDTCONFIG_VAL(OF_LIBFDT)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_OF_LIBFDTCONFIG_VAL(OF_LIBFDT_MODULE)CONFIG_OF_LIBFDT_MODULEOF_LIBFDT_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_OF_LIBFDT_MODULE__ARG_PLACEHOLDER_CONFIG_OF_LIBFDT_MODULE__ARG_PLACEHOLDER_CONFIG_OF_LIBFDT_MODULE 1fixup_silent_linuxwant_silentsilent_linux"silent_linux""before silent fix-up: %s\n"debug("before silent fix-up: %s\n", cmdline)458before silent fix-up: %s
console=CONSOLE_ARGCONSOLE_ARG_LEN"%s: out of memory\n"debug("%s: out of memory\n", __func__)465%s: out of memory
num_start_bytes%s %s"%s %s"env_val"after silent fix-up: %s\n"debug("after silent fix-up: %s\n", env_val)488after silent fix-up: %s
bootm_load_os(load) - ((16) - 1)(16)((load) - ((16) - 1))(typeof((load) - ((16) - 1)))((16))-1load_bufimage_lenCONFIG_SYS_BOOTM_LENload_endBOOTSTAGE_ID_DECOMP_IMAGEflush_startALIGN_DOWN(load, ARCH_DMA_MINALIGN)(load_end)(typeof(load_end))(16)-1ALIGN(load_end, ARCH_DMA_MINALIGN)"   kernel loaded at 0x%08lx, end = 0x%08lx\n"load, load_enddebug("   kernel loaded at 0x%08lx, end = 0x%08lx\n", load, load_end)365   kernel loaded at 0x%08lx, end = 0x%08lx
BOOTSTAGE_ID_KERNEL_LOADEDno_overlapimage_startblob_endblob_start"images.os.start = 0x%lX, images.os.end = 0x%lx\n"blob_start, blob_enddebug("images.os.start = 0x%lX, images.os.end = 0x%lx\n",
		      blob_start, blob_end)images.os.start = 0x%lX, images.os.end = 0x%lx
"images.os.load = 0x%lx, load_end = 0x%lx\n"debug("images.os.load = 0x%lx, load_end = 0x%lx\n", load,
		      load_end)374images.os.load = 0x%lx, load_end = 0x%lx
const image_header_tconst image_header_t *IH_TYPE_MULTIWARNING: legacy format multi component image overwritten
"WARNING: legacy format multi component image overwritten\n"ERROR: new format image overwritten - must RESET the board to recover
"ERROR: new format image overwritten - must RESET the board to recover\n"BOOTSTAGE_ID_OVERWRITTENhandle_decomp_errorImage too large: increase CONFIG_SYS_BOOTM_LEN
"Image too large: increase CONFIG_SYS_BOOTM_LEN\n"%s: uncompress error %d
"%s: uncompress error %d\n"Must RESET board to recover
"Must RESET board to recover\n"bootm_find_otherIH_TYPE_KERNEL_NOLOADIH_OS_VXWORKScomp_typeuncomp_sizeIH_INITRD_ARCHRamdisk image is corrupt or invalid
"Ramdisk image is corrupt or invalid\n"Could not find a valid device tree
"Could not find a valid device tree\n"CMD_FDTCONFIG_VAL(CMD_FDT)CONFIG_IS_ENABLED(CMD_FDT)CONFIG_VAL(CMD_FDT_MODULE)CONFIG_CMD_FDT_MODULE__ARG_PLACEHOLDER_CONFIG_CMD_FDT_MODULECMD_FDT_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_CMD_FDT_MODULE__ARG_PLACEHOLDER_CONFIG_CMD_FDT_MODULE 1__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_CMD_FDTCONFIG_CMD_FDTulong *constLoadable(s) is corrupt or invalid
"Loadable(s) is corrupt or invalid\n"bootm_find_osos_hdrERROR: can't get kernel image!
"ERROR: can't get kernel image!\n"Can't get image type!
"Can't get image type!\n"BOOTSTAGE_ID_FIT_TYPECan't get image compression!
"Can't get image compression!\n"BOOTSTAGE_ID_FIT_COMPRESSIONCan't get image OS!
"Can't get image OS!\n"BOOTSTAGE_ID_FIT_OSCan't get image ARCH!
"Can't get image ARCH!\n"Can't get image load address!
"Can't get image load address!\n"BOOTSTAGE_ID_FIT_LOADADDRep_foundERROR: unknown image format type!
"ERROR: unknown image format type!\n"IH_ARCH_I386IH_ARCH_X86_64Could not find a valid setup.bin for x86
"Could not find a valid setup.bin for x86\n"Can't get entry point property!
"Can't get entry point property!\n"Could not find kernel entry point!
"Could not find kernel entry point!\n"CMD_BOOTICONFIG_VAL(CMD_BOOTI)__ARG_PLACEHOLDER_CONFIG_CMD_BOOTICONFIG_IS_ENABLED(CMD_BOOTI)CONFIG_VAL(CMD_BOOTI_MODULE)CONFIG_CMD_BOOTI_MODULE__ARG_PLACEHOLDER_CONFIG_CMD_BOOTI_MODULECMD_BOOTI_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_CMD_BOOTI_MODULE__ARG_PLACEHOLDER_CONFIG_CMD_BOOTI_MODULE 1__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_CMD_BOOTI__ARG_PLACEHOLDER_CONFIG_CMD_BOOTI 1IH_ARCH_ARM64image_addrbootm_start496sizeof(images)BOOTSTAGE_ID_BOOTM_START"bootm_start"boot_start_lmbmem_size(sizeof(CONSOLE_ARG) - 1)"console="defined(CONFIG_CMD_USB)CONFIG_LMBCONFIG_IS_ENABLED(LEGACY_IMAGE_FORMAT)IMAGE_ENABLE_FITCONFIG_ANDROID_BOOT_IMAGEIMAGE_ENABLE_OF_LIBFDTdefined(CONFIG_FPGA)!defined(USE_HOSTCC) || defined(CONFIG_FIT_SIGNATURE)defined(CONFIG_SILENT_CONSOLE) && !defined(CONFIG_SILENT_U_BOOT_ONLY)IMAGE_ENABLE_OF_LIBFDT && defined(CONFIG_LMB)/* ndef USE_HOSTCC *//* Return the first error we found *//* Allow the image to expand by a factor of 4, should be safe *//**
 * switch_to_non_secure_mode() - switch to non-secure mode
 *
 * This routine is overridden by architectures requiring this feature.
 *//* save pointer to image header *//*
		 * copy image header to allow for image overwrites during
		 * kernel decompression.
		 *//* get os_data and os_len *//* check image type, for FIT images get FIT kernel node *//**
 * boot_get_kernel - find kernel image
 * @os_data: pointer to a ulong variable, will hold os data start address
 * @os_len: pointer to a ulong variable, will hold os data length
 *
 * boot_get_kernel() tries to find a kernel image, verifies its integrity
 * and locates kernel data.
 *
 * returns:
 *     pointer to image header if valid image was found, plus kernel start
 *     address and length, otherwise NULL
 *//**
 * image_get_kernel - verify legacy format kernel image
 * @img_addr: in RAM address of the legacy format image to be verified
 * @verify: data CRC verification flag
 *
 * image_get_kernel() verifies legacy image integrity and returns pointer to
 * legacy image header if image verification was completed successfully.
 *
 * returns:
 *     pointer to a legacy image header if valid image was found
 *     otherwise return NULL
 *//* Deal with any fallout *//* Now run the OS! We hope this doesn't return *//* Check for unsupported subcommand. *//* Pretend to run the OS, then run a user command *//* Call various other states that are not generally used *//* From now on, we need the OS boot function *//* Relocate the ramdisk *//* Load the OS *//*
	 * Work through the states and see how far we get. We stop on
	 * any error.
	 *//**
 * Execute selected states of the bootm command.
 *
 * Note the arguments to this state must be the first argument, Any 'bootm'
 * or sub-command arguments must have already been taken.
 *
 * Note that if states contains more than one flag it MUST contain
 * BOOTM_STATE_START, since this handles and consumes the command line args.
 *
 * Also note that aside from boot_os_fn functions and bootm_load_os no other
 * functions we store the return value of in 'ret' may use a negative return
 * value, without special handling.
 *
 * @param cmdtp		Pointer to bootm command table entry
 * @param flag		Command flags (CMD_FLAG_...)
 * @param argc		Number of subcommand arguments (0 = no arguments)
 * @param argv		Arguments
 * @param states	Mask containing states to run (BOOTM_STATE_...)
 * @param images	Image header information
 * @param boot_progress 1 to show boot progress, 0 to not do this
 * @return 0 if ok, something else on error. Some errors will cause this
 *	function to perform a reboot! If states contains BOOTM_STATE_OS_GO
 *	then the intent is to boot an OS, so this function will not return
 *	unless the image type is standalone.
 *//* CONFIG_SILENT_CONSOLE *//* Allocate space for maximum possible new command line *//*
	 * Only fix cmdline when requested. The environment variable can be:
	 *
	 *	no - we never fixup
	 *	yes - we always fixup
	 *	unset - we rely on the console silent flag
	 *//*
	 * turn off USB to prevent the host controller from writing to the
	 * SDRAM while Linux is booting. This could happen (at least for OHCI
	 * controller), because the HCCA (Host Controller Communication Area)
	 * lies within the SDRAM and the host controller writes continously to
	 * this area (as busmaster!). The HccaFrameNumber is for example
	 * updated every 1 ms within the HCCA structure in SDRAM! For more
	 * details see the OpenHCI specification.
	 *//* Stop the ethernet stack if NetConsole could have left it up *//*
	 * We have reached the point of no return: we are going to
	 * overwrite all exception vector code, so we cannot easily
	 * recover from any failures any more...
	 *//**
 * bootm_disable_interrupts() - Disable interrupts in preparation for load/boot
 *
 * @return interrupt flag (0 if interrupts were disabled, non-zero if they were
 *	enabled)
 *//* Check what type of image this is. *//*
	 * The decompression routines are now safe, so will not write beyond
	 * their bounds. Probably it is not necessary to reset, but maintain
	 * the current behaviour for now.
	 *//* ENOSYS means unimplemented compression type, don't reset. *//**
 * handle_decomp_error() - display a decompression error
 *
 * This function tries to produce a useful message. In the case where the
 * uncompressed size is the same as the available space, we can assume that
 * the image is too large for the buffer.
 *
 * @comp_type:		Compression type being used (IH_COMP_...)
 * @uncomp_size:	Number of bytes uncompressed
 * @ret:		errno error code received from compression library
 * @return Appropriate BOOTM_ERR_ error code
 *//* USE_HOSTC *//* find all of the loadables *//* find bitstreams *//* find flattened device tree *//* find ramdisk *//**
 * bootm_find_images - wrapper to find and locate various images
 * @flag: Ignored Argument
 * @argc: command argument count
 * @argv: command argument list
 *
 * boot_find_images() will attempt to load an available ramdisk,
 * flattened device tree, as well as specifically marked
 * "loadable" images (loadables are FIT only)
 *
 * Note: bootm_find_images will skip an image if it is not found
 *
 * @return:
 *     0, if all existing images were loaded correctly
 *     1, if an image is found but corrupted, or invalid
 *//* Kernel entry point is the setup.bin *//* If we have a valid setup.bin, we will use that for entry (x86) *//* get image parameters *//* get kernel image header, start address and length *//* pointers to os/initrd/fdt images *//opt/src/include/vxworks.hvxworksboot_jump_vxworksboot_prep_vxworksdo_bootvxefi_gop_infoe820_infox3x2x1x0signEFI_GOP_INFO_MAGIC0xfeedfaceEFI_GOP_INFO_OFFSET0x6100BOOT_IMAGE_SIZE_OFFSET0x5004E820_SIGNATURE0x534d4150E820_INFO_OFFSET0x4a00E820_DATA_OFFSETX86_BOOT_LINE_OFFSET0x1200VXWORKS_PHYS_MEM_BASE_VXWORKS_H_/* framebuffer size *//* framebuffer base address *//* EFI GOP mode info structure *//* signature *//* EFI GOP info signatiure *//*
 * When booting from EFI BIOS, VxWorks bootloader stores the EFI GOP
 * framebuffer info at a pre-defined offset @ 0x6100. When VxWorks kernel
 * boots up, its EFI console driver tries to find such a block and if
 * the signature matches, the framebuffer information will be used to
 * initialize the driver.
 *
 * However it is not necessary to prepare an EFI environment for VxWorks's
 * EFI console driver to function (eg: EFI loader in U-Boot). If U-Boot has
 * already initialized the graphics card and set it to a VESA mode that is
 * compatible with EFI GOP, we can simply prepare such a block for VxWorks.
 *//*
 * VxWorks bootloader stores its size at a pre-defined offset @ 0x5004.
 * Later when VxWorks kernel boots up and system memory information is
 * retrieved from the E820 table, the bootloader size will be subtracted
 * from the total system memory size to calculate the size of available
 * memory for the OS.
 *//* must be zero *//* e820 table entry count *//* don't care, used by VxWorks *//* last e820 table entry addr *//* "SMAP" signature *//* E820 info signatiure "SMAP" - System MAP *//*
 * VxWorks x86 E820 related stuff
 *
 * VxWorks on x86 gets E820 information from pre-defined offset @
 * 0x4a00 and 0x4000. At 0x4a00 it's an information table defined
 * by VxWorks and the actual E820 table entries starts from 0x4000.
 * As defined by the BIOS E820 spec, the maximum number of E820 table
 * entries is 128 and each entry occupies 20 bytes, so it's 128 * 20
 * = 2560 (0xa00) bytes in total. That's where VxWorks stores some
 * information that is retrieved from the BIOS E820 call and saved
 * later for sanity test during the kernel boot-up.
 *//* x86 bootline offset relative to LOCAL_MEM_LOCAL_ADRS in VxWorks *//*
 * Physical address of memory base for VxWorks x86
 * This is LOCAL_MEM_LOCAL_ADRS in the VxWorks kernel configuration.
 *//*
 * (C) Copyright 2008
 * Niklaus Giger, niklaus.giger@member.fsf.org
 *//opt/src/include/tee/optee.hopteeoptee_verify_bootm_imageoptee_verify_imageoptee_header *optee_image_get_load_addrsizeof(struct optee_header)optee_image_get_entry_pointoptee_hdroptee_headerpaged_sizeinit_mem_usageinit_load_addr_loinit_load_addr_hiinit_sizeOPTEE_ARCH_ARM64OPTEE_ARCH_ARM32OPTEE_VERSIONOPTEE_MAGIC0x4554504f_OPTEE_Hdefined(CONFIG_OPTEE)/* _OPTEE_H *//*
 * OP-TEE related definitions
 *
 * (C) Copyright 2016 Linaro Limited
 * Andrew F. Davis <andrew.davis@linaro.org>
 */image_load_addrtzdram_starttzdram_len/opt/src/common/bootm_os.cbootm_osboot_os_fn *[24]..(*[24])(..)boot_os_fn **IH_TYPE_STANDALONEBOOTSTAGE_ID_BOOT_OS_RETURNED"\n## Control returned to monitor - resetting...\n"debug("\n## Control returned to monitor - resetting...\n")common/bootm_os.c527
## Control returned to monitor - resetting...
board_preboot_osdo_bootm_plan9"Plan 9"! %s:%d FIT images not supported for '%s' - must reset board to recover!
fit_unsupported_reset("Plan 9")char[74]Plan 9confaddr"confaddr"## Transferring control to Plan 9 (at address %08lx) ...
"## Transferring control to Plan 9 (at address %08lx) ...\n"do_bootm_rtems"RTEMS"fit_unsupported_reset("RTEMS")RTEMS## Transferring control to RTEMS (at address %08lx) ...
"## Transferring control to RTEMS (at address %08lx) ...\n"do_bootm_netbsd"NetBSD"fit_unsupported_reset("NetBSD")NetBSDkernel_datakernel_len<tee/optee.h><vxworks.h>loader## Transferring control to NetBSD stage-2 loader (at address %08lx) ...
"## Transferring control to NetBSD stage-2 loader (at address %08lx) ...\n"copy_argsdo_bootm_standaloneno"no"applboot_os_fn *[]boot_osdefined(CONFIG_BOOTM_NETBSD) || defined(CONFIG_BOOTM_PLAN9)CONFIG_BOOTM_NETBSDCONFIG_LYNXKDICONFIG_BOOTM_RTEMSdefined(CONFIG_BOOTM_OSE)defined(CONFIG_BOOTM_PLAN9)defined(CONFIG_BOOTM_VXWORKS) && \defined(CONFIG_CMD_ELF)CONFIG_INTEGRITYCONFIG_BOOTM_OPENRTOSCONFIG_BOOTM_OPTEECONFIG_BOOTM_LINUX/* relocate boot function table *//* We expect to return *//* Stand-alone may return when 'autostart' is 'no' *//* please define board specific board_preboot_os() *//* Allow for board specific config before we boot *//* please define platform specific arch_preboot_os() *//* Allow for arch specific config before we boot *//* From here we can run the regular linux boot path *//* Locate FDT etc *//* Validate OPTEE header *//* Verify OS type *//*
	 * OpenRTOS Parameters:
	 *   None
	 *//*
	 * INTEGRITY Parameters:
	 *   None
	 *//*
	 * QNX images require the data cache is disabled.
	 *//* and provide it via the arguments *//* write entry-point into string *//* Update ethernet nodes *//* CONFIG_BOOTM_PLAN9 *//*
	 * Plan 9 Parameters:
	 *   None
	 *//* See README.plan9 *//* CONFIG_BOOTM_OSE *//*
	 * OSE Parameters:
	 *   None
	 *//* CONFIG_BOOTM_RTEMS *//*
	 * RTEMS Parameters:
	 *   r3: ptr to board info data
	 *//* CONFIG_LYNXKDI *//* CONFIG_BOOTM_NETBSD*//*
	 * NetBSD Stage-2 Loader Parameters:
	 *   arg[0]: pointer to board info data
	 *   arg[1]: image load address
	 *   arg[2]: char pointer to the console device to use
	 *   arg[3]: char pointer to the boot arguments
	 *//*
	 * Booting a (NetBSD) kernel image
	 *
	 * This process is pretty similar to a standalone application:
	 * The (first part of an multi-) image must be a stage-2 loader,
	 * which in turn is responsible for loading & invoking the actual
	 * kernel.  The only differences are the parameters being passed:
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 *//* OS booting routines *//* Don't start if "autostart" is set to "no" *//opt/src/common/bootstage.cbootstage_init968sizeof(struct bootstage_data)BOOTSTAGE_ID_USERBOOTSTAGE_ID_AWAKEbootstage_get_sizebootstage_unstash(uintptr_t)0~(uintptr_t)0(char *)(~(uintptr_t)0)const bootstage_hdrconst bootstage_hdr *bootstage_hdr *"%s: Not enough space for bootstage hdr\n"debug("%s: Not enough space for bootstage hdr\n", __func__)common/bootstage.c436%s: Not enough space for bootstage hdr
BOOTSTAGE_MAGIC"%s: Invalid bootstage magic\n"debug("%s: Invalid bootstage magic\n", __func__)441%s: Invalid bootstage magic
"%s: Bootstage data runs past buffer end\n"debug("%s: Bootstage data runs past buffer end\n", __func__)446%s: Bootstage data runs past buffer end
bootstage_record *"%s: Bootstage has %d records needing %lu bytes, but " "only %d bytes is available\n"__func__, hdr->count, (ulong)hdr->count * sizeof(*rec), hdr->sizedebug("%s: Bootstage has %d records needing %lu bytes, but "
			"only %d bytes is available\n", __func__, hdr->count,
		      (ulong)hdr->count * sizeof(*rec), hdr->size)%s: Bootstage has %d records needing %lu bytes, but only %d bytes is available
"%s: Bootstage has %d records needing %lu bytes, but "
			"only %d bytes is available\n"BOOTSTAGE_VERSION"%s: Bootstage data version %#0x unrecognised\n"__func__, hdr->versiondebug("%s: Bootstage data version %#0x unrecognised\n",
		      __func__, hdr->version)459%s: Bootstage data version %#0x unrecognised
RECORD_COUNT"%s: Bootstage has %d records, we have space for %d\n" "Please increase CONFIG_(SPL_)BOOTSTAGE_RECORD_COUNT\n"__func__, hdr->count, RECORD_COUNT - data->rec_countdebug("%s: Bootstage has %d records, we have space for %d\n"
			"Please increase CONFIG_(SPL_)BOOTSTAGE_RECORD_COUNT\n",
		      __func__, hdr->count, RECORD_COUNT - data->rec_count)466%s: Bootstage has %d records, we have space for %d
Please increase CONFIG_(SPL_)BOOTSTAGE_RECORD_COUNT
"%s: Bootstage has %d records, we have space for %d\n"
			"Please increase CONFIG_(SPL_)BOOTSTAGE_RECORD_COUNT\n"char[104]rec_sizebootstage_record[30]sizeof(*data->record)"Unstashed %d records\n"hdr->countdebug("Unstashed %d records\n", hdr->count)Unstashed %d records
bootstage_stashconst bootstage_dataconst bootstage_data *const bootstage_recordconst bootstage_record *"%s: Not enough space for bootstage stash\n"debug("%s: Not enough space for bootstage stash\n", __func__)412%s: Not enough space for bootstage stash
"Stashed %d records\n"debug("Stashed %d records\n", hdr->count)418Stashed %d records
append_databootstage_reportTimer summary in microseconds (%d records):
"Timer summary in microseconds (%d records):\n"%11s%11s  %s
"%11s%11s  %s\n"Mark"Mark"Elapsed"Elapsed"Stage"Stage"Overflowed internal boot id table by %d entries
Please increase CONFIG_(SPL_)BOOTSTAGE_RECORD_COUNT
"Overflowed internal boot id table by %d entries\n"
		       "Please increase CONFIG_(SPL_)BOOTSTAGE_RECORD_COUNT\n"
Accumulated time:
"\nAccumulated time:\n"bootstage_fdt_add_reportbootstage: Failed to add to device tree
"bootstage: Failed to add to device tree\n"add_bootstages_devicetree"bootstage"recnumget_record_name(buf, sizeof(buf), rec)fdt_setprop_string(blob, node, "name",
				       get_record_name(buf, sizeof(buf), rec))accum"accum"mark"mark"h_compare_recordrec1rec2print_time_record%11s"%11s"BOOTSTAGE_DIGITSget_record_nameuser_%d"user_%d"id=%d"id=%d"bootstage_accumbootstage_startr1r2start_usbootstage_mark_code%s,"%s,": %s": %s"BOOTSTAGE_ID_ALLOCbootstage_mark_nameBOOTSTAGEF_ALLOCbootstage_errorBOOTSTAGEF_ERRORbootstage_markbootstage_add_recordensure_idfind_idbootstage_relocate"Relocating %d records\n"data->rec_countdebug("Relocating %d records\n", data->rec_count)Relocating %d records
bootstage_hdrbootstage_recordBOOTSTAGE_RECORD_COUNTCONFIG_VAL(BOOTSTAGE_RECORD_COUNT)next_id__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_BOOTSTAGE_RECORD_COUNTCONFIG_BOOTSTAGE_RECORD_COUNT/* Mark the records as read *//* Assume no data corruption here *//* Read the name strings *//* Read the records *//* Update total data size *//* Check for buffer overflow *//* Write the name strings *//* Write the records, silently stopping when we run out of space *//* Count the number of records, and write that value first *//* Write an arbitrary version number *//**
 * Append data to a memory buffer
 *
 * Write data to the buffer if there is space. Whether there is space or not,
 * the buffer pointer is incremented.
 *
 * @param ptrp	Pointer to buffer, updated by this function
 * @param end	Pointer to end of buffer
 * @param data	Data to write to buffer
 * @param size	Size of data
 *//* Sort records by increasing time *//* Check if this is a 'mark' or 'accum' record *//* add properties to the node. *//*
	 * Insert the timings to the device tree in the reverse order so
	 * that they can be printed in the Linux kernel in the right order.
	 *//*
	 * Create the node for bootstage.
	 * The address of flat device tree is set up by the command bootm.
	 *//**
 * Add all bootstage timings to a device tree.
 *
 * @param blob	Device tree blob
 * @return 0 on success, != 0 on failure.
 *//**
 * Get a record name as a printable string
 *
 * @param buf	Buffer to put name if needed
 * @param len	Length of buffer
 * @param rec	Boot stage record to get the name from
 * @return pointer to name, either from the record or pointing to buf.
 *//* First work out the length we need to allocate *//* Tell the board about this progress *//* Only record the first event for each *//*
	 * initf_bootstage() is called very early during boot but since hang()
	 * calls bootstage_error() we can be called before bootstage is set up.
	 * Add a check to avoid this.
	 *//*
	 * Duplicate all strings.  They may point to an old location in the
	 * program .text section that can eventually get trashed.
	 *//* Total data size (non-zero if valid) *//* BOOTSTAGE_VERSION *//* see enum bootstage_flags *//*
 * This module records the progress of boot and arbitrary commands, and
 * permits accurate timestamping of each.
 *//*
 * Copyright (c) 2011, Google Inc. All rights reserved.
 */linenum/opt/src/common/cli.cBOOTSTAGE_ID_ENTER_CLI_LOOP## Error: Secure boot command not specified
"## Error: Secure boot command not specified\n"## Error: "%s" returned (code %d)
"## Error: \"%s\" returned (code %d)\n"bootsecure"bootsecure"CMD_FLAG_ENVneed_buffFLAG_PARSE_SEMICOLONFLAG_EXIT_FROM_LOOPFLAG_PARSE_SEMICOLON | FLAG_EXIT_FROM_LOOPhush_flagsFLAG_CONT_ON_NEWLINEHUSH_PARSERCONFIG_VAL(HUSH_PARSER)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_HUSH_PARSERCONFIG_HUSH_PARSERCONFIG_VAL(HUSH_PARSER_MODULE)CONFIG_HUSH_PARSER_MODULEHUSH_PARSER_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_HUSH_PARSER_MODULE__ARG_PLACEHOLDER_CONFIG_HUSH_PARSER_MODULE__ARG_PLACEHOLDER_CONFIG_HUSH_PARSER_MODULE 1!CONFIG_IS_ENABLED(HUSH_PARSER)defined(CONFIG_CMDLINE)defined(CONFIG_HUSH_INIT_VAR)/*CONFIG_HUSH_PARSER*//* This point is never reached *//*
	 * Not a whole lot to do here.  Rebooting won't help much, since we'll
	 * just end up right back here.  Just loop.
	 *//* Shouldn't ever return from boot command. *//* Run the command, forcing no flags and faking argc and argv. *//* Find the command directly. *//* Disable Ctrl-C just in case some command is used that checks it. *//*
 * Runs the given boot command securely.  Specifically:
 * - Doesn't run the command with the shell (run_command or parse_string_outer),
 *   since that's a lot of code surface that an attacker might exploit.
 *   Because of this, we don't do any argument parsing--the secure boot command
 *   has to be a full-fledged u-boot command.
 * - Doesn't check for keypresses before booting, since that could be a
 *   security hole; also disables Ctrl-C.
 * - Doesn't allow the command to return.
 *
 * Upon any failures, this function will drop into an infinite loop after
 * printing the error message to console.
 *//*
	 * If the bootsecure option was chosen, use secure_boot_cmd().
	 * Always use 'env' in this case, since bootsecure requres that the
	 * bootcmd was specified in the FDT too.
	 *//* Allow the fdt to override the boot command *//*
	 * This function will overwrite any \n it sees with a \0, which
	 * is why it can't work with a const char *. Here we are making
	 * using of internal knowledge of this function, to avoid always
	 * doing a malloc() which is actually required only in a case that
	 * is pretty rare.
	 *//* the built-in parser will change our string if it sees \n *//* hush will never change our string *//* cast away const *//* CONFIG_CMDLINE *//*
	 * parse_string_outer() returns 1 for failure, so clean up
	 * its result.
	 *//*
 * Run a command using the selected parser, and check if it is repeatable.
 *
 * @param cmd	Command to run
 * @param flag	Execution flags (CMD_FLAG_...)
 * @return 0 (not repeatable) or 1 (repeatable) on success, -1 on error.
 *//*
	 * cli_run_command can return 0 or 1 for success, so clean up
	 * its result.
	 *//*
 * Run a command using the selected parser.
 *
 * @param cmd	Command to run
 * @param flag	Execution flags (CMD_FLAG_...)
 * @return 0 on success, or != 0 on error.
 *//*
 * (C) Copyright 2000
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *
 * Add to readline cmdline-editing by
 * (C) Copyright 2005
 * JinHua Luo, GuangDong Linux Center, <luo.jinhua@gd-linux.com>
 *//opt/src/include/cli_hush.h<cli_hush.h>_LINUX_STDDEF_Hdefined(__cplusplus)cli_hushFLAG_REPARSING_CLI_HUSH_H_get_local_varunset_local_varset_local_varparse_file_outerparse_string_outeru_boot_hush_start/* continue when we see \n *//* >=2nd pass *//* symbol ';' is special for parser */flg_export/opt/src/common/cli_hush.cdo_showvarvariables *cur
 ** Abort
"\n ** Abort\n"make_stringnoeval_strHUSH_NO_EVAL"HUSH_NO_EVAL"noeval'"'"make_list_insizeof(*list)p3p1p2inpinsert_var_value_subSPECIAL_VAR_SYMBOLres_strres_str_lenSUBSTED_VAR_SYMBOLinsert_var_valuexreallocERROR : memory not allocated
"ERROR : memory not allocated\n"xmallocsizeof(struct variables)HUSH_VERSION"HUSH_VERSION"0.01"0.01"in_str *parse_stream_outerctxp_context *;$&|";$&|"tag_substo_string *NULL_O_STRINGPIPE_SEQpipe *exit not allowed from main input shell.
"exit not allowed from main input shell.\n"<INTERRUPT>
"<INTERRUPT>\n"update_ifs_mapIFS"IFS" 	
" \t\n"sizeof(map)uchar[2]subst\$'""\\$'\"";&|#";&|#"mapsetparse_streamparse_stream, end_trigger=%d
"parse_stream, end_trigger=%d\n"parse_stream: ch=%c (%d) m=%d quote=%d - %c
"parse_stream: ch=%c (%d) m=%d quote=%d - %c\n"RES_NONEleaving parse_stream (triggered)
"leaving parse_stream (triggered)\n"'\''PIPE_ANDend_triggerPIPE_ORsubst, pass=%d
"subst, pass=%d\n"subst, term=%d
"subst, term=%d\n"leaving parse_stream (EOF)
"leaving parse_stream (EOF)\n"handle_dollarhandle_dollar: ch=%c
"handle_dollar: ch=%c\n"isalpha(ch)child_prog *isalnum(ch)'_'advanceget_dollar_var%u"%u"lookup_paramassignexpand_empty%s=%s"%s=%s"done_pipedone_pipe, type %d
"done_pipe, type %d\n"new_pdone_commandprogdone_command: skipping null command
"done_command: skipping null command\n"done_command: num_progs incremented to %d
"done_command: num_progs incremented to %d\n"done_command: initializing
"done_command: initializing\n"sizeof(*pi->progs)done_worddone_word: %s %p
"done_word: %s %p\n"  true null, ignored
"  true null, ignored\n"checking %s for reserved-ness
"checking %s for reserved-ness\n"RES_SNTXsizeof(*child->argv)sizeof(*child->argv_nonnull)RES_FORreserved_wordreserved_combo *reserved_combo[11]NRESfound reserved word %s, code %d
"found reserved word %s, code %d\n"FLAG_STARTsizeof(struct p_context)push stack
"push stack\n"RES_INFLAG_ENDpop stack
"pop stack\n"initialize_contextnew_pipesizeof(struct pipe)is_assignmentisalpha(*s)isalnum(*s)%s: readonly variable"%s: readonly variable"ERROR: There is a global environment variable with the same name.
"ERROR: "
				"There is a global environment variable with the same name.\n"bottomrun_listfree_pipe_list%s pipe reserved mode %d
"%s pipe reserved mode %d\n"ind%s pipe followup code %d
"%s pipe followup code %d\n"free_pipe%s  command %d:
"%s  command %d:\n"%s   argv[%d] = %s
"%s   argv[%d] = %s\n"ret_code%s   end group
"%s   end group\n"%s   (nil)
"%s   (nil)\n"indenterblanks                                    sizeof(blanks)run_list_realrpipeindentRES_WHILERES_UNTILflag_restoreflag_reprmodermode=%d  if_code=%d  next_if_code=%d skip_more=%d
"rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n"if_codenext_if_codeskip_more_in_this_rmodeRES_XXXXflag_skipRES_THENRES_ELSERES_ELIFsave_listsave_nameRES_DORES_DONErun_pipe_real returned %d
"run_pipe_real returned %d\n"RES_IFrun_pipe_realnextinchild_prog **non-subshell grouping
"non-subshell grouping\n"export_meLocal environment set: %s
"Local environment set: %s\n"FLAG_EXIT_FROM_LOOP | FLAG_REPARSINGUnknown command '%s' - try 'help' or use 'run' command
"Unknown command '%s' - try 'help' or use "
					"'run' command\n"setup_string_in_strsetup_file_in_strfile_peekfile_getb_getch: got a %d
"b_getch: got a %d\n"get_user_inputchar[1025]CONFIG_SYS_CBSIZE + 1the_commanduboot_cli_readline=> CONFIG_SYS_PROMPT> CONFIG_SYS_PROMPT_HUSH_PS2ps_promptstatic_peekstatic_getb_addqchr*?[\"*?[\\"b_freeb_resetb_addchrb_addchr: %c %d %p
"b_addchr: %c %d %p\n"B_NOSPACb_check_spaceold_data2*lenB_CHUNK(100)max(2*len, B_CHUNK)syntax_errsyntax error
"syntax error\n"debug_printfreserved_comboin_stro_stringvariablesp_contextchild_progreserved_styleRES_FIpipe_stylePIPE_BGliteralpeekpromptmode__promptmequoteflg_read_onlystackold_flagspr_modefollowupprogsnum_progsargv_nonnullshowvar"print local hushshell variables""\n    - print values of all hushshell variables\n" "showvar name ...\n" "    - print value of hushshell variable 'name'"U_BOOT_CMD(
	showvar, CONFIG_SYS_MAXARGS, 1,	do_showvar,
	"print local hushshell variables",
	"\n    - print values of all hushshell variables\n"
	"showvar name ...\n"
	"    - print value of hushshell variable 'name'"
)print local hushshell variables
    - print values of all hushshell variables
showvar name ...
    - print value of hushshell variable 'name'"\n    - print values of all hushshell variables\n"
	"showvar name ...\n"
	"    - print value of hushshell variable 'name'"_u_boot_list_2_cmd_2_showvar.u_boot_list_2_cmd_2_showvarreserved_combo[]"if"FLAG_THEN2052FLAG_THEN | FLAG_STARTthen"then"FLAG_ELIFFLAG_ELSEFLAG_ELIF | FLAG_ELSEFLAG_FIFLAG_ELIF | FLAG_ELSE | FLAG_FIelif"elif"else"else"fi"fi"for"for"FLAG_INFLAG_IN   | FLAG_STARTwhile"while"FLAG_DO2560FLAG_DO   | FLAG_STARTuntil"until""in"do"do"FLAG_DONE"done"reserved_listtop_varsdo_repeatflag_repeatifslast_return_code(sizeof(reserved_list)/sizeof(struct reserved_combo))final_printfb_peek(input)((input)->peek(input))b_getch(input)((input)->get(input)){NULL,0,0,0,0}(1<<RES_XXXX)(1<<RES_IN)(1<<RES_DONE)(1<<RES_DO)FLAG_UNTIL(1<<RES_UNTIL)FLAG_WHILE(1<<RES_WHILE)FLAG_FOR(1<<RES_FOR)(1<<RES_FI)(1<<RES_ELSE)(1<<RES_ELIF)(1<<RES_THEN)FLAG_IF(1<<RES_IF)(1<<RES_NONE)error_msgxstrdupsyntax()syntax_err()0403"> "__U_BOOT__DEBUG_SHELLCONFIG_FEATURE_SH_FANCY_PROMPTCONFIG_CMDLINE_PS_SUPPORTCONFIG_FEATURE_COMMAND_EDITINGCONFIG_RESET_TO_RETRYCONFIG_FEATURE_SH_STANDALONE_SHELLCONFIG_FEATURE_SH_APPLETS_ALWAYS_WINBB_VERCONFIG_FEATURE_SH_EXTRA_QUIETCONFIG_FEATURE_CLEAN_UPoinput0/* print single env variables	*//* Print all env variables	*//*
 * Make new string for parser
 * inp     - array of argument strings to flatten
 * nonnull - indicates argument was quoted when originally parsed
 *//* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element *//* create list of variable values *//*
				 * copy the variable value to the result
				 * string
				 *//*
				 * mark the replaced text to be accepted as
				 * is
				 *//* look up the value to substitute *//* find the ending marker *//* copy any characters to the result string *//* check the beginning of the string for normal characters *//* Looks like they want an interactive shell *//* A shell is interactive if the `-i' flag was given, or if all of
	 * the following conditions are met:
	 *	  no -c command
	 *    no arguments remaining or the -s flag given
	 *    standard input is a terminal
	 *    standard output is a terminal
	 *    Refer to Posix.2, the description of the `sh' utility. *//* without call putenv() *//* initialize our shell local variables with the values
	 * currently living in the environment *//* Initialize some more globals to non-zero values *//* map[] is taken care of with call to update_ifs_map() *//* (re?) initialize globals.  Sometimes hush_main() ends up calling
	 * hush_main(), therefore we cannot rely on the BSS to zero out this
	 * stuff.  Reset these to 0 every time. *//* XXX what should these be while sourcing /etc/profile? *//* Grab control of the terminal.  *//* Put ourselves in our own process group.  *//* Ignore interactive and job-control signals.  *//* Loop until we are in the foreground.  *//* Make sure we have a controlling tty.  If we get started under a job
 * aware app (like bash for example), make sure we are now in charge so
 * we don't fight over who gets the foreground *//* __U_BOOT__ *//* loop on syntax errors, return on EOF *//* XXX hackish way to not allow exit from main loop *//* exit *//* most recursion does not come through here, the exeception is
 * from builtin_source() *//* also flow through if quoted *//* flow through if quoted *//* never flow through *//* most characters flow through always *//* Precompute a list of 'flow through' behavior so it can be treated
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 *//* char *ifs and char map[256] are both globals. *//* complain if quote?  No, maybe we just finished a command substitution
	 * that was quoted.  Example:
	 * $ echo "`cat foo` plus more"
	 * and we just got the EOF generated by the subshell that ran "cat foo"
	 * The only real complaint is if we got an EOF when end_trigger != '\0',
	 * that is, we were really supposed to get end_trigger, and never got
	 * one before the EOF.  Can't use the standard "syntax error" return code,
	 * so that parse_stream_outer can distinguish the EOF and exit smoothly. *//* this is really an internal logic error *//* Proper use of this character caught by end_trigger *//* we could pick up a file descriptor choice here
				 * with redirect_opt_num(), but bash doesn't do it.
				 * "echo foo 2| cat" yields "foo 2". *//* until we support <(list) Process Substitution *//* until we support >(list) Process Substitution *//* Yahoo!  Time to run with it! *//* If we aren't performing a substitution, treat a newline as a
				 * command separator.  *//* unquoted IFS *//* Only double-quote state is handled in the state variable dest->quote.
	 * A single-quote triggers a bypass of the main loop until its mate is
	 * found.  When recursing, quote state is passed in via dest->quote. *//* return code is 0 for normal exit, 1 for syntax error *//* Eat the character if the flag was set.  If the compiler
	 * is smart enough, we could substitute "b_getch(input);"
	 * for all the "advance = 1;" above, and also end up with
	 * a nice size-optimized program.  Hah!  That'll be the day.
	 *//* still unhandled, but should be eventually *//* XXX maybe someone will try to escape the '}' *//* recursion *//* XXX is $0 special? *//* first character after the $ *//* return code: 0 for OK, 1 for syntax error *//* basically useful version until someone wants to get fancier,
 * see the bash man page under "Parameter Expansion" *//* child remains "open", available for possible redirects *//* and the final command there, too *//* finish off the final word in the subcontext *//* really logic error *//* syntax error, groups and arglists don't mix *//* XXX this process fails to trim a single trailing newline *//* This is the step that wait()s for the child.  Should be pretty
	 * safe, since we just read an EOF from its stdout.  We could try
	 * to better, by using wait(), and keeping track of background jobs
	 * at the same time.  That would be a lot of work, and contrary
	 * to the KISS philosophy of this program. *//* discard *//* XXX In case of a syntax error, should we try to kill the child?
	 * That would be tough to do right, so just read until EOF. *//* now send results of command back into original context *//* syntax error or EOF *//* recursion to generate command *//* return code is exit status of the process that is run. *//* this version hacked for testing purposes *//* leaks memory *//* reuse num (and save an int) *//* If a redirect is immediately preceded by a number, that number is
 * supposed to tell which file descriptor to redirect.  This routine
 * looks for such preceding numbers.  In an ideal world this routine
 * needs to handle all the following classes of redirects...
 *     echo 2>foo     # redirects fd  2 to file "foo", nothing passed to echo
 *     echo 49>foo    # redirects fd 49 to file "foo", nothing passed to echo
 *     echo -2>foo    # redirects fd  1 to file "foo",    "-2" passed to echo
 *     echo 49x>foo   # redirects fd  1 to file "foo",   "49x" passed to echo
 * A -1 output from this program means no valid number was found, so the
 * caller should use the appropriate default for this redirection.
 *//* "-" represents "close me" *//* get the & *//* peek ahead in the in_str to find out if we have a "&n" construct,
 * as in "2>&1", that represents duplicating a file descriptor.
 * returns either -2 (syntax error), -1 (no &), or the number found.
 *//* set up new pipe to accept commands *//* implicit closure of previous command *//* but ctx->pipe and ctx->list_head remain unchanged *//* The child is really already in the pipe structure, so
	 * advance the pipe counter and make a new, null child.
	 * Only real trickiness here is that the uncommitted
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. *//* The only possible error here is out of memory, in which case
 * xmalloc exits. *//* normal return is 0.
 * Syntax or xglob errors return 1. *//* physical copy *//* Mostly a list of accepted follow-up reserved words.
 * FLAG_END means we are done with the sequence, and are ready
 * to turn the compound list into a command.
 * FLAG_START means the word must start a new compound list.
 *//* normal return is 0
 * if a reserved word is found, and processed, return 1
 * should handle if, then, elif, else, fi, for, while, until, do, done.
 * case, function, and select are obnoxious, save those for later.
 *//* creates the memory for working child *//* invalid *//* We do _not_ try to open the file that src points to,
		 * since we need to return and let src be expanded first.
		 * Set ctx->pending_redirect, so we know what to do at the
		 * end of the next parsed word.
		 *//* Erik had a check here that the file descriptor in question
		 * is legit; I postpone that to "run time"
		 * A "-" representation of "close me" shows up as a -3 here *//* syntax error *//* Check for a '2>&1' type redirect *//* Create a new redir_struct and drop it onto the end of the linked list *//* the src parameter allows us to peek forward to a possible &n syntax
 * for file descriptor duplication, e.g., "2>&1".
 * Return code is 0 normally, 1 if a syntax error is detected in src.
 * Resource errors (in xmalloc) cause the process to exit *//* equivalent to previous set *//* Assume when we enter this function that we are already in
	 * NAME=VALUE format.  So the first order of business is to
	 * split 's' on the '=' into 'name' and 'value' *//* might be possible! *//* This is used to set local shell variables
   flg_export==0 if only local (not exporting) variable
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) *//* This is used to get/check local shell variables *//* globprint(glob_target); *//* GLOB_ABORTED ? *//* quote removal, or more accurately, backslash removal *//* bash man page calls this an "explicit" null *//* we can code this better when the debug_printf's are gone *//* short-circuit for null word *//* XXX broken if the last character is '\\', check that before calling *//* The API for glob is arguably broken.  This routine pushes a non-matching
 * string into the output structure, removing non-backslashed backslashes.
 * If someone can prove me wrong, by performing this function within the
 * original glob(3) api, feel free to rewrite this routine into oblivion.
 * Return code (0 vs. GLOB_NOSPACE) matches glob(3).
 * XXX broken if the last character is '\\', check that before calling.
 *//* free_pipe_list has the side effect of clearing memory
	 * In the long run that function can be merged with run_list_real,
	 * but doing that now would hobble the debugging effort. *//* Select which version we will use *//* if list has no members *//* children are an array, they get freed all at once *//* guard against the case >$FOO, where foo is unset or blank *//* return code is the exit status of the pipe *//* broken, of course, but OK for testing *//* can be overwritten a number of times *//* restore number of programs *//* move the shell to the foreground *//* move the new process group into the foreground *//* XXX what does bash do with attempts to background builtins? *//* XXX compute jobid *//* XXX check bash's behavior with nontrivial pipes *//* We only ran a builtin: rcode was set by the return value
			 * of run_pipe_real(), and we don't need to wait for anything. *//* save number of programs *//* insert new value from list for variable *//* if no variable values after "in" we skip "for" *//* check Ctrl-C *//* check syntax for "for" *//* need double-buffer to handle elif *//* If there isn't another process, nextin is garbage
		   but it doesn't matter *//* Don't check for errors.  The child may be dead already,
		 * in which case setpgid returns error code EACCES. *//* put our child in the process group whose leader is the
		   first process in this pipe *//* If we (the child) win the race, put ourselves in the process
				 * group whose leader is the first process in this pipe. *//* Like bash, explicit redirects override pipes,
			 * and the pipe fd is available for dup'ing. *//* opposite end of our output pipe *//* Set the handling for job control signals back to the default.  *//* XXX test for failed fork()? *//* pipes are inserted between pairs of commands *//* Process the command *//* check ";", because ,example , argv consist from
		 * "help;flinfo" must not execute
		 *//* XXX restore hack so free() can work right *//* XXX horrible hack *//* XXX setup_redirects acts on file descriptors, not FILEs.
				 * This is perfect for work that comes after exec().
				 * Is it really safe for inline use?  Experimentally,
				 * things seem to work with glibc. *//* don't worry about errors in set_local_var() yet *//* Ok, this case is tricky.  We have to decide if this is a
				 * local variable, or an already exported variable.  If it is
				 * already exported, we have to export the new value.  If it is
				 * not exported, we need only set this as a local variable.
				 * This junk is all to decide whether or not to export this
				 * variable. *//* assignments, but no command: set the local environment *//* nothing *//* XXX could we merge code with following builtin case,
		 * by creating a pseudo builtin that calls run_list_real? *//* Check if this is a simple builtin (not part of a pipe).
	 * Builtins within pipes have to fork anyway, and are handled in
	 * pseudo_exec.  "echo foo | read bar" doesn't work on bash, either.
	 *//* Avoid longjmp clobbering *//* pipefds[0] is for reading *//* run_pipe_real() starts all the jobs, but doesn't wait for anything
 * to finish.  See checkjobs().
 *
 * return code is normally -1, when the caller has to wait for children
 * to finish to determine the exit status of the pipe.  If the pipe
 * is a simple builtin command, however, the action is done by the
 * time run_pipe_real returns, and the exit code is provided as the
 * return value.
 *
 * The input of the pipe is always stdin, the output is always
 * stdout.  The outpipe[] mechanism in BusyBox-0.48 lash is bogus,
 * because it tries to avoid running the command substitution in
 * subshell, when that is in fact necessary.  The subshell process
 * now has its stdout directed to the input of the appropriate pipe,
 * so this routine is noticeably simpler.
 *//* Figure out our controlling tty, checking in order stderr,
 * stdin, and stdout.  If check_pgrp is set, also check that
 * we belong to the foreground process group associated with
 * that tty.  The value of shell_terminal is needed in order to call
 * tcsetpgrp(shell_terminal, ...); *//*	perror_msg("tcsetpgrp-2"); *//*if (interactive && tcsetpgrp(shell_terminal, getpgid(0))) *//* Printing this stuff is a pain, since it tends to
			 * overwrite the prompt an inconveinient moments.  So
			 * don't do that.  *//* child stopped *//* child exited *//* Checks to see if any processes have exited -- if they
   have, figure out why and see if a job has completed *//* remove a backgrounded job *//* we don't wait for background thejobs to return -- append it
	   to the list of backgrounded thejobs and leave it alone *//*if (pi->progs[0] && pi->progs[0].argv && pi->progs[0].argv[0]) *//* cmdedit buffer size *//* physically copy the struct job *//* add thejob to the list of running jobs *//* Linear search for the ID of the job to use *//* Can happen.  See what bash does with ">foo" by itself. *//* OK to leak memory by not calling free_pipe_list,
		 * since this process is about to exit *//* crucial!!!! *//* Count argc for use in a second... *//* Following discussions from November 2000 on the busybox mailing
			 * list, the default configuration, (without
			 * get_last_path_component()) lets the user force use of an
			 * external command by specifying the full (with slashes) filename.
			 * If you enable CONFIG_FEATURE_SH_APPLETS_ALWAYS_WIN then applets
			 * _aways_ override external commands, so if you want to run
			 * /bin/cat, it will use BusyBox cat even if /bin/cat exists on the
			 * filesystem and is _not_ busybox.  Some systems may want this,
			 * most do not.  *//* Check if the command matches any busybox internal commands
		 * ("applets") here.
		 * FIXME: This feature is not 100% safe, since
		 * BusyBox is not fully reentrant, so we have no guarantee the things
		 * from the .bss are still zeroed, or that things from .data are still
		 * at their defaults.  We could exec ourself from /proc/self/exe, but I
		 * really dislike relying on /proc for things.  We could exec ourself
		 * from global_argv[0], but if we are in a chroot, we may not be able
		 * to find ourself... *//*
		 * Check if the command matches any of the builtins.
		 * Depending on context, this might be redundant.  But it's
		 * easier to waste a few CPU cycles than it is to figure out
		 * if this is one of those cases.
		 *//* If a variable is assigned in a forest, and nobody listens,
		 * was it ever really set?
		 *//* XXX this hack isn't so horrible, since we are about
					to exit, and therefore don't need to keep data
					structures consistent for free() use. *//* XXX no exit() here.  If you don't exec, use _exit instead.
 * The at_exit handlers apparently confuse the calling process,
 * in particular stdin handling.  Not sure why? *//* never returns *//* No error checking.  I sure wouldn't know what
			 * to do with an error if I found one! *//* this could get lost if stderr has been redirected, but
			   bash and ash both lose it as well (though zsh doesn't!) *//* something went wrong in the parse.  Pretend it didn't happen *//* squirrel != NULL means we squirrel away copies of stdin, stdout,
 * and stderr if they are redirected. *//* All the callers guarantee this routine will never be
 * used right after a newline, so prompting is not needed.
 *//* need to double check i->file because we might be doing something
		 * more complicated by now, like sourcing or substituting. *//* If there is data waiting, eat it up *//* This is the magic location that prints prompts
 * and gets data back from the user *//*
	 ** enable command line editing only while a command line
	 ** is actually being read; otherwise, we'll end up bequeathing
	 ** atexit() handlers and other unwanted stuff to our
	 ** child processes (rob@sysgo.de)
	 *//* Set up the prompt *//* no escape checking necessary *//* My analysis of quoting semantics tells me that state information
 * is associated with a destination, not a source.
 *//* assert (data == NULL || o->maxlen != 0); *//* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length *//* bash returned already true *//* built-in 'unset VAR' handler *//* XXX argv and argc are broken; need to save old global_argv
	 * (pointer only is OK!) on this stack frame,
	 * set global_argv=child->argv+1, recurse, and restore. *//* Now run the file *//* XXX search through $PATH is missing *//* Built-in '.' handler (read-in and execute commands from file) *//* XXX This probably breaks $0 *//* Built-in 'shift' handler *//* built-in 'set VAR=value' handler *//* So not move up to avoid breaking errno *//* read string *//* In case stdin has only EOF *//* built-in 'read VAR' handler *//* built-in 'pwd' handler *//* built-in 'jobs' handler *//* built-in 'help' handler *//* Restart the processes in the job *//* Put the job into the foreground.  *//* If they gave us no args, assume they want the last backgrounded task *//* built-in 'fg' and 'bg' handler *//* bash does not return an error when trying to export
				 * an undefined variable.  Do likewise. *//* They are exporting something without an =VALUE *//* built-in 'export VAR=value' handler *//* built-in 'exit' handler *//* Really? *//* built-in 'exec' handler *//* built-in 'env' handler *//* built-in 'cd <path>' handler *//* built-in 'eval' handler *//* xgetcwd(arg) called free(arg) *//* Table of built-in functions.  They can be forked or not, depending on
 * context: within pipes, they fork.  As simple commands, they do not.
 * When used in non-forking context, they can change global variables
 * in the parent shell process.  If forked, of course they can not.
 * For example, 'unset foo | whatever' will parse and run, but foo will
 * still be set at the end. *//*     local variable support *//*   job management: *//*   setup: *//*   primary string parsing: *//*   data structure manipulation: *//*   variable assignment: *//*   extended glob support: *//*  really run the final data structures: *//*  "run" the final data structures: *//*  close_me manipulations: *//*  in_str manipulations: *//*   o_string manipulation: *//*   function prototypes for builtins *//* Index of subroutines: *//* This should be in utility.c *//* define DEBUG_SHELL for debugging output (obviously ;-)) *//* function ptr *//* description *//* I can almost use ordinary FILE *.  Is open_memstream() universally
 * available?  Where is it documented? *//* used for initialization:
	o_string foo = NULL_O_STRING; *//*__U_BOOT__ *//* "globals" within this file *//* This is in <unistd.h>, but protected with __USE_GNU *//* globals, connect us to the outside world
 * the first three support $?, $#, and $1 *//* supports if, for, while, until *//* PIPE_BG, PIPE_SEQ, PIPE_OR, PIPE_AND *//* bitmask defining current context *//* number of programs alive, but stopped *//* to track background commands *//* array of commands in pipe *//* process group ID for the job *//* buffer various argv's point into *//* name of job *//* number of programs running *//* total number of programs in job *//* job number *//* number of SPECIAL_VAR_SYMBOL *//* pointer back to the child's parent pipe *//* is the program currently running? *//* result of parameter globbing *//* I/O redirections *//* flag, non-zero if group must be forked *//* if non-NULL, first in group or subshell *//* number of program arguments *//* was quoted when parsed; copy of struct o_string.nonnull field *//* program name and arguments *//* 0 if exited *//* *word.gl_pathv is the filename *//* pointer to the next redirect in the list *//* -1, or file descriptor being duplicated *//* file descriptor being redirected *//* type of redirection *//* How about quoting status? *//* define type of parser : ";$" common or special symbol *//* for figuring out valid reserved words *//* This holds pointers to the various results of parsing *//* might eventually control execution *//* The descrip member of this structure is only used to make debugging
 * output pretty *//* >= 2nd pass *//* #include <dmalloc.h> *//* ulimit *//* should be pretty obvious *//* va_list *//* glob, of course *//* popen etc. *//* strchr *//* getenv, atoi *//* getpid *//* isalpha, isdigit *//* find_cmd *//* readline *//* malloc, free, realloc*//*
 * sh.c -- a prototype Bourne shell grammar parser
 *      Intended to follow the original Thompson and Ritchie
 *      "small and simple is beautiful" philosophy, which
 *      incidentally is a good match to today's BusyBox.
 *
 * Copyright (C) 2000,2001  Larry Doolittle  <larry@doolittle.boa.org>
 *
 * Credits:
 *      The parser routines proper are all original material, first
 *      written Dec 2000 and Jan 2001 by Larry Doolittle.
 *      The execution engine, the builtins, and much of the underlying
 *      support has been adapted from busybox-0.49pre's lash,
 *      which is Copyright (C) 2000 by Lineo, Inc., and
 *      written by Erik Andersen <andersen@lineo.com>, <andersee@debian.org>.
 *      That, in turn, is based in part on ladsh.c, by Michael K. Johnson and
 *      Erik W. Troan, which they placed in the public domain.  I don't know
 *      how much of the Johnson/Troan code has survived the repeated rewrites.
 * Other credits:
 *      b_addchr() derived from similar w_addchar function in glibc-2.2
 *      setup_redirect(), redirect_opt_num(), and big chunks of main()
 *        and many builtins derived from contributions by Erik Andersen
 *      miscellaneous bugfixes from Matt Kraai
 *
 * There are two big (and related) architecture differences between
 * this parser and the lash parser.  One is that this version is
 * actually designed from the ground up to understand nearly all
 * of the Bourne grammar.  The second, consequential change is that
 * the parser and input reader have been turned inside out.  Now,
 * the parser is in control, and asks for input as needed.  The old
 * way had the input reader in control, and it asked for parsing to
 * take place as needed.  The new way makes it much easier to properly
 * handle the recursion implicit in the various substitutions, especially
 * across continuation lines.
 *
 * Bash grammar not implemented: (how many of these were in original sh?)
 *      $@ (those sure look like weird quoting rules)
 *      $_
 *      ! negation operator for pipes
 *      &> and >& redirection of stdout+stderr
 *      Brace Expansion
 *      Tilde Expansion
 *      fancy forms of Parameter Expansion
 *      aliases
 *      Arithmetic Expansion
 *      <(list) and >(list) Process Substitution
 *      reserved words: case, esac, select, function
 *      Here Documents ( << word )
 *      Functions
 * Major bugs:
 *      job handling woefully incomplete and buggy
 *      reserved word execution woefully incomplete and buggy
 * to-do:
 *      port selected bugfixes from post-0.49 busybox lash - done?
 *      finish implementing reserved words: for, while, until, do, done
 *      change { and } from special chars to reserved words
 *      builtins: break, continue, eval, return, set, trap, ulimit
 *      test magic exec
 *      handle children going into background
 *      clean up recognition of null pipes
 *      check setting of global_argc and global_argv
 *      control-C handling, probably with longjmp
 *      follow IFS rules more precisely, including update semantics
 *      figure out what to do with backslash-newline
 *      explain why we use signal instead of sigaction
 *      propagate syntax errors, die on resource errors?
 *      continuation lines, both explicit and implicit - done?
 *      memory leak finding and plugging - done?
 *      more testing, especially quoting rules and redirection
 *      document how quoting rules not precisely followed for variable assignments
 *      maybe change map[] to use 2-bit entries
 *      (eventually) remove all the printf's
 *//opt/src/common/cli_readline.cinittedp_buf
"\r\n"const char[4]1022CONFIG_SYS_CBSIZE-2'\t'07'\a'cread_lineinit_leneol_numetimeicharesc_lenESC_REJECTESC_SAVEESC_CONVERTEDactCTL_CH('b')'C'CTL_CH('f')'H'CTL_CH('a')CTL_CH('e')CTL_CH('p')CTL_CH('n')'3''4''7''8'esc_save'~'CTL_CH('d')insertimpossible condition #876
"impossible condition #876\n"CTL_BACKSPACE('\b')BEGINNING_OF_LINE()CTL_CH('c')buf[num]getcmd_putch(CTL_BACKSPACE)wlenbuf + num%.*sputnstr(buf + num, wlen)CTL_CH('k')%*sERASE_TO_EOL()REFRESH_TO_EOL()CTL_CH('o')CTL_CH('x')'u'CTL_CH('u')DELDEL7hlinegetcmd_cbeep()num2CREAD_HIST_CHARcread_add_strcread_add_charbuf + *numputnstr(buf + *num, wlen)hist_nextchar *[20]HIST_MAXhist_prevold_curcread_add_to_histhist_initHIST_SIZEHIST_SIZE + 1char[20][1025]char(*)[1025]delete_charhist_lineshist_listhist_numhist_curhist_add_idxhist_max        tab_seq erase_seq{ if (num < eol_num) { wlen = eol_num - num; putnstr(buf + num, wlen); num = eol_num; } }{ if (num < eol_num) { printf("%*s", (int)(eol_num - num), ""); do { getcmd_putch(CTL_BACKSPACE); } while (--eol_num > num); } }{ while (num) { getcmd_putch(CTL_BACKSPACE); num--; } }add_idx_minus_one()((hist_add_idx == 0) ? hist_max : hist_add_idx-1)getcmd_putch('\a')getcmd_getch()getc()getcmd_putch(ch)putc(ch)('!')((char)127)((char)255)CTL_CH(c)((c) - 'a' + 1)putnstr(str,n)printf("%.*s", (int)n, str)CONFIG_CMDLINE_EDITING/* Buffer full *//*
					 * Echo input using puts() to force an
					 * LCD flush if we are using an LCD
					 *//* reset *//*
					 * if auto completion triggered just
					 * continue
					 *//* expand TABs *//*
			 * Must be a normal character then
			 *//* DEL - backspace	*//* ^H  - backspace	*//* ^W - erase word	*//* ^U - erase line	*//* discard input *//* ^C - break		*//* nul			*//* Enter		*//*
		 * Special character handling
		 *//* Trigger watchdog, if needed *//* timed out *//* print prompt *//* output column cnt	*//* prompt length	*//* buffer index		*//* CONFIG_CMDLINE_EDITING *//*
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 *//*
	 * If console_buffer isn't 0-length the user will be prompted to modify
	 * it instead of entering it from scratch as desired.
	 *//* lose the newline *//* do not autocomplete when in the middle *//* copy new line into place and display *//* erase to end of line *//* first, go home *//* nuke the current line *//* ^C - break *//* pass to ^E handler *//* End key *//* pass to ^A handler *//* Home key *//* pass to ^D handler *//* Delete key *//* see if next character is ~ *//* pass off to ^N handler *//* down arrow *//* pass off to ^P handler *//* up arrow *//* pass off to ^E handler *//* pass off to ^A handler *//* pass off to ^F handler *//* -> key *//* pass off to ^B handler *//* <- key *//*
		 * handle standard linux xterm esc sequences for arrow key, etc.
		 *//* ichar=0x0 when error occurs in U-Boot getc *//* while no incoming data *//* echo the character *//* room ??? *//* Save room for NULL *//*
 * cmdline-editing related codes from vivi.
 * Author: Janghoon Lyu <nandy@mizi.com>
 *//* will retype the whole line *//* console I/O buffer	*//* used to expand TABs *//* erase sequence */strsizecolp/opt/src/common/cli_simple.ccli_simple"** exec: \"%s\"\n"debug("** exec: \"%s\"\n", line)common/cli_simple.c** exec: "%s"
lastcommand"[RUN_COMMAND] cmd[%p]=\""DEBUG_PARSERdebug_parser("[RUN_COMMAND] cmd[%p]=\"", cmd)[RUN_COMMAND] cmd[%p]=""NULL""
"\"\n"## Command too long!
"## Command too long!\n"cmdbuf"[PROCESS_SEPARATORS] %s\n"debug_parser("[PROCESS_SEPARATORS] %s\n", cmd)[PROCESS_SEPARATORS] %s
inquotes"token: \"%s\"\n"debug_parser("token: \"%s\"\n", token)token: "%s"
finaltokenchar *[17]CONFIG_SYS_MAXARGS + 1"[PROCESS_MACROS] INPUT len %zd: \"%s\"\n"strlen(input), inputdebug_parser("[PROCESS_MACROS] INPUT len %zd: \"%s\"\n", strlen(input),
		     input)const char[26][PROCESS_MACROS] INPUT len %zd: "%s"
inputcntoutputcnt CONFIG_SYS_CBSIZEvarname_startenvnameenvvalenvcnt"[PROCESS_MACROS] OUTPUT len %zd: \"%s\"\n"strlen(output_start), output_startdebug_parser("[PROCESS_MACROS] OUTPUT len %zd: \"%s\"\n",
		     strlen(output_start), output_start)[PROCESS_MACROS] OUTPUT len %zd: "%s"
output_start"%s: \"%s\"\n"__func__, linedebug_parser("%s: \"%s\"\n", __func__, line)%s: "%s"
nargs*lineisblank(*line)"%s: nargs=%d\n"__func__, nargsdebug_parser("%s: nargs=%d\n", __func__, nargs)%s: nargs=%d
"parse_line: nargs=%d\n"debug_parser("parse_line: nargs=%d\n", nargs)parse_line: nargs=%d
** Too many args (max. %d) **
"** Too many args (max. %d) **\n"debug_parser(fmt,args...)debug_cond(DEBUG_PARSER, fmt, ## args)/* run only non-empty commands *//*
	 * Break into individual lines, and execute each line; terminate on
	 * error.
	 *//* invalid command or not repeatable, forget it *//* retry autoboot *//* Reinit board to run initialization code again *//* -2 means timed out, retry autoboot
			 *//* assume no special flags for now *//* Saw enough of a valid command to
			 * restart the timeout.
			 *//* if stopped then not repeatable *//* Did the user stop this? *//* no command at all *//* Extract arguments *//* find macros in this token and replace them *//* no more commands for next pass *//* start of command for next pass *//*
		 * Limit the token to data between separators
		 *//* and NOT escaped *//* past string start	*//* separator		*//*
		 * Find separator, or string end
		 * Allow simple escape of ';' by writing "\;"
		 *//* Process separators and check for invalid
	 * repeatable commands
	 *//* empty command *//* forget any previous Control C *//* use puts - string may be loooong *//* NULL terminated	*//* end of token (separator) in cmdbuf *//* start of token in cmdbuf	*//* working copy of cmd		*//*
 * WARNING:
 *
 * We must create a temporary copy of the command since the command we get
 * may be the result from env_get(), which returns a pointer directly to
 * the environment data, which may change magicly when the command we run
 * creates or modifies environment variables (like "bootp" does).
 *//* Waiting for '        *//* Look for another '$' *//* Copy into the line if it exists *//* Get its value *//* Get the varname *//* Varname # of chars *//* Waiting for )        *//* Waiting for (        *//* Waiting for (unescaped) $    *//* remove one level of escape characters *//* previous character   *//* 3 = waiting for '''  *//* 2 = waiting for ')' or '}' *//* 1 = waiting for '(' or '{' *//* 0 = waiting for '$'  *//* terminate current arg	 *//* end of line, no more args	*//* find end of string *//* begin of argument string	*//* skip any white space *//* set to 1 to debug *//opt/src/common/command.ccmd_process_errorCommand '%s' failed: Error %d
"Command '%s' failed: Error %d\n"cmd_processxtrace"xtrace"+"+"Unknown command '%s' - try 'help'
"Unknown command '%s' - try 'help'\n"CMD_FLAG_BOOTD'bootd' recursion detected
"'bootd' recursion detected\n"newrepcmd_call"Command failed, result=%d\n"debug("Command failed, result=%d\n", result)common/command.c572Command failed, result=%d
cmd_discard_repeatablecmd_never_repeatablecmd_always_repeatablecmd_get_data_size'q'cmd_auto_completelast_charsizeof(argv)sizeof(argv[0])sizeof(argv)/sizeof(argv[0])default_sizesizeof(cmdv)sizeof(cmdv[0])sizeof(cmdv) / sizeof(cmdv[0])seplenisblank(last_char)CONFIG_SYS_CBSIZE - 2  "  "find_common_prefixanchorprint_argvslllmake_argvisblank(*s)leaderlinemaxargvszcomplete_cmdvcomplete_subcmdvcmdendn_found..."..."clendollar_completesizeof(env_complete_buf)spacecmd_usage%s - %s

"%s - %s\n\n"Usage:
%s "Usage:\n%s "- No additional help available.
"- No additional help available.\n"find_cmdfind_cmd_tblcmdtp_temp_do_helptable_lencmd_startcmd_itemscmd_tbl_t *[]cmd_tbl_s *[]cmd_arrayswapscmd_tbl_t **cmd_tbl_s **%-*s- %s
"%-*s- %s\n"CONFIG_SYS_HELP_CMD_WIDTHUnknown command '%s' - try 'help' without arguments for list of all known commands

"Unknown command '%s' - try 'help' without arguments for list of all known commands\n\n"char[85]env_complete_bufCMD_DATA_SIZEDEBUG_COMMANDSdefined(CONFIG_SYS_XTRACE)/* If OK so far, then do the command *//* avoid "bootd" recursion *//* found - check max args *//* Look up command in command table *//**
 * Call a command function. This should be the only route in U-Boot to call
 * a command, so that we can track whether we are waiting for input or
 * executing a command.
 *
 * @param cmdtp		Pointer to the command to execute
 * @param flag		Some flags normally 0 (see CMD_FLAG_.. above)
 * @param argc		Number of arguments (arg 0 must be the command text)
 * @param argv		Arguments
 * @param repeatable	Can the command be repeated
 * @return 0 if command succeeded, else non-zero (CMD_RET_...)
 *//* Check for a size specification .b, .w or .l.
	 *//* make sure it fits *//* more *//* one match; perfect *//* allow tab for non command *//* no match; bell and out *//* do the completion and return the possible completions *//* first try a $ completion *//* separate into argv *//* copy to secondary buffer which will be affected *//* not in normal console *//* copy of console I/O buffer *//* begin with max *//* force leader and newline *//* end of s, no more args	*//* split into argv *//* too many! *//* return the partial matches *//*
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 *//* more than one arg or one but the start of the next *//* output full list of commands *//* sanity? *//*************************************************************************************//* Make sure the last argument starts with a $. *//* not found or ambiguous command *//* exactly one match *//* abbreviated command ? *//* full match *//* Init value *//* find command table entry for a command *//*
	 * command help (long version)
	 *//* allow user abort *//* print short help (usage) *//* Sort command list (trivial bubble sort) *//* Make array of commands from .uboot_cmd section *//* show list of commands *//*
 * Use puts() instead of printf() to avoid printf buffer overflow
 * for long help messages
 *//*
 *  Command Processor Table
 *//opt/src/include/debug_uart.hdebug_uartprintdecprinthex8printhex4printhex2printasciiprintchboard_debug_uart_initdebug_uart_initDEBUG_UART_FUNCSstatic inline void _printch(int ch) { if (ch == '\n') _debug_uart_putc('\r'); _debug_uart_putc(ch); } void printch(int ch) { _printch(ch); } void printascii(const char *str) { while (*str) _printch(*str++); } static inline void printhex1(uint digit) { digit &= 0xf; _debug_uart_putc(digit > 9 ? digit - 10 + 'a' : digit + '0'); } static inline void printhex(uint value, int digits) { while (digits-- > 0) printhex1(value >> (4 * digits)); } void printhex2(uint value) { printhex(value, 2); } void printhex4(uint value) { printhex(value, 4); } void printhex8(uint value) { printhex(value, 8); } void printdec(uint value) { if (value > 10) { printdec(value / 10); value %= 10; } else if (value == 10) { _debug_uart_putc('1'); value = 0; } _debug_uart_putc('0' + value); } void debug_uart_init(void) { board_debug_uart_init(); _debug_uart_init(); _DEBUG_UART_ANNOUNCE }serial_din(reg)serial_in_shift((char *)com_port + ((char *)reg - (char *)com_port) * (1 << CONFIG_DEBUG_UART_SHIFT), CONFIG_DEBUG_UART_SHIFT)serial_dout(reg,value)serial_out_shift((char *)com_port + ((char *)reg - (char *)com_port) * (1 << CONFIG_DEBUG_UART_SHIFT), CONFIG_DEBUG_UART_SHIFT, value)_DEBUG_UART_ANNOUNCE_DEBUG_UART_HCONFIG_DEBUG_UART_BOARD_INITCONFIG_DEBUG_UART_ANNOUNCE/*
 * Now define some functions - this should be inserted into the serial driver
 *//**
 * printdec() - Output a decimalism value
 *
 * @value:	Value to output
 *//**
 * printhex8() - Output a 8-digit hex value
 *
 * @value:	Value to output
 *//**
 * printhex4() - Output a 4-digit hex value
 *
 * @value:	Value to output
 *//**
 * printhex2() - Output a 2-digit hex value
 *
 * @value:	Value to output
 *//**
 * printascii() - Output an ASCII string to the debug UART
 *
 * @str:	String to output
 *//**
 * printch() - Output a character to the debug UART
 *
 * @ch:		Character to output
 *//**
 * debug_uart_init() - Set up the debug UART ready for use
 *
 * This sets up the UART with the correct baud rate, etc.
 *
 * Available CONFIG is:
 *
 *    - CONFIG_DEBUG_UART_BASE: Base address of UART
 *    - CONFIG_BAUDRATE: Requested baud rate
 *    - CONFIG_DEBUG_UART_CLOCK: Input clock for UART
 *//*
 * The debug UART is intended for use very early in U-Boot to debug problems
 * when an ICE or other debug mechanism is not available.
 *
 * To use it you should:
 * - Make sure your UART supports this interface
 * - Enable CONFIG_DEBUG_UART
 * - Enable the CONFIG for your UART to tell it to provide this interface
 *       (e.g. CONFIG_DEBUG_UART_NS16550)
 * - Define the required settings as needed (see below)
 * - Call debug_uart_init() before use
 * - Call printch() to output a character
 *
 * Depending on your platform it may be possible to use this UART before a
 * stack is available.
 *
 * If your UART does not support this interface you can probably add support
 * quite easily. Remember that you cannot use driver model and it is preferred
 * to use no stack.
 *
 * You must not use this UART once driver model is working and the serial
 * drivers are up and running (done in serial_init()). Otherwise the drivers
 * may conflict and you will get strange output.
 *
 *
 * To enable the debug UART in your serial driver:
 *
 * - #include <debug_uart.h>
 * - Define _debug_uart_init(), trying to avoid using the stack
 * - Define _debug_uart_putc() as static inline (avoiding stack usage)
 * - Immediately afterwards, add DEBUG_UART_FUNCS to define the rest of the
 *     functionality (printch(), etc.)
 *
 * If your board needs additional init for the UART to work, enable
 * CONFIG_DEBUG_UART_BOARD_INIT and write a function called
 * board_debug_uart_init() to perform that init. When debug_uart_init() is
 * called, the init will happen automatically.
 *//*
 * Early debug UART support
 *
 * (C) Copyright 2014 Google, Inc
 * Writte by Simon Glass <sjg@chromium.org>
 *//opt/src/common/console.cstdinname"stdin"stdoutname"stdout"stderrname"stderr"OVERWRITE_CONSOLEOVERWRITE_CONSOLE == 0inputdevoutputdeverrdeviomux_errCONSOLE_MUXCONFIG_VAL(CONSOLE_MUX)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_CONSOLE_MUXCONFIG_VAL(CONSOLE_MUX_MODULE)CONFIG_CONSOLE_MUX_MODULECONSOLE_MUX_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_CONSOLE_MUX_MODULE__ARG_PLACEHOLDER_CONFIG_CONSOLE_MUX_MODULE__ARG_PLACEHOLDER_CONFIG_CONSOLE_MUX_MODULE 1PRE_CONSOLE_FLUSHPOINT2_EVERYTHING_BUT_SERIALIn:    "In:    "No input devices available!
"No input devices available!\n"Out:   "Out:   "No output devices available!
"No output devices available!\n"Err:   "Err:   "No error devices available!
"No error devices available!\n"PRE_CONSOLE_FLUSHPOINT1_SERIALconsole_update_silentsilent"silent"<debug_uart.h>str_inputsizeof(str_input)y"y\r"Y"Y\r"yes"yes\r"YES"YES\r"membuff *CONFIG_CONSOLE_RECORD_OUT_SIZECONFIG_CONSOLE_RECORD_IN_SIZEprint_pre_console_bufferbuf_inCONFIG_PRE_CON_BUF_ADDRCONFIG_PRE_CON_BUF_SZchar[4097]4097CONFIG_PRE_CON_BUF_SZ + 1buf_outin++CIRC_BUF_IDX(in++)pre_console_putspre_console_putcgd->precon_buf_idx++CIRC_BUF_IDX(gd->precon_buf_idx++)flushpointchar[1044]1044CONFIG_SYS_PBSIZEprintbuffersizeof(printbuffer)ftstcconsole_doenvconsole_putsstdio_dev ***console_puts_noserialconsole_putcconsole_tstcconsole_getcconsole_dev_is_serialis_serialUCLASS_SERIALconsole_setfileon_silentSILENT_CONSOLE_UPDATE_ON_SETCONFIG_VAL(SILENT_CONSOLE_UPDATE_ON_SET)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_SILENT_CONSOLE_UPDATE_ON_SETCONFIG_SILENT_CONSOLE_UPDATE_ON_SETCONFIG_VAL(SILENT_CONSOLE_UPDATE_ON_SET_MODULE)CONFIG_SILENT_CONSOLE_UPDATE_ON_SET_MODULESILENT_CONSOLE_UPDATE_ON_SET_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_SILENT_CONSOLE_UPDATE_ON_SET_MODULE__ARG_PLACEHOLDER_CONFIG_SILENT_CONSOLE_UPDATE_ON_SET_MODULE__ARG_PLACEHOLDER_CONFIG_SILENT_CONSOLE_UPDATE_ON_SET_MODULE 1SILENT_CONSOLE_UPDATE_ON_RELOCCONFIG_VAL(SILENT_CONSOLE_UPDATE_ON_RELOC)CONFIG_SILENT_CONSOLE_UPDATE_ON_RELOC__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_SILENT_CONSOLE_UPDATE_ON_RELOC__ARG_PLACEHOLDER_CONFIG_SILENT_CONSOLE_UPDATE_ON_RELOC__ARG_PLACEHOLDER_CONFIG_SILENT_CONSOLE_UPDATE_ON_RELOC 1CONFIG_VAL(SILENT_CONSOLE_UPDATE_ON_RELOC_MODULE)CONFIG_SILENT_CONSOLE_UPDATE_ON_RELOC_MODULESILENT_CONSOLE_UPDATE_ON_RELOC_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_SILENT_CONSOLE_UPDATE_ON_RELOC_MODULE__ARG_PLACEHOLDER_CONFIG_SILENT_CONSOLE_UPDATE_ON_RELOC_MODULE__ARG_PLACEHOLDER_CONFIG_SILENT_CONSOLE_UPDATE_ON_RELOC_MODULE 1on_consoleCan't delete "%s"
"Can't delete \"%s\"\n"ctrlc_was_pressedctrlc_disabledtstcdev_u_boot_list_2_env_clbk_2_silent.u_boot_list_2_env_clbk_2_silent_u_boot_list_2_env_clbk_2_console.u_boot_list_2_env_clbk_2_consoleCIRC_BUF_IDX(idx)((idx) % (unsigned long)CONFIG_PRE_CON_BUF_SZ)CONFIG_IS_ENABLED(CONSOLE_MUX)!CONFIG_IS_ENABLED(SILENT_CONSOLE_UPDATE_ON_SET)!CONFIG_IS_ENABLED(SILENT_CONSOLE_UPDATE_ON_RELOC)CONFIG_IS_ENABLED(SYS_CONSOLE_IS_IN_ENV)CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINECONFIG_DM_SERIALCONFIG_DISABLE_CONSOLECONFIG_DEBUG_UARTCONFIG_VIDCONSOLE_AS_LCD!CONFIG_IS_ENABLED(PRE_CONSOLE_BUFFER)CONFIG_SYS_CONSOLE_ENV_OVERWRITECONFIG_SYS_CONSOLE_INFO_QUIETCONFIG_SPLASH_SCREENSYS_CONSOLE_IS_IN_ENVCONFIG_VAL(SYS_CONSOLE_IS_IN_ENV_MODULE)CONFIG_SYS_CONSOLE_IS_IN_ENV_MODULE__ARG_PLACEHOLDER_CONFIG_SYS_CONSOLE_IS_IN_ENV_MODULE__ARG_PLACEHOLDER_CONFIG_SYS_CONSOLE_IS_IN_ENV_MODULE 1SYS_CONSOLE_IS_IN_ENV_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_SYS_CONSOLE_IS_IN_ENV_MODULECONFIG_VAL(SYS_CONSOLE_IS_IN_ENV)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_SYS_CONSOLE_IS_IN_ENVCONFIG_SYS_CONSOLE_IS_IN_ENV/* CONFIG_IS_ENABLED(SYS_CONSOLE_IS_IN_ENV) *//* If nothing usable installed, use only the initial console *//* device initialization completed *//* Setting environment variables *//* CONFIG_SYS_CONSOLE_INFO_QUIET *//* Initializes input console *//* Initializes output console first *//* Scan devices looking for input and output devices *//*
	 * suppress all output if splash screen is enabled and we have
	 * a bmp to display. We redirect the output from frame buffer
	 * console to serial console in this case or suppress it if
	 * "silent" mode was requested.
	 *//* Called after the relocation - use desired console functions *//* !CONFIG_IS_ENABLED(SYS_CONSOLE_IS_IN_ENV) *//* CONFIG_SYS_CONSOLE_ENV_OVERWRITE *//* set the environment variables (will overwrite previous env settings) *//* need to set a console if not done above. *//* if the devices are overwritten or not found, use default device *//* Successful, so skip all the code below. *//* if not overwritten by config switch *//* scan for it *//* stdin stdout and stderr are in environment *//* set default handlers at first *//* Print information *//* Called before relocation - use serial functions *//* Check for valid device name *//* Check for valid file *//** U-Boot INIT FUNCTIONS *************************************************//* save previous state *//* pass 1 to disable ctrlc() checking, 0 to enable.
 * returns previous state
 *//* Flush input *//* Reads user's confirmation.
   Returns 1 if user's input is "y", "Y", "yes" or "YES"
*//* ^C - Control C *//* see disable_ctrl() *//* test if ctrl-c was pressed *//* Send directly to the handler *//* Send to the standard output *//* sandbox can send characters to stdout before it has a console *//* if we don't have a console yet, use the debug UART *//* Test the standard input *//* Get from the standard input *//** U-Boot INITIAL CONSOLE-COMPATIBLE FUNCTION *****************************//* Send to desired file *//* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 *//*
			 * If the watchdog must be rate-limited then it should
			 * already be handled in board-specific code.
			 *//*
			 * Upper layer may have already called tstc() so
			 * check for that first.
			 *//*
		 * Effectively poll for input wherever it may be available.
		 *//** U-Boot INITIAL CONSOLE-NOT COMPATIBLE FUNCTIONS *************************//* CONIFIG_IS_ENABLED(CONSOLE_MUX) *//* This is never called with testcdev == NULL *//*
 * This depends on tstc() always being called before getc().
 * This is guaranteed to be true because this routine is called
 * only from fgetc() which assures it.
 * No attempt is made to demultiplex multiple input sources.
 *//** Console I/O multiplexing *******************************************//**
 * console_dev_is_serial() - Check if a stdio device is a serial device
 *
 * @sdev: Device to check
 * @return true if this device is in the serial uclass (or for pre-driver-model,
 * whether it is called "serial".
 *//* Invalid file ID *//*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 *//* Assign the new device (leaving the existing one started) *//* If it's not started dont use it *//* Start new device *//* CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE *//*
 * if overwrite_console returns 1, the stdin, stderr and stdout
 * are switched to the serial port, else the settings in the
 * environment are used
 *//* Try assigning specified device *//* if not actually setting a console variable, we don't care *//* Check for console redirection *//opt/src/common/cros_ec.c"%s: Error %d\n"debug("%s: Error %d\n", __func__, ret)common/cros_ec.c%s: Error %d
/*
 * Copyright (c) 2012 The Chromium OS Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
 *//opt/src/common/dlmalloc.cdlmallocgd->malloc_baseassert(gd->malloc_base)common/dlmalloc.c238910240max system bytes = %10u
"max system bytes = %10u\n"system bytes     = %10u
"system bytes     = %10u\n"in use bytes     = %10u
"in use bytes     = %10u\n"malloc_update_mallinfotop(av_[2])NAVmbinptr[258]malloc_chunk *malloc_chunk *[258]NAV * 2NAV * 2 + 2mbinptr *malloc_chunk **bin_at(i)qinuse(q)18446744073709551614chunksize(q)MINSIZE(long)MINSIZEnext_chunk(p)next_chunk(q)chunksize(top)chunksize(p)navailparam_numbermem2chunk(mem)chunk_is_mmapped(p)inuse(p)SIZE_SZ2*SIZE_SZtop_sizepageszcurrent_brknew_brk(char*)(MORECORE_FAILURE)top_size | PREV_INUSEtop_size | 0x1set_head(top, top_size | PREV_INUSE)check_chunk(top)(top_size - extra) | PREV_INUSE(top_size - extra) | 0x1set_head(top, (top_size - extra) | PREV_INUSE)MALLOC_ZERO(mem, sz)mzszmzcszoldtopelem_sizeoldtopsizecsz - SIZE_SZcsz - (sizeof(size_t))MALLOC_ZERO(mem, csz - SIZE_SZ)MALLOC_ALIGNMENTnbrequest2size(bytes)extra2mem2chunk(m)((unsigned long)(m + alignment - 1)) & -((signed) alignment)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment))leadsizenewsizenewsize | PREV_INUSEnewsize | 0x1set_head(newp, newsize | PREV_INUSE)set_inuse_bit_at_offset(newp, newsize)set_head_size(p, leadsize)chunk2mem(p)newsize >= nb && (((unsigned long)(chunk2mem(p))) % alignment) == 0newsize >= nb && (((unsigned long)(((void*)((char*)(p) + 2*(sizeof(size_t)))))) % alignment) == 0assert (newsize >= nb && (((unsigned long)(chunk2mem(p))) % alignment) == 0)remainder_sizeremainder_size | PREV_INUSEremainder_size | 0x1set_head(remainder, remainder_size | PREV_INUSE)set_head_size(p, nb)chunk2mem(remainder)pre-reloc realloc() is not supported"pre-reloc realloc() is not supported"oldpoldmemmem2chunk(oldmem)oldsizechunksize(oldp)inuse(next)nextsizechunksize(next)(newsize - nb) | PREV_INUSE(newsize - nb) | 0x1set_head(top, (newsize - nb) | PREV_INUSE)set_head_size(oldp, nb)chunk2mem(oldp)bckfwdprev_inuse(oldp)prevsizechunksize(prev)newmemchunk2mem(newp)oldsize - SIZE_SZoldsize - (sizeof(size_t))MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ)mcszmcsrcmcdstset_head_size(newp, nb)mem2chunk(newmem)next_chunk(oldp)chunksize(newp)set_inuse_bit_at_offset(remainder, remainder_size)set_head_size(newp, newsize)hdPREV_INUSE~PREV_INUSEnextszprevsz-((long) prevsz)sz | PREV_INUSEsz | 0x1set_head(p, sz | PREV_INUSE)islrsplitlast_remainderinuse_bit_at_offset(next, nextsz)link_last_remainder(p)frontlink(p, sz, idx, bck, fwd)3401364is_small_request(nb)smallbin_index(nb)bin_at(idx)victimnext_bin(q)victim_sizechunksize(victim)set_inuse_bit_at_offset(victim, victim_size)chunk2mem(victim)bin_index(nb)binnb | PREV_INUSEnb | 0x1set_head(victim, nb | PREV_INUSE)link_last_remainder(remainder)clear_last_remainderremainder_indexfrontlink(victim, victim_size, remainder_index, bck, fwd)idx2binblock(idx)binblocks_rBINBLOCKWIDTHBINBLOCKWIDTH - 1(BINBLOCKWIDTH - 1)~(BINBLOCKWIDTH - 1)startidxnext_bin(bin)prev_bin(q)set_head(top, remainder_size | PREV_INUSE)malloc_extend_topold_topold_top_size(char*)(-1)sbrk_sizeold_endchunksize(old_top)initial_topfront_misalignchunk2mem(brk)MALLOC_ALIGN_MASKcorrection(MALLOC_ALIGNMENT)set_head(top, PREV_INUSE)3*SIZE_SZ~MALLOC_ALIGN_MASKset_head_size(old_top, old_top_size)SIZE_SZ|PREV_INUSEold_top_size + SIZE_SZold_top_size + (sizeof(size_t))chunk_at_offset(old_top, old_top_size + SIZE_SZ)chunk2mem(old_top)((unsigned long)((char*)top + top_size) & (pagesz - 1)) == 0((unsigned long)((char*)(av_[2]) + top_size) & (pagesz - 1)) == 0assert(((unsigned long)((char*)top + top_size) & (pagesz - 1)) == 0)1168do_check_malloced_chunk(long)sz >= (long)MINSIZE(long)sz >= (long)(sizeof(struct malloc_chunk))assert((long)sz >= (long)MINSIZE)(long)MINSIZE)826(sz & MALLOC_ALIGN_MASK) == 0(sz & (((sizeof(size_t)) + (sizeof(size_t))) - 1)) == 0assert((sz & MALLOC_ALIGN_MASK) == 0)827roomroom >= 0assert(room >= 0)828room < (long)MINSIZEroom < (long)(sizeof(struct malloc_chunk))assert(room < (long)MINSIZE)829aligned_OK(chunk2mem(p))(((unsigned long)((((void*)((char*)(p) + 2*(sizeof(size_t)))))) & ((((sizeof(size_t)) + (sizeof(size_t))) - 1))) == 0)assert(aligned_OK(chunk2mem(p)))((void*)((char*)(p) + 2*(sizeof(size_t))))832prev_inuse(p)((p)->size & 0x1)assert(prev_inuse(p))836do_check_inuse_chunk((((mchunkptr)(((char*)(p))+((p)->size & ~0x1)))->size) & 0x1)assert(inuse(p))792const char[21]next_chunk(prv) == p((mchunkptr)( ((char*)(prv)) + ((prv)->size & ~0x1) )) == passert(next_chunk(prv) == p)801prev_inuse(next)((next)->size & 0x1)assert(prev_inuse(next))806chunksize(next) >= MINSIZE((next)->size & ~((0x1|0x2))) >= (sizeof(struct malloc_chunk))assert(chunksize(next) >= MINSIZE)807do_check_free_chunk!inuse(p)!((((mchunkptr)(((char*)(p))+((p)->size & ~0x1)))->size) & 0x1)assert(!inuse(p))761766next->prev_size == szassert(next->prev_size == sz)769771next == top || inuse(next)next == (av_[2]) || ((((mchunkptr)(((char*)(next))+((next)->size & ~0x1)))->size) & 0x1)assert (next == top || inuse(next))772p->fd->bk == passert(p->fd->bk == p)775p->bk->fd == passert(p->bk->fd == p)776sz == SIZE_SZsz == (sizeof(size_t))assert(sz == SIZE_SZ)779do_check_chunk!chunk_is_mmapped(p)!((p)->size & 0x2)assert(!chunk_is_mmapped(p))737(char*)p >= sbrk_baseassert((char*)p >= sbrk_base)740(char*)p + sz <= (char*)top(char*)p + sz <= (char*)(av_[2])assert((char*)p + sz <= (char*)top)742(char*)p + sz <= sbrk_base + sbrked_mem(char*)p + sz <= sbrk_base + (current_mallinfo.arena)assert((char*)p + sz <= sbrk_base + sbrked_mem)744"using memory %#lx-%#lx for malloc()\n"mem_malloc_start, mem_malloc_enddebug("using memory %#lx-%#lx for malloc()\n", mem_malloc_start,
	      mem_malloc_end)608using memory %#lx-%#lx for malloc()
(void *)MORECORE_FAILUREmalloc_bin_relocmbinptrmchunkptrmalloc_chunkmay_aliasbkprev_sizemmapped_memn_mmapscurrent_mallinfomax_total_memmax_sbrked_memsbrk_basemmap_thresholdn_mmaps_maxtop_padtrim_thresholdincrementIAV(0)IAV(1)IAV(2)IAV(3)IAV(4)IAV(5)IAV(6)IAV(7)IAV(8)IAV(9)IAV(10)IAV(11)IAV(12)IAV(13)IAV(14)IAV(15)IAV(16)IAV(17)IAV(18)IAV(19)IAV(20)IAV(21)IAV(22)IAV(23)IAV(24)IAV(25)IAV(26)IAV(27)IAV(28)IAV(29)IAV(30)IAV(31)IAV(32)IAV(33)IAV(34)IAV(35)IAV(36)IAV(37)IAV(38)IAV(39)IAV(40)IAV(41)IAV(42)IAV(43)IAV(44)IAV(45)IAV(46)IAV(47)IAV(48)IAV(49)IAV(50)IAV(51)IAV(52)IAV(53)IAV(54)IAV(55)IAV(56)IAV(57)IAV(58)IAV(59)IAV(60)IAV(61)IAV(62)IAV(63)IAV(64)IAV(65)IAV(66)IAV(67)IAV(68)IAV(69)IAV(70)IAV(71)IAV(72)IAV(73)IAV(74)IAV(75)IAV(76)IAV(77)IAV(78)IAV(79)IAV(80)IAV(81)IAV(82)IAV(83)IAV(84)IAV(85)IAV(86)IAV(87)IAV(88)IAV(89)IAV(90)IAV(91)IAV(92)IAV(93)IAV(94)IAV(95)IAV(96)IAV(97)IAV(98)IAV(99)IAV(100)IAV(101)IAV(102)IAV(103)IAV(104)IAV(105)IAV(106)IAV(107)IAV(108)IAV(109)IAV(110)IAV(111)IAV(112)IAV(113)IAV(114)IAV(115)IAV(116)IAV(117)IAV(118)IAV(119)IAV(120)IAV(121)IAV(122)IAV(123)IAV(124)IAV(125)IAV(126)IAV(127)av_(last_remainder->fd = last_remainder->bk = last_remainder)link_last_remainder(P){ last_remainder->fd = last_remainder->bk = P; P->fd = P->bk = last_remainder; }unlink(P,BK,FD){ BK = P->bk; FD = P->fd; FD->bk = BK; BK->fd = FD; }frontlink(P,S,IDX,BK,FD){ if (S < MAX_SMALLBIN_SIZE) { IDX = smallbin_index(S); mark_binblock(IDX); BK = bin_at(IDX); FD = BK->fd; P->bk = BK; P->fd = FD; FD->bk = BK->fd = P; } else { IDX = bin_index(S); BK = bin_at(IDX); FD = BK->fd; if (FD == BK) mark_binblock(IDX); else { while (FD != BK && S < chunksize(FD)) FD = FD->fd; BK = FD->bk; } P->bk = BK; P->fd = FD; FD->bk = BK->fd = P; } }check_malloced_chunk(P,N)do_check_malloced_chunk(P,N)check_chunk(P)do_check_chunk(P)check_inuse_chunk(P)do_check_inuse_chunk(P)check_free_chunk(P)do_check_free_chunk(P)sbrked_mem(current_mallinfo.arena)clear_binblock(ii)(binblocks_w = (mbinptr)(binblocks_r & ~(idx2binblock(ii))))mark_binblock(ii)(binblocks_w = (mbinptr)(binblocks_r | idx2binblock(ii)))idx2binblock(ix)((unsigned)1 << (ix / BINBLOCKWIDTH))binblocks_w(av_[1])((INTERNAL_SIZE_T)av_[1])(nb < MAX_SMALLBIN_SIZE - SMALLBIN_WIDTH)smallbin_index(sz)(((unsigned long)(sz)) >> 3)SMALLBIN_WIDTHMAX_SMALLBIN_SIZEMAX_SMALLBINbin_index(sz)(((((unsigned long)(sz)) >> 9) == 0) ? (((unsigned long)(sz)) >> 3): ((((unsigned long)(sz)) >> 9) <= 4) ? 56 + (((unsigned long)(sz)) >> 6): ((((unsigned long)(sz)) >> 9) <= 20) ? 91 + (((unsigned long)(sz)) >> 9): ((((unsigned long)(sz)) >> 9) <= 84) ? 110 + (((unsigned long)(sz)) >> 12): ((((unsigned long)(sz)) >> 9) <= 340) ? 119 + (((unsigned long)(sz)) >> 15): ((((unsigned long)(sz)) >> 9) <= 1364) ? 124 + (((unsigned long)(sz)) >> 18): 126)last(b)((b)->bk)first(b)((b)->fd)IAV(i)bin_at(i), bin_at(i)((mchunkptr)(bin_at(0)))(bin_at(1))prev_bin(b)((mbinptr)((char*)(b) - 2 * sizeof(mbinptr)))next_bin(b)((mbinptr)((char*)(b) + 2 * sizeof(mbinptr)))((mbinptr)((char*)&(av_[2*(i) + 2]) - 2*SIZE_SZ))set_foot(p,s)(((mchunkptr)((char*)(p) + (s)))->prev_size = (s))set_head(p,s)((p)->size = (s))set_head_size(p,s)((p)->size = (((p)->size & PREV_INUSE) | (s)))((p)->size & ~(SIZE_BITS))clear_inuse_bit_at_offset(p,s)(((mchunkptr)(((char*)(p)) + (s)))->size &= ~(PREV_INUSE))set_inuse_bit_at_offset(p,s)(((mchunkptr)(((char*)(p)) + (s)))->size |= PREV_INUSE)inuse_bit_at_offset(p,s)(((mchunkptr)(((char*)(p)) + (s)))->size & PREV_INUSE)clear_inuse(p)((mchunkptr)(((char*)(p)) + ((p)->size & ~PREV_INUSE)))->size &= ~(PREV_INUSE)set_inuse(p)((mchunkptr)(((char*)(p)) + ((p)->size & ~PREV_INUSE)))->size |= PREV_INUSE((p)->size & IS_MMAPPED)((p)->size & PREV_INUSE)((((mchunkptr)(((char*)(p))+((p)->size & ~PREV_INUSE)))->size) & PREV_INUSE)chunk_at_offset(p,s)((mchunkptr)(((char*)(p)) + (s)))prev_chunk(p)((mchunkptr)( ((char*)(p)) - ((p)->prev_size) ))((mchunkptr)( ((char*)(p)) + ((p)->size & ~PREV_INUSE) ))SIZE_BITS(PREV_INUSE|IS_MMAPPED)IS_MMAPPEDaligned_OK(m)(((unsigned long)((m)) & (MALLOC_ALIGN_MASK)) == 0)request2size(req)(((long)((req) + (SIZE_SZ + MALLOC_ALIGN_MASK)) < (long)(MINSIZE + MALLOC_ALIGN_MASK)) ? MINSIZE : (((req) + (SIZE_SZ + MALLOC_ALIGN_MASK)) & ~(MALLOC_ALIGN_MASK)))((mchunkptr)((char*)(mem) - 2*SIZE_SZ))((Void_t*)((char*)(p) + 2*SIZE_SZ))(sizeof(struct malloc_chunk))(MALLOC_ALIGNMENT - 1)(SIZE_SZ + SIZE_SZ)(sizeof(INTERNAL_SIZE_T))defined(CONFIG_UNIT_TEST)CONFIG_SYS_MALLOC_CLEAR_ON_INITREALLOC_ZERO_BYTES_FREES!defined(INTERNAL_LINUX_C_LIB) || !defined(__ELF__)/*

History:

    V2.6.6 Sun Dec  5 07:42:19 1999  Doug Lea  (dl at gee)
      * return null for negative arguments
      * Added Several WIN32 cleanups from Martin C. Fong <mcfong@yahoo.com>
	 * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'
	  (e.g. WIN32 platforms)
	 * Cleanup up header file inclusion for WIN32 platforms
	 * Cleanup code to avoid Microsoft Visual C++ compiler complaints
	 * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing
	   memory allocation routines
	 * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)
	 * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to
	   usage of 'assert' in non-WIN32 code
	 * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to
	   avoid infinite loop
      * Always call 'fREe()' rather than 'free()'

    V2.6.5 Wed Jun 17 15:57:31 1998  Doug Lea  (dl at gee)
      * Fixed ordering problem with boundary-stamping

    V2.6.3 Sun May 19 08:17:58 1996  Doug Lea  (dl at gee)
      * Added pvalloc, as recommended by H.J. Liu
      * Added 64bit pointer support mainly from Wolfram Gloger
      * Added anonymously donated WIN32 sbrk emulation
      * Malloc, calloc, getpagesize: add optimizations from Raymond Nijssen
      * malloc_extend_top: fix mask error that caused wastage after
	foreign sbrks
      * Add linux mremap support code from HJ Liu

    V2.6.2 Tue Dec  5 06:52:55 1995  Doug Lea  (dl at gee)
      * Integrated most documentation with the code.
      * Add support for mmap, with help from
	Wolfram Gloger (Gloger@lrz.uni-muenchen.de).
      * Use last_remainder in more cases.
      * Pack bins using idea from  colin@nyx10.cs.du.edu
      * Use ordered bins instead of best-fit threshhold
      * Eliminate block-local decls to simplify tracing and debugging.
      * Support another case of realloc via move into top
      * Fix error occuring when initial sbrk_base not word-aligned.
      * Rely on page size for units instead of SBRK_UNIT to
	avoid surprises about sbrk alignment conventions.
      * Add mallinfo, mallopt. Thanks to Raymond Nijssen
	(raymond@es.ele.tue.nl) for the suggestion.
      * Add `pad' argument to malloc_trim and top_pad mallopt parameter.
      * More precautions for cases where other routines call sbrk,
	courtesy of Wolfram Gloger (Gloger@lrz.uni-muenchen.de).
      * Added macros etc., allowing use in linux libc from
	H.J. Lu (hjl@gnu.ai.mit.edu)
      * Inverted this history list

    V2.6.1 Sat Dec  2 14:10:57 1995  Doug Lea  (dl at gee)
      * Re-tuned and fixed to behave more nicely with V2.6.0 changes.
      * Removed all preallocation code since under current scheme
	the work required to undo bad preallocations exceeds
	the work saved in good cases for most test programs.
      * No longer use return list or unconsolidated bins since
	no scheme using them consistently outperforms those that don't
	given above changes.
      * Use best fit for very large chunks to prevent some worst-cases.
      * Added some support for debugging

    V2.6.0 Sat Nov  4 07:05:23 1995  Doug Lea  (dl at gee)
      * Removed footers when chunks are in use. Thanks to
	Paul Wilson (wilson@cs.texas.edu) for the suggestion.

    V2.5.4 Wed Nov  1 07:54:51 1995  Doug Lea  (dl at gee)
      * Added malloc_trim, with help from Wolfram Gloger
	(wmglo@Dent.MED.Uni-Muenchen.DE).

    V2.5.3 Tue Apr 26 10:16:01 1994  Doug Lea  (dl at g)

    V2.5.2 Tue Apr  5 16:20:40 1994  Doug Lea  (dl at g)
      * realloc: try to expand in both directions
      * malloc: swap order of clean-bin strategy;
      * realloc: only conditionally expand backwards
      * Try not to scavenge used bins
      * Use bin counts as a guide to preallocation
      * Occasionally bin return list chunks in first scan
      * Add a few optimizations from colin@nyx10.cs.du.edu

    V2.5.1 Sat Aug 14 15:40:43 1993  Doug Lea  (dl at g)
      * faster bin computation & slightly different binning
      * merged all consolidations to one part of malloc proper
	 (eliminating old malloc_find_space & malloc_clean_bin)
      * Scan 2 returns chunks (not just 1)
      * Propagate failure in realloc if malloc returns 0
      * Add stuff to allow compilation on non-ANSI compilers
	  from kpv@research.att.com

    V2.5 Sat Aug  7 07:41:59 1993  Doug Lea  (dl at g.oswego.edu)
      * removed potential for odd address access in prev_chunk
      * removed dependency on getpagesize.h
      * misc cosmetics and a bit more internal documentation
      * anticosmetics: mangled names in macros to evade debugger strangeness
      * tested on sparc, hp-700, dec-mips, rs6000
	  with gcc & native cc (hp, dec only) allowing
	  Detlefs & Zorn comparison study (in SIGPLAN Notices.)

    Trial version Fri Aug 28 13:14:29 1992  Doug Lea  (dl at g.oswego.edu)
      * Based loosely on libg++-1.2X malloc. (It retains some of the overall
	 structure of old version,  but most details differ.)

*//* Set up by crt0.S *//*
  mallopt:

    mallopt is the general SVID/XPG interface to tunable parameters.
    The format is to provide a (parameter-number, parameter-value) pair.
    mallopt then sets the corresponding parameter to the argument
    value if it can (i.e., so long as the value is meaningful),
    and returns 1 if successful else 0.

    See descriptions of tunable parameters above.

*//* DEBUG *//*
  mallinfo returns a copy of updated current mallinfo.
*//*

  malloc_stats:

    Prints on the amount of space obtain from the system (both
    via sbrk and mmap), the maximum amount (which may be more than
    current if malloc_trim and/or munmap got called), the maximum
    number of simultaneous mmap regions used, and the current number
    of bytes allocated via malloc (or realloc, etc) but not yet
    freed. (Note that this is the number of bytes allocated, not the
    number requested. It will be larger than the number requested
    because of alignment and bookkeeping overhead.)

*//* Utility to update current_mallinfo for malloc_stats and mallinfo() *//*
  malloc_usable_size:

    This routine tells you how many bytes you can actually use in an
    allocated chunk, which may be more than you requested (although
    often not). You can use this many bytes without worrying about
    overwriting other allocated objects. Not a particularly great
    programming practice, but still sometimes useful.

*//* Success. Adjust top accordingly. *//* if not, we are very very dead! *//* Try to figure out what we have *//* sbrk failed? *//* Apparently we don't own memory; must fail *//* Test to make sure no one else called sbrk *//* Not enough memory to release *//* address returned by negative sbrk call *//* address returned by pre-check sbrk call *//* Amount to release *//* Amount of top-most memory *//*

    Malloc_trim gives memory back to the system (via negative
    arguments to sbrk) if there is unused memory at the `high' end of
    the malloc pool. You can call this after freeing large blocks of
    memory to potentially reduce the system-level memory requirements
    of a program. However, it cannot guarantee to reduce memory. Under
    some allocation patterns, some large free blocks of memory will be
    locked between two used chunks, so they cannot be given back to
    the system.

    The `pad' argument to malloc_trim represents the amount of free
    trailing space to leave untrimmed. If this argument is zero,
    only the minimum amount of memory to maintain internal data
    structures will be left (one page or less). Non-zero arguments
    can be supplied to maintain enough trailing space to service
    future expected allocations without having to re-obtain memory
    from the system.

    Malloc_trim returns 1 if it actually released any memory, else 0.

*//*

  cfree just calls free. It is needed/defined on some systems
  that pair it with calloc, presumably for odd historical reasons.

*//* clear only the bytes from non-freshly-sbrked memory *//* Two optional cases in which clearing not necessary *//* check if expand_top called, in which case don't need to clear *//*

  calloc calls malloc, then zeroes out the allocated chunk.

*//*
  pvalloc just invokes valloc for the nearest pagesize
  that will accommodate request
*//*
    valloc just invokes memalign with alignment argument equal
    to the page size of the system (or as near to this as can
    be figured out from all the includes/defines above.)
*//* Also give back spare room at the end *//* give back leader, use the rest *//*
      Find an aligned spot inside chunk.
      Since we need to give back leading space in a chunk of at
      least MINSIZE, if the first calculation places us at
      a spot with less than MINSIZE leader, we can move to the
      next aligned spot -- we've allocated enough total room so that
      this is always possible.
    *//* misaligned *//* nothing more to do *//* aligned *//* propagate failure *//* Fall through to original NULL check and chunk splitting logic *//*
     * m might not be the same as before. Validate that the previous value of
     * extra still works for the current value of m.
     * If (!m), extra2=alignment so 
     *//* Add in extra bytes to match misalignment of unexpanded allocation *//*
     * Otherwise, try again, requesting enough extra space to be able to
     * acquire alignment.
     *//* Aligned -> return it *//*
     * Use bytes not nb, since mALLOc internally calls request2size too, and
     * each call increases the size to allocate, to account for the header.
     *//*
  * The attempt to over-allocate (with a size large enough to guarantee the
  * ability to find an aligned region within allocated memory) failed.
  *
  * Try again, this time only allocating exactly the size the user wants. If
  * the allocation now succeeds and just happens to be aligned, we can still
  * fulfill the user's request.
  *//* Call malloc with worst case padding to hit alignment. *//* Otherwise, ensure that it is at least a minimum chunk size *//* If need less alignment than we give anyway, just relay to malloc *//* its size *//* spare room at end to split off *//* leading space befor alignment point *//* chunk to return *//* alignment point within p *//* corresponding chunk *//* memory returned by malloc call *//* padded  request size *//*

  memalign algorithm:

    memalign requests more than enough space from malloc, finds a spot
    within that chunk that meets the alignment request, and then
    possibly frees the leading and trailing space.

    The alignment argument must be a power of two. This property is not
    checked by memalign, so misuse may result in random runtime errors.

    8-byte alignment is guaranteed by normal malloc calls, so don't
    bother calling memalign with an argument of 8 or less.

    Overreliance on memalign is a sure way to fragment space.

*//* let free() deal with it *//* split off remainder *//* split off extra room in old or expanded chunk *//* Otherwise copy, free, and exit *//* (This can only happen when new chunk is sbrk'ed.) *//* Avoid copy if newp is next chunk after oldp. *//* Must allocate *//* backward only *//* into next chunk *//* into top *//* try forward + backward first to save a later consolidation *//* Try shifting backwards. *//* Forward into next chunk *//* Forward into top only if a remainder *//* Try expanding forward *//* Must alloc, copy, free. *//* do nothing *//* Note the extra SIZE_SZ overhead. *//* This is harder to support and should not be needed *//* realloc of null is supposed to be same as malloc *//* misc temp for linking *//* holds split off extra space from newp *//* previous contiguous chunk before oldp *//* next contiguous chunk after oldp *//* corresponding user mem *//* chunk corresponding to oldmem *//* padded request size *//*

  Realloc algorithm:

    Chunks that were obtained via mmap cannot be extended or shrunk
    unless HAVE_MREMAP is defined, in which case mremap is used.
    Otherwise, if their reallocation is for additional space, they are
    copied.  If for less, they are just left alone.

    Otherwise, if the reallocation is for additional space, and the
    chunk can be extended, it is, else a malloc-copy-free sequence is
    taken.  There are several different ways that a chunk could be
    extended. All are tried:

       * Extending forward into following adjacent free chunk.
       * Shifting backwards, joining preceding adjacent space
       * Both shifting backwards and extending forward.
       * Extending into newly sbrked space

    Unless the #define REALLOC_ZERO_BYTES_FREES is set, realloc with a
    size argument of zero (re)allocates a minimum-sized chunk.

    If the reallocation is for less space, and the new request is for
    a `small' (<512 bytes) size, then the newly unused space is lopped
    off and freed.

    The old unix realloc convention of allowing the last-free'd chunk
    to be used as an argument to realloc is no longer supported.
    I don't know of any programs still relying on this feature,
    and allowing it would also allow too many other incorrect
    usages of realloc to be sensible.


*//* re-insert last_remainder *//* consolidate forward *//* keep as last_remainder *//* consolidate backward *//* clear inuse bit *//* merge with top *//* release mmapped memory. *//* free(0) has no effect *//* free() is a no-op - all the memory will be freed on relocation *//* track whether merging with last_remainder *//* size of previous contiguous chunk *//* next contiguous chunk *//* its bin index *//* its head field *//* chunk corresponding to mem *//*

  free() algorithm :

    cases:

       1. free(0) has no effect.

       2. If the chunk was allocated via mmap, it is release via munmap().

       3. If a returned chunk borders the current high end of memory,
	  it is consolidated into the top, and if the total unused
	  topmost memory exceeds the trim threshold, malloc_trim is
	  called.

       4. Other chunks are consolidated as they arrive, and
	  placed in corresponding bins. (This includes the case of
	  consolidating with the current `last_remainder').

*//* Try to extend *//* If big and would otherwise need to extend, try to use mmap instead *//* Require that there be a remainder, ensuring top always exists  *//* Try to use top chunk *//* Get to the next possibly nonempty block *//* Possibly backtrack to try to clear a partial block *//* Clear out the block bit. *//* take *//* split *//* Find and use first big enough chunk ... *//* For each bin in this block ... *//* (track incomplete blocks) *//* For each possibly nonempty block ... *//* force to an even block boundary *//* Get to the first marked block *//*
     If there are any possibly nonempty big-enough blocks,
     search for best fitting chunk by scanning bins in blockwidth units.
  *//* Else place in bin *//* exhaust *//* re-split *//* Try to use the last split-off remainder *//* exact fit *//* adjust to rescan below after checking last remainder *//* too big *//* Set for bin scan below. We've already scanned 2 bins. *//* Also scan the next one, since it would have a remainder < MINSIZE *//* No traversal or size check necessary for small bins.  *//* Faster version for small requests *//* Check for exact match in a bin *//* padded request size; *//* not initialized yet *//* check if mem_malloc_init() was run *//* misc temp *//* first bin of a traversed block *//* block traverser bit *//* remainder from a split *//* associated bin *//* index for bin traversal *//* inspected/selected chunk *//*
  Malloc Algorthim:

    The requested size is first converted into a usable form, `nb'.
    This currently means to add 4 bytes overhead plus possibly more to
    obtain 8-byte alignment and/or to obtain a size of at least
    MINSIZE (currently 16 bytes), the smallest allocatable size.
    (All fits are considered `exact' if they are within MINSIZE bytes.)

    From there, the first successful of the following steps is taken:

      1. The bin corresponding to the request size is scanned, and if
	 a chunk of exactly the right size is found, it is taken.

      2. The most recently remaindered chunk is used if it is big
	 enough.  This is a form of (roving) first fit, used only in
	 the absence of exact fits. Runs of consecutive requests use
	 the remainder of the chunk used for the previous such request
	 whenever possible. This limited use of a first-fit style
	 allocation strategy tends to give contiguous chunks
	 coextensive lifetimes, which improves locality and can reduce
	 fragmentation in the long run.

      3. Other bins are scanned in increasing size order, using a
	 chunk big enough to fulfill the request, and splitting off
	 any remainder.  This search is strictly by best-fit; i.e.,
	 the smallest (with ties going to approximately the least
	 recently used) chunk that fits is selected.

      4. If large enough, the chunk bordering the end of memory
	 (`top') is split off. (This use of `top' is in accord with
	 the best-fit search rule.  In effect, `top' is treated as
	 larger (and thus less well fitting) than any other available
	 chunk since it can be extended to be as large as necessary
	 (up to system limitations).

      5. If the request size meets the mmap threshold and the
	 system supports mmap, and there are few enough currently
	 allocated mmapped regions, and a call to mmap succeeds,
	 the request is allocated via direct memory mapping.

      6. Otherwise, the top of memory is extended by
	 obtaining more space from the system (normally using sbrk,
	 but definable to anything else via the MORECORE macro).
	 Memory is gathered from the system (in system page-sized
	 units) in a way that allows chunks obtained across different
	 sbrk calls to be consolidated, but does not require
	 contiguous memory. Thus, it should be safe to intersperse
	 mallocs with other sbrk calls.


      All allocations are made from the the `lowest' part of any found
      chunk. (The implementation invariant is that prev_inuse is
      always true of any allocated chunk; i.e., that each allocated
      chunk borders either a previously allocated and still in-use chunk,
      or the base of its memory arena.)

*//* Main public routines *//* We always land on a page boundary *//* If possible, release the rest. *//* Also keep size a multiple of MALLOC_ALIGNMENT *//* will force null return from malloc *//* If not enough space to do this, then user did something very wrong *//* A double fencepost is necessary to prevent consolidation *//* There must have been an intervening foreign sbrk call. *//* Allocate correction *//* Guarantee the next brk will be at a page boundary *//* Guarantee alignment of first new chunk made from this space *//* Someone else called sbrk().  Count those bytes as sbrked_mem. *//* First time through. Record base *//* can just add bytes to current top *//* Fail if sbrk failed or if a foreign sbrk call killed our space *//* (We also correct below if an intervening foreign sbrk call.) *//* Otherwise, we need to correct to a page size below anyway. *//* If not the first time through, round to preserve page boundary *//* Pad request with top_pad plus minimal overhead *//* Record state of old top *//* new size of top chunk *//* return of 2nd sbrk call *//* bytes for 2nd sbrk call *//* unusable bytes at front of sbrked space *//* return value from sbrk *//*
  Extend the top-most chunk by obtaining memory from system.
  Main interface to sbrk (but see also malloc_trim).
*//* HAVE_MREMAP *//* Note the extra SIZE_SZ overhead as in mmap_chunk(). *//* munmap returns non-zero on failure *//* The offset to the start of the mmapped region is stored
   * in the prev_size field of the chunk; normally it is zero,
   * but that can be changed in memalign().
   *//* We demand that eight bytes into a page must be 8-byte aligned. *//* !MAP_ANONYMOUS *//* For mmapped chunks, the overhead is one SIZE_SZ unit larger, because
   * there is no following chunk whose prev_size field could be used.
   *//* too many regions *//* Routines dealing with mmap(). *//* Clear the last_remainder bin *//* Place p as the last remainder *//* take a chunk off a list *//*
  Place chunk p of size s in its bin, in size order,
  putting it ahead of others of same size.
*//*
  Linking chunks in bin lists.
  Call these only with variables, not arbitrary expressions, as arguments.
*//*
  Macro-based internal utilities
*//* ... and was allocated at front of an available chunk *//* ... and alignment *//* Legal size ... *//* ... and is surrounded by OK chunks.
    Since more things can be checked with free chunks than inuse ones,
    if an inuse chunk borders them and debug is on, it's worth doing them.
  *//* Check whether it claims to be in use ... *//* markers are always of size SIZE_SZ *//* ... and has minimally sane links *//* ... and is fully consolidated *//* ... matching footer field *//* Unless a special marker, must have OK fields *//* Check whether it claims to be free ... *//* Check for legal address ... *//* No checkable chunk is mmapped *//*
  These routines make a number of assertions about the states
  of data structures that should be true at all times. If any
  are not true, it's very likely that a user program has somehow
  trashed memory. (It's also possible that there is a coding error
  in malloc. In which case, please report it!)
*//*
  Debugging support
*//* Tracking mmaps *//* The total memory obtained from system via sbrk *//* internal working copy of mallinfo *//* The maximum via either sbrk or mmap *//* The maximum memory obtained from system via sbrk *//* The first value returned from sbrk *//* variables holding tunable values *//*  Other static bookkeeping data *//* bin<->block macros *//* bitvector of nonempty blocks *//* bins per block *//*
    To help compensate for the large number of bins, a one-level index
    structure is used for bin-by-bin searching.  `binblocks' is a
    one-word bitvector recording whether groups of BINBLOCKWIDTH bins
    have any (possibly) non-empty bins, so they can be skipped over
    all at once during during traversals. The bits are NOT always
    cleared as soon as all bins in a block are empty, but instead only
    when all are noticed to be empty during traversal in malloc.
*//*
   Requests are `small' if both the corresponding and the next bin are small
*//*
  bins for chunks < 512 are all spaced 8 bytes apart, and hold
  identically sized chunks. This is exploited in malloc.
*//*
  Indexing into bins
*//* field-extraction macros *//*
	 * if we are giving memory back make sure we clear it out since
	 * we set MORECORE_CLEARS to 1
	 *//* Helper macro to initialize bins *//*
   Because top initially points to its own bin with initial
   zero size, thus forcing extension on the first malloc request,
   we avoid having any special code in malloc to check whether
   it even exists yet. But we still need to in malloc_extend_top.
*//* remainder from last split *//* The topmost chunk *//*
   The first 2 bins are never indexed. The corresponding av_ cells are instead
   used for bookkeeping. This is not to save space, but to simplify
   indexing, maintain locality, and avoid some initialization tests.
*//* access macros *//* number of bins *//*
   Bins

    The bins, `av_' are an array of pairs of pointers serving as the
    heads of (initially empty) doubly-linked lists of chunks, laid out
    in a way so that each pair can be treated as if it were in a
    malloc_chunk. (This way, the fd/bk offsets for linking bin heads
    and chunks are the same).

    Bins for sizes < 512 bytes contain chunks of all the same size, spaced
    8 bytes apart. Larger bins are approximately logarithmically
    spaced. (See the table below.) The `av_' array is never mentioned
    directly in the code, but instead via bin access macros.

    Bin layout:

    64 bins of size       8
    32 bins of size      64
    16 bins of size     512
     8 bins of size    4096
     4 bins of size   32768
     2 bins of size  262144
     1 bin  of size what's left

    There is actually a little bit of slop in the numbers in bin_index
    for the sake of speed. This makes no difference elsewhere.

    The special chunks `top' and `last_remainder' get their own bins,
    (this is implemented via yet more trickery with the av_ array),
    although `top' is never properly linked to its bin since it is
    always handled specially.

*//* Set size at footer (only when chunk is not in use) *//* Set size/use ignoring previous bits in header *//* Set size at head, without disturbing its use bit *//* Get size, ignoring use bits *//*
  Dealing with size fields
*//* check/set/clear inuse bits in known places *//* set/clear chunk as in use without otherwise disturbing *//* check for mmap()'ed chunk *//* extract inuse bit of previous chunk *//* extract p's inuse bit *//*
  Dealing with use bits
*//* Treat space at ptr + offset as a chunk *//* Ptr to previous physical malloc_chunk *//* Ptr to next physical malloc_chunk. *//* Bits to mask off when extracting size *//* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() *//* size field is or'ed with PREV_INUSE when previous adjacent chunk in use *//*
  Physical chunk operations
*//* Check if m has acceptable alignment *//* pad request bytes into a usable size *//* conversion from malloc headers to user pointers, and back *//*  sizes, alignments *//*

   malloc_chunk details:

    (The following includes lightly edited explanations by Colin Plumb.)

    Chunks of memory are maintained using a `boundary tag' method as
    described in e.g., Knuth or Standish.  (See the paper by Paul
    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a
    survey of such techniques.)  Sizes of free chunks are stored both
    in the front of each chunk and at the end.  This makes
    consolidating fragmented chunks into bigger chunks very fast.  The
    size fields also hold bits representing whether chunks are free or
    in use.

    An allocated chunk looks like this:


    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of previous chunk, if allocated            | |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of chunk, in bytes                         |P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             User data starts here...                          .
	    .                                                               .
	    .             (malloc_usable_space() bytes)                     .
	    .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of chunk                                     |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


    Where "chunk" is the front of the chunk for the purpose of most of
    the malloc code, but "mem" is the pointer that is returned to the
    user.  "Nextchunk" is the beginning of the next contiguous chunk.

    Chunks always begin on even word boundries, so the mem portion
    (which is returned to the user) is also on an even word boundary, and
    thus double-word aligned.

    Free chunks are stored in circular doubly-linked lists, and look like this:

    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Size of previous chunk                            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                         |P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Forward pointer to next chunk in list             |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Back pointer to previous chunk in list            |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
	    |             Unused space (may be 0 bytes long)                .
	    .                                                               .
	    .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
	    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    The P (PREV_INUSE) bit, stored in the unused low-order bit of the
    chunk size (which is always a multiple of two words), is an in-use
    bit for the *previous* chunk.  If that bit is *clear*, then the
    word before the current chunk size contains the previous chunk
    size, and can be used to find the front of the previous chunk.
    (The very first chunk allocated always has this bit set,
    preventing access to non-existent (or non-owned) memory.)

    Note that the `foot' of the current chunk is actually represented
    as the prev_size of the NEXT chunk. (This makes it easier to
    deal with alignments etc).

    The two exceptions to all this are

     1. The special chunk `top', which doesn't bother using the
	trailing size field since there is no
	next contiguous chunk that would have to index off it. (After
	initialization, `top' is forced to always exist.  If it would
	become less than MINSIZE bytes long, it is replenished via
	malloc_extend_top.)

     2. Chunks allocated via mmap, which have the second-lowest-order
	bit (IS_MMAPPED) set in their size fields.  Because they are
	never merged or traversed from any other chunk, they have no
	foot size or inuse information.

    Available chunks are kept in any of several places (all declared below):

    * `av': An array of chunks serving as bin headers for consolidated
       chunks. Each bin is doubly linked.  The bins are approximately
       proportionally (log) spaced.  There are a lot of these bins
       (128). This may look excessive, but works very well in
       practice.  All procedures maintain the invariant that no
       consolidated chunk physically borders another one. Chunks in
       bins are kept in size order, with ties going to the
       approximately least recently used chunk.

       The chunks in each bin are maintained in decreasing sorted order by
       size.  This is irrelevant for the small bins, which all contain
       the same-sized chunks, but facilitates best-fit allocation for
       larger chunks. (These lists are just sequential. Keeping them in
       order almost never requires enough traversal to warrant using
       fancier ordered data structures.)  Chunks of the same size are
       linked with the most recently freed at the front, and allocations
       are taken from the back.  This results in LRU or FIFO allocation
       order, which tends to give each chunk an equal opportunity to be
       consolidated with adjacent freed chunks, resulting in larger free
       chunks and less fragmentation.

    * `top': The top-most available chunk (i.e., the one bordering the
       end of available memory) is treated specially. It is never
       included in any bin, is used only if no other chunk is
       available, and is released back to the system if it is very
       large (see M_TRIM_THRESHOLD).

    * `last_remainder': A bin holding only the remainder of the
       most recently split (non-top) chunk. This bin is checked
       before other non-fitting chunks, so as to provide better
       locality for runs of sequentially allocated chunks.

    *  Implicitly, through the host system's memory mapping tables.
       If supported, requests greater than a threshold are usually
       serviced via calls to mmap, and then later released via munmap.

*//* double links -- used only if free. *//* Size in bytes, including overhead. *//* Size of previous chunk (if free). *//*
  Type declarations
*//* Trim by releasing the virtual memory *//* by another thread *//* The region that we found has been snagged *//* repeat in case of race condition *//* here, causing us to go into an infinite loop. *//* to 'VirtualAlloc()' will fail and bring us back *//* unavailable region.  Thus, the subsequent call *//* we already know is an address in the *//* the requested address to a 64K boundary which *//* this routine in 'wsbrk()') will round *down* *//* 'VirtualAlloc()' (which follows the call to *//* 'VirtualQuery()', the subsequent call to *//* the new region is free according to *//* on the *next* 64K boundary.  Otherwise, even if *//* Make sure we start looking for the next region *//* again. *//* to the next region and call 'VirtualQuery()' *//* next region is available.  Set 'start_address' *//* Requested region is not available so see if the *//* resrve 64MB to insure large contiguous space *//*
  Emulation of sbrk for WIN32
  All code within the ifdef WIN32 is untested by me.

  Thanks to Martin Fong and others for supplying this.
*//opt/src/common/edid.cNot a valid EDID
"Not a valid EDID\n"EDID version: %d.%d
"EDID version: %d.%d\n"Product ID code: %04x
"Product ID code: %04x\n"*edid_infoEDID1_INFO_PRODUCT_CODE(*edid_info)Manufacturer: %s
"Manufacturer: %s\n"EDID1_INFO_SERIAL_NUMBER(*edid_info)MAG"MAG"1174405120x7000000OQI"OQI"456150000VSC"VSC"640000000Serial number: %08x
"Serial number: %08x\n"Manufactured in week: %d year: %d
"Manufactured in week: %d year: %d\n"1990Video input definition: %svoltage level %d%s%s%s%s%s
"Video input definition: %svoltage level %d%s%s%s%s%s\n"((*edid_info).video_input_definition)EDID1_INFO_VIDEO_INPUT_DIGITAL(*edid_info)digital signal, "digital signal, "analog signal, "analog signal, "EDID1_INFO_VIDEO_INPUT_VOLTAGE_LEVEL(*edid_info)EDID1_INFO_VIDEO_INPUT_BLANK_TO_BLACK(*edid_info), blank to black", blank to black"EDID1_INFO_VIDEO_INPUT_SEPARATE_SYNC(*edid_info), separate sync", separate sync"EDID1_INFO_VIDEO_INPUT_COMPOSITE_SYNC(*edid_info), composite sync", composite sync"EDID1_INFO_VIDEO_INPUT_SYNC_ON_GREEN(*edid_info), sync on green", sync on green"EDID1_INFO_VIDEO_INPUT_SERRATION_V(*edid_info), serration v", serration v"Monitor is %s
"Monitor is %s\n"((*edid_info).feature_support)EDID1_INFO_FEATURE_RGB(*edid_info)RGB"RGB"non-RGB"non-RGB"Maximum visible display size: %d cm x %d cm
"Maximum visible display size: %d cm x %d cm\n"Power management features: %s%s, %s%s, %s%s
"Power management features: %s%s, %s%s, %s%s\n"EDID1_INFO_FEATURE_ACTIVE_OFF(*edid_info)no "no "active off"active off"EDID1_INFO_FEATURE_SUSPEND(*edid_info)"suspend"EDID1_INFO_FEATURE_STANDBY(*edid_info)standby"standby"Estabilished timings:
"Estabilished timings:\n"EDID1_INFO_ESTABLISHED_TIMING_720X400_70(*edid_info)((*edid_info).established_timings[0])	720x400		70 Hz (VGA 640x400, IBM)
"\t720x400\t\t70 Hz (VGA 640x400, IBM)\n"EDID1_INFO_ESTABLISHED_TIMING_720X400_88(*edid_info)	720x400		88 Hz (XGA2)
"\t720x400\t\t88 Hz (XGA2)\n"EDID1_INFO_ESTABLISHED_TIMING_640X480_60(*edid_info)	640x480		60 Hz (VGA)
"\t640x480\t\t60 Hz (VGA)\n"EDID1_INFO_ESTABLISHED_TIMING_640X480_67(*edid_info)	640x480		67 Hz (Mac II, Apple)
"\t640x480\t\t67 Hz (Mac II, Apple)\n"EDID1_INFO_ESTABLISHED_TIMING_640X480_72(*edid_info)	640x480		72 Hz (VESA)
"\t640x480\t\t72 Hz (VESA)\n"EDID1_INFO_ESTABLISHED_TIMING_640X480_75(*edid_info)	640x480		75 Hz (VESA)
"\t640x480\t\t75 Hz (VESA)\n"EDID1_INFO_ESTABLISHED_TIMING_800X600_56(*edid_info)	800x600		56 Hz (VESA)
"\t800x600\t\t56 Hz (VESA)\n"EDID1_INFO_ESTABLISHED_TIMING_800X600_60(*edid_info)	800x600		60 Hz (VESA)
"\t800x600\t\t60 Hz (VESA)\n"EDID1_INFO_ESTABLISHED_TIMING_800X600_72(*edid_info)((*edid_info).established_timings[1])	800x600		72 Hz (VESA)
"\t800x600\t\t72 Hz (VESA)\n"EDID1_INFO_ESTABLISHED_TIMING_800X600_75(*edid_info)	800x600		75 Hz (VESA)
"\t800x600\t\t75 Hz (VESA)\n"EDID1_INFO_ESTABLISHED_TIMING_832X624_75(*edid_info)	832x624		75 Hz (Mac II)
"\t832x624\t\t75 Hz (Mac II)\n"EDID1_INFO_ESTABLISHED_TIMING_1024X768_87I(*edid_info)	1024x768	87 Hz Interlaced (8514A)
"\t1024x768\t87 Hz Interlaced (8514A)\n"EDID1_INFO_ESTABLISHED_TIMING_1024X768_60(*edid_info)	1024x768	60 Hz (VESA)
"\t1024x768\t60 Hz (VESA)\n"EDID1_INFO_ESTABLISHED_TIMING_1024X768_70(*edid_info)	1024x768	70 Hz (VESA)
"\t1024x768\t70 Hz (VESA)\n"EDID1_INFO_ESTABLISHED_TIMING_1024X768_75(*edid_info)	1024x768	75 Hz (VESA)
"\t1024x768\t75 Hz (VESA)\n"EDID1_INFO_ESTABLISHED_TIMING_1280X1024_75(*edid_info)	1280x1024	75 (VESA)
"\t1280x1024\t75 (VESA)\n"EDID1_INFO_ESTABLISHED_TIMING_1152X870_75(*edid_info)((*edid_info).established_timings[2])	1152x870	75 (Mac II)
"\t1152x870\t75 (Mac II)\n"Standard timings:
"Standard timings:\n"edid_info->standard_timingsARRAY_SIZE(edid_info->standard_timings)aspectxresvfreq((*edid_info).standard_timings[i].aspect_vfreq)EDID1_INFO_STANDARD_TIMING_VFREQ(*edid_info, i)EDID1_INFO_STANDARD_TIMING_ASPECT(*edid_info,
					i)6250750080005625	%dx%d%c	%d Hz
"\t%dx%d%c\t%d Hz\n"have_timingedid_info->monitor_details.descriptorARRAY_SIZE(edid_info->monitor_details.descriptor)edid_monitor_descriptor *	None
"\tNone\n"edid_get_manufacturer_name*edidEDID1_INFO_MANUFACTURER_NAME_CHAR1(*edid)((*edid).manufacturer_name[0])EDID1_INFO_MANUFACTURER_NAME_CHAR2(*edid)((*edid).manufacturer_name[1])EDID1_INFO_MANUFACTURER_NAME_CHAR3(*edid)edid_print_dtdMonitor serial number: %s
"Monitor serial number: %s\n"Monitor ID: %s
"Monitor ID: %s\n"Monitor name: %s
"Monitor name: %s\n"Monitor range limits, horizontal sync: %d-%d kHz, vertical refresh: %d-%d Hz, max pixel clock: %d MHz
"Monitor range limits, horizontal sync: "
			       "%d-%d kHz, vertical refresh: "
			       "%d-%d Hz, max pixel clock: "
			       "%d MHz\n"char[103]pixclockh_activeh_blankingv_activev_blankingh_totalv_totaledid_detailed_timing **timingEDID_DETAILED_TIMING_PIXEL_CLOCK(*timing)monitor(*timing).horizontal_active_blanking_hiEDID_DETAILED_TIMING_HORIZONTAL_ACTIVE(*timing)EDID_DETAILED_TIMING_HORIZONTAL_BLANKING(*timing)(*timing).vertical_active_blanking_hiEDID_DETAILED_TIMING_VERTICAL_ACTIVE(*timing)EDID_DETAILED_TIMING_VERTICAL_BLANKING(*timing)	%dx%d%c	%d Hz (detailed)
"\t%dx%d\%c\t%d Hz (detailed)\n"snipsizeof(*edid)"%s: Invalid buffer\n"debug("%s: Invalid buffer\n", __func__)common/edid.c%s: Invalid buffer
((*edid).feature_support)EDID1_INFO_FEATURE_PREFERRED_TIMING_MODE(*edid)"%s: No preferred timing\n"debug("%s: No preferred timing\n", __func__)%s: No preferred timing
timing_done((*edid).video_input_definition)EDID1_INFO_VIDEO_INPUT_DIGITAL(*edid)"%s: Not a digital display\n"debug("%s: Not a digital display\n", __func__)%s: Not a digital display
"%s: EDID version %d.%d does not have required info\n"__func__, edid->version, edid->revisiondebug("%s: EDID version %d.%d does not have required info\n",
		      __func__, edid->version, edid->revision)%s: EDID version %d.%d does not have required info
edid_cea861_info *cea_is_hdmi_vsdb_presentsizeof(info->data)*info(*info).data[i]EDID_CEA861_DB_TYPE(*info, i)EDID_CEA861_DB_LEN(*info, i)db3075decode_timingtiming_entry *x_mmy_mmhahblhsohspwvavblvsovspw*t(*t).flagsEDID_DETAILED_TIMING_FLAG_HSYNC_POLARITY(*t)EDID_DETAILED_TIMING_FLAG_VSYNC_POLARITY(*t)EDID_DETAILED_TIMING_FLAG_INTERLACED(*t)"Detailed mode clock %u Hz, %d mm x %d mm\n" "               %04x %04x %04x %04x hborder %x\n" "               %04x %04x %04x %04x vborder %x\n"timing->pixelclock.typ, x_mm, y_mm, ha, ha + hso, ha + hso + hspw, ha + hbl, hborder, va, va + vso, va + vso + vspw, va + vbl, vborderdebug("Detailed mode clock %u Hz, %d mm x %d mm\n"
	      "               %04x %04x %04x %04x hborder %x\n"
	      "               %04x %04x %04x %04x vborder %x\n",
	      timing->pixelclock.typ,
	      x_mm, y_mm,
	      ha, ha + hso, ha + hso + hspw,
	      ha + hbl, hborder,
	      va, va + vso, va + vso + vspw,
	      va + vbl, vborder)Detailed mode clock %u Hz, %d mm x %d mm
               %04x %04x %04x %04x hborder %x
               %04x %04x %04x %04x vborder %x
"Detailed mode clock %u Hz, %d mm x %d mm\n"
	      "               %04x %04x %04x %04x hborder %x\n"
	      "               %04x %04x %04x %04x vborder %x\n"char[134]set_entryedid->monitor_details.descriptorARRAY_SIZE(edid->monitor_details.descriptor)  "\x0\xff\xff\xff\xff\xff\xff\x0"/* Detailed timing information. *//* Standard timings. *//**
 * Get the manufacturer name from an EDID info.
 *
 * @param edid_info     The EDID info to be printed
 * @param name		Returns the string of the manufacturer name
 *//* Error case *//**
 * Print an EDID monitor descriptor block
 *
 * @param monitor	The EDID monitor descriptor block
 * @have_timing		Modifies to 1 if the desciptor contains timing info
 *//*
	 * This is always a 13 character buffer
	 * and it's not always terminated.
	 *//**
 * Snip the tailing whitespace/return of a string.
 *
 * @param string	The string to be snipped
 * @return the snipped string
 *//* Look for detailed timing *//* Look for vendor specific data block of appropriate size *//* check for end of data block *//**
 * Check if HDMI vendor specific data block is present in CEA block
 * @param info	CEA extension block
 * @return true if block is found
 *//* Edid contains pixel clock in terms of 10KHz *//**
 * decode_timing() - Decoding an 18-byte detailed timing record
 *
 * @buf:	Pointer to EDID detailed timing record
 * @timing:	Place to put timing
 *//* Set all parts of a timing entry to the same value *//opt/src/common/exports.csizeof(struct jt_funcs)EXPORT_FUNC(f,a,x,__VA_ARGS__...)gd->jt->x = f;phy_find_by_mask		dummy/opt/src/common/fdt_support.cfdt_supportfdt_overlay_apply_verbose/__symbols__"/__symbols__"has_symbolsfailed on fdt_overlay_apply(): %s
"failed on fdt_overlay_apply(): %s\n"base fdt does did not have a /__symbols__ node
"base fdt does did not have a /__symbols__ node\n"make sure you've compiled with -@
"make sure you've compiled with -@\n"fdt_fixup_displaydisplay-timings"display-timings""%s:0x%x\n"fdt_get_name(blob, off, NULL), fdt32_to_cpu(h)debug("%s:0x%x\n", fdt_get_name(blob, off, NULL),
		      fdt32_to_cpu(h))common/fdt_support.c1739%s:0x%x
(__force __u32)(__be32)(h)(__u32)(__be32)(h)((__u32)(__be32)(h))native-mode"native-mode"fdt_setup_simplefb_nodeaddrcsizecfdt32_t[4]base_address >> 32(base_address >> 32)((base_address >> 32))cpu_to_fdt32(base_address >> 32)fdtostride(base_address)((base_address))cpu_to_fdt32(base_address)height * stride(height * stride)((height * stride))cpu_to_fdt32(height * stride)"reg"sizeof(cells[0])framebuffer@%llx"framebuffer@%llx""width""height""stride""format"fdt_setprop_string(fdt, node, "format", format)"okay"fdt_setprop_string(fdt, node, "status", "okay")okayfdt_read_rangepacellspnode#address-cells"#address-cells"acellsscells#size-cells"#size-cells"ranges"ranges"ranges_lenchild_addrfdt_read_propFDT_ERR_NOSPACE-FDT_ERR_NOSPACE*prop32(__force __u32)(__be32)(*prop32)(__u32)(__be32)(*prop32)prop32((__u32)(__be32)(*prop32))fdt32_to_cpu(*prop32)*prop64(__force __u64)(__be64)(*prop64)(__u64)(__be64)(*prop64)const fdt64_tconst fdt64_t *prop64((__u64)(__be64)(*prop64))fdt64_to_cpu(*prop64)fdt_get_base_addressfdt_verify_alias_addressWarning: device tree alias '%s' points to invalid node %s.
"Warning: device tree alias '%s' points to invalid "
		       "node %s.\n"Warning: device tree node '%s' has no address.
"Warning: device tree node '%s' has no address.\n"dt_addrWarning: U-Boot configured device %s at address %llu,
but the device tree has it address %llx.
"Warning: U-Boot configured device %s at address %llu,\n"
		       "but the device tree has it address %llx.\n"char[96]fdt_set_status_by_aliasfdt_set_node_statusFDT_STATUS_OKAYfdt_setprop_string(fdt, nodeoffset, "status", "okay")FDT_STATUS_DISABLEDfdt_setprop_string(fdt, nodeoffset, "status", "disabled")prop_lencell_offanodealiaserror_codeFDT_STATUS_FAIL"fail"fdt_setprop_string(fdt, nodeoffset, "status", "fail")failFDT_STATUS_FAIL_ERROR_CODEfail-%d"fail-%d"fdt_setprop_string(fdt, nodeoffset, "status", buf)Invalid fdt status: %x
"Invalid fdt status: %x\n"fdt_create_phandleCan't set phandle %u: %s
"Can't set phandle %u: %s\n"fdt_set_phandlelinux,phandle"linux,phandle"fdt_alloc_phandlefdt_get_phandle(blob, offset)fdt_node_offset_by_compat_regfdt_translate_dma_addressdma-ranges"dma-ranges"fdt_translate_address__of_translate_address"OF: ** translation for device %s **\n"fdt_get_name(blob, node_offset, NULL)debug("OF: ** translation for device %s **\n",
		fdt_get_name(blob, node_offset, NULL))1229OF: ** translation for device %s **
of_bus *OF_CHECK_COUNTS(na, ns)%s: Bad cell count for %s
"%s: Bad cell count for %s\n"OF_MAX_ADDR_CELLS"OF: bus is %s (na=%d, ns=%d) on %s\n"bus->name, na, ns, fdt_get_name(blob, parent, NULL)debug("OF: bus is %s (na=%d, ns=%d) on %s\n",
	    bus->name, na, ns, fdt_get_name(blob, parent, NULL))1247OF: bus is %s (na=%d, ns=%d) on %s
OF: translating address:"OF: translating address:""OF: reached root node\n"debug("OF: reached root node\n")compat_offnode_offsetrprop1258OF: reached root node
pbuspnapnsOF_CHECK_COUNTS(pna, pns)"OF: parent bus is %s (na=%d, ns=%d) on %s\n"pbus->name, pna, pns, fdt_get_name(blob, parent, NULL)debug("OF: parent bus is %s (na=%d, ns=%d) on %s\n",
		    pbus->name, pna, pns, fdt_get_name(blob, parent, NULL))1273OF: parent bus is %s (na=%d, ns=%d) on %s
OF: one level translation:"OF: one level translation:"of_translate_onerlen"OF: no ranges, 1:1 translation\n"debug("OF: no ranges, 1:1 translation\n")1181OF: no ranges, 1:1 translation
"OF: walking ranges...\n"debug("OF: walking ranges...\n")1185OF: walking ranges...
rone"OF: not found !\n"debug("OF: not found !\n")1196OF: not found !
OF: parent translation for:"OF: parent translation for:""OF: with offset: %llu\n"debug("OF: with offset: %llu\n", offset)1203OF: with offset: %llu
bailfinishof_match_busof_bus[1]of_bussesARRAY_SIZE(of_busses)ARRAY_SIZE(of_busses) == 1assert(0)1152of_bus_default_translatea >> 32(a >> 32)((a >> 32))cpu_to_fdt32(a >> 32)a & 0xffffffffu(a & 0xffffffffu)0xffffffffu((a & 0xffffffffu))cpu_to_fdt32(a & 0xffffffffu)of_bus_default_mapda"OF: default map, cp=%llx, s=%llx, da=%llx\n"cp, s, dadebug("OF: default map, cp=%llx, s=%llx, da=%llx\n", cp, s, da)1042OF: default map, cp=%llx, s=%llx, da=%llx
fdt_support_default_count_cellsof_dump_addrfdt_del_node_and_alias/aliases"/aliases"fdt_increase_sizenewlenparentoffsetrangeadd_lenfdt_pci_dma_rangesaddrcellsizecelldma_rangeu32[28]unsigned int[28](3 + 2 + 2)CONFIG_SYS_PCI_NR_INBOUND_WIN(3 + 2 + 2) * CONFIG_SYS_PCI_NR_INBOUND_WINdma_ranges0x100000000ullFDT_PCI_MEM64(0x03000000)((0x03000000))cpu_to_fdt32(FDT_PCI_MEM64)(((0x03000000)))FDT_PCI_MEM32(0x02000000)((0x02000000))cpu_to_fdt32(FDT_PCI_MEM32)(((0x02000000)))FDT_PCI_PREFETCH(0x40000000)((0x40000000))cpu_to_fdt32(FDT_PCI_PREFETCH)(((0x40000000)))bus_start & 0xffffffff(bus_start & 0xffffffff)((bus_start & 0xffffffff))cpu_to_fdt32(bus_start & 0xffffffff)phb_offphys_start >> 32(phys_start >> 32)((phys_start >> 32))cpu_to_fdt32(phys_start >> 32)phys_start & 0xffffffff(phys_start & 0xffffffff)((phys_start & 0xffffffff))cpu_to_fdt32(phys_start & 0xffffffff)size >> 32(size >> 32)((size >> 32))cpu_to_fdt32(size >> 32)size & 0xffffffff(size & 0xffffffff)((size & 0xffffffff))cpu_to_fdt32(size & 0xffffffff)fdt_shrink_to_minimumfdt_memrsvactualsizesizeof(struct fdt_reserve_entry)5 * sizeof(struct fdt_reserve_entry)actualsize + ((uintptr_t)blob & 0xfff)0xfff(actualsize + ((uintptr_t)blob & 0xfff))(typeof(actualsize + ((uintptr_t)blob & 0xfff)))(0x1000)-1ALIGN(actualsize + ((uintptr_t)blob & 0xfff), 0x1000)fdt_record_loadablefit-images"fit-images"load-addr"load-addr"entry-point"entry-point""type"fdt_setprop_string(blob, node, "type", type)"os"fdt_setprop_string(blob, node, "os", os)fdt_fixup_ethernetethernet"ethernet"eth%daddr"eth%daddr"ARP_HLENmac-address"mac-address"unsigned char(*)[6]local-mac-address"local-mac-address"fdt_fixup_memoryfdt_fixup_memory_banksu64[]unsigned long long[]MEMORY_BANKS_MAX%s: num banks %d exceeds hardcoded limit %d. Recompile with higher MEMORY_BANKS_MAX?
"%s: num banks %d exceeds hardcoded limit %d."
		       " Recompile with higher MEMORY_BANKS_MAX?\n"__FUNCTION__"memory"device_type"device_type""memory")sizeof("memory")WARNING: could not set %s %s.
"WARNING: could not set %s %s.\n"u8[64]MEMORY_BANKS_MAX * 16fdt_pack_regaddress_cellsfdt64_t *address[i](address[i])((address[i]))cpu_to_fdt64(address[i])cpu_to_fdt32(address[i])size_cellssize[i](size[i])((size[i]))cpu_to_fdt64(size[i])cpu_to_fdt32(size[i])do_fixup_by_compat_u32cpu_to_fdt32(val)do_fixup_by_compatdo_fixup_by_prop_u32createpnamepvaldo_fixup_by_propdo_fixup_by_path_u32sizeof(tmp)do_fixup_by_pathUnable to update property %s:%s, err=%s
"Unable to update property %s:%s, err=%s\n"fdt_chosenfdt_chosen: %s
"fdt_chosen: %s\n"chosen"chosen"WARNING: could not set bootargs %s.
"WARNING: could not set bootargs %s.\n"fdt_initrdfdt_initrd: %s
"fdt_initrd: %s\n"is_u64linux,initrd-start"linux,initrd-start"WARNING: could not set linux,initrd-start %s.
"WARNING: could not set linux,initrd-start %s.\n"linux,initrd-end"linux,initrd-end"WARNING: could not set linux,initrd-end %s.
"WARNING: could not set linux,initrd-end %s.\n"fdt_rootfdt_root: %s
"fdt_root: %s\n"serial#"serial#"serial-number"serial-number"WARNING: could not set serial-number %s.
"WARNING: could not set serial-number %s.\n"fdt_setprop_uxxfdt_fixup_stdoutfdt_find_or_add_subnode%s: %s: %s
"%s: %s: %s\n"fdt_find_and_setpropnodeofffdt_getprop_u32_defaultfdt_getprop_u32_default_node*val(__force __u32)(__be32)(*val)(__u32)(__be32)(*val)chosenoffdflt((__u32)(__be32)(*val))fdt32_to_cpu(*val)of_buscount_cellsaddressesof_bus[]OF_CHECK_COUNTS(na,ns)((na) > 0 && (na) <= OF_MAX_ADDR_CELLS && (ns) > 0)FDT_PCI_IO(0x01000000)defined(OF_STDOUT_PATH)defined(CONFIG_OF_STDOUT_VIA_ALIAS) && defined(CONFIG_CONS_INDEX)defined(DEBUG)CONFIG_ARCH_FIXUP_FDT_MEMORYCONFIG_NR_DRAM_BANKS > 4FDT_SEQ_MACADDR_FROM_ENVCONFIG_FDT_FIXUP_PARTITIONSCONFIG_OF_ISA_BUSdefined(CONFIG_VIDEO) || defined(CONFIG_LCD)/**
 * fdt_overlay_apply_verbose - Apply an overlay with verbose error reporting
 *
 * @fdt: ptr to device tree
 * @fdto: ptr to device tree overlay
 *
 * Convenience function to apply an overlay and display helpful messages
 * in the case of an error
 *//*
 * Update native-mode in display-timings from display environment variable.
 * The node to update are specified by path.
 *//**
 * fdt_setup_simplefb_node - Fill and enable a simplefb node
 *
 * @fdt: ptr to device tree
 * @node: offset of the simplefb node
 * @base_address: framebuffer base address
 * @width: width in pixels
 * @height: height in pixels
 * @stride: bytes per line
 * @format: pixel format string
 *
 * Convenience function to fill and enable a simplefb node.
 *//* Read <size in child address space> *//* Read <parent address> *//* Read <child address> *//* Jump to the n'th entry *//* Now try to get the ranges property *//*
	 * The "ranges" property is an array of
	 * { <child address> <parent address> <size in child address space> }
	 *
	 * All 3 elements can span a diffent number of cells. Fetch their size.
	 *//**
 * fdt_read_range - Read a node's n'th range property
 *
 * @fdt: ptr to device tree
 * @node: offset of node
 * @n: range index
 * @child_addr: pointer to storage for the "child address" field
 * @addr: pointer to storage for the CPU view translated physical start
 * @len: pointer to storage for the range length
 *
 * Convenience function that reads and interprets a specific range out of
 * a number of the "ranges" property array.
 *//*
 * Read a property of size <prop_len>. Currently only supports 1 or 2 cells.
 *//*
 * Returns the base address of an SOC or PCI node
 *//* If there's no such alias, then it's not a failure *//*
 * Verify the physical address of device tree node for a given alias
 *
 * This function locates the device tree node of a given alias, and then
 * verifies that the physical address of that device matches the given
 * parameter.  It displays a message if there is a mismatch.
 *
 * Returns 1 on success, 0 on failure
 *//*
 * fdt_set_status_by_alias: Set status for the given node given an alias
 *
 * @fdt: ptr to device tree
 * @alias: alias of node to update
 * @status: FDT_STATUS_OKAY, FDT_STATUS_DISABLED,
 *	    FDT_STATUS_FAIL, FDT_STATUS_FAIL_ERROR_CODE
 * @error_code: optional, only used if status is FDT_STATUS_FAIL_ERROR_CODE
 *//*
 * fdt_set_node_status: Set status for the given node
 *
 * @fdt: ptr to device tree
 * @nodeoffset: node to update
 * @status: FDT_STATUS_OKAY, FDT_STATUS_DISABLED,
 *	    FDT_STATUS_FAIL, FDT_STATUS_FAIL_ERROR_CODE
 * @error_code: optional, only used if status is FDT_STATUS_FAIL_ERROR_CODE
 *//* if we got 0, means no phandle so create one *//* see if there is a phandle already *//*
 * fdt_create_phandle: Create a phandle property for the given node
 *
 * @fdt: ptr to device tree
 * @nodeoffset: node to update
 *//*
	 * For now, also set the deprecated "linux,phandle" property, so that we
	 * don't break older kernels.
	 *//*
 * fdt_set_phandle: Create a phandle property for the given node
 *
 * @fdt: ptr to device tree
 * @nodeoffset: node to update
 * @phandle: phandle value to set (must be unique)
 *//**
 * fdt_alloc_phandle: Return next free phandle value
 *
 * @blob: ptr to device tree
 *//**
 * fdt_node_offset_by_compat_reg: Find a node that matches compatiable and
 * who's reg property matches a physical cpu address
 *
 * @blob: ptr to device tree
 * @compat: compatiable string to match
 * @compat_off: property name
 *
 *//* Complete the move up one level *//* Apply bus translation *//* Get new parent bus and counts *//* If root, we have finished *//* Switch to parent bus *//* Translate *//* Cound address cells & copy address locally *//* Get parent & match bus type *//*
 * Translate an address from the device-tree into a CPU physical address,
 * this walks up the tree and applies the various bus mappings on the
 * way.
 *
 * Note: We consider that crossing any level with #size-cells == 0 to mean
 * that translation is impossible (that is we are not dealing with a value
 * that can be mapped to a cpu physical address). This is not really specified
 * that way, but this is traditionally the way IBM at least do things
 *//* Translate it into parent bus space *//* Now walk through the ranges *//* Normally, an absence of a "ranges" property means we are
	 * crossing a non-translatable boundary, and thus the addresses
	 * below the current not cannot be converted to CPU physical ones.
	 * Unfortunately, while this is very clear in the spec, it's not
	 * what Apple understood, and they do have things like /uni-n or
	 * /ht nodes with no "ranges" property and a lot of perfectly
	 * useable mapped devices below them. Thus we treat the absence of
	 * "ranges" as equivalent to an empty "ranges" property which means
	 * a 1:1 translation at that level. It's up to the caller not to try
	 * to translate addresses that aren't supposed to be translated in
	 * the first place. --BenH.
	 *//*
	 * We should always have matched the default bus at least, since
	 * it has a NULL match field. If we didn't then it somehow isn't
	 * in the of_busses array or something equally catastrophic has
	 * gone wrong.
	 *//* CONFIG_OF_ISA_BUS *//* ISA *//* Array of bus specific translators *//* Check address type match *//* ISA bus translator *//* Default translator (generic bus) *//**
 * struct of_bus - Callbacks for bus specific translators
 * @name:	A string used to identify this bus in debug output.
 * @addresses:	The name of the DT property from which addresses are
 *		to be read, typically "reg".
 * @match:	Return non-zero if the node whose parent is at
 *		parentoffset in the FDT blob corresponds to a bus
 *		of this type, otherwise return zero. If NULL a match
 *		is assumed.
 * @count_cells:Count how many cells (be32 values) a node whose parent
 *		is at parentoffset in the FDT blob will require to
 *		represent its address (written to *addrc) & size
 *		(written to *sizec).
 * @map:	Map the address addr from the address space of this
 *		bus to that of its parent, making use of the ranges
 *		read from DT to an array at range. na and ns are the
 *		number of cells (be32 values) used to hold and address
 *		or size, respectively, for this bus. pna is the number
 *		of cells used to hold an address for the parent bus.
 *		Returns the address in the address space of the parent
 *		bus.
 * @translate:	Update the value of the address cells at addr within an
 *		FDT by adding offset to it. na specifies the number of
 *		cells used to hold the address being translated. Returns
 *		zero on success, non-zero on error.
 *
 * Each bus type will include a struct of_bus in the of_busses array,
 * providing implementations of some or all of the functions used to
 * match the bus & handle address translation for its children.
 *//* Debug utility *//* Max address size we deal with *//* Jump to next flash node *//* return on error *//*
 * Update partitions in nor/nand nodes using info from
 * mtdparts environment variable. The nodes to update are
 * specified by node_info structure which contains mtd device
 * type and compatible string: E. g. the board code in
 * ft_board_setup() could use:
 *
 *	struct node_info nodes[] = {
 *		{ "fsl,mpc5121-nfc",    MTD_DEV_TYPE_NAND, },
 *		{ "cfi-flash",          MTD_DEV_TYPE_NOR,  },
 *	};
 *
 *	fdt_fixup_mtdparts(blob, nodes, ARRAY_SIZE(nodes));
 *//* Check MTD_WRITEABLE_CMD flag *//*
	 * Check if it is nand {}; subnode, adjust
	 * the offset in this case
	 *//*
	 * Check if size/address is 1 or 2 cells.
	 * We assume #address-cells and #size-cells have same value.
	 *//*
			 * Could not find label property, nand {}; node?
			 * Check subnode, delete partitions there if any.
			 *//* Open in place with a new len *//* skip if !PCI_REGION_SYS_MEMORY *//* sized based on pci addr cells, size-cells, & address-cells *//* Add the new reservation *//* Change the fdt header to reflect the correct size *//* Make it so the fdt ends on a page boundary *//*
	 * Calculate the actual size of the fdt
	 * plus the size needed for 5 fdt_add_mem_rsv, one
	 * for the fdt itself and 4 for a possible initrd
	 * ((initrd-start + initrd-end) * 2 (name & value))
	 *//* Resize the fdt to its actual size + a bit of padding *//*
	 * We record these as 32bit entities, possibly truncating addresses.
	 * However, spl_fit.c is not 64bit safe either: i.e. we should not
	 * have an issue here.
	 *//* find or create "/fit-images/<name>" node *//* find or create "/fit-images" node *//* Treat plain "ethernet" same as "ethernet0". *//* Select property number 'prop' *//* FDT might have been edited, recompute the offset *//* Cycle through all aliases *//* find or create "/memory" node. *//* Up to 64-bit address + 64-bit size *//*
 * fdt_pack_reg - pack address and size array into the "reg"-suitable stream
 *//* find or create "/chosen" node. *//* used to set string properties *//*
	 * Look for an existing entry and update it.  If we don't find
	 * the entry, we will j be the next available slot.
	 *//* just return if the size of initrd is zero *//* fdt_setprop may break "path" so we copy it to tmp buffer *//* long enough *//* rename to CONFIG_OF_STDOUT_PATH ? *//**
 * fdt_find_or_add_subnode() - find or possibly add a subnode of a given node
 *
 * @fdt: pointer to the device tree blob
 * @parentoffset: structure block offset of a node
 * @name: name of the subnode to locate
 *
 * fdt_subnode_offset() finds a subnode of the node with a given name.
 * If the subnode does not exist, it will be created.
 *//* create flag not set; so exit quietly *//**
 * fdt_find_and_setprop: Find a node and set it's property
 *
 * @fdt: ptr to device tree
 * @node: path of node
 * @prop: property name
 * @val: ptr to new value
 * @len: length of new property value
 * @create: flag to create the property if it doesn't exist
 *
 * Convenience function to directly set a property given the path to the node.
 *//**
 * fdt_getprop_u32_default - Find a node and return it's property or a default
 *
 * @fdt: ptr to device tree
 * @path: path of node
 * @prop: property name
 * @dflt: default value if the property isn't found
 *
 * Convenience function to find a node and return it's property or a
 * default value if it doesn't exist.
 *//* Check if property is long enough *//* Check if property exists *//**
 * fdt_getprop_u32_default_node - Return a node's property or a default
 *
 * @fdt: ptr to device tree
 * @off: offset of node
 * @cell: cell offset in property
 * @prop: property name
 * @dflt: default value if the property isn't found
 *
 * Convenience function to return a node's property or a default value if
 * the property doesn't exist.
 *//*
 * (C) Copyright 2007
 * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com
 *
 * Copyright 2010-2011 Freescale Semiconductor, Inc.
 *//opt/src/include/hw_sha.hhw_shahw_sha_finishhash_algo *hw_sha_updatehw_sha_inithw_sha1const uchar *hw_sha256__HW_SHA_H/*
 * Copy sha hash result at destination location
 *
 * The context is freed after completion of hash operation or after an error.
 *
 * @algo: Pointer to the hash_algo struct
 * @ctx: Pointer to the context for hashing
 * @dest_buf: Pointer to the destination buffer where hash is to be copied
 * @size: Size of the buffer being hashed
 * @return 0 if ok, -ve on error
 *//*
 * Update buffer for sha progressive hashing using h/w acceleration
 *
 * The context is freed by this function if an error occurs.
 *
 * @algo: Pointer to the hash_algo struct
 * @ctx: Pointer to the context for hashing
 * @buf: Pointer to the buffer being hashed
 * @size: Size of the buffer being hashed
 * @is_last: 1 if this is the last update; 0 otherwise
 * @return 0 if ok, -ve on error
 *//*
 * Create the context for sha progressive hashing using h/w acceleration
 *
 * @algo: Pointer to the hash_algo struct
 * @ctxp: Pointer to the pointer of the context for hashing
 * @return 0 if ok, -ve on error
 *//**
 * Computes hash value of input pbuf using h/w acceleration
 *
 * @param in_addr	A pointer to the input buffer
 * @param bufleni	Byte length of input buffer
 * @param out_addr	A pointer to the output buffer. When complete
 *			32 bytes are copied to pout[0]...pout[31]. Thus, a user
 *			should allocate at least 32 bytes at pOut in advance.
 * @param chunk_size	chunk_size for sha1
 *//**
 * Computes hash value of input pbuf using h/w acceleration
 *
 * @param in_addr	A pointer to the input buffer
 * @param bufleni	Byte length of input buffer
 * @param out_addr	A pointer to the output buffer. When complete
 *			32 bytes are copied to pout[0]...pout[31]. Thus, a user
 *			should allocate at least 32 bytes at pOut in advance.
 * @param chunk_size	chunk size for sha256
 *//*
 * Header file for SHA hardware acceleration
 *
 * Copyright (c) 2012  Samsung Electronics
 */dest_bufis_lastctxpout_addrchunk_size/opt/src/common/hash.chash_commandmulti_hash()HASH_MAX_DIGEST_SIZEvsumhash_algo **Unknown hash algorithm '%s'
"Unknown hash algorithm '%s'\n"HASH_MAX_DIGEST_SIZE exceeded
"HASH_MAX_DIGEST_SIZE exceeded\n"sizeof(uint32_t) * HASH_MAX_DIGEST_SIZEERROR: %s does not contain a valid %s sum
"ERROR: %s does not contain a valid "
					"%s sum\n" != " != " ** ERROR **
" ** ERROR **\n"CHUNKSZ_CRC32CRC32 for %08lx ... %08lx ==> %08lx
"CRC32 for %08lx ... %08lx ==> %08lx\n"hash_show%s for %08lx ... %08lx ==> "%s for %08lx ... %08lx ==> "parse_verify_sumvsum_strdigits<u-boot/sha1.h><hw_sha.h>algo_nameverify_strallow_env_varsExpected %d hex digits in env var
"Expected %d hex digits in env var\n"HASH_MAX_DIGEST_SIZE * 2HASH_MAX_DIGEST_SIZE * 2 + 1hash_block"Output buffer size %d too small (need %d bytes)"*output_size, algo->digest_sizedebug("Output buffer size %d too small (need %d bytes)",
		      *output_size, algo->digest_size)common/hash.cOutput buffer size %d too small (need %d bytes)hash_parse_stringchrhash_progressive_lookup_algohash_algo[4]ARRAY_SIZE(hash_algo)debug("Unknown hash algorithm '%s'\n", algo_name)const char[29]EPROTONOSUPPORThash_lookup_algooutput_sizealgophash_finish_crc32hash_update_crc32hash_init_crc32hash_finish_crc16_ccitthash_update_crc16_ccitthash_init_crc16_ccitthash_finish_sha256sha256_context *hash_update_sha256hash_init_sha256sizeof(sha256_context)hash_finish_sha1sha1_context *hash_update_sha1hash_init_sha1sizeof(sha1_context)hash_algo[]sha1"sha1"SHA1_SUM_LENCHUNKSZ_SHA1sha256"sha256"SHA256_SUM_LENCHUNKSZ_SHA256crc16-ccitt"crc16-ccitt"defined(CONFIG_SHA1) && !defined(CONFIG_SHA_PROG_HW_ACCEL)defined(CONFIG_SHA256) && !defined(CONFIG_SHA_PROG_HW_ACCEL)CONFIG_SHA1CONFIG_SHA_HW_ACCELCONFIG_SHA_PROG_HW_ACCELCONFIG_SHA256defined(CONFIG_SHA256) || defined(CONFIG_CMD_SHA1SUM) || \defined(CONFIG_CMD_HASH) || defined(CONFIG_CMD_SHA1SUM) || defined(CONFIG_CMD_CRC32)defined(CONFIG_CRC32_VERIFY) || defined(CONFIG_SHA1SUM_VERIFY) || \/* CONFIG_CMD_HASH || CONFIG_CMD_SHA1SUM || CONFIG_CMD_CRC32) *//* Horrible code size hack for boards that just want crc32 *//* Try to avoid code bloat when verify is not needed *//*
		 * As with the original code from sha1sum.c, we assume that a
		 * string which matches the digest size exactly is a hex
		 * string and not an environment variable.
		 *//* See comment above in store_result() *//**
 * parse_verify_sum: Parse a hash verification parameter
 *
 * @algo:		Hash algorithm being used
 * @verify_str:		Argument to parse. If it starts with * then it is
 *			interpreted as a hex address containing the hash.
 *			If the length is exactly the right number of hex digits
 *			for the digest size, then we assume it is a hex digest.
 *			Otherwise we assume it is an environment variable, and
 *			look up its value (it must contain a hex digest).
 * @vsum:		Returns binary digest value (algo->digest_size bytes)
 * @allow_env_vars:	non-zero to permit storing the result to an environment
 *			variable. If 0 then verify_str is assumed to be an
 *			address, and the * prefix is not expected.
 * @return 0 if ok, non-zero on error
 *//*
	 * If environment variables are allowed, then we assume that 'dest'
	 * is an environment variable, unless it starts with *, in which
	 * case we assume it is an address. If not allowed, it is always an
	 * address. This is to support the crc32 command.
	 *//**
 * store_result: Store the resulting sum to an address or variable
 *
 * @algo:		Hash algorithm being used
 * @sum:		Hash digest (algo->digest_size bytes)
 * @dest:		Destination, interpreted as a hex address if it starts
 *			with * (or allow_env_vars is 0) or otherwise as an
 *			environment variable.
 * @allow_env_vars:	non-zero to permit storing the result to an
 *			variable environment
 *//* Try to minimize code size for boards that don't want much hashing *//*
 * These are the hash algorithms we support.  If we have hardware acceleration
 * is enable we will use that, otherwise a software version of the algorithm.
 * Note that algorithm names must be in lower case.
 *//* !USE_HOSTCC*/fit_find_config_nodefdt_getprop_u32board_fit_config_name_matchfit_image_check_target_archimage_region *fit_region_make_listfdt_region *fit_image_check_sigfit_image_verify_required_sigspadding_algo *image_get_padding_algocrypto_algo *image_get_crypto_algochecksum_algo *image_get_checksum_algocalculate_hashfit_check_ramdiskfit_conf_get_prop_nodefit_conf_get_prop_node_indexfit_conf_get_prop_node_countfit_conf_get_nodefit_conf_find_compatfit_check_formatfit_image_check_compfit_image_check_typefit_image_check_archfit_image_check_osfit_all_image_verifyfit_config_verifyfit_image_verifyfit_image_verify_with_datafit_add_verification_datafit_set_timestampfit_image_hash_get_valuefit_image_hash_get_algofit_image_get_data_and_sizefit_image_get_data_sizefit_image_get_data_positionfit_image_get_data_offsetfit_image_get_datafit_image_get_entryfit_image_get_loadfit_image_get_compfit_image_get_typefit_image_get_archfit_image_get_osfit_image_get_nodefit_get_timestampfit_get_descfit_get_namefit_get_endfit_get_size((const struct fdt_header *)(fit))->totalsize(__force __u32)(__be32)(((const struct fdt_header *)(fit))->totalsize)(__u32)(__be32)(((const struct fdt_header *)(fit))->totalsize)((__u32)(__be32)(((const struct fdt_header *)(fit))->totalsize))fdt_totalsize(fit)fit_image_printfit_print_contentsfit_get_subimage_countfit_parse_subimagefit_parse_confbooti_setupimage_setup_linuximage_setup_libfdtimage_decompimage_check_target_archimage_print_contentsimage_multi_getimgimage_multi_countimage_check_osimage_check_archIH_ARCH_ARMimage_check_typeimage_check_magic654645590IH_MAGICmemmove_wdenv_get_bootm_mapsizeenv_get_bootm_sizeenv_get_bootm_lowimage_check_dcrcimage_check_hcrcimage_set_nameIH_NMLENimage_set_compimage_set_typeimage_set_archimage_set_osimage_set_dcrcdcrcimage_set_hdr_l(dcrc)image_set_epimage_set_hdr_l(ep)<u-boot/rsa-checksum.h>image_set_loadimage_set_hdr_l(load)image_set_sizeimage_set_hdr_l(size)image_set_timeimage_set_hdr_l(time)image_set_hcrcimage_set_hdr_l(hcrc)image_set_magicimage_set_hdr_l(magic)image_get_image_endimage_get_image_sizeimage_get_dataimage_get_data_sizeimage_get_nameimage_get_compimage_get_typeimage_get_archimage_get_osimage_get_dcrchdr->ih_dcrc(__force __u32)(__be32)(hdr->ih_dcrc)(__u32)(__be32)(hdr->ih_dcrc)((__u32)(__be32)(hdr->ih_dcrc))image_get_hdr_l(dcrc)image_get_ephdr->ih_ep(__force __u32)(__be32)(hdr->ih_ep)(__u32)(__be32)(hdr->ih_ep)((__u32)(__be32)(hdr->ih_ep))image_get_hdr_l(ep)image_get_loadhdr->ih_load(__force __u32)(__be32)(hdr->ih_load)(__u32)(__be32)(hdr->ih_load)((__u32)(__be32)(hdr->ih_load))image_get_hdr_l(load)image_get_sizehdr->ih_size(__force __u32)(__be32)(hdr->ih_size)(__u32)(__be32)(hdr->ih_size)((__u32)(__be32)(hdr->ih_size))image_get_hdr_l(size)image_get_timehdr->ih_time(__force __u32)(__be32)(hdr->ih_time)(__u32)(__be32)(hdr->ih_time)((__u32)(__be32)(hdr->ih_time))image_get_hdr_l(time)image_get_hcrchdr->ih_hcrc(__force __u32)(__be32)(hdr->ih_hcrc)(__u32)(__be32)(hdr->ih_hcrc)((__u32)(__be32)(hdr->ih_hcrc))image_get_hdr_l(hcrc)image_get_magichdr->ih_magic(__force __u32)(__be32)(hdr->ih_magic)(__u32)(__be32)(hdr->ih_magic)((__u32)(__be32)(hdr->ih_magic))image_get_hdr_l(magic)image_get_header_sizesizeof(image_header_t)(sizeof(image_header_t))boot_get_cmdlineboot_ramdisk_highboot_relocate_fdtboot_fdt_add_mem_rsv_regionsboot_get_fdtfit_get_node_from_configfit_image_loadboot_get_fdt_fitboot_get_setup_fitboot_get_loadableboot_get_ramdiskboot_get_fpgagenimg_has_configgenimg_get_formatgenimg_get_kernel_addrgenimg_get_kernel_addr_fitboot_get_setupgenimg_print_timegenimg_print_sizegenimg_get_comp_idgenimg_get_type_idgenimg_get_arch_idgenimg_get_os_idgenimg_get_cat_descgenimg_get_cat_countgenimg_get_cat_short_namegenimg_get_cat_namegenimg_get_comp_short_namegenimg_get_comp_namegenimg_get_type_short_namegenimg_get_type_namegenimg_get_arch_short_namegenimg_get_arch_namegenimg_get_os_short_namegenimg_get_os_nameget_table_entry_nameconst table_entry_tconst table_entry_t *table_entry *get_table_entry_idfit_loadable_tblimage_sign_infocrypto_algopadding_algochecksum_algoimage_regionfit_load_opFIT_LOAD_OPTIONALFIT_LOAD_OPTIONAL_NON_ZEROFIT_LOAD_REQUIREDtable_entry_ttable_entrybootm_headers_tbootm_headersimage_info_timage_header_timage_headerIH_COMP_BZIP2IH_COMP_LZMAIH_COMP_LZOIH_COMP_LZ4IH_COMP_COUNTIH_TYPE_INVALIDIH_TYPE_RAMDISKIH_TYPE_FIRMWAREIH_TYPE_FILESYSTEMIH_TYPE_FLATDTIH_TYPE_KWBIMAGEIH_TYPE_IMXIMAGEIH_TYPE_UBLIMAGEIH_TYPE_OMAPIMAGEIH_TYPE_AISIMAGEIH_TYPE_PBLIMAGEIH_TYPE_MXSIMAGEIH_TYPE_GPIMAGEIH_TYPE_ATMELIMAGEIH_TYPE_SOCFPGAIMAGEIH_TYPE_X86_SETUPIH_TYPE_LPC32XXIMAGEIH_TYPE_LOADABLEIH_TYPE_RKIMAGEIH_TYPE_RKSDIH_TYPE_RKSPIIH_TYPE_ZYNQIMAGEIH_TYPE_ZYNQMPIMAGEIH_TYPE_ZYNQMPBIFIH_TYPE_FPGAIH_TYPE_VYBRIDIMAGEIH_TYPE_TEEIH_TYPE_FIRMWARE_IVTIH_TYPE_PMMCIH_TYPE_STM32IMAGEIH_TYPE_SOCFPGAIMAGE_V1IH_TYPE_MTKIMAGEIH_TYPE_IMX8MIMAGEIH_TYPE_IMX8IMAGEIH_TYPE_COUNTIH_ARCH_INVALIDIH_ARCH_ALPHAIH_ARCH_IA64IH_ARCH_MIPSIH_ARCH_MIPS64IH_ARCH_PPCIH_ARCH_S390IH_ARCH_SHIH_ARCH_SPARCIH_ARCH_SPARC64IH_ARCH_M68KIH_ARCH_NIOSIH_ARCH_MICROBLAZEIH_ARCH_NIOS2IH_ARCH_BLACKFINIH_ARCH_AVR32IH_ARCH_ST200IH_ARCH_SANDBOXIH_ARCH_NDS32IH_ARCH_OPENRISCIH_ARCH_ARCIH_ARCH_XTENSAIH_ARCH_RISCVIH_ARCH_COUNTIH_OS_INVALIDIH_OS_OPENBSDIH_OS_NETBSDIH_OS_FREEBSDIH_OS_4_4BSDIH_OS_SVR4IH_OS_ESIXIH_OS_SOLARISIH_OS_IRIXIH_OS_SCOIH_OS_DELLIH_OS_NCRIH_OS_LYNXOSIH_OS_PSOSIH_OS_QNXIH_OS_U_BOOTIH_OS_RTEMSIH_OS_ARTOSIH_OS_UNITYIH_OS_INTEGRITYIH_OS_OSEIH_OS_PLAN9IH_OS_OPENRTOSIH_OS_ARM_TRUSTED_FIRMWAREIH_OS_TEEIH_OS_COUNTih_categoryIH_ARCHIH_COMPIH_OSIH_TYPEIH_COUNTengine_idrequire_keysrequired_keynodecryptoimage_sign_info *const image_regionconst image_region *add_verify_datakey_lender_prefixder_lenchecksum_lenkeynamekeydirlnamesnamelmbkbdcmdline_endcmdline_startft_lenft_addrrd_endrd_startfit_noffset_setupfit_uname_setupfit_hdr_setupfit_noffset_fdtfit_uname_fdtfit_hdr_fdtfit_noffset_rdfit_uname_rdfit_hdr_rdfit_noffset_osfit_uname_osfit_hdr_osfit_uname_cfglegacy_hdr_validlegacy_hdr_os_copylegacy_hdr_osih_nameih_compih_typeih_archih_osih_dcrcih_epih_loadih_sizeih_timeih_hcrcih_magicU_BOOT_FIT_LOADABLE_HANDLER(_type,_handler)ll_entry_declare(struct fit_loadable_tbl, _function, fit_loadable) = { .type = _type, .handler = _handler, }FDT_ERROR((ulong)(-1))fit_unsupported_reset(msg)printf("! %s:%d " "FIT images not supported for '%s' " "- must reset board to recover!\n", __FILE__, __LINE__, (msg))fit_unsupported(msg)printf("! %s:%d " "FIT images not supported for '%s'\n", __FILE__, __LINE__, (msg))IMAGE_ENABLE_BEST_MATCHgd_fdt_blob()(gd->fdt_blob)IMAGE_ENABLE_VERIFYCONFIG_IS_ENABLED(FIT_SIGNATURE)IMAGE_ENABLE_SIGNFIT_MAX_HASH_LENFIT_STANDALONE_PROP"standalone"FIT_FIRMWARE_PROP"firmware"FIT_FPGA_PROP"fpga"FIT_SETUP_PROP"setup"FIT_LOADABLE_PROP"loadables"FIT_FDT_PROPFIT_RAMDISK_PROP"ramdisk"FIT_KERNEL_PROPFIT_LOAD_PROPFIT_ENTRY_PROP"entry"FIT_COMP_PROP"compression"FIT_OS_PROPFIT_TYPE_PROPFIT_ARCH_PROP"arch"FIT_DESC_PROP"description"FIT_TIMESTAMP_PROP"timestamp"FIT_DATA_SIZE_PROP"data-size"FIT_DATA_OFFSET_PROP"data-offset"FIT_DATA_POSITION_PROP"data-position"FIT_DATA_PROP"data"FIT_SIG_NODENAME"signature"FIT_IGNORE_PROP"uboot-ignore"FIT_VALUE_PROP"value"FIT_ALGO_PROP"algo"FIT_HASH_NODENAMEFIT_CONFS_PATH"/configurations""/images"image_set_hdr_b(f)static inline void image_set_ ## f(image_header_t *hdr, uint8_t val) { hdr->ih_ ## f = val; }image_set_hdr_l(f)static inline void image_set_ ## f(image_header_t *hdr, uint32_t val) { hdr->ih_ ## f = cpu_to_uimage(val); }image_get_hdr_b(f)static inline uint8_t image_get_ ## f(const image_header_t *hdr) { return hdr->ih_ ## f; }image_get_hdr_l(f)static inline uint32_t image_get_ ## f(const image_header_t *hdr) { return uimage_to_cpu(hdr->ih_ ## f); }IMAGE_ENABLE_TIMESTAMPcpu_to_uimage(x)cpu_to_be32(x)uimage_to_cpu(x)be32_to_cpu(x)(64 * 1024)(0x00000400)(0x00000200)(0x00000100)(0x00000080)(0x00000040)(0x00000020)BOOTM_STATE_RAMDISK(0x00000010)(0x00000008)(0x00000004)(0x00000002)(0x00000001)0x27051956LZ4F_MAGIC0x184D2204IMAGE_OF_SYSTEM_SETUPIMAGE_OF_BOARD_SETUPIMAGE_BOOT_GET_CMDLINEIMAGE_ENABLE_SHA256IMAGE_ENABLE_SHA1IMAGE_ENABLE_MD5IMAGE_ENABLE_CRC32CONFIG_IS_ENABLED(OF_LIBFDT)IMAGE_INDENT_STRINGIMAGE_ENABLE_IGNORE__IMAGE_H__CONFIG_SPL_CRC32_SUPPORTCONFIG_SPL_MD5_SUPPORTCONFIG_SPL_SHA1_SUPPORTdefined(CONFIG_FIT_ENABLE_SHA256_SUPPORT) || \CONFIG_SYS_BOOT_GET_CMDLINEdefined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || \CONFIG_SYS_BOOT_GET_KBDdefined(USE_HOSTCC)CONFIG_FIT_BEST_MATCHCONFIG_FIT_VERBOSEdefined(CONFIG_SPL_FIT_IMAGE_POST_PROCESS) || \android_print_contentsandroid_image_get_kcompandroid_image_get_kloadandroid_image_get_endandroid_image_get_secondandroid_image_get_ramdiskandroid_image_get_kernelandroid_image_check_headerandr_img_hdrfdt_regionFIT_SIGNATURECONFIG_VAL(FIT_SIGNATURE_MODULE)CONFIG_FIT_SIGNATURE_MODULE__ARG_PLACEHOLDER_CONFIG_FIT_SIGNATURE_MODULE__ARG_PLACEHOLDER_CONFIG_FIT_SIGNATURE_MODULE 1FIT_SIGNATURE_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_FIT_SIGNATURE_MODULECONFIG_VAL(FIT_SIGNATURE)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_FIT_SIGNATURECONFIG_FIT_SIGNATURE/* __IMAGE_H__ *//*
 * Define a FIT loadable image type handler
 *
 * _type is a valid uimage_type ID as defined in the "Image Type" enum above
 * _handler is the handler function to call after this image type is loaded
 *//**
	 * handler() - Process a loaded image
	 *
	 * @data: Pointer to start of loaded image data
	 * @size: Size of loaded image data
	 *//**
 * Mapping of image types to function handlers to be invoked on the associated
 * loaded images
 *
 * @type: Type of image, I.E. IH_TYPE_*
 * @handler: Function to call on loaded image
 *//**
 * fit_find_config_node() - Find the node for the best DTB in a FIT image
 *
 * A FIT image contains one or more DTBs. This function parses the
 * configurations described in the FIT images and returns the node of
 * the first matching DTB. To check if a DTB matches a board, this function
 * calls board_fit_config_name_match(). If no matching DTB is found, it returns
 * the node described by the default configuration if it exists.
 *
 * @fdt: pointer to flat device tree
 * @return the node if found, -ve otherwise
 *//* CONFIG_SPL_FIT_IMAGE_POST_PROCESS *//**
 * board_fit_image_post_process() - Do any post-process on FIT binary data
 *
 * This is used to do any sort of image manipulation, verification, decryption
 * etc. in a platform or board specific way. Obviously, anything done here would
 * need to be comprehended in how the images were prepared before being injected
 * into the FIT creation (i.e. the binary blobs would have been pre-processed
 * before being added to the FIT image).
 *
 * @image: pointer to the image start pointer
 * @size: pointer to the image size
 * @return no return value (failure should be handled internally)
 *//**
 * board_fit_config_name_match() - Check for a matching board name
 *
 * This is used when SPL loads a FIT containing multiple device tree files
 * and wants to work out which one to use. The description of each one is
 * passed to this function. The description comes from the 'description' field
 * in each (FDT) image node.
 *
 * @name: Device tree description
 * @return 0 if this device tree should be used, non-zero to try the next
 *//* CONFIG_ANDROID_BOOT_IMAGE *//* CONFIG_FIT *//* CONFIG_FIT_VERBOSE *//**
 * fit_region_make_list() - Make a list of regions to hash
 *
 * Given a list of FIT regions (offset, size) provided by libfdt, create
 * a list of regions (void *, size) for use by the signature creationg
 * and verification code.
 *
 * @fit:		FIT image to process
 * @fdt_regions:	Regions as returned by libfdt
 * @count:		Number of regions returned by libfdt
 * @region:		Place to put list of regions (NULL to allocate it)
 * @return pointer to list of regions, or NULL if out of memory
 *//**
 * fit_image_check_sig() - Check a single image signature node
 *
 * @fit:		FIT to check
 * @noffset:		Offset of signature node to check
 * @data:		Image data to check
 * @size:		Size of image data
 * @required_keynode:	Offset in the control FDT of the required key node,
 *			if any. If this is given, then the image wil not
 *			pass verification unless that key is used. If this is
 *			-1 then any signature will do.
 * @err_msgp:		In the event of an error, this will be pointed to a
 *			help error string to display to the user.
 * @return 0 if all verified ok, <0 on error
 *//**
 * fit_image_verify_required_sigs() - Verify signatures marked as 'required'
 *
 * @fit:		FIT to check
 * @image_noffset:	Offset of image node to check
 * @data:		Image data to check
 * @size:		Size of image data
 * @sig_blob:		FDT containing public keys
 * @no_sigsp:		Returns 1 if no signatures were required, and
 *			therefore nothing was checked. The caller may wish
 *			to fall back to other mechanisms, or refuse to
 *			boot.
 * @return 0 if all verified ok, <0 on error
 *//**
 * image_get_padding_algo() - Look up a padding algorithm
 *
 * @param name		Name of padding algorithm
 * @return pointer to algorithm information, or NULL if not found
 *//**
 * image_get_crypto_algo() - Look up a cryptosystem algorithm
 *
 * @param full_name	Name of algorithm in the form "checksum,crypto"
 * @return pointer to algorithm information, or NULL if not found
 *//**
 * image_get_checksum_algo() - Look up a checksum algorithm
 *
 * @param full_name	Name of algorithm in the form "checksum,crypto"
 * @return pointer to algorithm information, or NULL if not found
 *//**
	 * verify() - Verify a signature against some data
	 *
	 * @info:	Specifies key and FIT information
	 * @data:	Pointer to the input data
	 * @data_len:	Data length
	 * @sig:	Signature
	 * @sig_len:	Number of bytes in signature
	 * @return 0 if verified, -ve on error
	 *//**
	 * add_verify_data() - Add verification information to FDT
	 *
	 * Add public key information to the FDT node, suitable for
	 * verification at run-time. The information added depends on the
	 * algorithm being used.
	 *
	 * @info:	Specifies key and FIT information
	 * @keydest:	Destination FDT blob for public key data
	 * @return: 0, on success, -ve on error
	 *//**
	 * sign() - calculate and return signature for given input data
	 *
	 * @info:	Specifies key and FIT information
	 * @data:	Pointer to the input data
	 * @data_len:	Data length
	 * @sigp:	Set to an allocated buffer holding the signature
	 * @sig_len:	Set to length of the calculated hash
	 *
	 * This computes input data signature according to selected algorithm.
	 * Resulting signature value is placed in an allocated buffer, the
	 * pointer is returned as *sigp. The length of the calculated
	 * signature is returned via the sig_len pointer argument. The caller
	 * should free *sigp.
	 *
	 * @return: 0, on success, -ve on error
	 *//* Name of algorithm *//* A part of an image, used for hashing *//* Allow struct image_region to always be defined for rsa.h *//* Engine to use for signing *//* Value for 'required' property *//* Node offset of key to use: -1=any *//* FDT containing public keys *//* Crypto algorithm information *//* Padding algorithm information *//* Checksum algorithm information *//* Algorithm name *//* Offset of signature node *//* Pointer to FIT blob *//* Name of key to use *//* Directory conaining keys *//* Information passed to the signing routines *//*
 * At present we only support signing on the host, and verification on the
 * device
 *//**
 * fit_conf_get_prop_node() - Get node refered to by a configuration
 * @fit:	FIT to check
 * @noffset:	Offset of conf@xxx node to check
 * @prop_name:	Property to read from the conf node
 *
 * The conf- nodes contain references to other nodes, using properties
 * like 'kernel = "kernel"'. Given such a property name (e.g. "kernel"),
 * return the offset of the node referred to (e.g. offset of node
 * "/images/kernel".
 *//**
 * fit_add_verification_data() - add verification data to FIT image nodes
 *
 * @keydir:	Directory containing keys
 * @kwydest:	FDT blob to write public key information to
 * @fit:	Pointer to the FIT format image header
 * @comment:	Comment to add to signature nodes
 * @require_keys: Mark all keys as 'required'
 * @engine_id:	Engine to use for signing
 * @cmdname:	Command name used when reporting errors
 *
 * Adds hash values for all component images in the FIT blob.
 * Hashes are calculated for all component images which have hash subnodes
 * with algorithm property set to one of the supported hash algorithms.
 *
 * Also add signatures if signature nodes are present.
 *
 * returns
 *     0, on success
 *     libfdt error code, on failure
 *//**
 * fit_get_name - get FIT node name
 * @fit: pointer to the FIT format image header
 *
 * returns:
 *     NULL, on error
 *     pointer to node name, on success
 *//**
 * fit_get_end - get FIT image end
 * @fit: pointer to the FIT format image header
 *
 * returns:
 *     end address of the FIT image (blob) in memory
 *//**
 * fit_get_end - get FIT image size
 * @fit: pointer to the FIT format image header
 *
 * returns:
 *     size of the FIT image (blob) in memory
 *//* cmdline argument format parsing *//* configuration node *//* image node *//* hash/signature node *//* New uImage format specific code (prefixed with fit_) *//**
 * Return the correct start address and size of a Linux aarch64 Image.
 *
 * @image: Address of image
 * @start: Returns start address of image
 * @size : Returns size image
 * @force_reloc: Ignore image->ep field, always place image to RAM start
 * @return 0 if OK, 1 if the image was not recognised
 *//**
 * bootz_setup() - Extract stat and size of a Linux xImage
 *
 * @image: Address of image
 * @start: Returns start address of image
 * @end : Returns end address of image
 * @return 0 if OK, 1 if the image was not recognised
 *//**
 * Set up the FDT to use for booting a kernel
 *
 * This performs ramdisk setup, sets up the FDT if required, and adds
 * paramters to the FDT if libfdt is available.
 *
 * @param images	Images information
 * @return 0 if ok, <0 on failure
 *//**
 * Set up properties in the FDT
 *
 * This sets up properties in the FDT that is to be passed to linux.
 *
 * @images:	Images information
 * @blob:	FDT to update
 * @of_size:	Size of the FDT
 * @lmb:	Points to logical memory block structure
 * @return 0 if ok, <0 on failure
 *//**
 * image_decomp() - decompress an image
 *
 * @comp:	Compression algorithm that is used (IH_COMP_...)
 * @load:	Destination load address in U-Boot memory
 * @image_start Image start address (where we are decompressing from)
 * @type:	OS type (IH_OS_...)
 * @load_bug:	Place to decompress to
 * @image_buf:	Address to decompress from
 * @image_len:	Number of bytes in @image_buf to decompress
 * @unc_len:	Available space for decompression
 * @return 0 if OK, -ve on error (BOOTM_ERR_...)
 *//* image_set_comp *//* image_set_type *//* image_set_arch *//* image_set_os *//* image_set_dcrc *//* image_set_ep *//* image_set_load *//* image_set_size *//* image_set_time *//* image_set_hcrc *//* image_set_magic *//**
 * image_get_data - get image payload start address
 * @hdr: image header
 *
 * image_get_data() returns address of the image payload. For single
 * component images it is image data start. For multi component
 * images it points to the null terminated table of sub-images sizes.
 *
 * returns:
 *     image payload data start address
 *//* image_get_comp *//* image_get_type *//* image_get_arch *//* image_get_os *//* image_get_dcrc *//* image_get_ep *//* image_get_load *//* image_get_size *//* image_get_time *//* image_get_hcrc *//* image_get_magic *//* Legacy format specific code (prefixed with image_) *//* CONFIG_SYS_BOOT_GET_KBD *//**
 * fit_get_node_from_config() - Look up an image a FIT by type
 *
 * This looks in the selected conf- node (images->fit_uname_cfg) for a
 * particular image type (e.g. "kernel") and then finds the image that is
 * referred to.
 *
 * For example, for something like:
 *
 * images {
 *	kernel {
 *		...
 *	};
 * };
 * configurations {
 *	conf-1 {
 *		kernel = "kernel";
 *	};
 * };
 *
 * the function will return the node offset of the kernel@1 node, assuming
 * that conf-1 is the chosen configuration.
 *
 * @param images	Boot images structure
 * @param prop_name	Property name to look up (FIT_..._PROP)
 * @param addr		Address of FIT in memory
 *//**
 * fit_image_load() - load an image from a FIT
 *
 * This deals with all aspects of loading an image from a FIT, including
 * selecting the right image based on configuration, verifying it, printing
 * out progress messages, checking the type/arch/os and optionally copying it
 * to the right load address.
 *
 * The property to look up is defined by image_type.
 *
 * @param images	Boot images structure
 * @param addr		Address of FIT in memory
 * @param fit_unamep	On entry this is the requested image name
 *			(e.g. "kernel") or NULL to use the default. On exit
 *			points to the selected image name
 * @param fit_uname_configp	On entry this is the requested configuration
 *			name (e.g. "conf-1") or NULL to use the default. On
 *			exit points to the selected configuration name.
 * @param arch		Expected architecture (IH_ARCH_...)
 * @param image_type	Required image type (IH_TYPE_...). If this is
 *			IH_TYPE_KERNEL then we allow IH_TYPE_KERNEL_NOLOAD
 *			also.
 * @param bootstage_id	ID of starting bootstage to use for progress updates.
 *			This will be added to the BOOTSTAGE_SUB values when
 *			calling bootstage_mark()
 * @param load_op	Decribes what to do with the load address
 * @param datap		Returns address of loaded image
 * @param lenp		Returns length of loaded image
 * @return node offset of image, or -ve error code on error
 *//**
 * boot_get_fdt_fit() - load a DTB from a FIT file (applying overlays)
 *
 * This deals with all aspects of loading an DTB from a FIT.
 * The correct base image based on configuration will be selected, and
 * then any overlays specified will be applied (as present in fit_uname_configp).
 *
 * @param images	Boot images structure
 * @param addr		Address of FIT in memory
 * @param fit_unamep	On entry this is the requested image name
 *			(e.g. "kernel") or NULL to use the default. On exit
 *			points to the selected image name
 * @param fit_uname_configp	On entry this is the requested configuration
 *			name (e.g. "conf-1") or NULL to use the default. On
 *			exit points to the selected configuration name.
 * @param arch		Expected architecture (IH_ARCH_...)
 * @param datap		Returns address of loaded image
 * @param lenp		Returns length of loaded image
 *
 * @return node offset of base image, or -ve error code on error
 *//**
 * boot_get_loadable - routine to load a list of binaries to memory
 * @argc: Ignored Argument
 * @argv: Ignored Argument
 * @images: pointer to the bootm images structure
 * @arch: expected architecture for the image
 * @ld_start: Ignored Argument
 * @ld_len: Ignored Argument
 *
 * boot_get_loadable() will take the given FIT configuration, and look
 * for a field named "loadables".  Loadables, is a list of elements in
 * the FIT given as strings.  exe:
 *   loadables = "linux_kernel", "fdt-2";
 * this function will attempt to parse each string, and load the
 * corresponding element from the FIT into memory.  Once placed,
 * no aditional actions are taken.
 *
 * @return:
 *     0, if only valid images or no images are found
 *     error code, if an error occurs during fit_image_load
 *//* Android boot image *//* new, libfdt based format *//* legacy image_header based format *//* Image format types, returned by _get_format() routine *//* Must be provided *//* Optional, a value of 0 is ignored *//* Can be provided, but optional *//* Ignore load address *//* What to do with a image load address ('load = <> 'in the FIT) *//**
 * genimg_get_cat_desc() - Get the description of a category
 *
 * @return the description of a category, e.g. "architecture". This
 * effectively converts the enum to a string.
 *//**
 * genimg_get_cat_count() - Get the number of items in a category
 *
 * @category:	Category to check
 * @return the number of items in the category (IH_xxx_COUNT)
 *//**
 * genimg_get_cat_short_name() - Get the short name of an item in a category
 *
 * @category:	Category of item
 * @id:		Item ID
 * @return short name of item, or "Unknown ..." if unknown
 *//**
 * genimg_get_cat_name() - Get the name of an item in a category
 *
 * @category:	Category of item
 * @id:		Item ID
 * @return name of item, or "Unknown ..." if unknown
 *//**
 * genimg_get_comp_short_name() - get the short name for a compression method
 *
 * @param comp	compression method (IH_COMP_...)
 * @return compression method short name, or "unknown" if unknown
 *//**
 * genimg_get_type_short_name() - get the short name for an image type
 *
 * @param type	Image type (IH_TYPE_...)
 * @return image short name, or "unknown" if unknown
 *//**
 * genimg_get_arch_short_name() - get the short name for an architecture
 *
 * @param arch	Architecture type (IH_ARCH_...)
 * @return architecture short name, or "unknown" if unknown
 *//**
 * genimg_get_os_short_name() - get the short name for an OS
 *
 * @param os	OS (IH_OS_...)
 * @return OS short name, or "unknown" if unknown
 *//*
 * get_table_entry_name() scans the translation table trying to find
 * an entry that matches the given id. If a matching entry is found,
 * its long name is returned to the caller.
 *//*
 * get_table_entry_id() scans the translation table trying to find an
 * entry that matches the given short name. If a matching entry is
 * found, it's id is returned to the caller.
 *//* long (output) name to print for messages *//* short (input) name to find table entry *//*
 * Translation table for entries of a specific type; used by
 * get_table_entry_id() and get_table_entry_name().
 *//*
 * Some systems (for example LWMON) have very short watchdog periods;
 * we must make sure to split long operations like memmove() or
 * checksum calculations into reasonable chunks.
 *//* for memory mgmt *//* 'Almost' run the OS *//* env_get("verify")[0] != 'n' *//* length of flat device tree *//* flat dev tree address *//* ramdisk start/end *//* entry point of OS *//* os image info *//* x86 setup subimage node offset *//* x86 setup subimage node name *//* x86 setup FIT image header *//* FDT blob subimage node offset *//* FDT blob subimage node unit name *//* FDT blob FIT image header *//* init ramdisk subimage node offset *//* init ramdisk subimage node unit name *//* init ramdisk FIT image header *//* os subimage node offset *//* os subimage node unit name *//* os FIT image header *//* configuration node unit name *//* header copy *//* image header pointer *//*
	 * Legacy os image header, if it is a multi component image
	 * then boot_get_ramdisk() and get_fdt() will attempt to get
	 * data from second and third component accordingly.
	 *//*
 * Legacy and FIT format headers used by do_bootm() and do_bootm_<os>()
 * routines.
 *//* CPU architecture *//* compression, type of image, os type *//* load addr for the image *//* start of image within blob, len of image *//* start/end of blob *//* Image Name		*//* Compression Type		*//* Image Type			*//* CPU architecture		*//* Operating System		*//* Image Data CRC Checksum	*//* Entry Point Address		*//* Data	 Load  Address		*//* Image Data Size		*//* Image Creation Timestamp	*//* Image Header CRC Checksum	*//* Image Header Magic Number	*//*
 * Legacy format image header,
 * all data in network byte order (aka natural aka bigendian).
 *//* Reused from common.h *//* Image Name Length		*//* Image Magic Number		*//* LZ4 Magic Number		*//* lz4   Compression Used	*//* lzo   Compression Used	*//* lzma  Compression Used	*//* bzip2 Compression Used	*//* gzip	 Compression Used	*//*  No	 Compression Used	*//*
 * Compression Types
 *
 * The following are exposed to uImage header.
 * New IDs *MUST* be appended at the end of the list and *NEVER*
 * inserted for backward compatibility.
 *//* Number of image types *//* Freescale IMX8Boot Image	*//* Freescale IMX8MBoot Image	*//* MediaTek BootROM loadable Image *//* Altera SOCFPGA A10 Preloader	*//* STMicroelectronics STM32 Image *//* TI Power Management Micro-Controller Firmware *//* Firmware Image with HABv4 IVT *//* Trusted Execution Environment OS Image *//* VYBRID .vyb Image *//* FPGA Image *//* Xilinx ZynqMP Boot Image (bif) *//* Xilinx ZynqMP Boot Image *//* Xilinx Zynq Boot Image *//* Rockchip SPI image		*//* Rockchip SD card		*//* Rockchip Boot Image		*//* A list of typeless images	*//* x86 setup.bin Image		*//* Altera SOCFPGA CV/AV Preloader *//* ATMEL ROM bootable Image	*//* TI Keystone GPHeader Image	*//* Freescale MXSBoot Image	*//* Freescale PBL Boot Image	*//* OS Kernel Image, can run from any load address *//* TI Davinci AIS Image		*//* TI OMAP Config Header Image	*//* Davinci UBL Image		*//* Freescale IMXBoot Image	*//* Kirkwood Boot Image		*//* Binary Flat Device Tree Blob	*//* Filesystem Image (any type)	*//* Script file			*//* Firmware Image		*//* Multi-File Image		*//* RAMDisk Image		*//* OS Kernel Image		*//* Standalone Program		*//* Invalid Image		*//*
 * Image Types
 *
 * "Standalone Programs" are directly runnable in the environment
 *	provided by U-Boot; it is expected that (if they behave
 *	well) you can continue to work in U-Boot after return from
 *	the Standalone Program.
 * "OS Kernel Images" are usually images of some Embedded OS which
 *	will take over control completely. Usually these programs
 *	will install their own set of exception handlers, device
 *	drivers, set up the MMU, etc. - this means, that you cannot
 *	expect to re-enter U-Boot except by resetting the CPU.
 * "RAMDisk Images" are more or less just data blocks, and their
 *	parameters (address, size) are passed to an OS kernel that is
 *	being started.
 * "Multi-File Images" contain several images, typically an OS
 *	(Linux) kernel image and one or more data images like
 *	RAMDisks. This construct is useful for instance when you want
 *	to boot over the network using BOOTP etc., where the boot
 *	server provides just a single image file, but you want to get
 *	for instance an OS kernel and a RAMDisk image.
 *
 *	"Multi-File Images" start with a list of image sizes, each
 *	image size (in bytes) specified by an "uint32_t" in network
 *	byte order. This list is terminated by an "(uint32_t)0".
 *	Immediately after the terminating 0 follow the images, one by
 *	one, all aligned on "uint32_t" boundaries (size rounded up to
 *	a multiple of 4 bytes - except for the last file).
 *
 * "Firmware Images" are binary images containing firmware (like
 *	U-Boot or FPGA images) which usually will be programmed to
 *	flash memory.
 *
 * "Script files" are command sequences that will be executed by
 *	U-Boot's command interpreter; this feature is especially
 *	useful when you configure U-Boot to use a real shell (hush)
 *	as command interpreter (=> Shell Scripts).
 *
 * The following are exposed to uImage header.
 * New IDs *MUST* be appended at the end of the list and *NEVER*
 * inserted for backward compatibility.
 *//* RISC-V *//* Xtensa	*//* AMD x86_64, Intel and Via *//* Synopsys DesignWare ARC *//* ARM64	*//* OpenRISC 1000  *//* ANDES Technology - NDS32  *//* Sandbox architecture (test only) *//* STMicroelectronics ST200  *//* AVR32	*//* Blackfin	*//* Nios-II	*//* MicroBlaze   *//* Nios-32	*//* M68K		*//* Sparc 64 Bit *//* Sparc	*//* SuperH	*//* IBM S390	*//* PowerPC	*//* MIPS	 64 Bit *//* MIPS		*//* IA64		*//* Intel x86	*//* ARM		*//* Alpha	*//* Invalid CPU	*//*
 * CPU Architecture Codes (supported by Linux)
 *
 * The following are exposed to uImage header.
 * New IDs *MUST* be appended at the end of the list and *NEVER*
 * inserted for backward compatibility.
 *//* Trusted Execution Environment *//* ARM Trusted Firmware *//* OpenRTOS	*//* Plan 9	*//* OSE		*//* INTEGRITY	*//* Unity OS	*//* ARTOS	*//* RTEMS	*//* Firmware	*//* QNX		*//* pSOS		*//* VxWorks	*//* LynxOS	*//* NCR		*//* Dell		*//* SCO		*//* Irix		*//* Solaris	*//* Esix		*//* SVR4		*//* Linux	*//* 4.4BSD	*//* FreeBSD	*//* NetBSD	*//* OpenBSD	*//* Invalid OS	*//*
 * Operating System Codes
 *
 * The following are exposed to uImage header.
 * New IDs *MUST* be appended at the end of the list and *NEVER*
 * inserted for backward compatibility.
 *//* IMAGE_ENABLE_FIT *//* Take notice of the 'ignore' property for hashes *//* enable fit_format_{error,warning}() *//* new uImage format support enabled on host *//* Define this to avoid #ifdefs later on *//*
 * (C) Copyright 2008 Semihalf
 *
 * (C) Copyright 2000-2005
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 ********************************************************************
 * NOTE: This header file defines an interface to U-Boot. Including
 * this (unmodified) header file in another file is considered normal
 * use of U-Boot, and does *not* fall under the heading of "derived
 * work".
 ********************************************************************
 */second_datasecond_lenrd_datard_lenfdt_regionserr_msgpimage_noffsetsig_blobno_sigspvalue_lenconf_unameconf_noffsetkeydestcmdnamedata_positionimage_unameaddr_currimage_nameconf_namerelocated_addrforce_relocof_sizechunkszcmd_endof_flat_treefit_unamepfit_uname_configpbootstage_idload_opsetup_startsetup_lenld_startld_lencategorytable_name/opt/src/include/android_image.handroid_imageANDR_BOOT_EXTRA_ARGS_SIZEextra_cmdlineu32[8]unsigned int[8]ANDR_BOOT_ARGS_SIZEANDR_BOOT_NAME_SIZEos_versiontags_addrsecond_addrsecond_sizeramdisk_addrramdisk_sizeANDR_BOOT_MAGIC_SIZEANDR_BOOT_MAGIC"ANDROID!"_ANDROID_IMAGE_H_/*
 * +-----------------+
 * | boot header     | 1 page
 * +-----------------+
 * | kernel          | n pages
 * +-----------------+
 * | ramdisk         | m pages
 * +-----------------+
 * | second stage    | o pages
 * +-----------------+
 *
 * n = (kernel_size + page_size - 1) / page_size
 * m = (ramdisk_size + page_size - 1) / page_size
 * o = (second_size + page_size - 1) / page_size
 *
 * 0. all entities are page_size aligned in flash
 * 1. kernel and ramdisk are required (size != 0)
 * 2. second is optional (second_size == 0 -> no second)
 * 3. load each element (kernel, ramdisk, second) at
 *    the specified physical address (kernel_addr, etc)
 * 4. prepare tags at tag_addr.  kernel_args[] is
 *    appended to the kernel commandline in the tags.
 * 5. r0 = 0, r1 = MACHINE_TYPE, r2 = tags_addr
 * 6. if second_size != 0: jump to second_addr
 *    else: jump to kernel_addr
 *//* Supplemental command line data; kept here to maintain
	 * binary compatibility with older versions of mkbootimg *//* timestamp / checksum / sha1 / etc *//* asciiz product name *//* operating system version and security patch level; for
	 * version "A.B.C" and patch level "Y-M-D":
	 * ver = A << 14 | B << 7 | C         (7 bits for each of A, B, C)
	 * lvl = ((Y - 2000) & 127) << 4 | M  (7 bits for Y, 4 bits for M)
	 * os_version = ver << 11 | lvl *//* reserved for future expansion: MUST be 0 *//* flash page size we assume *//* physical addr for kernel tags *//* physical load addr *//*
 * This is from the Android Project,
 * Repository: https://android.googlesource.com/platform/system/core/
 * File: mkbootimg/bootimg.h
 * Commit: d162828814b08ada310846a33205befb69ef5799
 *
 * Copyright (C) 2008 The Android Open Source Project
 *//opt/src/common/image-android.cimage-android%skernel size:      %x
"%skernel size:      %x\n"%skernel address:   %x
"%skernel address:   %x\n"%sramdisk size:     %x
"%sramdisk size:     %x\n"%sramdisk address:  %x
"%sramdisk address:  %x\n"%ssecond size:      %x
"%ssecond size:      %x\n"%ssecond address:   %x
"%ssecond address:   %x\n"%stags address:     %x
"%stags address:     %x\n"%spage size:        %x
"%spage size:        %x\n"%sos_version:       %x (ver: %u.%u.%u, level: %u.%u)
"%sos_version:       %x (ver: %u.%u.%u, level: %u.%u)\n"os_veros_lvl1U << 11(1U << 11)2047(1U << 11) - 1((1U << 11) - 1)%sname:             %s
"%sname:             %s\n"%scmdline:          %s
"%scmdline:          %s\n"hdr->kernel_sizehdr->page_size(hdr->kernel_size)(typeof(hdr->kernel_size))(hdr->page_size)-1ALIGN(hdr->kernel_size, hdr->page_size)hdr->ramdisk_size(hdr->ramdisk_size)(typeof(hdr->ramdisk_size))(hdr->page_size)-1ALIGN(hdr->ramdisk_size, hdr->page_size)second address is 0x%lx
"second address is 0x%lx\n"RAM disk load addr 0x%08x size %u KiB
"RAM disk load addr 0x%08x size %u KiB\n"DIV_ROUND_UP(hdr->ramdisk_size, 1024)407708164<android_image.h>hdr->second_size(hdr->second_size)(typeof(hdr->second_size))(hdr->page_size)-1ALIGN(hdr->second_size, hdr->page_size)ANDROID!ANDR_BOOT_ARGS_SIZE + 1Android's image name: %s
"Android's image name: %s\n"Kernel load addr 0x%08x size %u KiB
"Kernel load addr 0x%08x size %u KiB\n"DIV_ROUND_UP(hdr->kernel_size, 1024)Kernel command line: %s
"Kernel command line: %s\n"newbootargsError: malloc in android_image_get_kernel failed!
"Error: malloc in android_image_get_kernel failed!\n"ihdrandroid_image_get_kernel_addr268468224ANDROID_IMAGE_DEFAULT_KERNEL_ADDRandr_tmp_str0x10008000!defined(CONFIG_SPL_BUILD)/* ver = A << 14 | B << 7 | C         (7 bits for each of A, B, C)
	 * lvl = ((Y - 2000) & 127) << 4 | M  (7 bits for Y, 4 bits for M) *//* os_version = ver << 11 | lvl *//**
 * android_print_contents - prints out the contents of the Android format image
 * @hdr: pointer to the Android format image header
 *
 * android_print_contents() formats a multi line Android image contents
 * description.
 * The routine prints out Android image properties
 *
 * returns:
 *     no returned results
 *//*
	 * The header takes a full page, the remaining components are aligned
	 * on page boundary
	 *//*
	 * Not all Android tools use the id field for signing the image with
	 * sha1 (or anything) so we don't check it. It is not obvious that the
	 * string is null terminated so we take care of this.
	 *//**
 * android_image_get_kernel() - processes kernel part of Android boot images
 * @hdr:	Pointer to image header, which is at the start
 *			of the image.
 * @verify:	Checksum verification flag. Currently unimplemented.
 * @os_data:	Pointer to a ulong variable, will hold os data start
 *			address.
 * @os_len:	Pointer to a ulong variable, will hold os data length.
 *
 * This function returns the os image's start address and length. Also,
 * it appends the kernel command line to the bootargs env variable.
 *
 * Return: Zero, os start address and length on success,
 *		otherwise on failure.
 *//*
	 * All the Android tools that generate a boot.img use this
	 * address as the default.
	 *
	 * Even though it doesn't really make a lot of sense, and it
	 * might be valid on some platforms, we treat that adress as
	 * the default value for this field, and try to execute the
	 * kernel in place in such a case.
	 *
	 * Otherwise, we will return the actual value set by the user.
	 *//*
 * Copyright (c) 2011 Sebastian Andrzej Siewior <bigeasy@linutronix.de>
 *//opt/src/common/image-fdt.cimage-fdtERROR: root node setup failed
"ERROR: root node setup failed\n"ERROR: /chosen node create failed
"ERROR: /chosen node create failed\n"ERROR: arch-specific fdt fixup failed
"ERROR: arch-specific fdt fixup failed\n"fdt_retERROR: board-specific fdt fixup failed: %s
"ERROR: board-specific fdt fixup failed: %s\n"ERROR: system-specific fdt fixup failed: %s
"ERROR: system-specific fdt fixup failed: %s\n"FDT_RAMDISK_OVERHEAD - must RESET the board to recover.

" - must RESET the board to recover.\n\n"ft_verify_fdtdefault_addr"*  fdt: config '%s' from image at 0x%08lx\n"fit_uname_config, fdt_addrdebug("*  fdt: config '%s' from image at 0x%08lx\n",
				      fit_uname_config, fdt_addr)common/image-fdt.c*  fdt: config '%s' from image at 0x%08lx
"*  fdt: subimage '%s' from image at 0x%08lx\n"fit_uname_fdt, fdt_addrdebug("*  fdt: subimage '%s' from image at 0x%08lx\n",
				      fit_uname_fdt, fdt_addr)*  fdt: subimage '%s' from image at 0x%08lx
"*  fdt: cmdline image address = 0x%08lx\n"debug("*  fdt: cmdline image address = 0x%08lx\n",
				      fdt_addr)*  fdt: cmdline image address = 0x%08lx
fdt_noffset"## Checking for 'FDT'/'FDT Image' at %08lx\n"debug("## Checking for 'FDT'/'FDT Image' at %08lx\n",
		      fdt_addr)## Checking for 'FDT'/'FDT Image' at %08lx
"*  fdt: raw FDT blob\n"debug("*  fdt: raw FDT blob\n")416*  fdt: raw FDT blob
## Flattened Device Tree blob at %08lx
"## Flattened Device Tree blob at %08lx\n"ERROR: Did not find a cmdline Flattened Device Tree
"ERROR: Did not find a cmdline Flattened Device Tree\n"   Booting using the fdt blob at %#08lx
"   Booting using the fdt blob at %#08lx\n"fdt_datafdt_len## Flattened Device Tree from multi component Image at %08lX
"## Flattened Device Tree from multi component Image at %08lX\n"   Booting using the fdt at 0x%p
"   Booting using the fdt at 0x%p\n"image is not a fdt"image is not a fdt"((const struct fdt_header *)(fdt_blob))->totalsize(__force __u32)(__be32)(((const struct fdt_header *)(fdt_blob))->totalsize)(__u32)(__be32)(((const struct fdt_header *)(fdt_blob))->totalsize)((__u32)(__be32)(((const struct fdt_header *)(fdt_blob))->totalsize))fdt_totalsize(fdt_blob)fdt size != image size"fdt size != image size""## No Flattened Device Tree\n"debug("## No Flattened Device Tree\n")## No Flattened Device Tree
"## Using FDT in Android image second area\n"debug("## Using FDT in Android image second area\n")470## Using FDT in Android image second area
"## Using FDT at ${fdtaddr}=Ox%lx\n"debug("## Using FDT at ${fdtaddr}=Ox%lx\n", fdt_addr)## Using FDT at ${fdtaddr}=Ox%lx
484"   of_flat_tree at 0x%08lx size 0x%08lx\n"(ulong)*of_flat_tree, *of_sizedebug("   of_flat_tree at 0x%08lx size 0x%08lx\n",
	      (ulong)*of_flat_tree, *of_size)491   of_flat_tree at 0x%08lx size 0x%08lx
"Continuing to boot without FDT\n"debug("Continuing to boot without FDT\n")Continuing to boot without FDT
of_lenCONFIG_SYS_FDT_PADfdt_high"fdt_high"desired_addrof_startdisable_relocationFailed using fdt_high value for Device Tree"Failed using fdt_high value for Device Tree"device tree - allocation error
"device tree - allocation error\n"   Using Device Tree in place at %p, end %p
"   Using Device Tree in place at %p, end %p\n""## device tree at %p ... %p (len=%ld [0x%lX])\n"fdt_blob, fdt_blob + *of_size - 1, of_len, of_lendebug("## device tree at %p ... %p (len=%ld [0x%lX])\n",
		      fdt_blob, fdt_blob + *of_size - 1, of_len, of_len)## device tree at %p ... %p (len=%ld [0x%lX])
   Loading Device Tree to %p, end %p ... "   Loading Device Tree to %p, end %p ... "fdt move failed"fdt move failed"no_fdtreserved-memory"reserved-memory"subnodeboot_fdt_reserve_region"   reserving fdt memory region: addr=%llx size=%llx\n"(unsigned long long)addr, (unsigned long long)sizedebug("   reserving fdt memory region: addr=%llx size=%llx\n",
		      (unsigned long long)addr, (unsigned long long)size)   reserving fdt memory region: addr=%llx size=%llx
ERROR: reserving fdt memory region failed "ERROR: reserving fdt memory region failed "(addr=%llx size=%llx)
"(addr=%llx size=%llx)\n"fdt_errorERROR: "ERROR: " - must RESET the board to recover.
" - must RESET the board to recover.\n"defined(CONFIG_SOC_KEYSTONE)/* Create a new LMB reservation *//* Delete the old LMB reservation *//*
 * Verify the device tree.
 *
 * This function is called after all device tree fix-ups have been enacted,
 * so that the final device tree can be verified.  The definition of "verified"
 * is up to the specific implementation.  However, it generally means that the
 * addresses of some of the devices in the device tree are compared with the
 * actual addresses at which U-Boot has placed them.
 *
 * Returns 1 on success, 0 on failure.  If 0 is returned, U-Boot will halt the
 * boot process.
 *//*
		 * Now check if we have a legacy multi-component image,
		 * get second entry data start address and len.
		 *//*
				 * FDT blob
				 *//* check FDT blob vs FIT blob *//*
			 * This case will catch both: new uImage format
			 * (libfdt based) and raw FDT blob (also libfdt
			 * based).
			 *//*
			 * move image data to the load address,
			 * make sure we don't overwrite initial image
			 *//* verify fdt_addr points to a valid image header *//*
		 * Check if there is an FDT image at the
		 * address provided in the second bootm argument
		 * check image type, for FIT images get a FIT node.
		 *//* use FIT configuration provided in first bootm
			 * command argument
			 *//*
			 * If the FDT blob comes from the FIT image and the
			 * FIT image address is omitted in the command line
			 * argument, try to use ramdisk or os FIT image
			 * address or default load address.
			 *//**
 * boot_get_fdt - main fdt handling routine
 * @argc: command argument count
 * @argv: command argument list
 * @arch: architecture (IH_ARCH_...)
 * @images: pointer to the bootm images structure
 * @of_flat_tree: pointer to a char* variable, will hold fdt start address
 * @of_size: pointer to a ulong variable, will hold fdt length
 *
 * boot_get_fdt() is responsible for finding a valid flat device tree image.
 * Curently supported are the following ramdisk sources:
 *      - multicomponent kernel/ramdisk image,
 *      - commandline provided address of decicated ramdisk image.
 *
 * returns:
 *     0, if fdt image was found and valid, or skipped
 *     of_flat_tree and of_size are set to fdt start address and length if
 *     fdt image is found and valid
 *
 *     1, if fdt image is found but corrupted
 *     of_flat_tree and of_size are set to 0 if no fdt exists
 *//*
		 * We assume there is space after the existing fdt to use
		 * for padding
		 *//* All ones means use fdt in place *//* If fdt_high is set use it to select the relocation address *//* Pad the FDT by a specified amount *//* position on a 4K boundary before the alloc_current *//* nothing to do *//**
 * boot_relocate_fdt - relocate flat device tree
 * @lmb: pointer to lmb handle, will be used for memory mgmt
 * @of_flat_tree: pointer to a char* variable, will hold fdt start address
 * @of_size: pointer to a ulong variable, will hold fdt length
 *
 * boot_relocate_fdt() allocates a region of memory within the bootmap and
 * relocates the of_flat_tree into that region, even if the fdt is already in
 * the bootmap.  It also expands the size of the fdt by CONFIG_SYS_FDT_PAD
 * bytes.
 *
 * of_flat_tree and of_size are set to final (after relocation) values
 *
 * returns:
 *      0 - success
 *      1 - failure
 *//* check if this subnode has a reg property *//* process reserved-memory *//* process memreserve sections *//**
 * boot_fdt_add_mem_rsv_regions - Mark the memreserve and reserved-memory
 * sections as unusable
 * @lmb: pointer to lmb handle, will be used for memory mgmt
 * @fdt_blob: pointer to fdt blob base address
 *
 * Adds the and reserved-memorymemreserve regions in the dtb to the lmb block.
 * Adding the memreserve regions prevents u-boot from using them to store the
 * initrd or the fdt blob.
 *//* adding a ramdisk needs 0x44 bytes in version 2008.10 *//*
 * Copyright (c) 2013, Google Inc.
 *
 * (C) Copyright 2008 Semihalf
 *
 * (C) Copyright 2000-2006
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *//opt/src/common/image-fit.cimage-fitfit_uname_config_copynext_configBOOTSTAGE_ID_FIT_FDT_START"fit_uname=%s, fit_uname_config=%s\n"fit_uname ? fit_uname : "<NULL>", fit_uname_config ? fit_uname_config : "<NULL>"debug("fit_uname=%s, fit_uname_config=%s\n",
			fit_uname ? fit_uname : "<NULL>",
			fit_uname_config ? fit_uname_config : "<NULL>")common/image-fit.c2109fit_uname=%s, fit_uname_config=%s
image_endOverlayed FDT requires relocation
"Overlayed FDT requires relocation\n"EBADF-EBADFuconfig"%d: using uname=%s uconfig=%s\n"i, uname, uconfigdebug("%d: using uname=%s uconfig=%s\n", i, uname, uconfig)2164%d: using uname=%s uconfig=%s
ov_noffsetovloadovlenload of %s failed
"load of %s failed\n""%s loaded at 0x%08lx len=0x%08lx\n"uname, ovload, ovlendebug("%s loaded at 0x%08lx len=0x%08lx\n",
				uname, ovload, ovlen)2176%s loaded at 0x%08lx len=0x%08lx
ovfailed on fdt_open_into
"failed on fdt_open_into\n"((const struct fdt_header *)(base))->totalsize(__force __u32)(__be32)(((const struct fdt_header *)(base))->totalsize)(__u32)(__be32)(((const struct fdt_header *)(base))->totalsize)((__u32)(__be32)(((const struct fdt_header *)(base))->totalsize))fdt_totalsize(base)BOOTSTAGE_ID_FIT_SETUP_STARTfit_base_uname_config## Loading %s from FIT Image at %08lx ...
"## Loading %s from FIT Image at %08lx ...\n"BOOTSTAGE_SUB_FORMATBad FIT %s image format!
"Bad FIT %s image format!\n"BOOTSTAGE_SUB_FORMAT_OKBOOTSTAGE_SUB_UNIT_NAMEBOOTSTAGE_SUB_NO_UNIT_NAMECould not find configuration node
"Could not find configuration node\n"   Using '%s' configuration
"   Using '%s' configuration\n"   Verifying Hash Integrity ... "   Verifying Hash Integrity ... "BOOTSTAGE_SUB_HASHBOOTSTAGE_ID_FIT_CONFIGCould not find subimage node
"Could not find subimage node\n"BOOTSTAGE_SUB_SUBNODE   Trying '%s' %s subimage
"   Trying '%s' %s subimage\n"BOOTSTAGE_SUB_CHECK_ARCHos_archBOOTSTAGE_SUB_CHECK_ALLtype_okos_okNo %s %s %s Image
"No %s %s %s Image\n"BOOTSTAGE_SUB_CHECK_ALL_OKCould not find %s subimage data!
"Could not find %s subimage data!\n"BOOTSTAGE_SUB_GET_DATABOOTSTAGE_SUB_GET_DATA_OKCan't get %s subimage load address!
"Can't get %s subimage load address!\n"BOOTSTAGE_SUB_LOADError: %s overwritten
"Error: %s overwritten\n"EXDEV-18-EXDEV   Loading %s from 0x%08lx to 0x%08lx
"   Loading %s from 0x%08lx to 0x%08lx\n"loadbufmax_decomp_lenError decompressing %s
"Error decompressing %s\n"Subimage data is not a FDT"Subimage data is not a FDT"fit_get_image_type_propertyramdiskloadablesfpgastandalone"*  %s: using config '%s' from image at 0x%08lx\n"prop_name, images->fit_uname_cfg, addrdebug("*  %s: using config '%s' from image at 0x%08lx\n",
	      prop_name, images->fit_uname_cfg, addr)*  %s: using config '%s' from image at 0x%08lx
"*  %s: no such config\n"debug("*  %s: no such config\n", prop_name)*  %s: no such config
"*  %s: no '%s' in config\n"prop_name, prop_namedebug("*  %s: no '%s' in config\n", prop_name, prop_name)1767*  %s: no '%s' in config
fit_image_selectconfs_noffset/configurations"Can't find configurations parent node '%s' (%s)\n"FIT_CONFS_PATH, fdt_strerror(confs_noffset)debug("Can't find configurations parent node '%s' (%s)\n",
		      FIT_CONFS_PATH, fdt_strerror(confs_noffset))1662Can't find configurations parent node '%s' (%s)
"No configuration specified, trying default...\n"debug("No configuration specified, trying default...\n")1668No configuration specified, trying default...
"Found default configuration: '%s'\n"debug("Found default configuration: '%s'\n", conf_uname)1676Found default configuration: '%s'
conf_uname_copy"Can't allocate uname copy: '%s'\n"debug("Can't allocate uname copy: '%s'\n",
					conf_uname)1685Can't allocate uname copy: '%s'
"Can't get node offset for configuration unit name: '%s' (%s)\n"conf_uname, fdt_strerror(noffset)debug("Can't get node offset for configuration unit name: '%s' (%s)\n",
		      conf_uname, fdt_strerror(noffset))1696rd_noffsetCan't get node offset for configuration unit name: '%s' (%s)
"Can't find configurations or images nodes.\n"debug("Can't find configurations or images nodes.\n")1545Can't find configurations or images nodes.
fdt_compatfdt_compat_len"Fdt for comparison has no \"compatible\" property.\n"debug("Fdt for comparison has no \"compatible\" property.\n")1551Fdt for comparison has no "compatible" property.
ndepthkfdt_namekfdt_noffsetcompat_noffsetcur_fdt_compat"No fdt property found.\n"debug("No fdt property found.\n")1579No fdt property found.
"No image node named \"%s\" found.\n"debug("No image node named \"%s\" found.\n",
				      kfdt_name)1586No image node named "%s" found.
"Can't extract compat from \"%s\" " "(compressed)\n"debug("Can't extract compat from \"%s\" "
				      "(compressed)\n", kfdt_name)1593Can't extract compat from "%s" (compressed)
"Can't extract compat from \"%s\" "
				      "(compressed)\n""Failed to get fdt \"%s\".\n"debug("Failed to get fdt \"%s\".\n", kfdt_name)1599Failed to get fdt "%s".
best_match_offsetbest_match_poscur_len"No match found.\n"debug("No match found.\n")No match found.
description"Wrong FIT format: no description\n"debug("Wrong FIT format: no description\n")1468Wrong FIT format: no description
"Wrong FIT format: no timestamp\n"debug("Wrong FIT format: no timestamp\n")1475Wrong FIT format: no timestamp
"Wrong FIT format: no images parent node\n"debug("Wrong FIT format: no images parent node\n")1482Wrong FIT format: no images parent node
image_compimage_archaarch32_supportimage_osCan't find images parent node '%s' (%s)
"Can't find images parent node '%s' (%s)\n"## Checking hash(es) for FIT Image at %08lx ...
"## Checking hash(es) for FIT Image at %08lx ...\n"   Hash(es) for Image %u (%s): "   Hash(es) for Image %u (%s): "err_msgCan't get image data/size"Can't get image data/size"error!
%s for '%s' hash node in '%s' image node
"error!\n%s for '%s' hash node in '%s' image node\n"verify_allUnable to verify required signature"Unable to verify required signature"fdt_for_each_subnode(noffset, fit, image_noffset)+ "+ "- "- "FDT_ERR_TRUNCATED-FDT_ERR_TRUNCATEDFDT_ERR_BADSTRUCTURE-11-FDT_ERR_BADSTRUCTURECorrupted or truncated tree"Corrupted or truncated tree" error!
%s for '%s' hash node in '%s' image node
" error!\n%s for '%s' hash node in '%s' image node\n"fit_image_check_hashCan't get hash algo property"Can't get hash algo property"ignore-skipped "-skipped "fit_valuefit_value_lenCan't get hash value property"Can't get hash value property"Unsupported hash algorithm"Unsupported hash algorithm"Bad hash value len"Bad hash value len"Bad hash value"Bad hash value"*((uint32_t *)value)(*((uint32_t *)value))((*((uint32_t *)value)))cpu_to_uimage(*((uint32_t *)value))"md5""Unsupported hash alogrithm\n"debug("Unsupported hash alogrithm\n")1156Unsupported hash alogrithm
(timestamp)((timestamp))cpu_to_uimage(timestamp)"Can't set '%s' property for '%s' node (%s)\n"FIT_TIMESTAMP_PROP, fit_get_name(fit, noffset, NULL), fdt_strerror(ret)debug("Can't set '%s' property for '%s' node (%s)\n",
		      FIT_TIMESTAMP_PROP, fit_get_name(fit, noffset, NULL),
		      fdt_strerror(ret))1111Can't set '%s' property for '%s' node (%s)
fit_image_hash_get_ignoreuboot-ignoreexternal_data4294967292~3"External Data\n"debug("External Data\n")986External Data
data-sizedata-positiondata-offsetfit_image_get_addressUnsupported %s address size
"Unsupported %s address size\n"cell_lenload64*cell(__force __u32)(__be32)(*cell)(__u32)(__be32)(*cell)((__u32)(__be32)(*cell))uimage_to_cpu(*cell)FIT_IMAGES_PATH, fdt_strerror(images_noffset)debug("Can't find images parent node '%s' (%s)\n",
		      FIT_IMAGES_PATH, fdt_strerror(images_noffset))636"Can't get node offset for image unit name: '%s' (%s)\n"image_uname, fdt_strerror(noffset)debug("Can't get node offset for image unit name: '%s' (%s)\n",
		      image_uname, fdt_strerror(noffset))643Can't get node offset for image unit name: '%s' (%s)
"FIT timestamp with incorrect size of (%u)\n"debug("FIT timestamp with incorrect size of (%u)\n", len)FIT timestamp with incorrect size of (%u)
*((uint32_t *)data)(__force __u32)(__be32)(*((uint32_t *)data))(__u32)(__be32)(*((uint32_t *)data))((__u32)(__be32)(*((uint32_t *)data)))uimage_to_cpu(*((uint32_t *)data))%s  Description:  "%s  Description:  "unavailable
"unavailable\n"%s  Created:      "%s  Created:      "%s  Type:         %s
"%s  Type:         %s\n"%s  Compression:  %s
"%s  Compression:  %s\n"%s  Data Start:   "%s  Data Start:   "vdata0x%08lx
"0x%08lx\n"%s  Data Size:    "%s  Data Size:    "%s  Architecture: %s
"%s  Architecture: %s\n"%s  OS:           %s
"%s  OS:           %s\n"%s  Load Address: "%s  Load Address: "%s  Load Address: 0x%08lx
"%s  Load Address: 0x%08lx\n"%s  Entry Point:  "%s  Entry Point:  "%sFIT description: "%sFIT description: "%sCreated:         "%sCreated:         "%s Image %u (%s)
"%s Image %u (%s)\n""Can't get configurations parent node '%s' (%s)\n"debug("Can't get configurations parent node '%s' (%s)\n",
		      FIT_CONFS_PATH, fdt_strerror(confs_noffset))405Can't get configurations parent node '%s' (%s)
%s Default Configuration: '%s'
"%s Default Configuration: '%s'\n"%s Configuration %u (%s)
"%s Configuration %u (%s)\n"fit_conf_print%s  Kernel:       "%s  Kernel:       "%s  Init Ramdisk: %s
"%s  Init Ramdisk: %s\n"firmware%s  Firmware:     %s
"%s  Firmware:     %s\n"fdt_index%s  FDT:          "%s  FDT:          "%s                "%s                "%s  FPGA:         %s
"%s  FPGA:         %s\n"loadables_index%s  Loadables:    "%s  Loadables:    "fit_image_print_verification_dataHash"Hash"Sign"Sign"fit_image_print_data"%s  %s node:    '%s'\n"p, type, fit_get_name(fit, noffset, NULL)debug("%s  %s node:    '%s'\n", p, type,
	      fit_get_name(fit, noffset, NULL))%s  %s node:    '%s'
%s  %s algo:    "%s  %s algo:    "invalid/unsupported
"invalid/unsupported\n"key-name-hint"key-name-hint"required"required":%s":%s" (required)" (required)""padding"%s  %s padding: %s
"%s  %s padding: %s\n"%s  %s value:   "%s  %s value:   ""%s  %s len:     %d\n"p, type, value_lendebug("%s  %s len:     %d\n", p, type, value_len)%s  %s len:     %d
%s  Timestamp:    "%s  Timestamp:    "fit_get_debug"Can't get '%s' property from FIT 0x%08lx, node: offset %d, name %s (%s)\n"prop_name, (ulong)fit, noffset, fit_get_name(fit, noffset, NULL), fdt_strerror(err)debug("Can't get '%s' property from FIT 0x%08lx, node: offset %d, name %s (%s)\n",
	      prop_name, (ulong)fit, noffset, fit_get_name(fit, noffset, NULL),
	      fdt_strerror(err))Can't get '%s' property from FIT 0x%08lx, node: offset %d, name %s (%s)
fit_parse_spec!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_FIT_PRINT)CONFIG_ARM64_SUPPORT_AARCH32!defined(USE_HOSTCC) && !defined(CONFIG_SANDBOX)!defined(USE_HOSTCC) && defined(CONFIG_FIT_IMAGE_POST_PROCESS)/* the verbose method prints out messages on error *//*
			 * fit_image_load() would load the first FDT from the
			 * extra config only when uconfig is specified.
			 * Check if the extra config contains multiple FDTs and
			 * if so, load them.
			 *//* apply extra configs in FIT first, followed by args *//* check is simplified; fit load checks for overlaps *//* verify that relocation took place by load address not being in fit *//* we need to apply overlays *//* single blob, or error just return as well *//* verify that image data is a proper FDT blob *//* Kernel images get decompressed later in bootm_load_os(). *//* No load address specified *//*
		 * move image data to the load address,
		 * make sure we don't overwrite initial image
		 *//* Don't load *//* perform any post-processing on the image data *//* get image data address and length *//*
	 * If either of the checks fail, we should report an error, but
	 * if the image type is coming from the "loadables" field, we
	 * don't care what it is
	 *//* Remember this config *//*
		 * no image node unit name, try to get config
		 * node first. If config unit node name is NULL
		 * fit_conf_get_node() will try to find default config node
		 *//* get FIT component image node offset *//*
	 * This is sort-of available in the uimage_type[] table in image.c
	 * but we don't have access to the short name, and "fdt" is different
	 * anyway. So let's just keep it here.
	 *//**
 * fit_get_image_type_property() - get property name for IH_TYPE_...
 *
 * @return the properly name where we expect to find the image in the
 * config node
 *//* Check whether configuration has this property defined *//* get kernel image unit name from configuration kernel property *//* get configuration unit name from the default property *//**
 * fit_conf_get_node - get node offset for configuration of a given unit name
 * @fit: pointer to the FIT format image header
 * @conf_uname: configuration node unit name
 *
 * fit_conf_get_node() finds a configuration (within the '/configurations'
 * parent node) of a provided unit name. If configuration is found its node
 * offset is returned to the caller.
 *
 * When NULL is provided in second argument fit_conf_get_node() will search
 * for a default configuration node instead. Default configuration node unit
 * name is retrieved from FIT_DEFAULT_PROP property of the '/configurations'
 * node.
 *
 * returns:
 *     configuration node offset when found (>=0)
 *     negative number on failure (FDT_ERR_* code)
 *//*
		 * Look for a match for each U-Boot compatibility string in
		 * turn in the compat string property.
		 *//* search kFDT under root node *//* search in this config's kernel FDT *//* Otherwise extract it from the kernel FDT. *//* search under config node *//* search in FIT image *//* If there's a compat property in the config node, use that. *//*
	 * Loop over the configurations in the FIT image.
	 *//**
 * fit_conf_find_compat
 * @fit: pointer to the FIT format image header
 * @fdt: pointer to the device tree to compare against
 *
 * fit_conf_find_compat() attempts to find the configuration whose fdt is the
 * most compatible with the passed in device tree.
 *
 * Example:
 *
 * / o image-tree
 *   |-o images
 *   | |-o fdt-1
 *   | |-o fdt-2
 *   |
 *   |-o configurations
 *     |-o config-1
 *     | |-fdt = fdt-1
 *     |
 *     |-o config-2
 *       |-fdt = fdt-2
 *
 * / o U-Boot fdt
 *   |-compatible = "foo,bar", "bim,bam"
 *
 * / o kernel fdt1
 *   |-compatible = "foo,bar",
 *
 * / o kernel fdt2
 *   |-compatible = "bim,bam", "baz,biz"
 *
 * Configuration 1 would be picked because the first string in U-Boot's
 * compatible list, "foo,bar", matches a compatible string in the root of fdt1.
 * "bim,bam" in fdt2 matches the second string which isn't as good as fdt1.
 *
 * As an optimization, the compatible property from the FDT's root node can be
 * copied into the configuration node in the FIT image. This is required to
 * match configurations with compressed FDTs.
 *
 * returns:
 *     offset to the configuration to use if one was found
 *     -1 otherwise
 *//* mandatory subimages parent '/images' node *//* mandatory / node 'timestamp' property *//* mandatory / node 'description' property *//**
 * fit_check_format - sanity check FIT image format
 * @fit: pointer to the FIT format image header
 *
 * fit_check_format() runs a basic sanity FIT image verification.
 * Routine checks for mandatory properties, nodes, etc.
 *
 * returns:
 *     1, on success
 *     0, on failure
 *//**
 * fit_image_check_comp - check whether image node uses given compression
 * @fit: pointer to the FIT format image header
 * @noffset: component image node offset
 * @comp: requested image compression type
 *
 * fit_image_check_comp() reads image compression property and compares its
 * numeric id with the requested compression type. Comparison result is
 * returned to the caller.
 *
 * returns:
 *     1 if image uses requested compression
 *     0 otherwise (or on error)
 *//**
 * fit_image_check_type - check whether image node is of a given type
 * @fit: pointer to the FIT format image header
 * @noffset: component image node offset
 * @type: requested image type
 *
 * fit_image_check_type() reads image type property and compares its numeric
 * id with the requested type. Comparison result is returned to the caller.
 *
 * returns:
 *     1 if image is of given type
 *     0 otherwise (or on error)
 *//**
 * fit_image_check_arch - check whether image node is of a given arch
 * @fit: pointer to the FIT format image header
 * @noffset: component image node offset
 * @arch: requested imagearch
 *
 * fit_image_check_arch() reads image arch property and compares its numeric
 * id with the requested arch. Comparison result is returned to the caller.
 *
 * returns:
 *     1 if image is of given arch
 *     0 otherwise (or on error)
 *//**
 * fit_image_check_os - check whether image node is of a given os type
 * @fit: pointer to the FIT format image header
 * @noffset: component image node offset
 * @os: requested image os
 *
 * fit_image_check_os() reads image os property and compares its numeric
 * id with the requested os. Comparison result is returned to the caller.
 *
 * returns:
 *     1 if image is of given os type
 *     0 otherwise (or on error)
 *//*
			 * Direct child node of the images parent node,
			 * i.e. component image node.
			 *//* Process all image subnodes, check hashes for each *//* Find images parent node offset *//**
 * fit_all_image_verify - verify data integrity for all images
 * @fit: pointer to the FIT format image header
 *
 * fit_all_image_verify() goes over all images in the FIT and
 * for every images checks if all it's hashes are valid.
 *
 * returns:
 *     1, if all hashes of all images are valid
 *     0, otherwise (or on error)
 *//* Get image data and data length *//**
 * fit_image_verify - verify data integrity
 * @fit: pointer to the FIT format image header
 * @image_noffset: component image node offset
 *
 * fit_image_verify() goes over component image hash nodes,
 * re-calculates each data hash and compares with the value stored in hash
 * node.
 *
 * returns:
 *     1, if all hashes are valid
 *     0, otherwise (or on error)
 *//*
			 * Show an indication on failure, but do not return
			 * an error. Only keys marked 'required' can cause
			 * an image validation failure. See the call to
			 * fit_image_verify_required_sigs() above.
			 *//*
		 * Check subnode name, must be equal to "hash".
		 * Multiple hash nodes require unique unit node
		 * names, e.g. hash-1, hash-2, etc.
		 *//* Process all hash subnodes of the component image node *//* Verify all required signatures *//**
 * calculate_hash - calculate and return hash for provided input data
 * @data: pointer to the input data
 * @data_len: data length
 * @algo: requested hash algorithm
 * @value: pointer to the char, will hold hash value data (caller must
 * allocate enough free space)
 * value_len: length of the calculated hash
 *
 * calculate_hash() computes input data hash according to the requested
 * algorithm.
 * Resulting hash value is placed in caller provided 'value' buffer, length
 * of the calculated hash is returned via value_len pointer argument.
 *
 * returns:
 *     0, on success
 *    -1, when algo is unsupported
 *//**
 * fit_set_timestamp - set node timestamp property
 * @fit: pointer to the FIT format image header
 * @noffset: node offset
 * @timestamp: timestamp value to be set
 *
 * fit_set_timestamp() attempts to set timestamp property in the requested
 * node and returns operation status to the caller.
 *
 * returns:
 *     0, on success
 *     -ENOSPC if no space in device tree, -1 for other error
 *//**
 * fit_image_hash_get_ignore - get hash ignore flag
 * @fit: pointer to the FIT format image header
 * @noffset: hash node offset
 * @ignore: pointer to an int, will hold hash ignore flag
 *
 * fit_image_hash_get_ignore() finds hash ignore property in a given hash node.
 * If the property is found and non-zero, the hash algorithm is not verified by
 * u-boot automatically.
 *
 * returns:
 *     0, on ignore not found
 *     value, on ignore found
 *//**
 * fit_image_hash_get_value - get hash value and length
 * @fit: pointer to the FIT format image header
 * @noffset: hash node offset
 * @value: double pointer to uint8_t, will hold address of a hash value data
 * @value_len: pointer to an int, will hold hash data length
 *
 * fit_image_hash_get_value() finds hash value property in a given hash node.
 * If the property is found its data start address and size are returned to
 * the caller.
 *
 * returns:
 *     0, on success
 *     -1, on failure
 *//**
 * fit_image_hash_get_algo - get hash algorithm name
 * @fit: pointer to the FIT format image header
 * @noffset: hash node offset
 * @algo: double pointer to char, will hold pointer to the algorithm name
 *
 * fit_image_hash_get_algo() finds hash algorithm property in a given hash node.
 * If the property is found its data start address is returned to the caller.
 *
 * returns:
 *     0, on success
 *     -1, on failure
 *//*
		 * For FIT with external data, figure out where
		 * the external images start. This is the base
		 * for the data-offset properties in each image.
		 *//**
 * fit_image_get_data_and_size - get data and its size including
 *				 both embedded and external data
 * @fit: pointer to the FIT format image header
 * @noffset: component image node offset
 * @data: double pointer to void, will hold data property's data address
 * @size: pointer to size_t, will hold data property's data size
 *
 * fit_image_get_data_and_size() finds data and its size including
 * both embedded and external data. If the property is found
 * its data start address and size are returned to the caller.
 *
 * returns:
 *     0, on success
 *     otherwise, on failure
 *//**
 * Get 'data-size' property from a given image node.
 *
 * @fit: pointer to the FIT image header
 * @noffset: component image node offset
 * @data_size: holds the data-size property
 *
 * returns:
 *     0, on success
 *     -ENOENT if the property could not be found
 *//**
 * Get 'data-position' property from a given image node.
 *
 * @fit: pointer to the FIT image header
 * @noffset: component image node offset
 * @data_position: holds the data-position property
 *
 * returns:
 *     0, on success
 *     -ENOENT if the property could not be found
 *//**
 * Get 'data-offset' property from a given image node.
 *
 * @fit: pointer to the FIT image header
 * @noffset: component image node offset
 * @data_offset: holds the data-offset property
 *
 * returns:
 *     0, on success
 *     -ENOENT if the property could not be found
 *//**
 * fit_image_get_data - get data property and its size for a given component image node
 * @fit: pointer to the FIT format image header
 * @noffset: component image node offset
 * @data: double pointer to void, will hold data property's data address
 * @size: pointer to size_t, will hold data property's data size
 *
 * fit_image_get_data() finds data property in a given component image node.
 * If the property is found its data start address and size are returned to
 * the caller.
 *
 * returns:
 *     0, on success
 *     -1, on failure
 *//**
 * fit_image_get_entry() - get entry point address property
 * @fit: pointer to the FIT format image header
 * @noffset: component image node offset
 * @entry: pointer to the uint32_t, will hold entry point address
 *
 * This gets the entry point address property for a given component image
 * node.
 *
 * fit_image_get_entry() finds entry point address property in a given
 * component image node.  If the property is found, its value is returned
 * to the caller.
 *
 * returns:
 *     0, on success
 *     -1, on failure
 *//**
 * fit_image_get_load() - get load addr property for given component image node
 * @fit: pointer to the FIT format image header
 * @noffset: component image node offset
 * @load: pointer to the uint32_t, will hold load address
 *
 * fit_image_get_load() finds load address property in a given component
 * image node. If the property is found, its value is returned to the caller.
 *
 * returns:
 *     0, on success
 *     -1, on failure
 *//* Use load64 to avoid compiling warning for 32-bit target *//* Translate compression name to id *//* Get compression name from property data *//**
 * fit_image_get_comp - get comp id for a given component image node
 * @fit: pointer to the FIT format image header
 * @noffset: component image node offset
 * @comp: pointer to the uint8_t, will hold comp numeric id
 *
 * fit_image_get_comp() finds comp property in a given component image node.
 * If the property is found, its (string) value is translated to the numeric
 * id which is returned to the caller.
 *
 * returns:
 *     0, on success
 *     -1, on failure
 *//* Translate image type name to id *//* Get image type name from property data *//**
 * fit_image_get_type - get type id for a given component image node
 * @fit: pointer to the FIT format image header
 * @noffset: component image node offset
 * @type: pointer to the uint8_t, will hold type numeric id
 *
 * fit_image_get_type() finds type property in a given component image node.
 * If the property is found, its (string) value is translated to the numeric
 * id which is returned to the caller.
 *
 * returns:
 *     0, on success
 *     -1, on failure
 *//* Translate architecture name to id *//* Get architecture name from property data *//**
 * fit_image_get_arch - get arch id for a given component image node
 * @fit: pointer to the FIT format image header
 * @noffset: component image node offset
 * @arch: pointer to the uint8_t, will hold arch numeric id
 *
 * fit_image_get_arch() finds arch property in a given component image node.
 * If the property is found, its (string) value is translated to the numeric
 * id which is returned to the caller.
 *
 * returns:
 *     0, on success
 *     -1, on failure
 *//* Translate OS name to id *//* Get OS name from property data *//**
 * fit_image_get_os - get os id for a given component image node
 * @fit: pointer to the FIT format image header
 * @noffset: component image node offset
 * @os: pointer to the uint8_t, will hold os numeric id
 *
 * fit_image_get_os() finds os property in a given component image node.
 * If the property is found, its (string) value is translated to the numeric
 * id which is returned to the caller.
 *
 * returns:
 *     0, on success
 *     -1, on failure
 *//**
 * fit_image_get_node - get node offset for component image of a given unit name
 * @fit: pointer to the FIT format image header
 * @image_uname: component image node unit name
 *
 * fit_image_get_node() finds a component image (within the '/images'
 * node) of a provided unit name. If image is found its node offset is
 * returned to the caller.
 *
 * returns:
 *     image node offset when found (>=0)
 *     negative number on failure (FDT_ERR_* code)
 *//**
 * fit_get_timestamp - get node timestamp property
 * @fit: pointer to the FIT format image header
 * @noffset: node offset
 * @timestamp: pointer to the time_t, will hold read timestamp
 *
 * fit_get_timestamp() reads timestamp property from given node, if timestamp
 * is found and has a correct size its value is returned in third call
 * argument.
 *
 * returns:
 *     0, on success
 *     -1, on property read failure
 *     -2, on wrong timestamp size
 *//**
 * fit_get_desc - get node description property
 * @fit: pointer to the FIT format image header
 * @noffset: node offset
 * @desc: double pointer to the char, will hold pointer to the description
 *
 * fit_get_desc() reads description property from a given node, if
 * description is found pointer to it is returned in third call argument.
 *
 * returns:
 *     0, on success
 *     -1, on failure
 *//* !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_FIT_PRINT) *//* Direct child node of the component image node *//* optional load address for FDT *//* Remaining, type dependent properties *//* Mandatory properties *//**
 * fit_image_print - prints out the FIT component image details
 * @fit: pointer to the FIT format image header
 * @image_noffset: offset of the component image node
 * @p: pointer to prefix string
 *
 * fit_image_print() lists all mandatory properties for the processed component
 * image. If present, hash nodes are printed out as well. Load
 * address for images of type firmware is also printed out. Since the load
 * address is not mandatory for firmware images, it will be output as
 * "unavailable" when not present.
 *
 * returns:
 *     no returned results
 *//*
			 * Direct child node of the configurations parent node,
			 * i.e. configuration node.
			 *//* Process its subnodes, print out configurations details *//* get default configuration unit name from default property *//* Find configurations parent node offset *//* Process its subnodes, print out component images details *//* Root node properties *//* Indent string is defined in header image.h *//**
 * fit_print_contents - prints out the contents of the FIT format image
 * @fit: pointer to the FIT format image header
 * @p: pointer to prefix string
 *
 * fit_print_contents() formats a multi line FIT image contents description.
 * The routine prints out FIT image properties (root node level) followed by
 * the details of each component image.
 *
 * returns:
 *     no returned results
 *//* Direct child node of the component configuration node *//* Process all hash subnodes of the component configuration node *//* Print out all of the specified loadables *//* Optional properties *//**
 * fit_conf_print - prints out the FIT configuration details
 * @fit: pointer to the FIT format image header
 * @noffset: offset of the configuration node
 * @p: pointer to prefix string
 *
 * fit_conf_print() lists all mandatory properties for the processed
 * configuration node.
 *
 * returns:
 *     no returned results
 *//*
	 * Check subnode name, must be equal to "hash" or "signature".
	 * Multiple hash/signature nodes require unique unit node
	 * names, e.g. hash-1, hash-2, signature-1, signature-2, etc.
	 *//**
 * fit_image_print_verification_data() - prints out the hash/signature details
 * @fit: pointer to the FIT format image header
 * @noffset: offset of the hash or signature node
 * @p: pointer to prefix string
 *
 * This lists properties for the processed hash node
 *
 * returns:
 *     no returned results
 *//* Signatures have a time stamp *//**
 * fit_image_print_data() - prints out the hash node details
 * @fit: pointer to the FIT format image header
 * @noffset: offset of the hash node
 * @p: pointer to prefix string
 * @type: Type of information to print ("hash" or "sign")
 *
 * fit_image_print_data() lists properties for the processed hash node
 *
 * This function avoid using puts() since it prints a newline on the host
 * but does not in U-Boot.
 *
 * returns:
 *     no returned results
 *//**
 * fit_get_subimage_count - get component (sub-image) count
 * @fit: pointer to the FIT format image header
 * @images_noffset: offset of images node
 *
 * returns:
 *     number of image components
 *//**
 * fit_parse_subimage - parse FIT subimage spec
 * @spec: input string, containing subimage spec
 * @add_curr: current image address (to be used as a possible default)
 * @addr: pointer to a ulong variable, will hold FIT image address of a given
 * subimage
 * @image_name: double pointer to a char, will hold pointer to a subimage name
 *
 * fit_parse_subimage() expects subimage spec in the form of
 * [<addr>]:<subimage>, where <addr> is a FIT image address that contains
 * subimage with a <subimg> unit name.
 *
 * Address part is optional, and if omitted default add_curr will
 * be used instead.
 *
 * returns:
 *     1 if spec is a valid subimage string,
 *     addr and image_name are set accordingly
 *     0 otherwise
 *//**
 * fit_parse_conf - parse FIT configuration spec
 * @spec: input string, containing configuration spec
 * @add_curr: current image address (to be used as a possible default)
 * @addr: pointer to a ulong variable, will hold FIT image address of a given
 * configuration
 * @conf_name double pointer to a char, will hold pointer to a configuration
 * unit name
 *
 * fit_parse_conf() expects configuration spec in the form of [<addr>]#<conf>,
 * where <addr> is a FIT image address that contains configuration
 * with a <conf> unit name.
 *
 * Address part is optional, and if omitted default add_curr will
 * be used instead.
 *
 * returns:
 *     1 if spec is a valid configuration string,
 *     addr and conf_name are set accordingly
 *     0 otherwise
 *//* New uImage format routines */sepc/opt/src/include/u-boot/rsa.hrsapadding_pss_verifypadding_pkcs_15_verifyrsa_verifyconst image_region[]image_region[]rsa_add_verify_datarsa_signrsa_public_keyexponentrrmodulusRSA_MAX_SIG_BITSRSA_MAX_KEY_BITSRSA_MIN_KEY_BITSRSA4096_BYTES(4096 / 8)RSA2048_BYTES(2048 / 8)RSA_DEFAULT_PADDING_NAME"pkcs-1.5"_RSA_HCONFIG_FIT_ENABLE_RSASSA_PSS_SUPPORT/* This is the maximum signature length that we support, in bits *//* This is the minimum/maximum key size we support, in bits *//* CONFIG_FIT_ENABLE_RSASSA_PSS_SUPPORT *//**
 * rsa_verify() - Verify a signature against some data
 *
 * Verify a RSA PKCS1.5 signature against an expected hash.
 *
 * @info:	Specifies key and FIT information
 * @data:	Pointer to the input data
 * @data_len:	Data length
 * @sig:	Signature
 * @sig_len:	Number of bytes in signature
 * @return 0 if verified, -ve on error
 *//**
 * add_verify_data() - Add verification information to FDT
 *
 * Add public key information to the FDT node, suitable for
 * verification at run-time. The information added depends on the
 * algorithm being used.
 *
 * @info:	Specifies key and FIT information
 * @keydest:	Destination FDT blob for public key data
 * @return: 0, on success, -ENOSPC if the keydest FDT blob ran out of space,
		other -ve value on error
*//**
 * sign() - calculate and return signature for given input data
 *
 * @info:	Specifies key and FIT information
 * @data:	Pointer to the input data
 * @data_len:	Data length
 * @sigp:	Set to an allocated buffer holding the signature
 * @sig_len:	Set to length of the calculated hash
 *
 * This computes input data signature according to selected algorithm.
 * Resulting signature value is placed in an allocated buffer, the
 * pointer is returned as *sigp. The length of the calculated
 * signature is returned via the sig_len pointer argument. The caller
 * should free *sigp.
 *
 * @return: 0, on success, -ve on error
 *//* public exponent *//* R^2 as little endian array *//* modulus as little endian array *//* -1 / modulus[0] mod 2^32 *//* len of modulus[] in number of uint32_t *//**
 * struct rsa_public_key - holder for a public key
 *
 * An RSA public key consists of a modulus (typically called N), the inverse
 * and R^2, where R is 2^(# key bits).
 */sigpsig_len/opt/src/common/image-sig.cimage-sigfit_config_verify_required_sigssig_node"%s: No signature node found: %s\n"__func__, fdt_strerror(sig_node)debug("%s: No signature node found: %s\n", __func__,
		      fdt_strerror(sig_node))common/image-sig.cconst char[32]%s: No signature node found: %s
fdt_for_each_subnode(noffset, sig_blob, sig_node)"conf"Failed to verify required signature '%s'
"Failed to verify required signature '%s'\n"fit_config_verify_sigfdt_for_each_subnode(noffset, fit, conf_noffset)verified error!
%s for '%s' hash node in '%s' config node
" error!\n%s for '%s' hash node in '%s' config node\n"fit_config_check_sig"%s: fdt=%p, conf='%s', sig='%s'\n"__func__, gd_fdt_blob(), fit_get_name(fit, noffset, NULL), fit_get_name(gd_fdt_blob(), required_keynode, NULL)debug("%s: fdt=%p, conf='%s', sig='%s'\n", __func__, gd_fdt_blob(),
	      fit_get_name(fit, noffset, NULL),
	      fit_get_name(gd_fdt_blob(), required_keynode, NULL))%s: fdt=%p, conf='%s', sig='%s'
<u-boot/rsa.h>sig_offsethashed-nodes"hashed-nodes"Can't get hashed-nodes property"Can't get hashed-nodes property"hashed-nodes property must be null-terminated"hashed-nodes property must be null-terminated"IMAGE_MAX_HASHED_NODESNumber of hashed nodes exceeds maximum"Number of hashed nodes exceeds maximum""Hash nodes (%d):\n"debug("Hash nodes (%d):\n", count)Hash nodes (%d):
"   '%s'\n"debug("   '%s'\n", name)388   '%s'
node_incmax_regionsexc_propchar *const[1]char *[1]ARRAY_SIZE(exc_prop)fdt_region[]sizeof(path)Failed to hash configuration"Failed to hash configuration"No data to hash"No data to hash"Too many hash regions"Too many hash regions"const uint32_tconst uint32_t *hashed-strings"hashed-strings"((const struct fdt_header *)(fit))->off_dt_strings(__force __u32)(__be32)(((const struct fdt_header *)(fit))->off_dt_strings)(__u32)(__be32)(((const struct fdt_header *)(fit))->off_dt_strings)((__u32)(__be32)(((const struct fdt_header *)(fit))->off_dt_strings))fdt_off_dt_strings(fit)strings[1](__force __u32)(__be32)(strings[1])(__u32)(__be32)(strings[1])((__u32)(__be32)(strings[1]))fdt32_to_cpu(strings[1])Verification failed"Verification failed"const char[31]"image"verify_countfit_image_verify_sigfit_image_setup_verifyCONFIG_FIT_SIGNATURE_MAX_SIZETotal size too large"Total size too large"padding_namepkcs-1.5sizeof(*info)%s:%s"%s:%s"Unknown signature algorithm"Unknown signature algorithm""Hash regions:\n"debug("Hash regions:\n")Hash regions:
"%10s %10s\n""Offset", "Size"debug("%10s %10s\n", "Offset", "Size")%10s %10s
Offset"Offset"sizeof(*region)"%10x %10x\n"fdt_regions[i].offset, fdt_regions[i].sizedebug("%10x %10x\n", fdt_regions[i].offset,
		      fdt_regions[i].size)%10x %10x
padding_algo[2]padding_algosARRAY_SIZE(padding_algos)crypto_algo[2]crypto_algosARRAY_SIZE(crypto_algos)checksum_algo[2]checksum_algosARRAY_SIZE(checksum_algos)padding_algo[]pss"pss"crypto_algo[]rsa2048"rsa2048"rsa4096"rsa4096"checksum_algo[]SHA1_DER_LENconst uint8_t[]SHA256_DER_LEN/* Work out what we need to verify *//* Process all hash subnodes of the component conf node *//* Allocate the region list on the stack *//*
		 * The strings region offset must be a static 0x0.
		 * This is set in tool/image-host.c
		 *//* Add the strings *//* Get a list of regions to hash *//*
	 * Each node can generate one region for each sub-node. Allow for
	 * 7 sub-nodes (hash-1, signature-1, etc.) and some extra.
	 *//* Create a list of node names from those strings *//* Add a sanity check here since we are using the stack *//* Count the number of strings in the property *//*
	 * Use malloc() except in SPL (to save code size). In SPL the caller
	 * must allocate the array.
	 *//**
 * fit_region_make_list() - Make a list of image regions
 *
 * Given a list of fdt_regions, create a list of image_regions. This is a
 * simple conversion routine since the FDT and image code use different
 * structures.
 *
 * @fit: FIT image
 * @fdt_regions: Pointer to FDT regions
 * @count: Number of FDT regions
 * @region: Pointer to image regions, which must hold @count records. If
 * region is NULL, then (except for an SPL build) the array will be
 * allocated.
 * @return: Pointer to image regions
 *//* Move name to after the comma *//* Make sure names match and next char is a comma *//*
 * Copyright (c) 2013, Google Inc.
 *//opt/src/include/fpga.hconst fpga_descconst fpga_desc *const fpga_desc *constfpga_validatefpga_infofpga_dumpfpga_loadbitstreamfpga_loadsfpga_secure_info *fpga_fsloadfpga_fs_info *fpga_loadfpga_is_partial_datafpga_get_descfpga_countfpga_addfpga_initbitstream_typeBIT_FULLBIT_PARTIALBIT_NONEfpga_secure_infofpga_fs_infofpga_descfpga_typefpga_min_typefpga_xilinxfpga_alterafpga_latticefpga_undefinedencflagauthflaguserkey_addrdevdescFPGA_NO_ENC_OR_NO_AUTHFPGA_ENC_USR_KEYFPGA_INVALID_DEVICEFPGA_FAILFPGA_SUCCESSCONFIG_MAX_FPGA_DEVICES_FPGA_H_/* _FPGA_H_ *//* root function definitions *//* typedef fpga_desc *//* end, typedef fpga_desc *//* real device descriptor *//* switch value to select sub-functions *//* end, typedef fpga_type *//* invalid range check value *//* Lattice family *//* unimplemented *//* Xilinx Family) *//* range check value *//* typedef fpga_type *//* root data type defintions *//* device numbers must be non-negative *//* fpga_xxxx function return value definitions *//* for ulong typedef *//*
 * (C) Copyright 2002
 * Rich Ireland, Enterasys Networks, rireland@enterasys.com.
 */bsizefpgadatabstypefpga_sec_infofpga_fsinfoimg_len/opt/src/include/xilinx.hxilinxxilinx_loadsxilinx_desc *xilinx_loadfsxilinx_infoxilinx_dumpxilinx_loadxilinx_bwr_fnxilinx_post_fnxilinx_pre_fnxilinx_abort_fnxilinx_busy_fnxilinx_wdata_fnxilinx_rdata_fnxilinx_wr_fnxilinx_cs_fnxilinx_clk_fnxilinx_done_fnxilinx_err_fnxilinx_init_fnxilinx_pgm_fnxilinx_fpga_opxilinx_descxilinx_familymin_xilinx_typexilinx_spartan2xilinx_virtexExilinx_virtex2xilinx_spartan3xilinx_zynqxilinx_zynqmpmax_xilinx_typexilinx_ifacemin_xilinx_iface_typeslave_serialmaster_serialslave_paralleljtag_modemaster_selectmapslave_selectmapdevcfgcsu_dmamax_xilinx_iface_typexilinx_fpga_op *operationsloadfscookieiface_fns_XILINX_H_/* _XILINX_H_ *//* Board specific implementation specific function types
 *********************************************************************//* Generic Xilinx Functions
 *********************************************************************//* end, typedef xilinx_desc *//* device name in bitstream *//* operations *//* implementation specific cookie *//* interface function table *//* bytes of data part can accept *//* interface type *//* part type *//* typedef xilinx_desc *//* end, typedef xilinx_family *//* insert all new types before this *//* ZynqMP Family *//* Zynq Family *//* Spartan-III Family *//* Virtex2 Family *//* Virtex-E Family *//* Spartan-II Family *//* low range check value *//* typedef xilinx_family *//* end, typedef xilinx_iface *//* csu_dma interface (zynqmp) *//* devcfg interface (zynq) *//* slave SelectMap (virtex2)            *//* master SelectMap (virtex2)           *//* jtag/tap serial (not used ) *//* parallel data w/ external latch *//* serial data w/ internal clock (not used) *//* serial data and external clock *//* typedef xilinx_iface *//* Xilinx types
 *********************************************************************/<fpga.h>/opt/src/include/linux/lzo.hlzolzop_is_valid_headerlzop_decompresslzo1x_decompress_safelzo1x_1_compressLZO_E_NOT_YET_IMPLEMENTEDLZO_E_INPUT_NOT_CONSUMEDLZO_E_EOF_NOT_FOUNDLZO_E_LOOKBEHIND_OVERRUNLZO_E_OUTPUT_OVERRUNLZO_E_INPUT_OVERRUNLZO_E_NOT_COMPRESSIBLELZO_E_OUT_OF_MEMORYLZO_E_ERRORLZO_E_OKlzo1x_worst_compress(x)((x) + ((x) / 16) + 64 + 3)LZO1X_1_MEM_COMPRESSLZO1X_MEM_COMPRESS(16384 * sizeof(unsigned char *))__LZO_H__/*
 * Return values (< 0 = Error)
 *//* check if the header is valid (based on magic numbers) *//* decompress lzop format *//* safe decompression with overrun testing *//* This requires 'workmem' of size LZO1X_1_MEM_COMPRESS *//*
 *  LZO Public Kernel Interface
 *  A mini subset of the LZO real-time data compression library
 *
 *  Copyright (C) 1996-2005 Markus F.X.J. Oberhumer <markus@oberhumer.com>
 *
 *  The full LZO package can be found at:
 *  http://www.oberhumer.com/opensource/lzo/
 *
 *  Changed for kernel use by:
 *  Nitin Gupta <nitingupta910@gmail.com>
 *  Richard Purdie <rpurdie@openedhand.com>
 */wrkmem/opt/src/lib/lzma/LzmaDec.hLzmaDecLzmaDecodeconst LZByteconst LZByte *ELzmaStatus *enum <unnamed> *ISzAlloc *LzmaDec_DecodeToBufCLzmaDec *LzmaDec_DecodeToDicLzmaDec_FreeLzmaDec_AllocateLzmaDec_FreeProbsLzmaDec_AllocateProbsLzmaDec_InitLzmaProps_DecodeCLzmaProps *_CLzmaProps *ELzmaStatusLZMA_STATUS_NOT_SPECIFIEDLZMA_STATUS_FINISHED_WITH_MARKLZMA_STATUS_NOT_FINISHEDLZMA_STATUS_NEEDS_MORE_INPUTLZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARKELzmaFinishModeLZMA_FINISH_ANYLZMA_FINISH_ENDCLzmaDecCLzmaProps_CLzmaPropsLZByte[20]LZMA_REQUIRED_INPUT_MAXtempBuftempBufSizenumProbsneedInitStateneedFlushremainLenUInt32[4]repscheckDicSizeprocessedPosdicBufSizedicPosdicUInt16 *probsdicSizepblplcLzmaDec_Construct(p){ (p)->dic = 0; (p)->probs = 0; }LZMA_PROPS_SIZECLzmaProb__LZMA_DEC_H_LZMA_PROB32/* LzmaDecode

finishMode:
  It has meaning only if the decoding reaches output limit (*destLen).
  LZMA_FINISH_ANY - Decode just destLen bytes.
  LZMA_FINISH_END - Stream must be finished after (*destLen).

Returns:
  SZ_OK
    status:
      LZMA_STATUS_FINISHED_WITH_MARK
      LZMA_STATUS_NOT_FINISHED
      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
  SZ_ERROR_DATA - Data error
  SZ_ERROR_MEM  - Memory allocation error
  SZ_ERROR_UNSUPPORTED - Unsupported properties
  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
*//* ---------- One Call Interface ---------- *//* It's zlib-like interface.
   See LzmaDec_DecodeToDic description for information about STEPS and return results,
   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
   to work with CLzmaDec variables manually.

finishMode:
  It has meaning only if the decoding reaches output limit (*destLen).
  LZMA_FINISH_ANY - Decode just destLen bytes.
  LZMA_FINISH_END - Stream must be finished after (*destLen).
*//* ---------- Buffer Interface ---------- *//* LzmaDec_DecodeToDic

   The decoding to internal dictionary buffer (CLzmaDec::dic).
   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!

finishMode:
  It has meaning only if the decoding reaches output limit (dicLimit).
  LZMA_FINISH_ANY - Decode just dicLimit bytes.
  LZMA_FINISH_END - Stream must be finished after dicLimit.

Returns:
  SZ_OK
    status:
      LZMA_STATUS_FINISHED_WITH_MARK
      LZMA_STATUS_NOT_FINISHED
      LZMA_STATUS_NEEDS_MORE_INPUT
      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
  SZ_ERROR_DATA - Data error
*//* You can use it, if you want to eliminate the overhead for data copying from
   dictionary to some other external buffer.
   You must work with CLzmaDec variables directly in this interface.

   STEPS:
     LzmaDec_Constr()
     LzmaDec_Allocate()
     for (each new stream)
     {
       LzmaDec_Init()
       while (it needs more decompression)
       {
         LzmaDec_DecodeToDic()
         use data from CLzmaDec::dic and update CLzmaDec::dicPos
       }
     }
     LzmaDec_Free()
*//* ---------- Dictionary Interface ---------- *//* There are two variants to allocate state for Dictionary Interface:
     1) LzmaDec_Allocate / LzmaDec_Free
     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
   You can use variant 2, if you set dictionary buffer manually.
   For Buffer Interface you must always use variant 1.

LzmaDec_Allocate* can return:
  SZ_OK
  SZ_ERROR_MEM         - Memory allocation error
  SZ_ERROR_UNSUPPORTED - Unsupported properties
*//* There are 3 levels of interfaces:
     1) Dictionary Interface
     2) Buffer Interface
     3) One Call Interface
   You can select any of these interfaces, but don't mix functions from different
   groups for same object. *//* ---------- Interfaces ---------- *//* ELzmaStatus is used only as output value for function call *//* there is probability that stream was finished without end mark *//* you must provide more input bytes *//* stream was not finished *//* stream was finished with end mark. *//* use main error code instead *//* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!

   You must use LZMA_FINISH_END, when you know that current output buffer
   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.

   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
   and output value of destLen will be less than output buffer size limit.
   You can check status result also.

   You can use multiple checks to test data integrity after full decompression:
     1) Check Result and "status" variable.
     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
        You must use correct finish mode in that case. *//* block must be finished at the end *//* finish at any point *//* There are two types of LZMA streams:
     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. *//* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; *//* ---------- LZMA Decoder state ---------- *//* LzmaProps_Decode - decodes properties
Returns:
  SZ_OK
  SZ_ERROR_UNSUPPORTED - Unsupported properties
*//* ---------- LZMA Properties ---------- *//* _LZMA_PROB32 can increase the speed on some CPUs,
   but memory usage for CLzmaDec::probs will be doubled in that case *//* #define _LZMA_PROB32 *//* LzmaDec.h -- LZMA Decoder
2009-02-07 : Igor Pavlov : Public domain */"Types.h"srcLenpropDatapropSizefinishModedicLimitpropsSizeprops/opt/src/include/lzma/LzmaDec.h__LZMADEC_H__FAKE__/*
 * Fake include for LzmaDec.h
 *
 * Copyright (C) 2007-2009 Industrie Dial Face S.p.A.
 * Luigi 'Comio' Mantellini (luigi.mantellini@idf-hit.com)
 *
 */"../../lib/lzma/LzmaDec.h"/opt/src/common/image.cERROR with allocation of cmdline
"ERROR with allocation of cmdline\n""## FIT configuration was not specified\n"debug("## FIT configuration was not specified\n")common/image.c1461## FIT configuration was not specified
tmp_img_addrfit_img_resultBOOTSTAGE_ID_FIT_LOADABLE_STARTimg_dataimg_typeThe given image format is not supported (corrupt?)
"The given image format is not supported (corrupt?)\n"fit_loadable_processstruct fit_loadable_tblfit_loadableconst unsigned intfit_loadable_tbl *ll_entry_count(struct fit_loadable_tbl, fit_loadable).u_boot_list_2_fit_loadable_1.u_boot_list_2_fit_loadable_3fit_loadable_handlerll_entry_start(struct fit_loadable_tbl, fit_loadable)<lzma/LzmaDec.h><linux/lzo.h><xilinx.h>"## Skipping init Ramdisk\n"debug("## Skipping init Ramdisk\n")1082## Skipping init Ramdisk
rd_addr"*  ramdisk: config '%s' from image at " "0x%08lx\n"fit_uname_config, rd_addrdebug("*  ramdisk: config '%s' from image at "
						"0x%08lx\n",
						fit_uname_config, rd_addr)1102*  ramdisk: config '%s' from image at 0x%08lx
"*  ramdisk: config '%s' from image at "
						"0x%08lx\n"fit_uname_ramdisk"*  ramdisk: subimage '%s' from image at " "0x%08lx\n"fit_uname_ramdisk, rd_addrdebug("*  ramdisk: subimage '%s' from image at "
						"0x%08lx\n",
						fit_uname_ramdisk, rd_addr)1107*  ramdisk: subimage '%s' from image at 0x%08lx
"*  ramdisk: subimage '%s' from image at "
						"0x%08lx\n""*  ramdisk: cmdline image address = " "0x%08lx\n"debug("*  ramdisk: cmdline image address = "
						"0x%08lx\n",
						rd_addr)1114*  ramdisk: cmdline image address = 0x%08lx
"*  ramdisk: cmdline image address = "
						"0x%08lx\n"BOOTSTAGE_ID_FIT_RD_STARTWrong Ramdisk Image Format
"Wrong Ramdisk Image Format\n"rd_loadBOOTSTAGE_ID_RAMDISK## Loading init Ramdisk from multi component Legacy Image at %08lx ...
"## Loading init Ramdisk from multi component "
				"Legacy Image at %08lx ...\n"BOOTSTAGE_ID_NO_RAMDISK"## No init Ramdisk\n"debug("## No init Ramdisk\n")1218## No init Ramdisk
"   ramdisk start = 0x%08lx, ramdisk end = 0x%08lx\n"*rd_start, *rd_enddebug("   ramdisk start = 0x%08lx, ramdisk end = 0x%08lx\n",
			*rd_start, *rd_end)1224   ramdisk start = 0x%08lx, ramdisk end = 0x%08lx
debug("*  kernel: default image load address = 0x%08lx\n",
		      load_addr)932const char[27]"*  kernel: config '%s' from image at 0x%08lx\n"*fit_uname_config, kernel_addrdebug("*  kernel: config '%s' from image at 0x%08lx\n",
		      *fit_uname_config, kernel_addr)937*  kernel: config '%s' from image at 0x%08lx
"*  kernel: subimage '%s' from image at 0x%08lx\n"*fit_uname_kernel, kernel_addrdebug("*  kernel: subimage '%s' from image at 0x%08lx\n",
		      *fit_uname_kernel, kernel_addr)941*  kernel: subimage '%s' from image at 0x%08lx
debug("*  kernel: cmdline image address = 0x%08lx\n",
		      kernel_addr)946const table_entry_t[7]table_entry[7]Compression"Compression"const table_entry_t[39]table_entry[39]Image"Image"const table_entry_t[27]table_entry[27]"CPU"const table_entry_t[11]table_entry[11]OS"OS""Invalid %s Type: %s\n"table_name, namedebug("Invalid %s Type: %s\n", table_name, name)Invalid %s Type: %s
Unknown Compression"Unknown Compression"genimg_get_short_nameUnknown Image"Unknown Image"Unknown Architecture"Unknown Architecture"Unknown OS"Unknown OS"const table_infoconst table_info[4]table_info[4]const table_info *table_info *unknown_msgunknown_strUnknown sizeof(msg)sizeof(unknown_str)sizeof(msg) - sizeof(unknown_str)get_table_entry%4d-%02d-%02d  %2d:%02d:%02d UTC
"%4d-%02d-%02d  %2d:%02d:%02d UTC\n"%d Bytes = "%d Bytes = "bootm_mapsize"bootm_mapsize"bootm_size"bootm_size"bootm_low"bootm_low"on_loadaddrCONFIG_SYS_MALLOC_LEN4096 * 1024(4096 * 1024)CONFIG_SYS_MALLOC_LEN < (4096 * 1024)lzma_lenprint_decomp_msg   %s %s
"   %s %s\n"XIP"XIP"Loading"Loading"   Uncompressing %s
"   Uncompressing %s\n"%sImage Name:   %.*s
"%sImage Name:   %.*s\n"%sCreated:      "%sCreated:      "%sImage Type:   "%sImage Type:   "%sData Size:    "%sData Size:    "%sLoad Address: %08x
"%sLoad Address: %08x\n"%sEntry Point:  %08x
"%sEntry Point:  %08x\n"%sContents:
"%sContents:\n"%s   Image %d: "%s   Image %d: "%s    Offset = 0x%08lx
"%s    Offset = 0x%08lx\n"HAB Blocks:   0x%08x   0x0000   0x%08x
"HAB Blocks:   0x%08x   0x0000   0x%08x\n"81600x1FE0image_print_type%s %s %s (%s)
"%s %s %s (%s)\n"size[idx](__force __u32)(__be32)(size[idx])(__u32)(__be32)(size[idx])((__u32)(__be32)(size[idx]))uimage_to_cpu(size[idx])(__force __u32)(__be32)(size[i])(__u32)(__be32)(size[i])is_xip((__u32)(__be32)(size[i]))uimage_to_cpu(size[i])table_info_u_boot_list_2_env_clbk_2_loadaddr.u_boot_list_2_env_clbk_2_loadaddrarchitecture"architecture"operating system"operating system"image type"image type"const table_entry_t[]table_entry[]uncompressed"uncompressed"bzip2"bzip2"bzip2 compressed"bzip2 compressed""gzip"gzip compressed"gzip compressed""lzma"lzma compressed"lzma compressed""lzo"lzo compressed"lzo compressed"lz4"lz4"lz4 compressed"lz4 compressed"uimage_compaisimage"aisimage"Davinci AIS image"Davinci AIS image"filesystem"filesystem"Filesystem Image"Filesystem Image"Firmware"Firmware"flat_dt"flat_dt"Flat Device Tree"Flat Device Tree"gpimage"gpimage"TI Keystone SPL Image"TI Keystone SPL Image"Kernel Image"Kernel Image"kernel_noload"kernel_noload"Kernel Image (no loading done)"Kernel Image (no loading done)"kwbimage"kwbimage"Kirkwood Boot Image"Kirkwood Boot Image"imximage"imximage"Freescale i.MX Boot Image"Freescale i.MX Boot Image"imx8image"imx8image"NXP i.MX8 Boot Image"NXP i.MX8 Boot Image"imx8mimage"imx8mimage"NXP i.MX8M Boot Image"NXP i.MX8M Boot Image"invalid"invalid"Invalid Image"Invalid Image""multi"Multi-File Image"Multi-File Image"omapimage"omapimage"TI OMAP SPL With GP CH"TI OMAP SPL With GP CH"pblimage"pblimage"Freescale PBL Boot Image"Freescale PBL Boot Image"RAMDisk Image"RAMDisk Image"script"script"Script"Script"socfpgaimage"socfpgaimage"Altera SoCFPGA CV/AV preloader"Altera SoCFPGA CV/AV preloader"socfpgaimage_v1"socfpgaimage_v1"Altera SoCFPGA A10 preloader"Altera SoCFPGA A10 preloader"Standalone Program"Standalone Program"ublimage"ublimage"Davinci UBL image"Davinci UBL image"mxsimage"mxsimage"Freescale MXS Boot Image"Freescale MXS Boot Image"atmelimage"atmelimage"ATMEL ROM-Boot Image"ATMEL ROM-Boot Image"x86_setup"x86_setup"x86 setup.bin"x86 setup.bin"lpc32xximage"lpc32xximage"LPC32XX Boot Image"LPC32XX Boot Image"rkimage"rkimage"Rockchip Boot Image"Rockchip Boot Image"rksd"rksd"Rockchip SD Boot Image"Rockchip SD Boot Image"rkspi"rkspi"Rockchip SPI Boot Image"Rockchip SPI Boot Image"vybridimage"vybridimage"Vybrid Boot Image"Vybrid Boot Image"zynqimage"zynqimage"Xilinx Zynq Boot Image"Xilinx Zynq Boot Image"zynqmpimage"zynqmpimage"Xilinx ZynqMP Boot Image"Xilinx ZynqMP Boot Image"zynqmpbif"zynqmpbif"Xilinx ZynqMP Boot Image (bif)"Xilinx ZynqMP Boot Image (bif)"FPGA Image"FPGA Image""tee"Trusted Execution Environment Image"Trusted Execution Environment Image"firmware_ivt"firmware_ivt"Firmware with HABv4 IVT"Firmware with HABv4 IVT"pmmc"pmmc"TI Power Management Micro-Controller Firmware"TI Power Management Micro-Controller Firmware"stm32image"stm32image"STMicroelectronics STM32 Image"STMicroelectronics STM32 Image"mtk_image"mtk_image"MediaTek BootROM loadable Image"MediaTek BootROM loadable Image"uimage_typeInvalid OS"Invalid OS"arm-trusted-firmware"arm-trusted-firmware"ARM Trusted Firmware"ARM Trusted Firmware"Linux"Linux"netbsd"netbsd"ose"ose"Enea OSE"Enea OSE"plan9"plan9"rtems"rtems"Trusted Execution Environment"Trusted Execution Environment""u-boot""vxworks"VxWorks"VxWorks"uimage_osInvalid ARCH"Invalid ARCH""alpha"Alpha"Alpha"arm"arm""ARM"x86"x86"Intel x86"Intel x86"ia64"ia64"IA64"IA64"m68k"m68k"M68K"M68K"microblaze"microblaze"MicroBlaze"MicroBlaze"mips"mips"MIPS"MIPS"mips64"mips64"MIPS 64 Bit"MIPS 64 Bit"nios2"nios2"NIOS II"NIOS II"powerpc"powerpc"PowerPC"PowerPC"ppc"ppc"s390"s390"IBM S390"IBM S390"sh"sh"SuperH"SuperH"sparc"sparc"SPARC"SPARC"sparc64"sparc64"SPARC 64 Bit"SPARC 64 Bit"blackfin"blackfin"Blackfin"Blackfin"avr32"avr32"AVR32"AVR32"nds32"nds32"NDS32"NDS32"or1k"or1k"OpenRISC 1000"OpenRISC 1000""sandbox"Sandbox"Sandbox"arm64"arm64"AArch64"AArch64"arc"arc"ARC"ARC"x86_64"x86_64"AMD x86_64"AMD x86_64"xtensa"xtensa"Xtensa"Xtensa"riscv"riscv"RISC-V"RISC-V"uimage_archCONFIG_SYS_BARGSIZECONFIG_SHOW_BOOT_PROGRESSIMAGE_ENABLE_FIT || IMAGE_ENABLE_OF_LIBFDTCONFIG_CMD_BDI__maybe_unuseddefined(CONFIG_LYNXKDI) || defined(USE_HOSTCC)defined(CONFIG_CMD_ELF) || defined(USE_HOSTCC)defined(CONFIG_INTEGRITY) || defined(USE_HOSTCC)defined(CONFIG_BOOTM_OPENRTOS) || defined(USE_HOSTCC)CONFIG_BZIP2CONFIG_LZMACONFIG_LZOCONFIG_LZ4defined(CONFIG_SYS_SDRAM_BASE)defined(CONFIG_ARM) && defined(CONFIG_NR_DRAM_BANKS)defined(CONFIG_SYS_BOOTMAPSZ)defined(USE_HOSTCC) || !defined(CONFIG_NEEDS_MANUAL_RELOC)CONFIG_SUPPORT_RAW_INITRDdefined(DEBUG) && defined(CONFIG_CMD_BDI)/* CONFIG_LMB *//**
 * boot_get_kbd - allocate and initialize kernel copy of board info
 * @lmb: pointer to lmb handle, will be used for memory mgmt
 * @kbd: double pointer to board info data
 *
 * boot_get_kbd() allocates space for kernel copy of board info data below
 * BOOTMAPSZ + env_get_bootm_low() address and kernel board info is initialized
 * with the current u-boot board info data.
 *
 * returns:
 *      0 - success
 *     -1 - failure
 *//* CONFIG_SYS_BOOT_GET_CMDLINE *//**
 * boot_get_cmdline - allocate and initialize kernel cmdline
 * @lmb: pointer to lmb handle, will be used for memory mgmt
 * @cmd_start: pointer to a ulong variable, will hold cmdline start
 * @cmd_end: pointer to a ulong variable, will hold cmdline end
 *
 * boot_get_cmdline() allocates space for kernel command line below
 * BOOTMAPSZ + env_get_bootm_low() address. If "bootargs" U-Boot environment
 * variable is present its contents is copied to allocated kernel
 * command line.
 *
 * returns:
 *      0 - success
 *     -1 - failure
 *//* Something went wrong! *//*
	 * Check image type. For FIT images get FIT node
	 * and attempt to locate a generic binary.
	 *//*
	 * Obtain the os FIT header from the images struct
	 *//* Check to see if the images struct has a FIT configuration *//*
	 * These two variables are requirements for fit_image_load, but
	 * their values are not used
	 *//*
	 * These variables are used to hold the current image location
	 * in system memory.
	 *//* call that handler with this image data *//* matching this type *//* For each loadable handler *//* TODO support multi fpga platforms *//* CONFIG_SYS_BOOT_RAMDISK_HIGH *//*
			 * Ensure the image is flushed to memory to handle
			 * AMP boot scenarios in which we might not be
			 * HW cache coherent
			 *//* zero-copy ramdisk support *//* a value of "no" or a similar string will act like 0,
		 * turning the "load high" feature off. This is intentional.
		 *//**
 * boot_ramdisk_high - relocate init ramdisk
 * @lmb: pointer to lmb handle, will be used for memory mgmt
 * @rd_data: ramdisk data start address
 * @rd_len: ramdisk data length
 * @initrd_start: pointer to a ulong variable, will hold final init ramdisk
 *      start address (after possible relocation)
 * @initrd_end: pointer to a ulong variable, will hold final init ramdisk
 *      end address (after possible relocation)
 *
 * boot_ramdisk_high() takes a relocation hint from "initrd_high" environment
 * variable and if requested ramdisk data is moved to a specified location.
 *
 * Initrd_start and initrd_end are set to final (after relocation) ramdisk
 * start/end addresses if ramdisk image start and len were provided,
 * otherwise set initrd_start and initrd_end set to zeros.
 *
 * returns:
 *      0 - success
 *     -1 - failure
 *//*
		 * no initrd image
		 *//*
		 * Now check if we have a legacy mult-component image,
		 * get second entry data start address and len.
		 *//*
		 * Check if there is an initrd image at the
		 * address provided in the second bootm argument
		 * check image type, for FIT images get FIT node.
		 *//* use FIT configuration provided in first bootm
			 * command argument. If the property is not defined,
			 * quit silently.
			 *//*
			 * If the init ramdisk comes from the FIT image and
			 * the FIT image address is omitted in the command
			 * line argument, try to use os FIT image address or
			 * default load address.
			 *//*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 *//*
	 * Look for an Android boot image.
	 *//**
 * boot_get_ramdisk - main ramdisk handling routine
 * @argc: command argument count
 * @argv: command argument list
 * @images: pointer to the bootm images structure
 * @arch: expected ramdisk architecture
 * @rd_start: pointer to a ulong variable, will hold ramdisk start address
 * @rd_end: pointer to a ulong variable, will hold ramdisk end
 *
 * boot_get_ramdisk() is responsible for finding a valid ramdisk image.
 * Curently supported are the following ramdisk sources:
 *      - multicomponent kernel/ramdisk image,
 *      - commandline provided address of decicated ramdisk image.
 *
 * returns:
 *     0, if ramdisk image was found and valid, or skiped
 *     rd_start and rd_end are set to ramdisk start/end addresses if
 *     ramdisk image is found and valid
 *
 *     1, if ramdisk image is found but corrupted, or invalid
 *     rd_start and rd_end are set to 0 if no ramdisk exists
 *//**
 * fit_has_config - check if there is a valid FIT configuration
 * @images: pointer to the bootm command headers structure
 *
 * fit_has_config() checks if there is a FIT configuration in use
 * (if FTI support is present).
 *
 * returns:
 *     0, no FIT support or no configuration found
 *     1, configuration found
 *//**
 * genimg_get_format - get image format type
 * @img_addr: image start address
 *
 * genimg_get_format() checks whether provided address points to a valid
 * legacy or FIT image.
 *
 * New uImage format and FDT blob are based on a libfdt. FDT blob
 * may be passed directly or embedded in a FIT image. In both situations
 * genimg_get_format() must be able to dectect libfdt header.
 *
 * returns:
 *     image format type or IMAGE_FORMAT_INVALID if no image is present
 *//**
 * genimg_get_kernel_addr() is the simple version of
 * genimg_get_kernel_addr_fit(). It ignores those return FIT strings
 *//* find out kernel image address *//**
 * genimg_get_kernel_addr_fit - get the real kernel address and return 2
 *                              FIT strings
 * @img_addr: a string might contain real image address
 * @fit_uname_config: double pointer to a char, will hold pointer to a
 *                    configuration unit name
 * @fit_uname_kernel: double pointer to a char, will hold pointer to a subimage
 *                    name
 *
 * genimg_get_kernel_addr_fit get the real kernel start address from a string
 * which is normally the first argv of bootm/bootz
 *
 * returns:
 *     kernel start address
 *//**
 * get_table_entry_id - translate short entry name to id
 * @table: pointer to a translation table for entries of a specific type
 * @table_name: to be used in case of error
 * @name: entry short name to be translated
 *
 * get_table_entry_id() will go over translation table trying to find
 * entry that matches given short name. If matching entry is found,
 * its id returned to the caller.
 *
 * returns:
 *     entry id if translation succeeds
 *     -1 otherwise
 *//**
 * get_table_entry_name - translate entry id to long name
 * @table: pointer to a translation table for entries of a specific type
 * @msg: message to be returned when translation fails
 * @id: entry id to be translated
 *
 * get_table_entry_name() will go over translation table trying to find
 * entry that matches given id. If matching entry is found, its long
 * name is returned to the caller.
 *
 * returns:
 *     long entry name if translation succeeds
 *     msg otherwise
 *//**
 * get_cat_table_entry_short_name - translate entry id to short name
 * @category: category to look up (enum ih_category)
 * @id: entry id to be translated
 *
 * This will scan the translation table trying to find the entry that matches
 * the given id.
 *
 * @retur short entry name if translation succeeds; error string on failure
 *//**
 * get_cat_table_entry_name - translate entry id to long name
 * @category: category to look up (enum ih_category)
 * @id: entry id to be translated
 *
 * This will scan the translation table trying to find the entry that matches
 * the given id.
 *
 * @retur long entry name if translation succeeds; error string on failure
 *//* Default Save Size (in bytes) *//* Shared dual-format routines *//**
 * image_get_ramdisk - get and verify ramdisk image
 * @rd_addr: ramdisk image start address
 * @arch: expected ramdisk architecture
 * @verify: checksum verification flag
 *
 * image_get_ramdisk() returns a pointer to the verified ramdisk image
 * header. Routine receives image start address and expected architecture
 * flag. Verification done covers data and header integrity and os/type/arch
 * fields checking.
 *
 * returns:
 *     pointer to a ramdisk image header, if image was found and valid
 *     otherwise, return NULL
 *//* CONFIG_LZ4 *//* CONFIG_LZO *//* CONFIG_LZMA *//*
		 * If we've got less than 4 MB of malloc() space,
		 * use slower decompression algorithm which requires
		 * at most 2300 KB of memory.
		 *//* CONFIG_GZIP *//*
	 * Load the image to the right place, decompressing if needed. After
	 * this, image_len will be set to the number of uncompressed bytes
	 * loaded, ret will be non-zero on error.
	 *//**
 * print_decomp_msg() - Print a suitable decompression/loading message
 *
 * @type:	OS type (IH_OS_...)
 * @comp_type:	Compression type being used (IH_COMP_...)
 * @is_xip:	true if the load address matches the image start
 *//*
				 * the user may need to know offsets
				 * if planning to do something with
				 * multiple files
				 *//**
 * image_print_contents - prints out the contents of the legacy format image
 * @ptr: pointer to the legacy format image header
 * @p: pointer to prefix string
 *
 * image_print_contents() formats a multi line legacy image contents description.
 * The routine prints out all header fields followed by the size/offset data
 * for MULTI/SCRIPT images.
 *
 * returns:
 *     no returned results
 *//* calculate idx-th component data address *//* add up i-th component size, rounding up to 4 bytes *//* go over all indices preceding requested component idx *//* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) *//* get start of the image payload, which in case of multi
	 * component images that points to a table of component sizes *//* get number of component *//**
 * image_multi_getimg - get component data address and size
 * @hdr: pointer to the header of the multi component image
 * @idx: index of the requested component
 * @data: pointer to a ulong variable, will hold component data address
 * @len: pointer to a ulong variable, will hold component size
 *
 * image_multi_getimg() returns size and data address for the requested
 * component in a multi component image.
 *
 * Note: no checking of the image type is done, caller must pass
 * a valid multi component image.
 *
 * returns:
 *     data address and size of the component, if idx is valid
 *     0 in data and len, if idx is out of range
 *//* count non empty slots *//**
 * image_multi_count - get component (sub-image) count
 * @hdr: pointer to the header of the multi component image
 *
 * image_multi_count() returns number of components in a multi
 * component image.
 *
 * Note: no checking of the image type is done, caller must pass
 * a valid multi component image.
 *
 * returns:
 *     number of components
 *//* Copy header so we can blank CRC field for re-calculation *//* Legacy format routines *//*
 * (C) Copyright 2008 Semihalf
 *
 * (C) Copyright 2000-2006
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *//opt/src/common/init/board_init.cshow_boot_progressboard_init_f_init_reservegd_ptrsizeof(*gd)__ysizeof(struct global_data)roundup(sizeof(struct global_data), 16roundup(sizeof(struct global_data), 16)board_init_f_alloc_reservetop-sizeof(struct global_data)rounddown(top-sizeof(struct global_data), 16)arch_setup_gd!defined(CONFIG_X86) && !defined(CONFIG_ARM)!defined(CONFIG_ARM)/*
 * Board-specific Platform code can reimplement show_boot_progress () if needed
 *//* next alloc will be higher by one 'early malloc arena' size *//* go down one 'early malloc arena' *//*
	 * record early malloc arena start.
	 * Use gd as it is now properly set for all architectures.
	 *//* next alloc will be higher by one GD plus 16-byte alignment *//* set GD unless architecture did it already *//* zero the area *//*
	 * clear GD entirely and set it up.
	 * Use gd_ptr, as gd may not be properly set yet.
	 *//*
 * Initialize reserved space (which has been safely allocated on the C
 * stack from the C runtime environment handling code).
 *
 * Notes:
 *
 * Actual reservation was done by the caller; the locations from base
 * to base+size-1 (where 'size' is the value returned by the allocation
 * function above) can be accessed freely without risk of corrupting the
 * C runtime environment.
 *
 * IMPORTANT:
 *
 * Upon return from the allocation function above, on some architectures
 * the caller will set gd to the lowest reserved location. Therefore, in
 * this initialization function, the global data MUST be placed at base.
 *
 * ALSO IMPORTANT:
 *
 * On some architectures, gd will already be good when entering this
 * function. On others, it will only be good once arch_setup_gd() returns.
 * Therefore, global data accesses must be done:
 *
 * - through gd_ptr if before the call to arch_setup_gd();
 *
 * - through gd once arch_setup_gd() has been called.
 *
 * Do not use 'gd->' until arch_setup_gd() has been called!
 *
 * IMPORTANT TOO:
 *
 * Initialization for each "chunk" (GD, early malloc arena...) ends with
 * an incrementation line of the form 'base += <some size>'. The last of
 * these incrementations seems useless, as base will not be used any
 * more after this incrementation; but if/when a new "chunk" is appended,
 * this increment will be essential as it will give base right value for
 * this new chunk (which will have to end with its own incrementation
 * statement). Besides, the compiler's optimizer will silently detect
 * and remove the last base incrementation, therefore leaving that last
 * (seemingly useless) incrementation causes no code increase.
 *//* LAST : reserve GD (rounded up to a multiple of 16 bytes) *//* Reserve early malloc arena *//*
 * Allocate reserved space for use as 'globals' from 'top' address and
 * return 'bottom' address of allocated space
 *
 * Notes:
 *
 * Actual reservation cannot be done from within this function as
 * it requires altering the C stack pointer, so this will be done by
 * the caller upon return from this function.
 *
 * IMPORTANT:
 *
 * Alignment constraints may differ for each 'chunk' allocated. For now:
 *
 * - GD is aligned down on a 16-byte boundary
 *
 *  - the early malloc arena is not aligned, therefore it follows the stack
 *   alignment constraint of the architecture for which we are bulding.
 *
 *  - GD is allocated last, so that the return value of this functions is
 *   both the bottom of the reserved area and the address of GD, should
 *   the calling context need it.
 *//* !CONFIG_X86 && !CONFIG_ARM *//* Unfortunately x86 or ARM can't compile this code as gd cannot be assigned *//*
 * Code shared between SPL and U-Boot proper
 *
 * Copyright (c) 2015 Google, Inc
 * Written by Simon Glass <sjg@chromium.org>
 *//opt/src/common/init/opt/src/common/iomux.cconsole_argscons_setsizeof(struct stdio_dev *)io_flagcs_idxrepeat/* CONSOLE_MUX *//* Works even if console_devices[console] is NULL. *//* failed to set any console *//*
		 * Try assigning the specified device.
		 * This could screw up the console settings for apps.
		 *//*
		 * Prevent multiple entries for a device.
		 *//*
		 * Check whether the device exists and is valid.
		 * console_assign() also calls search_device(),
		 * but I need the pointer to the device.
		 *//* There's always one entry more than the number of commas. *//*
	 * Check whether a comma separated list of devices was
	 * entered and count how many devices were entered.
	 * The array start[] has pointers to the beginning of
	 * each device name (up to MAX_CONSARGS devices).
	 *
	 * Have to do this twice - once to count the number of
	 * commas and then again to populate start.
	 *//* This tries to preserve the old list if an error occurs. *//opt/src/common/iotrace.csizeof(struct iotrace_record)IOT_8 | IOT_WRITEreadb(ptr)IOT_8 | IOT_READIOT_16 | IOT_WRITEreadw(ptr)IOT_16 | IOT_READIOT_32 | IOT_WRITEreadl(ptr)IOT_32 | IOT_READadd_recordsrecsizeof(value)__warned"WARNING: iotrace buffer exhausted, please check needed length using \"iotrace stats\"\n"__ret_warn_onceWARN_ONCE(1, "WARNING: iotrace buffer exhausted, please check needed length using \"iotrace stats\"\n")__ret_warn_once && !__warnedWARNING: iotrace buffer exhausted, please check needed length using "iotrace stats"
region_startIOTRACE_IMPL/* Update our checksum *//* Store it if there is room *//*
	 * We don't support iotrace before relocation. Since the trace buffer
	 * is set up by a command, it can't be enabled at present. To change
	 * this we would need to set the iotrace buffer at build-time. See
	 * lib/trace.c for how this might be done if you are interested.
	 *//**
 * struct iotrace - current trace status and checksum
 *
 * @start:	Start address of iotrace buffer
 * @size:	Actual size of iotrace buffer in bytes
 * @needed_size: Needed of iotrace buffer in bytes
 * @offset:	Current write offset into iotrace buffer
 * @region_start: Address of IO region to trace
 * @region_size: Size of region to trace. if 0 will trace all address space
 * @crc32:	Current value of CRC chceksum of trace records
 * @enabled:	true if enabled, false if disabled
 *//opt/src/common/log.clog_initstruct log_driverlog_driverlog_driver *ll_entry_start(struct log_driver, log_driver).u_boot_list_2_log_driver_1ll_entry_count(struct log_driver, log_driver).u_boot_list_2_log_driver_3log_device *ldevsizeof(*ldev)"%s: Cannot allocate memory\n"debug("%s: Cannot allocate memory\n", __func__)common/log.c%s: Cannot allocate memory
CONFIG_LOG_DEFAULT_LEVELlog_remove_filterfilt&ldev->filter_headlog_filter *(&ldev->filter_head)->nexttypeof(*filt)list_for_each_entry(filt, &ldev->filter_head, sibling_node)filt->sibling_node.nextlog_add_filterlog_category_t[]sizeof(*filt)log_category_t *LOGFF_HAS_CATfilt->cat_listlog_category_t[5]ARRAY_SIZE(filt->cat_list)LOGC_END_logfilter_numcat_listmax_levelfile_listlog_rec *log_dispatch&gd->log_head(&gd->log_head)->nexttypeof(*ldev)list_for_each_entry(ldev, &gd->log_head, sibling_node)ldev->sibling_node.nextlog_passes_filterslog_has_filesubstr_lenfile_lenlog_has_catLOGF_MAX_CATEGORIESlog_device_find_by_namelog_get_level_by_nameLOGL_COUNTconst char *[10]log_get_level_nameINVALID"INVALID"log_get_cat_by_nameLOGC_COUNTLOGC_COUNT - LOGC_NONElog_get_cat_name<invalid>"<invalid>"<missing>"<missing>"EMERG"EMERG"ALERT"ALERT"CRIT"CRIT"ERR"ERR"WARNING"WARNING"NOTICE"NOTICE"INFO"INFO""DEBUG"CONTENT"CONTENT"IO"IO"log_level_namecore"core"driver-model"driver-model"device-tree"device-tree"log_cat_name/*
	 * We cannot add runtime data to the driver since it is likely stored
	 * in rodata. Instead, set up a 'device' corresponding to each driver.
	 * We only support having a single device.
	 *//**
 * log_dispatch() - Send a log record to all log devices for processing
 *
 * The log record is sent to each log device in turn, skipping those which have
 * filters which block the record
 *
 * @rec: Log record to dispatch
 * @return 0 (meaning success)
 *//* If there are no filters, filter on the default log level *//**
 * log_passes_filters() - check if a log record passes the filters for a device
 *
 * @ldev: Log device to check
 * @rec: Log record to check
 * @return true if @rec is not blocked by the filters in @ldev, false if it is
 *//**
 * log_has_file() - check if a file is with a list
 *
 * @file_list: List of files to check, separated by comma
 * @file: File to check for. This string is matched against the end of each
 *	file in the list, i.e. ignoring any preceding path. The list is
 *	intended to consist of relative pathnames, e.g. common/main.c,cmd/log.c
 * @return true if @file is in @file_list, else false
 *//**
 * log_has_cat() - check if a log category exists within a list
 *
 * @cat_list: List of categories to check, at most LOGF_MAX_CATEGORIES entries
 *	long, terminated by LC_END if fewer
 * @cat: Category to search for
 * @return true if @cat is in @cat_list, else false
 *//*
 * Logging support
 *
 * Copyright (c) 2017 Google, Inc
 * Written by Simon Glass <sjg@chromium.org>
 *//opt/src/common/log_console.clog_consolelog_console_emitLOGF_LEVEL1 << LOGF_LEVEL(1 << LOGF_LEVEL)%s."%s."LOGF_CAT1 << LOGF_CAT(1 << LOGF_CAT)LOGF_FILE1 << LOGF_FILE(1 << LOGF_FILE)%s:"%s:"LOGF_LINE1 << LOGF_LINE(1 << LOGF_LINE)%d-"%d-"LOGF_FUNC1 << LOGF_FUNC(1 << LOGF_FUNC)%s()"%s()"LOGF_MSG1 << LOGF_MSG(1 << LOGF_MSG)"console"_u_boot_list_2_log_driver_2_console.u_boot_list_2_log_driver_2_console/*
	 * The output format is designed to give someone a fighting chance of
	 * figuring out which field is which:
	 *    - level is in CAPS
	 *    - cat is lower case and ends with comma
	 *    - file normally has a .c extension and ends with a colon
	 *    - line is integer and ends with a -
	 *    - function is an identifier and ends with ()
	 *    - message has a space before it unless it is on its own
	 */__AUTOBOOT_HCONFIG_AUTOBOOT/**
 * autoboot_command() - run the autoboot command
 *
 * If enabled, run the autoboot command returned from bootdelay_process().
 * Also do the CONFIG_MENUKEY processing if enabled.
 *
 * @cmd: Command to run
 *//**
 * bootdelay_process() - process the bootd delay
 *
 * Process the boot delay, boot limit, then get the value of either
 * bootcmd, failbootcmd or altbootcmd depending on the current state.
 * Return this command so it can be executed.
 *
 * @return command to executed
 *//opt/src/common/main.cBOOTSTAGE_ID_MAIN_LOOP"main_loop"CONFIG_VERSION_VARIABLE__ARG_PLACEHOLDER_CONFIG_VERSION_VARIABLEIS_ENABLED(CONFIG_VERSION_VARIABLE)CONFIG_VERSION_VARIABLE_MODULE__ARG_PLACEHOLDER_CONFIG_VERSION_VARIABLE_MODULE__ARG_PLACEHOLDER_CONFIG_VERSION_VARIABLE_MODULE 1__ARG_PLACEHOLDER_CONFIG_VERSION_VARIABLE 1ver"ver"CONFIG_UPDATE_TFTP__ARG_PLACEHOLDER_CONFIG_UPDATE_TFTPIS_ENABLED(CONFIG_UPDATE_TFTP)CONFIG_UPDATE_TFTP_MODULE__ARG_PLACEHOLDER_CONFIG_UPDATE_TFTP_MODULE__ARG_PLACEHOLDER_CONFIG_UPDATE_TFTP_MODULE 1__ARG_PLACEHOLDER_CONFIG_UPDATE_TFTP 1No CLI available"No CLI available"run_preboot_environment_commandCONFIG_PREBOOT/* set version variable *//* We come here after U-Boot is initialised and ready to process commands *//* CONFIG_PREBOOT *//* restore Ctrl-C checking *//* disable Ctrl-C checking *//* #define	DEBUG	*/__assert_faillog_uc_cat(1 << LOGF_FUNC) | (1 << LOGF_MSG)log_filterlog_filter_flagslog_devicelog_reclog_category_tLOGC_FIRSTUCLASS_COUNTLOGC_ARCHLOGC_BOARDLOGC_CORELOGC_DMLOGC_DTLOGC_EFILOGC_ALLOCLOGC_SANDBOXlog_level_tLOGL_EMERGLOGL_ALERTLOGL_CRITLOGL_NOTICELOGL_DEBUG_CONTENTLOGL_DEBUG_IOLOGL_FIRSTemitfilter_headnext_filter_numLOG_DRIVER(_name)ll_entry_declare(struct log_driver, _name, log_driver)log_msg_ret(_msg,_ret)({ int __ret = (_ret); if (__ret < 0) log(LOG_CATEGORY, LOGL_ERR, "%s: returning err=%d\n", _msg, __ret); __ret; })log_ret(_ret)({ int __ret = (_ret); if (__ret < 0) log(LOG_CATEGORY, LOGL_ERR, "returning err=%d\n", __ret); __ret; })assert(x)({ if (!(x) && _DEBUG) __assert_fail(#x, __FILE__, __LINE__, __func__); })warn_non_spl(fmt,args...)debug_cond(!_SPL_BUILD, fmt, ## args)debug(fmt,args...)debug_cond(_DEBUG, fmt, ## args)debug_cond(cond,fmt,args...)do { if (1) log(LOG_CATEGORY, LOGL_DEBUG, fmt, ## args); } while (0)_SPL_BUILDlog(_cat,_level,_fmt,_args...)({ int _l = _level; if (CONFIG_IS_ENABLED(LOG) && (_l <= _LOG_MAX_LEVEL || _LOG_DEBUG)) _log((enum log_category_t)(_cat), _l, __FILE__, __LINE__, __func__, pr_fmt(_fmt), ## _args); })_LOG_DEBUGlog_io(_fmt...)log(LOG_CATEGORY, LOGL_DEBUG_IO, ## _fmt)log_content(_fmt...)log(LOG_CATEGORY, LOGL_DEBUG_CONTENT, ## _fmt)log_debug(_fmt...)log(LOG_CATEGORY, LOGL_DEBUG, ## _fmt)log_info(_fmt...)log(LOG_CATEGORY, LOGL_INFO, ## _fmt)log_notice(_fmt...)log(LOG_CATEGORY, LOGL_NOTICE, ## _fmt)log_warning(_fmt...)log(LOG_CATEGORY, LOGL_WARNING, ## _fmt)log_err(_fmt...)log(LOG_CATEGORY, LOGL_ERR, ## _fmt)_LOG_MAX_LEVELCONFIG_VAL(LOG_MAX_LEVEL)__LOG_Hpr_fmtLOG_DEBUG!_DEBUG && CONFIG_IS_ENABLED(LOG)CONFIG_IS_ENABLED(LOG) && defined(CONFIG_LOG_ERROR_RETURN)/**
 * log_init() - Set up the log system ready for use
 *
 * @return 0 if OK, -ENOMEM if out of memory
 *//**
 * log_remove_filter() - Remove a filter from a log device
 *
 * @drv_name: Driver name to remove the filter from (since each driver only has
 *	a single device)
 * @filter_num: Filter number to remove (as returned by log_add_filter())
 * @return 0 if the filter was removed, -ENOENT if either the driver or the
 *	filter number was not found
 *//**
 * log_add_filter() - Add a new filter to a log device
 *
 * @drv_name: Driver name to add the filter to (since each driver only has a
 *	single device)
 * @cat_list: List of categories to allow (terminated by LOGC_none). If empty
 *	then all categories are permitted. Up to LOGF_MAX_CATEGORIES entries
 *	can be provided
 * @max_level: Maximum log level to allow
 * @file_list: List of files to allow, separated by comma. If NULL then all
 *	files are permitted
 * @return the sequence number of the new filter (>=0) if the filter was added,
 *	or a -ve value on error
 *//* Handle the 'log test' command *//* Log format flags (bit numbers) for gd->log_fmt. See log_fmt_chars *//**
 * log_get_level_by_name() - Look up a log level by name
 *
 * @name: Name to look up
 * @return log level ID, or LOGL_NONE if not found
 *//**
 * log_get_level_name() - Get the name of a log level
 *
 * @level: Log level to look up
 * @return log level name (in ALL CAPS)
 *//**
 * log_get_cat_by_name() - Look up a category by name
 *
 * @name: Name to look up
 * @return category ID, or LOGC_NONE if not found
 *//**
 * log_get_cat_name() - Get the name of a category
 *
 * @cat: Category to look up
 * @return category name (which may be a uclass driver name) if found, or
 *	 "<invalid>" if invalid, or "<missing>" if not found
 *//**
 * struct log_filter - criterial to filter out log messages
 *
 * @filter_num: Sequence number of this filter.  This is returned when adding a
 *	new filter, and must be provided when removing a previously added
 *	filter.
 * @flags: Flags for this filter (LOGFF_...)
 * @cat_list: List of categories to allow (terminated by LOGC_none). If empty
 *	then all categories are permitted. Up to LOGF_MAX_CATEGORIES entries
 *	can be provided
 * @max_level: Maximum log level to allow
 * @file_list: List of files to allow, separated by comma. If NULL then all
 *	files are permitted
 * @sibling_node: Next filter in the list of filters for this log device
 *//* Filter has a category list *//* maximum categories per filter *//**
 * struct log_device - an instance of a log driver
 *
 * Since drivers are set up at build-time we need to have a separate device for
 * the run-time aspects of drivers (currently just a list of filters to apply
 * to records send to this device).
 *
 * @next_filter_num: Seqence number of next filter filter added (0=no filters
 *	yet). This increments with each new filter on the device, but never
 *	decrements
 * @drv: Pointer to driver for this device
 * @filter_head: List of filters for this device
 * @sibling_node: Next device in the list of all devices
 *//**
	 * emit() - emit a log record
	 *
	 * Called by the log system to pass a log record to a particular driver
	 * for processing. The filter is checked before calling this function.
	 *//**
 * struct log_driver - a driver which accepts and processes log records
 *
 * @name: Name of driver
 *//**
 * struct log_rec - a single log record
 *
 * Holds information about a single record in the log
 *
 * Members marked as 'not allocated' are stored as pointers and the caller is
 * responsible for making sure that the data pointed to is not overwritten.
 * Memebers marked as 'allocated' are allocated (e.g. via strdup()) by the log
 * system.
 *
 * @cat: Category, representing a uclass or part of U-Boot
 * @level: Severity level, less severe is higher
 * @file: Name of file where the log record was generated (not allocated)
 * @line: Line number where the log record was generated
 * @func: Function where the log record was generated (not allocated)
 * @msg: Log message (allocated)
 *//* Non-logging versions of the above which just return the error code *//*
 * Log an error return value, possibly with a message. Usage:
 *
 *	return log_ret(fred_call());
 *
 * or:
 *
 *	return log_msg_ret("fred failed", fred_call());
 *//*
 * An assertion is run-time check done in debug mode only. If DEBUG is not
 * defined then it is skipped. If DEBUG is defined and the assertion fails,
 * then it calls panic*( which may or may not reset/halt U-Boot (see
 * CONFIG_PANIC_HANG), It is hoped that all failing assertions are found
 * before release, and after release it is hoped that they don't matter. But
 * in any case these failing assertions cannot be fixed with a reset (which
 * may just do the same assertion again).
 *//* Show a message if not in SPL *//* Show a message if DEBUG is defined in a file *//* _DEBUG *//*
 * Output a debug text when condition "cond" is met. The "cond" should be
 * computed by a preprocessor in the best case, allowing for the best
 * optimization.
 *//* Emit a log record if the level is less that the maximum *//*
 * This header may be including when CONFIG_LOG is disabled, in which case
 * CONFIG_LOG_MAX_LEVEL is not defined. Add a check for this.
 *//* Use a default category if this file does not supply one *//* Define this at the top of a file to add a prefix to debug messages *//**
 * _log() - Internal function to emit a new log record
 *
 * @cat: Category of log record (indicating which subsystem generated it)
 * @level: Level of log record (indicating its severity)
 * @file: File name of file where log record was generated
 * @line: Line number in file where log record was generated
 * @func: Function where log record was generated
 * @fmt: printf() format string for log record
 * @...: Optional parameters, according to the format string @fmt
 * @return 0 if log record was emitted, -ve on error
 *//* Helper to cast a uclass ID to a log category *//* Sentinel value for a list of log categories *//* Number of log categories *//* Bloblist *//* Related to the sandbox board *//* Memory allocation *//* EFI implementation *//* Device-tree *//* Core driver-model *//* Related to core features (non-driver-model) *//* Related to board-specific code *//* Related to arch-specific code *//* First number is after all uclasses *//* First part mirrors UCLASS_... *//**
 * Log categories supported. Most of these correspond to uclasses (i.e.
 * enum uclass_id) but there are also some more generic categories
 *//* Debug message showing hardware I/O access *//* Debug message showing full message content *//* Basic debug-level message *//* General information message *//* Normal but significant condition, printf() *//* Warning may prevent optimial operation *//* Error that prevents something from working *//* Critical conditions *//* Action must be taken immediately *//* U-Boot is unstable *//** Log levels supported, ranging from most to least important */assertionupdate_tftprandom_portnet_parse_bootfileis_serverip_in_cmdcopy_filenameenv_get_vlanstring_to_vlanvlan_to_stringstring_to_ipip_to_stringnet_random_ethaddris_valid_ethaddris_broadcast_ethaddris_multicast_ethaddris_zero_ethaddrnet_copy_u32net_copy_ipsizeof(struct in_addr)net_write_ipsizeof(ip)net_read_u32sizeof(l)net_read_ipnet_auto_loadeth_set_last_protocoleth_is_on_demand_initNETCONSnc_input_packetnc_startnet_process_received_packetnet_send_udp_packetnet_send_ip_packetnet_send_packetnet_get_async_tx_pkt_bufnet_set_stateDEBUG_INT_STATE"--- NetState set to %d\n"debug_cond(DEBUG_INT_STATE, "--- NetState set to %d\n", state)include/net.h644--- NetState set to %d
net_set_timeout_handlerthand_f *net_set_icmp_handlerrxhand_icmp_f *arp_is_waitingnet_set_arp_handlerrxhand_f *net_get_arp_handlernet_set_udp_handlernet_get_udp_handlerip_checksum_okadd_ip_checksumscompute_ip_checksumnet_set_udp_headernet_set_ip_headernet_update_etherethernet_hdr *net_set_ethernet_eth_hdr_sizenet_start_againnet_loopnet_initis_cdp_packetconst u8[6]eth_mcast_joineth_get_nameeth_halteth_rxeth_receiveeth_sendeth_initeth_env_get_enetaddr_by_indexusb_ether_initeth_env_set_enetaddr_by_indexeth_get_dev_indexeth_set_currenteth_try_anothereth_initializeeth_halt_state_onlyeth_init_state_onlyeth_is_activeeth_get_ethaddreth_get_dev_by_nameeth_get_devnet_loop_stateNETLOOP_CONTINUENETLOOP_RESTARTNETLOOP_SUCCESSNETLOOP_FAILproto_tARPWOLicmp_hdrarp_hdrip_udp_hdrip_hdrvlan_ethernet_hdre802_hdrethernet_hdreth_opseth_recv_flagsETH_RECV_CHECK_DEVICEeth_pdataeth_state_tETH_STATE_INITETH_STATE_PASSIVEETH_STATE_ACTIVEthand_frxhand_icmp_frxhand_funfraggatewaymtusequencear_dataar_opar_plnar_hlnar_proar_hrdudp_xsumudp_lenudp_dstudp_srcip_hl_vvet_typevet_tagvet_vlan_typevet_srcvet_destet_protet_snap3et_snap2et_snap1et_ctlet_ssapet_dsapet_protlenet_srcet_destread_rom_hwaddrwrite_hwaddrmcastfree_pktuchar **priv_pdataiobaseuchar *[4]unsigned char *[4]PKTBUFSRXVLAN_IDMASK0x0fffVLAN_NONERINGSZ_LOG2RINGSZPKTSIZE_ALIGNPKTSIZE1522IP_ICMP_HDR_SIZE(IP_HDR_SIZE + ICMP_HDR_SIZE)ICMP_HDR_SIZE(sizeof(struct icmp_hdr))ICMP_NOT_REACH_PORTICMP_REDIR_HOSTICMP_REDIR_NETICMP_ECHO_REQUESTICMP_REDIRECTICMP_NOT_REACHICMP_ECHO_REPLYARP_HDR_SIZE(8+20)ar_tpaar_data[ARP_HLEN + ARP_PLEN + ARP_HLEN]ar_thaar_data[ARP_HLEN + ARP_PLEN]ar_spaar_data[ARP_HLEN]ar_shaar_data[0]RARPOP_REPLYRARPOP_REQUESTARPOP_REPLYARPOP_REQUESTARP_PLENARP_ETHERUDP_HDR_SIZE(IP_UDP_HDR_SIZE - IP_HDR_SIZE)IP_UDP_HDR_SIZE(sizeof(struct ip_udp_hdr))IP_HDR_SIZE(sizeof(struct ip_hdr))IP_FLAGS_MFRAGIP_FLAGS_DFRAGIP_FLAGS_RESIP_FLAGS0xe000IP_OFFSPROT_PPP_SESPROT_IPV60x86ddPROT_VLANPROT_RARPPROT_WOL0x0842PROT_ARPPROT_IPVLAN_ETHER_HDR_SIZE(sizeof(struct vlan_ethernet_hdr))E802_HDR_SIZE(sizeof(struct e802_hdr))ETHER_HDR_SIZE(sizeof(struct ethernet_hdr))eth_get_ops(dev)((struct eth_ops *)(dev)->driver->ops)(ARP_HLEN * 2) + (ARP_HLEN - 1)PKTALIGNDEBUG_NET_PKTDEBUG_DEV_PKTDEBUG_LL_STATE__NET_H__CONFIG_SYS_RX_ETH_BUFFERdefined(CONFIG_API) || defined(CONFIG_EFI_LOADER)defined(CONFIG_NETCONSOLE) && !defined(CONFIG_SPL_BUILD)net_loop_last_protocolnet_cdp_ethaddrnet_statedevstringsrc_ipdest_portsrc_portin_packetetherdportsportpayload_lentcp_seq_numtcp_ack_numfnew_sumnet_ntp_time_offsetnet_ntp_servernet_ping_ipnet_dns_env_varnet_dns_resolvenet_boot_file_expected_size_in_blocksnet_boot_file_sizenet_boot_file_name_explicitnet_boot_file_namenet_restart_wrapnet_native_vlannet_our_vlannet_null_ethaddrnet_bcast_ethaddrnet_rx_packet_lennet_rx_packetnet_rx_packetsnet_tx_packetnet_server_ipnet_ipnet_server_ethaddrnet_ethaddrnet_root_pathnet_hostnamenet_nis_domainnet_dns_server2net_dns_servernet_netmasknet_gatewaypush_packet/* __NET_H__ *//**********************************************************************//**
 * update_tftp - Update firmware over TFTP (via DFU)
 *
 * This function updates board's firmware via TFTP
 *
 * @param addr - memory address where data is stored
 * @param interface - the DFU medium name - e.g. "mmc"
 * @param devstring - the DFU medium number - e.g. "1"
 *
 * @return - 0 on success, other value on failure
 *//* get a random source port *//**
 * net_parse_bootfile - Parse the bootfile env var / cmd line param
 *
 * @param ipaddr - a pointer to the ipaddr to populate if included in bootfile
 * @param filename - a pointer to the string to save the filename part
 * @param max_len - The longest - 1 that the filename part can be
 *
 * return 1 if parsed, 0 if bootfile is empty
 *//* check if serverip is specified in filename from the command line *//* copy a filename (allow for "..." notation, limit length) *//* read a VLAN id from an environment variable *//* Convert a string to a vlan id *//* Convert a VLAN id to a string *//* Convert a string to ip address *//* Convert an IP address to a string *//* set local assignment bit (IEEE802) *//* clear multicast bit *//**
 * net_random_ethaddr - Generate software assigned random Ethernet address
 * @addr: Pointer to a six-byte array containing the Ethernet address
 *
 * Generate a random Ethernet address (MAC) that is not multicast
 * and has the local assigned bit set.
 *//* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
	 * explicitly check for it here. *//*
 * is_valid_ethaddr - Determine if the given Ethernet address is valid
 * @addr: Pointer to a six-byte array containing the Ethernet address
 *
 * Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not
 * a multicast address, and is not FF:FF:FF:FF:FF:FF.
 *
 * Return true if the address is valid.
 *//*
 * is_broadcast_ethaddr - Determine if the Ethernet address is broadcast
 * @addr: Pointer to a six-byte array containing the Ethernet address
 *
 * Return true if the address is the broadcast address.
 *//**
 * is_multicast_ethaddr - Determine if the Ethernet address is a multicast.
 * @addr: Pointer to a six-byte array containing the Ethernet address
 *
 * Return true if the address is a multicast address.
 * By definition the broadcast address is also a multicast address.
 *//**
 * is_zero_ethaddr - Determine if give Ethernet address is all zeros.
 * @addr: Pointer to a six-byte array containing the Ethernet address
 *
 * Return true if the address is all zeroes.
 *//* copy ulong *//* copy IP *//* write IP *in network byteorder* *//* return ulong *in network byteorder* *//* return IP *in network byteorder* *//*
 * The following functions are a bit ugly, but necessary to deal with
 * alignment restrictions on ARM.
 *
 * We're using inline functions, which had the smallest memory
 * footprint in our tests.
 *//*
 * Check if autoload is enabled. If so, use either NFS or TFTP to download
 * the boot file.
 *//* Processes a received packet *//*
 * Transmit "net_tx_packet" as UDP packet, performing ARP request if needed
 *  (ether will be populated)
 *
 * @param ether Raw packet buffer
 * @param dest IP address to send the datagram to
 * @param dport Destination UDP port
 * @param sport Source UDP port
 * @param payload_len Length of data after the UDP header
 *//* Currently no way to return errors from eth_send() *//* Transmit a packet *//*
 * net_get_async_tx_pkt_buf - Get a packet buffer that is not in use for
 *			      sending an asynchronous reply
 *
 * returns - ptr to packet buffer
 *//* Network loop state *//* Set timeout handler *//* Set ICMP RX handler *//* Waiting for ARP reply? *//* Set ARP RX packet handler *//* Get ARP RX packet handler *//* Set UDP RX packet handler *//* Get UDP RX packet handler *//* Callbacks *//**
 * ip_checksum_ok() - check if a checksum is correct
 *
 * This works by making sure the checksum sums to 0
 *
 * @addr:	Address to check (must be 16-bit aligned)
 * @nbytes:	Number of bytes to check (normally a multiple of 2)
 * @return true if the checksum matches, false if not
 *//**
 * add_ip_checksums() - add two IP checksums
 *
 * @offset:	Offset of first sum (if odd we do a byte-swap)
 * @sum:	First checksum
 * @new_sum:	New checksum to add
 * @return updated 16-bit IP checksum
 *//**
 * compute_ip_checksum() - Compute IP checksum
 *
 * @addr:	Address to check (must be 16-bit aligned)
 * @nbytes:	Number of bytes to check (normally a multiple of 2)
 * @return 16-bit IP checksum
 *//* Set IP header *//* Set ethernet header; returns the size of the header *//* Get size of the ethernet header when we send *//* Load failed.	 Start again. *//* Initialize the network adapter *//* offset time from UTC *//* the ip address to NTP *//*
 * Check for a CDP packet by examining the received MAC address field
 *//* CDP returned appliance VLAN *//* CDP returned native VLAN *//* when CDP completes these hold the return values *//* the ip address to ping *//* the env var to put the ip into *//* The host to resolve  *//* Boot file size in blocks as reported by the DHCP server *//* The actual transferred size of the bootfile (in bytes) *//* Indicates whether the file name was specified on the command line *//* Boot File name *//* Tried all network devices *//* Our Native VLAN *//* Our VLAN *//* mask of valid vlan id *//* untagged *//* Ethernet broadcast address *//* Current rx packet length *//* Current receive packet *//* Receive packets *//* THE transmit packet *//* Server IP addr (0 = unknown) *//* Our    IP addr (0 = unknown) *//* Boot server enet address *//* Our ethernet address *//** END OF BOOTP EXTENTIONS **//* Our root path *//* Our hostname *//* Our IS domain *//* Our 2nd Domain Name Server (0 = unknown) *//* Our Domain Name Server (0 = unknown) *//* Our subnet mask (0 = unknown) *//* Our gateway IP address *//** BOOTP EXTENTIONS **//* net.c *//*
 *	Globals.
 *
 * Note:
 *
 * All variables of type struct in_addr are stored in NETWORK byte order
 * (big endian).
 *//*
 * Maximum receive ring size; that is, the number of packets
 * we can buffer before overflow happens. Basically, this just
 * needs to be enough to prevent a packet being discarded while
 * we are processing the previous one.
 *//*
 * Maximum packet size; used to allocate packet storage. Use
 * the maxium Ethernet frame size as specified by the Ethernet
 * standard including the 802.1Q tag (VLAN tagging).
 * maximum packet size =  1522
 * maximum packet size and multiple of 32 bytes =  1536
 *//* Port unreachable		*//* Codes for NOT_REACH *//* Redirect Host		*//* Redirect Net			*//* Codes for REDIRECT. *//* Echo request			*//* Redirect (change route)	*//* Detination unreachable	*//* Echo reply			*//*
 * ICMP stuff (just enough to handle (host) redirect messages)
 *//* Size assuming ethernet	*//* Target protocol address	*//* Target hardware address	*//* Sender protocol address	*//* Sender hardware address	*//*
	 * The remaining fields are variable in size, according to
	 * the sizes above, and are defined as appropriate for
	 * specific hardware/protocol combinations.
	 *//* Response to previous request *//* Request  to resolve  address	*//* Response to previous request	*//* Operation			*//* Length of protocol address	*//* Length of hardware address	*//* Format of protocol address	*//* Ethernet  hardware address	*//* Format of hardware address	*//*
 *	Address Resolution Protocol (ARP) header.
 *//* Checksum			*//* Length of UDP packet		*//* UDP destination port		*//* UDP source port		*//* Destination IP address	*//* Source IP address		*//* checksum			*//* protocol			*//* time to live			*//* fragment offset field	*//* identification		*//* total length			*//* type of service		*//* header length and version	*//*
 *	Internet Protocol (IP) + UDP header.
 *//* more fragments *//* don't fragments *//* first 3 bits *//* ip offset *= 8 *//*
 *	Internet Protocol (IP) header.
 *//* User Datagram Protocol		*//* Internet Control Message Protocol	*//* IEEE 802.1q protocol		*//* IP ARP protocol		*//* ether-wake WoL protocol	*//* IP protocol			*//* VLAN Ethernet header size *//* protocol type	*//* TAG of VLAN		*//* PROT_VLAN		*//* Source node		*//* Destination node	*//*
 *	Virtual LAN Ethernet header
 *//* 802 + SNAP + ethernet header size *//* 802 protocol		*//* SNAP			*//* 802 control		*//* 802 SSAP		*//* 802 DSAP		*//* Protocol or length	*//* Octets in the FCS		*//* Ethernet header size *//*
 *	Ethernet header
 *//*
 *	Protocol headers.
 *//* get name of current device *//* stop SCC *//* Check for received packets *//* Receive a packet*//* Send a packet *//* Initialize the device *//*
 * Get the hardware address for an ethernet interface .
 * Args:
 *	base_name - base name for device (normally "eth")
 *	index - device index number (0 for first)
 *	enetaddr - returns 6 byte hardware address
 * Returns:
 *	Return true if the address is valid.
 *//*
 * Initialize USB ethernet device with CONFIG_DM_ETH
 * Returns:
 *	0 is success, non-zero is error status.
 *//**
 * eth_env_set_enetaddr_by_index() - set the MAC address environment variable
 *
 * This sets up an environment variable with the given MAC address (@enetaddr).
 * The environment variable to be set is defined by <@base_name><@index>addr.
 * If @index is 0 it is omitted. For common Ethernet this means ethaddr,
 * eth1addr, etc.
 *
 * @base_name:  Base name for variable, typically "eth"
 * @index:      Index of interface being updated (>=0)
 * @enetaddr:   Pointer to MAC address to put into the variable
 * @return 0 if OK, other value on error
 *//* get the device index *//* set nterface to ethcur var *//* Change the device *//* Initialize network subsystem *//*
 * Set the hardware address for an ethernet interface based on 'eth%daddr'
 * environment variable (or just 'ethaddr' if eth_number is 0).
 * Args:
 *	base_name - base name for device (normally "eth")
 *	eth_number - value of %d (0 for first device of this type)
 * Returns:
 *	0 is success, non-zero is error status from driver.
 *//* Set passive state *//* Set active state *//* Test device for active state *//* Used only when NetConsole is enabled *//* get the current device MAC *//* get dev @ index *//* Remove network device *//* Register network device *//*
 * The devname can be either an exact name given by the driver or device tree
 * or it can be an alias of the form "eth%d"
 *//* get the current device *//**
 * struct eth_ops - functions of Ethernet MAC controllers
 *
 * start: Prepare the hardware to send and receive packets
 * send: Send the bytes passed in "packet" as a packet on the wire
 * recv: Check if the hardware received a packet. If so, set the pointer to the
 *	 packet buffer in the packetp parameter. If not, return an error or 0 to
 *	 indicate that the hardware receive FIFO is empty. If 0 is returned, the
 *	 network stack will not process the empty packet, but free_pkt() will be
 *	 called if supplied
 * free_pkt: Give the driver an opportunity to manage its packet buffer memory
 *	     when the network stack is finished processing it. This will only be
 *	     called when no error was returned from recv - optional
 * stop: Stop the hardware from looking for packets - may be called even if
 *	 state == PASSIVE
 * mcast: Join or leave a multicast group (for TFTP) - optional
 * write_hwaddr: Write a MAC address to the hardware (used to pass it to Linux
 *		 on some platforms like ARM). This function expects the
 *		 eth_pdata::enetaddr field to be populated. The method can
 *		 return -ENOSYS to indicate that this is not implemented for
		 this hardware - optional.
 * read_rom_hwaddr: Some devices have a backup of the MAC address stored in a
 *		    ROM on the board. This is how the driver should expose it
 *		    to the network stack. This function should fill in the
 *		    eth_pdata::enetaddr field - optional
 *//*
	 * Check hardware device for new packets (otherwise only return those
	 * which are already in the memory buffer ready to process)
	 *//**
 * struct eth_pdata - Platform data for Ethernet MAC controllers
 *
 * @iobase: The base address of the hardware registers
 * @enetaddr: The Ethernet MAC address that is loaded from EEPROM or env
 * @phy_interface: PHY interface to use - see PHY_INTERFACE_MODE_...
 * @max_speed: Maximum speed of Ethernet connection supported by MAC
 * @priv_pdata: device specific platdata
 *//*
 *	A timeout handler.  Called after time interval has expired.
 *//**
 * An incoming ICMP packet handler.
 * @param type	ICMP type
 * @param code	ICMP code
 * @param dport	destination UDP port
 * @param sip	source IP address
 * @param sport	source UDP port
 * @param pkt	pointer to the ICMP packet data
 * @param len	packet length
 *//**
 * An incoming packet handler.
 * @param pkt    pointer to the application packet
 * @param dport  destination UDP port
 * @param sip    source IP address
 * @param sport  source UDP port
 * @param len    packet length
 *//* IPv4 addresses are always 32 bits in size *//*
 * The size of a MAC address in string form, each digit requires two chars
 * and five separator characters to form '00:00:00:00:00:00'.
 *//* ARP hardware address length *//*
 *	The number of receive packet buffers, and the required packet buffer
 *	alignment in memory.
 *
 *//* Internal network state changes *//* Packets on info on the network at large *//* Packets or info directed to the device *//* Link local state machine changes *//* for nton* / ntoh* stuff *//*
 *	LiMon Monitor (LiMon) - Network.
 *
 *	Copyright 1994 - 2000 Neil Russell.
 *	(See License)
 *
 * History
 *	9/16/00	  bor  adapted to TQM823L/STK8xxL board, RARP/TFTP boot added
 */pkt_lenetxetdest_ethaddrmcast_addrjoinbase_namefirst_restart/opt/src/common/malloc_simple.cmalloc_simple_info"malloc_simple: %lx bytes used, %lx remain\n", gd->malloc_ptr, CONFIG_VAL(SYS_MALLOC_F_LEN) - gd->malloc_ptr"malloc_simple: %lx bytes used, %lx remain\n"gd->malloc_ptr, CONFIG_VAL(SYS_MALLOC_F_LEN) - gd->malloc_ptrlog_info("malloc_simple: %lx bytes used, %lx remain\n", gd->malloc_ptr,
		 CONFIG_VAL(SYS_MALLOC_F_LEN) - gd->malloc_ptr)common/malloc_simple.cmalloc_simple: %lx bytes used, %lx remain
"aligned to %lx\n", (ulong)ptr"aligned to %lx\n"(ulong)ptrlog_debug("aligned to %lx\n", (ulong)ptr)aligned to %lx
"%lx\n", (ulong)ptr"%lx\n"log_debug("%lx\n", (ulong)ptr)%lx
alloc_simplegd->malloc_base + gd->malloc_ptr(gd->malloc_base + gd->malloc_ptr)(typeof(gd->malloc_base + gd->malloc_ptr))(align)-1ALIGN(gd->malloc_base + gd->malloc_ptr, align)new_ptr"size=%zx, ptr=%lx, limit=%lx: ", bytes, new_ptr, gd->malloc_limit"size=%zx, ptr=%lx, limit=%lx: "bytes, new_ptr, gd->malloc_limitlog_debug("size=%zx, ptr=%lx, limit=%lx: ", bytes, new_ptr,
		  gd->malloc_limit)size=%zx, ptr=%lx, limit=%lx: "alloc space exhausted\n"log_err("alloc space exhausted\n")alloc space exhausted
sizeof(new_ptr)(new_ptr)(typeof(new_ptr))(sizeof(new_ptr))-1ALIGN(new_ptr, sizeof(new_ptr))/*
 * Simple malloc implementation
 *
 * Copyright (c) 2014 Google, Inc
 *//opt/src/common/memsize.cvolatile longvolatile long *long[31]BITS_PER_LONGBITS_PER_LONG - 1save_basesync()CONFIG_VERY_BIG_RAM/* limit stack to what we can reasonable map *//* warning: don't restore save_base in this case,
			 * it is already done in the loop because
			 * base and base+size share the same physical memory
			 * and *base is saved after *(base+size) modification
			 * in first loop
			 *//*
			 * Restore the original data
			 * before leaving the function.
			 *//* pointer arith! *//* Restore the original data before leaving the function. *//*
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 *//* for sync() *//*
 * At least on G2 PowerPC cores, sequential accesses to non-existent
 * memory must be synchronized.
 *//*
 * (C) Copyright 2004
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *//opt/src/common/menu.cmenu_item *sizeof *msizeof *itemmenu_interactive_choicechoice_itemcbufreadretEnter choice: "Enter choice: "%s not found
"%s not found\n"EINTR-EINTRmenu_item_by_keymenu_item_key_matchmenu_displaymenu_item_destroymenu_item_printmenu_items_iter&m->itemsstruct menu_itemlist_entry(pos, struct menu_item, list)menu_itemitem_cntitemsdefault_item/*
 * menu_destroy() - frees the memory used by a menu and its items.
 *
 * m - Points to a menu created by menu_create().
 *
 * Returns 1 if successful, or -EINVAL if m is NULL.
 *//*
 * menu_create() - Creates a menu handle with default settings
 *
 * title - If not NULL, points to a string that will be displayed before the
 * list of menu items. It will be copied to internal storage, and is safe to
 * discard after passing to menu_create().
 *
 * timeout - A delay in seconds to wait for user input. If 0, timeout is
 * disabled, and the default choice will be returned unless prompt is 1.
 *
 * prompt - If 0, don't ask for user input unless there is an interrupted
 * timeout. If 1, the user will be prompted for input regardless of the value
 * of timeout.
 *
 * item_data_print - If not NULL, will be called for each item when the menu
 * is displayed, with the pointer to the item's data passed as the argument.
 * If NULL, each item's key will be printed instead.  Since an item's key is
 * what must be entered to select an item, the item_data_print function should
 * make it obvious what the key for each entry is.
 *
 * item_choice - If not NULL, will be called when asking the user to choose an
 * item. Returns a key string corresponding to the chosen item or NULL if
 * no item has been selected.
 *
 * item_choice_data - Will be passed as the argument to the item_choice function
 *
 * Returns a pointer to the menu if successful, or NULL if there is
 * insufficient memory available to create the menu.
 *//*
 * menu_item_add() - Adds or replaces a menu item. Note that this replaces the
 * data of an item if it already exists, but doesn't change the order of the
 * item.
 *
 * m - Points to a menu created by menu_create().
 *
 * item_key - Points to a string that will uniquely identify the item.  The
 * string will be copied to internal storage, and is safe to discard after
 * passing to menu_item_add.
 *
 * item_data - An opaque pointer associated with an item. It is never
 * dereferenced internally, but will be passed to the item_data_print, and
 * will be returned from menu_get_choice if the menu item is selected.
 *
 * Returns 1 if successful, -EINVAL if m is NULL, or -ENOMEM if there is
 * insufficient memory to add the menu item.
 *//*
 * menu_get_choice() - Returns the user's selected menu entry, or the default
 * if the menu is set to not prompt or the timeout expires. This is safe to
 * call more than once.
 *
 * m - Points to a menu created by menu_create().
 *
 * choice - Points to a location that will store a pointer to the selected
 * menu item. If no item is selected or there is an error, no value will be
 * written at the location it points to.
 *
 * Returns 1 if successful, -EINVAL if m or choice is NULL, -ENOENT if no
 * default has been set and the menu is set to not prompt or the timeout
 * expires, or -EINTR if the user exits the menu via ^c.
 *//*
 * menu_default_set() - Sets the default choice for the menu. This is safe to
 * call more than once on a menu.
 *
 * m - Points to a menu created by menu_create().
 *
 * item_key - Points to a string that, when compared using strcmp, matches the
 * key for an existing item in the menu.
 *
 * Returns 1 if successful, -EINVAL if m is NULL, or -ENOENT if no item with a
 * key matching item_key is found.
 *//*
 * Displays the menu and asks the user to choose an item. *choice will point
 * to the private data of the item the user chooses. The user makes a choice
 * by inputting a string matching the key of an item. Invalid choices will
 * cause the user to be prompted again, repeatedly, until the user makes a
 * valid choice. The user can exit the menu without making a choice via ^c.
 *
 * Returns 1 if the user made a choice, or -EINTR if they bail via ^c.
 *//*
 * Set *choice to point to the default item's data, if any default item was
 * set, and returns 1. If no default item was set, returns -ENOENT.
 *//*
 * Find the first item with a key matching item_key, if any exists.
 *//*
 * Check if an item's key matches a provided string, pointed to by extra. If
 * extra is NULL, an item with a NULL key will match. Otherwise, the item's
 * key has to match according to strcmp.
 *
 * This is called via menu_items_iter, so it returns a pointer to the item if
 * the key matches, and returns NULL otherwise.
 *//*
 * Display a menu so the user can make a choice of an item. First display its
 * title, if any, and then each item in the menu.
 *//*
 * Free the memory used by a menu item. This includes the memory used by its
 * key.
 *//*
 * Print a menu_item. If the consumer provided an item_data_print function
 * when creating the menu, call it with a pointer to the item's private data.
 * Otherwise, print the key of the item.
 *//*
 * An iterator function for menu items. callback will be called for each item
 * in m, with m, a pointer to the item, and extra being passed to callback. If
 * callback returns a value other than NULL, iteration stops and the value
 * return by callback is returned from menu_items_iter.  This allows it to be
 * used for search type operations. It is also safe for callback to remove the
 * item from the list of items.
 *//*
 * The menu is composed of a list of items along with settings and callbacks
 * provided by the user. An incomplete definition of this struct is available
 * in menu.h, but the full definition is here to prevent consumers from
 * relying on its contents.
 *//*
 * Internally, each item in a menu is represented by a struct menu_item.
 *
 * These items will be alloc'd and initialized by menu_item_add and destroyed
 * by menu_item_destroy, and the consumer of the interface never sees that
 * this struct is used at all.
 *//*
 * Copyright 2010-2011 Calxeda, Inc.
 * Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.
 *//opt/src/common/miiphyutil.cmiiphyutilbmcrPHY duplex"PHY duplex"anlparPHY AN duplex"PHY AN duplex"PHY AN adv duplex"PHY AN adv duplex"LPA_10FULL | LPA_100FULL read failed, assuming half duplex
" read failed, assuming half duplex\n"PHY speed"PHY speed"PHY AN speed"PHY AN speed"PHY AN adv speed"PHY AN adv speed" read failed, assuming 10BASE-T
" read failed, assuming 10BASE-T\n""PHY ID register 2 read failed\n""PHY ID register 1 read failed\n"0x0000003F"MII_PHYSID2 @ 0x%x = 0x%04x\n"addr, reg"PHY_PHYIDR[1,2] @ 0x%x = 0x%08x\n"MII devices: "MII devices: "&mii_devsstruct mii_devlist_entry(entry, struct mii_dev, link)'%s' "'%s' "Current device: '%s'
"Current device: '%s'\n"miiphy_read_failedmiiphy_get_active_dev%s is not a known ethernet
"%s is not a known ethernet\n"No such device: %s
"No such device: %s\n"%x - %s"%x - %s" <--> %s
" <--> %s\n"eth%d"eth%d"mdio_register: non unique device name '%s'
"mdio_register: non unique device name '%s'\n"344sizeof(*bus)NULL device name!
"NULL device name!\n"current_miimii_devsdebugMII_DEBUGCONFIG_PHYLIBCONFIG_PHY_RESET_DELAYdefined(CONFIG_PHY_GIGE)/* Determine if a link is active *//* dummy read; needed to latch some phys *//*****************************************************************************
 *
 * Determine link status
 *//*****************************************************************************
 *
 * Return 1 if PHY supports 1000BASE-X, 0 if PHY supports 10BASE-T/100BASE-TX/
 * 1000BASE-T, or on error.
 *//* Get speed from basic control settings. *//* Get auto-negotiation results. *//* Check if auto-negotiation is on. *//* Check Basic Management Control Register first. *//* CONFIG_PHY_GIGE *//* Check for 1000BASE-T. *//*
	 * No 1000BASE-X, so assume 1000BASE-T/100BASE-TX/10BASE-T register set.
	 *//* 1000BASE-X *//* Check for 1000BASE-X. *//*****************************************************************************
 *
 * Determine full/half duplex.  Return half on error.
 *//*
	 * Check for 1000BASE-X.  If it is supported, then assume that the speed
	 * is 1000.
	 *//*****************************************************************************
 *
 * Determine the ethernet speed (10/100/1000).  Return 10 on error.
 *//* !PHYLIB *//*
	 * Poll the control register for the reset bit to go to 0 (it is
	 * auto-clearing).  This should happen within 0.5 seconds per the
	 * IEEE spec.
	 *//* Intel LXT971A needs this *//*****************************************************************************
 *
 * Reset the PHY.
 *
 * This API is deprecated. Use PHYLIB.
 *
 * Returns:
 *   0 on success
 *//* No physical device present at this address *//*****************************************************************************
 *
 * Read the OUI, manufacture's model number, and revision number.
 *
 * OUI:     22 bits (unsigned int)
 * Model:    6 bits (unsigned char)
 * Revision: 4 bits (unsigned char)
 *
 * This API is deprecated.
 *
 * Returns:
 *   0 on success
 *//*****************************************************************************
 *
 * Print out list of registered MII capable devices.
 *//*****************************************************************************
 *
 * Write <value> to the PHY attached to device <devname>,
 * use PHY address <addr> and register <reg>.
 *
 * This API is deprecated. Use phy_write on a phy_device found by phy_connect
 *
 * Returns:
 *   0 on success
 *//*****************************************************************************
 *
 * Read to variable <value> from the PHY attached to device <devname>,
 * use PHY address <addr> and register <reg>.
 *
 * This API is deprecated. Use phy_read on a phy_device found via phy_connect
 *
 * Returns:
 *   0 on success
 *//* Otherwise, set the active one to the one we want *//* If the current mii is the one we want, return it *//* delete it from the list *//* Setup a unique name for each mdio bus *//* add it to the list *//* check if we have unique name *//* initalize mii_dev struct fields *//*****************************************************************************
 *
 * Initialize global data. Need to be called before any other miiphy routine.
 *//*
 * Lookup the mii_dev struct by the registered device name.
 *//* MII_DEBUG *//* local debug macro *//*
 * This provides a bit-banged interface to the ethernet MII management
 * channel.
 *//*
 * (C) Copyright 2001
 * Gerald Van Baren, Custom IDEAS, vanbaren@cideas.com.
 */ethname/opt/src/common/s_record.chex2_binhex1_bin(SREC_EMPTY)(SREC_E_NOSREC)srec_type'2''5'(SREC_E_BADTYPE)(SREC_E_BADCHKS)/* read anc check checksum *//* convert data and calculate checksum *//* 2 byte addr field	*//* FALL THRU *//* 3 byte addr field	*//* 4 byte addr field	*//* read address field *//* - checksum and addr	*//* end record with a	*//***	case '6' -- not used  ***//* no data		*//* a 2 byte record counter	*//* count record, addr field contains *//***	case '4'  ***//* data record with a	*//* start record		*//* record type		*//* no more data?	*//* skip 'S' *//* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 *//* buffer for checksum	*//* S-Record type	*//* conversion buffer	*//opt/src/common/splash.csplashpos"splashpos"splash_location[4]default_splash_locationsARRAY_SIZE(default_splash_locations)splash_location[]"sf"mmc_fs"mmc_fs"0:1"0:1"usb_fs"usb_fs"sata_fs"sata_fs"/*
 * Common function to show a splash image if env("splashimage") is set.
 * Is used for both dm_video and lcd video stacks. For additional
 * details please refer to doc/README.splashprepare.
 *//* CONFIG_SPLASH_SCREEN_ALIGN *//*
 * Copyright (C) 2013, Boundary Devices <info@boundarydevices.com>
 *
 * See file CREDITS for list of people who contributed to this
 * project.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., http://www.fsf.org/about/contact/
 *
 *//opt/src/common/stdio.cUCLASS_KEYBOARDFailed to probe keyboard '%s'
"Failed to probe keyboard '%s'\n"stdio_dev *[3]char[3][16]temp_nameschar(*)[16]nulldev"nulldev"sizeof(temp_names[l])&(devs.list)_devsizeof(struct stdio_dev)vidconsole"vidconsole"stdio_probe_device"No %s device for seq %d (%s)\n"uclass_get_name(id), seq, namedebug("No %s device for seq %d (%s)\n", uclass_get_name(id),
		      seq, name)common/stdio.cNo %s device for seq %d (%s)
&devs.list(&devs.list)->prevlist_last_entry(&devs.list, struct stdio_dev, list)"Device '%s' did not register with stdio as '%s'\n"dev->name, namedebug("Device '%s' did not register with stdio as '%s'\n",
		      dev->name, name)Device '%s' did not register with stdio as '%s'
drv_system_initsizeof (dev)DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUTstdio_serial_tstcstdio_serial_getcstdio_serial_putsstdio_serial_putcnulldev_inputnulldev_putsnulldev_putcdevsCONFIG_SYS_DEVICE_NULLDEVdefined(CONFIG_SPLASH_SCREEN) && !defined(CONFIG_SYS_DEVICE_NULLDEV)CONFIG_DM_KEYBOARDdefined(CONFIG_KEYBOARD) && !defined(CONFIG_DM_KEYBOARD)/* CONFIG_SPLASH_SCREEN && CONFIG_CMD_BMP *//* !CONFIG_SYS_CONSOLE_IS_IN_ENV *//*
	 * If the console setting is not in environment variables then
	 * console_init_r() will not be calling iomux_doenv() (which calls
	 * search_device()). So we will not dynamically add devices by
	 * calling stdio_probe_device().
	 *
	 * So just probe all video devices now so that whichever one is
	 * required will be available.
	 *//* Don't report errors to the caller - assume that they are non-fatal *//*
	 * For now we probe all the devices here. At some point this should be
	 * done only when the devices are required - e.g. we have a list of
	 * input devices to start up in the stdin environment variable. That
	 * work probably makes more sense when stdio itself is converted to
	 * driver model.
	 *
	 * TODO(sjg@chromium.org): Convert changing uclass_first_device() etc.
	 * to return the device even on error. Then we could use that here.
	 *//* Initialize the list *//* CONFIG_NEEDS_MANUAL_RELOC *//* relocate device name pointers *//* already relocated for current ARM implementation *//* CONFIG_IS_ENABLED(SYS_STDIO_DEREGISTER) *//* device not found *//* reassign Device list *//* Device is assigned -> report error *//* get stdio devices (ListRemoveItem changes the dev list) *//* deregister the device "devname".
 * returns 0 if success, -1 if device is assigned and 1 if devname not found
 *//*
	 * We did not find a suitable stdio device. If there is a video
	 * driver with a name starting with 'vidconsole', we can try probing
	 * that in the hope that it will produce the required stdio device.
	 *
	 * This function is sometimes called with the entire value of
	 * 'stdout', which may include a list of devices separate by commas.
	 * Obviously this is not going to work, so we ignore that case. The
	 * call path in that case is console_init_r() -> search_device() ->
	 * stdio_get_by_name().
	 *//* The device should be be the last one registered *//**
 * stdio_probe_device() - Find a device which provides the given stdio device
 *
 * This looks for a device of the given uclass which provides a particular
 * stdio device. It is currently really only useful for UCLASS_VIDEO.
 *
 * Ultimately we want to be able to probe a device by its stdio name. At
 * present devices register in their probe function (for video devices this
 * is done in vidconsole_post_probe()) and we don't know what name they will
 * use until they do so.
 * TODO(sjg@chromium.org): We should be able to determine the name before
 * probing, and probe the required device.
 *
 * @name:	stdio device name (e.g. "vidconsole")
 * id:		Uclass ID of device to look for (e.g. UCLASS_VIDEO)
 * @sdevp:	Returns stdout device, if found, else NULL
 * @return 0 if found, -ENOENT if no device found with that name, other -ve
 *	   on other error
 *//**************************************************************************
 * DEVICES
 **************************************************************************
 *//**************************************************************************
 * SYSTEM DRIVERS
 **************************************************************************
 *//* nulldev is empty! *//*
 * Copyright (C) 2009 Sergey Kubushyn <ksi@koi8.net>
 *
 * Changes for multibus/multiadapter I2C support.
 *
 * (C) Copyright 2000
 * Paolo Scaffardi, AIRVENT SAM s.p.a - RIMINI(ITALY), arsenio@tin.it
 */sdevp/opt/src/common/usb.cttdevuparentError: Cannot find high speed parent of usb-1 device
"Error: Cannot find high speed parent of usb-1 device\n"&dev->descriptor.bcdUSBle16_to_cpus&dev->descriptor.idVendor&dev->descriptor.idProduct&dev->descriptor.bcdDeviceusb_new_device: Cannot read configuration, skipping device %04x:%04x
"usb_new_device: Cannot read configuration, " \
		       "skipping device %04x:%04x\n"failed to set default configuration len %d, status %lX
"failed to set default configuration " \
			"len %d, status %lX\n""new device strings: Mfr=%d, Product=%d, SerialNumber=%d\n"dev->descriptor.iManufacturer, dev->descriptor.iProduct, dev->descriptor.iSerialNumberdebug("new device strings: Mfr=%d, Product=%d, SerialNumber=%d\n",
	      dev->descriptor.iManufacturer, dev->descriptor.iProduct,
	      dev->descriptor.iSerialNumber)common/usb.c1131new device strings: Mfr=%d, Product=%d, SerialNumber=%d
sizeof(dev->mf)sizeof(dev->prod)sizeof(dev->serial)"Manufacturer %s\n"dev->mfdebug("Manufacturer %s\n", dev->mf)1144Manufacturer %s
"Product      %s\n"dev->proddebug("Product      %s\n", dev->prod)1145Product      %s
"SerialNumber %s\n"dev->serialdebug("SerialNumber %s\n", dev->serial)1146SerialNumber %s
usb_prepare_deviceCannot allocate device context to get SLOT_ID
"Cannot allocate device context to get SLOT_ID\n"
      USB device not accepting new address (error=%lX)
"\n      USB device not accepting new address " \
			"(error=%lX)\n"usb_setup_descriptor%s: invalid max packet size
"%s: invalid max packet size\n"get_descriptor_lenUSB_BUFSIZPAD_SIZE((512) * sizeof(unsigned char), 1)(((((512) * sizeof(unsigned char)) - 1) / (1) + 1) * 1)(512) * sizeof(unsigned char)(uintptr_t)__tmpbuf((uintptr_t)__tmpbuf)(typeof((uintptr_t)__tmpbuf))(16)-1char[527]ALLOC_CACHE_ALIGN_BUFFER(unsigned char, tmpbuf, USB_BUFSIZ)__tmpbufunable to get device descriptor (error=%d)
"unable to get device descriptor (error=%d)\n"USB device descriptor short read (expected %i, got %i)
"USB device descriptor short read (expected %i, got %i)\n"sizeof(dev->descriptor)expect_lenusb_hub_port_resetmybuf(uintptr_t)__mybuf((uintptr_t)__mybuf)(typeof((uintptr_t)__mybuf))(16)-1tbufALLOC_CACHE_ALIGN_BUFFER(unsigned char, mybuf, USB_BUFSIZ)__mybuf"error getting string descriptor 0 " "(error=%lx)\n"dev->statusdebug("error getting string descriptor 0 " \
			      "(error=%lx)\n", dev->status)812error getting string descriptor 0 (error=%lx)
"error getting string descriptor 0 " \
			      "(error=%lx)\n""string descriptor 0 too short\n"debug("string descriptor 0 too short\n")string descriptor 0 too short
"USB device number %d default " "language ID 0x%x\n"dev->devnum, dev->string_langiddebug("USB device number %d default " \
			      "language ID 0x%x\n",
			      dev->devnum, dev->string_langid)824USB device number %d default language ID 0x%x
"USB device number %d default " \
			      "language ID 0x%x\n"usb_string_subusb_try_string_workaroundsnewlengtholdlengthbuf[newlength]isprint(buf[newlength])usb_get_stringlangidusb_rcvctrlpipe(dev, 0)USB_DT_STRING << 8(USB_DT_STRING << 8)USB_RECIP_INTERFACE | USB_DIR_INUSB_DIR_IN | USB_TYPE_CLASSUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACEUSB_TYPE_CLASS | USB_RECIP_INTERFACEusb_set_configuration"set configuration %d\n"configurationdebug("set configuration %d\n", configuration)660set configuration %d
if_faceselecting invalid interface %d"selecting invalid interface %d"USB_CNTL_TIMEOUT * 5usb_set_address"set address %d\n"dev->devnumdebug("set address %d\n", dev->devnum)610set address %d
"get_conf_no %d Result %d, wLength %d\n"cfgno, result, le16_to_cpu(config->wTotalLength)debug("get_conf_no %d Result %d, wLength %d\n", cfgno, result,
	      le16_to_cpu(config->wTotalLength))598get_conf_no %d Result %d, wLength %d
config->wTotalLengthPAD_SIZE((9) * sizeof(unsigned char), 1)(((((9) * sizeof(unsigned char)) - 1) / (1) + 1) * 1)(9) * sizeof(unsigned char)ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, 9)unable to get descriptor, error %lX
"unable to get descriptor, error %lX\n"config descriptor too short (expected %i, got %i)
"config descriptor too short " \
				"(expected %i, got %i)\n"usb_get_descriptorUSB_CNTL_TIMEOUT * 3usb_endpoint_running(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe))usb_settoggle(dev, usb_pipeendpoint(pipe), usb_pipeout(pipe), 0)usb_parse_configifnoepnocurr_if_num ERROR: NOT USB_CONFIG_DESC %x
" ERROR: NOT USB_CONFIG_DESC %x\n"ERROR: Invalid USB CFG length (%d)
"ERROR: Invalid USB CFG length (%d)\n"ERROR: Invalid USB IF length (%d)
"ERROR: Invalid USB IF length (%d)\n"USB IF descriptor overflowed buffer!
"USB IF descriptor overflowed buffer!\n"Too many USB interfaces!
"Too many USB interfaces!\n"ERROR: Invalid USB EP length (%d)
"ERROR: Invalid USB EP length (%d)\n"USB EP descriptor overflowed buffer!
"USB EP descriptor overflowed buffer!\n"Endpoint descriptor out of order!
"Endpoint descriptor out of order!\n"Interface %d has too many endpoints!
"Interface %d has too many endpoints!\n"ep_wMaxPacketSize&dev->config. if_desc[ifno]. ep_desc[epno]. wMaxPacketSize__gu_ple16_to_cpu(ep_wMaxPacketSize)((__u16)(__le16)(ep_wMaxPacketSize))"if %d, ep %d\n"ifno, epnodebug("if %d, ep %d\n", ifno, epno)474if %d, ep %d
ERROR: Invalid USB EPC length (%d)
"ERROR: Invalid USB EPC length (%d)\n"USB EPC descriptor overflowed buffer!
"USB EPC descriptor overflowed buffer!\n"EPC descriptor out of order!
"EPC descriptor out of order!\n""unknown Description Type : %x\n"head->bDescriptorTypedebug("unknown Description Type : %x\n",
			      head->bDescriptorType)unknown Description Type : %x
usb_set_maxpacketusb_set_maxpacket_ep&ep->wMaxPacketSize"##Control EP epmaxpacketout/in[%d] = %d\n"b, dev->epmaxpacketin[b]debug("##Control EP epmaxpacketout/in[%d] = %d\n",
		      b, dev->epmaxpacketin[b])##Control EP epmaxpacketout/in[%d] = %d
"##EP epmaxpacketout[%d] = %d\n"b, dev->epmaxpacketout[b]debug("##EP epmaxpacketout[%d] = %d\n",
				      b, dev->epmaxpacketout[b])##EP epmaxpacketout[%d] = %d
"##EP epmaxpacketin[%d] = %d\n"debug("##EP epmaxpacketin[%d] = %d\n",
				      b, dev->epmaxpacketin[b])345##EP epmaxpacketin[%d] = %d
struct devrequestsetup_packetPAD_SIZE((1) * sizeof(struct devrequest), 1)(((((1) * sizeof(struct devrequest)) - 1) / (1) + 1) * 1)(1) * sizeof(struct devrequest)(uintptr_t)__setup_packet((uintptr_t)__setup_packet)(typeof((uintptr_t)__setup_packet))(16)-1ALLOC_CACHE_ALIGN_BUFFER(struct devrequest, setup_packet, 1)__setup_packetif_idxep_idx"usb_control_msg: request: 0x%X, requesttype: 0x%X, " "value 0x%X index 0x%X length 0x%X\n"request, requesttype, value, index, sizedebug("usb_control_msg: request: 0x%X, requesttype: 0x%X, " \
	      "value 0x%X index 0x%X length 0x%X\n",
	      request, requesttype, value, index, size)usb_control_msg: request: 0x%X, requesttype: 0x%X, value 0x%X index 0x%X length 0x%X
"usb_control_msg: request: 0x%X, requesttype: 0x%X, " \
	      "value 0x%X index 0x%X length 0x%X\n"asynch_allowedCONFIG_USB_MAX_CONTROLLER_COUNTCONFIG_USB_XHCI_HCD/* EOF *//* Find out the nearest parent which is high speed *//*
	 * When called from usb-uclass.c: usb_scan_device() udev->dev points
	 * to the parent udevice, not the actual udevice belonging to the
	 * udev as the device is not instantiated yet. So when searching
	 * for the first usb-2 parent start with udev->dev not
	 * udev->dev->parent .
	 *//* Now probe if the device is a hub *//*
	 * XHCI needs to issue a Address device command to setup
	 * proper device context structures, before it can interact
	 * with the device. So a get_descriptor will fail before any
	 * of that is done for XHCI unlike EHCI.
	 *//*
 * By the time we get here, the device has gotten a new device ID
 * and is in the default state. We need to identify the thing and
 * get the ball rolling..
 *
 * Returns 0 for success, != 0 for error.
 *//* We still haven't set the Address yet *//*
	 * Wait until the Set Configuration request gets processed by the
	 * device. This is required by at least SanDisk Cruzer Pop USB 2.0
	 * and Kingston DT Ultimate 32GB USB 3.0 on DWC2 OTG controller.
	 *//*
	 * we set the default configuration here
	 * This seems premature. If the driver wants a different configuration
	 * it will need to select itself.
	 *//* only support for one config for now *//*
	 * Kingston DT Ultimate 32GB USB 3.0 seems to be extremely sensitive
	 * about this first Get Descriptor request. If there are any other
	 * requests in the first microframe, the stick crashes. Wait about
	 * one microframe duration here (1mS for USB 1.x , 125uS for USB 2.0).
	 *//* correct le values *//*
	 * If we haven't read device descriptor before, read it here
	 * after device is assigned an address. This is only applicable
	 * to xHCI so far.
	 *//* Let the SET_ADDRESS settle *//* set address *//*
	 * Allocate usb 3.0 device context.
	 * USB 3.0 (xHCI) protocol tries to allocate device slot
	 * and related data structures first. This call does that.
	 * Refer to sec 4.3.2 in xHCI spec rev1.0
	 *//*
		 * Validate we've received only at least 8 bytes, not that
		 * we've received the entire descriptor. The reasoning is:
		 * - The code only uses fields in the first 8 bytes, so
		 *   that's all we need to have fetched at this stage.
		 * - The smallest maxpacket size is 8 bytes. Before we know
		 *   the actual maxpacket the device uses, the USB controller
		 *   may only accept a single packet. Consequently we are only
		 *   guaranteed to receive 1 packet (at least 8 bytes) even in
		 *   a non-error case.
		 *
		 * At least the DWC2 controller needs to be programmed with
		 * the number of packets in addition to the number of bytes.
		 * A request for 64 bytes of data with the maxpacket guessed
		 * as 64 (above) yields a request for 1 packet.
		 *//*
	 * send 64-byte GET-DEVICE-DESCRIPTOR request.  Since the descriptor is
	 * only 18 bytes long, this will terminate with a short packet.  But if
	 * the maxpacket size is 8 or 16 the device may be waiting to transmit
	 * some more, or keeps on retransmitting the 8 byte header.
	 *//*
	 * This is a Windows scheme of initialization sequence, with double
	 * reset of the device (Linux uses the same sequence)
	 * Some equipment is said to work only with such init sequence; this
	 * patch is based on the work by Alan Stern:
	 * http://sourceforge.net/mailarchive/forum.php?
	 * thread_id=5729457&forum_id=5398
	 *//*
 * XHCI issues Enable Slot command and thereafter
 * allocates device contexts. Provide a weak alias
 * function for the purpose, so that XHCI overrides it
 * and EHCI/OHCI just work out of the box.
 *//*
 * Free the newly created device node.
 * Called in error cases where configuring a newly attached
 * device fails for some reason.
 *//* default Address is 0, real addresses start with 1 *//* returns a pointer to the device with the index [index].
 * if the device is not assigned (dev->devnum==-1) returns NULL
 *//********************************************************************
 * USB device handling:
 * the USB device are static allocated [USB_MAX_DEVICE].
 *//* non-ASCII character *//* high byte *//* leave room for trailing NULL char in output buffer *//* always use the first langid listed *//* get langid for strings if it's not yet known *//********************************************************************
 * usb_string:
 * Get string index and translate it to ascii.
 * returns string length (> 0) or error (< 0)
 *//* force a multiple of two *//* There might be extra junk at the end of the descriptor *//* If that failed try to read the descriptor length, then
	 * ask for just that many bytes *//* Try to read the string descriptor by asking for the maximum
	 * possible number of bytes *//* some devices are flaky *//********************************************************************
 * get string index in buffer
 *//********************************************************************
 * get class descriptor
 *//********************************************************************
 * get report
 *//********************************************************************
 * set idle
 *//********************************************************************
 * set protocol to protocol
 *//* set setup command *//********************************************************************
 * set configuration number to configuration
 *//*
	 * We should return now for devices with only one alternate setting.
	 * According to 9.4.10 of the Universal Serial Bus Specification
	 * Revision 2.0 such devices can return with a STALL. This results in
	 * some USB sticks timeouting during initialization and then being
	 * unusable in U-Boot.
	 *//********************************************************************
 * set interface number to interface
 *//********************************************************************
 * set address of a device to the value in dev->devnum.
 * This can only be done by addressing the device via the default address (0)
 *//* validated, with CPU byte order *//**********************************************************************
 * gets configuration cfgno and store it in the buffer
 *//**********************************************************************
 * gets len of configuration cfgno
 *//**********************************************************************
 * get_descriptor type
 *//* toggle is reset on clear *//*
	 * NOTE: we do not get status and verify reset was successful
	 * as some devices are reported to lock up upon this check..
	 *//* don't clear if failed *//***********************************************************************
 * Clears an endpoint
 * endp: endpoint number in bits 0-3;
 * direction flag in bit 7 (1 = IN, 0 = OUT)
 *//* found an endpoint *//* found alternate setting for the interface *//* try to go on with what we have *//* this is a new interface, copy new desc *//* Ok the first entry must be a configuration entry,
	 * now process the others *//*******************************************************************************
 * Parse the config, located in buffer, and fills the dev->config structure.
 * Note that all little/big endian swapping are done automatically.
 * (wTotalLength has already been swapped and sanitized when it was read.)
 *//*
 * set the max packed value of all endpoints in the given configuration
 *//* if control *//* if out *//* IN Endpoint *//* OUT Endpoint *//* Control => bidirectional *//*
 * The routine usb_set_maxpacket_ep() is extracted from the loop of routine
 * usb_set_maxpacket(), because the optimizer of GCC 4.x chokes on this routine
 * when it is inlined in 1 single routine. What happens is that the register r3
 * is used as loop-count 'i', but gets overwritten later on.
 * This is clearly a compiler bug, but it is easier to workaround it here than
 * to update the compiler (Occurs with at least several GCC 4.{1,2},x
 * CodeSourcery compilers like e.g. 2007q3, 2008q1, 2008q3 lite editions on ARM)
 *
 * NOTE: Similar behaviour was observed with GCC4.6 on ARMv5.
 *//* direction is out -> use emaxpacket out *//*
 * returns the max packet size, depending on the pipe direction and
 * the configurations values
 *//*-------------------------------------------------------------------
 * Max Packet stuff
 *//*not yet processed *//*-------------------------------------------------------------------
 * submits bulk message, and waits for completion. returns 0 if Ok or
 * negative if Error.
 * synchronous behavior
 *//*
	 * Wait for status to update until timeout expires, USB driver
	 * interrupt handler may set the status when the USB operation has
	 * been completed.
	 *//* request for a asynch control pipe is not allowed *//*
 * submits a control message and waits for comletion (at least timeout * 1ms)
 * If timeout is 0, we don't wait for completion (used as example to set and
 * clear keyboards LEDs). For data transfers, (storage transfers) we don't
 * allow control messages with 0 timeout, by previousely resetting the flag
 * asynch_allowed (usb_disable_asynch(1)).
 * returns the transferred length if OK or -1 if error. The transferred length
 * and the current status are stored in the dev->act_len and dev->status.
 *//*
 * submits an Interrupt Message
 *//*-------------------------------------------------------------------
 * Message wrappers.
 *
 *//*
 * disables the asynch behaviour of the control message. This is used for data
 * transfers that uses the exclusiv access to the control and bulk messages.
 * Returns the old value so it can be restored later.
 *//* USB request failed *//******************************************************************************
 * Detect if a USB device has been plugged or unplugged.
 *//******************************************************************************
 * Stop USB this stops the LowLevel Part and deregisters USB devices.
 *//* if we were not able to find at least one working bus, bail out *//*
		 * device 0 is always present
		 * (root hub, so let it analyze)
		 *//*
		 * lowlevel init is OK, now scan the bus for devices
		 * i.e. search HUBs and configure them
		 *//* Other error. *//* No such device. *//* init low_level USB *//* first make all devices unknown *//***************************************************************************
 * Init USB Device
 *//* flag for the started/stopped USB status *//*
 * How it works:
 *
 * Since this is a bootloader, the devices will not be automatic
 * (re)configured on hotplug, but after a restart of the USB the
 * device should work.
 *
 * For each transfer (except "Interrupt") we wait for completion.
 *//*
 * Most of this source has been derived from the Linux USB
 * project:
 * (C) Copyright Linus Torvalds 1999
 * (C) Copyright Johannes Erdfelt 1999-2001
 * (C) Copyright Andreas Gal 1999
 * (C) Copyright Gregory P. Smith 1999
 * (C) Copyright Deti Fliegl 1999 (new USB architecture)
 * (C) Copyright Randy Dunlap 2000
 * (C) Copyright David Brownell 2000 (kernel hotplug, usb_device_id)
 * (C) Copyright Yggdrasil Computing, Inc. 2000
 *     (usb_device_id matching changes by Adam J. Richter)
 *
 * Adapted for U-Boot:
 * (C) Copyright 2001 Denis Peter, MPL AG Switzerland
 *//opt/src/common/usb_hub.cusb_hubusb_hub_post_probedebug("%s\n", __func__)common/usb_hub.c935usb_hub_check"USB hub found\n"debug("USB hub found\n")USB hub found
"USB hub not found: bInterfaceClass=%d, bInterfaceSubClass=%d, bNumEndpoints=%d\n"iface->desc.bInterfaceClass, iface->desc.bInterfaceSubClass, iface->desc.bNumEndpointsdebug("USB hub not found: bInterfaceClass=%d, bInterfaceSubClass=%d, bNumEndpoints=%d\n",
	      iface->desc.bInterfaceClass, iface->desc.bInterfaceSubClass,
	      iface->desc.bNumEndpoints)905USB hub not found: bInterfaceClass=%d, bInterfaceSubClass=%d, bNumEndpoints=%d
"   bEndpointAddress=%#x, bmAttributes=%d"ep->bEndpointAddress, ep->bmAttributesdebug("   bEndpointAddress=%#x, bmAttributes=%d",
		      ep->bEndpointAddress, ep->bmAttributes)908   bEndpointAddress=%#x, bmAttributes=%dusb_hub_configureusb_hub_device *ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, USB_BUFSIZ)"usb_hub_configure: failed to get hub " "descriptor, giving up %lX\n"debug("usb_hub_configure: failed to get hub " \
		      "descriptor, giving up %lX\n", dev->status)628usb_hub_configure: failed to get hub descriptor, giving up %lX
"usb_hub_configure: failed to get hub " \
		      "descriptor, giving up %lX\n"usb_hub_descriptor *descriptor->bLengthsizeof(struct usb_hub_descriptor)min_t(int, descriptor->bLength,
		       sizeof(struct usb_hub_descriptor)min_t(int, descriptor->bLength,
		       sizeof(struct usb_hub_descriptor))"usb_hub_configure: failed to get hub " "descriptor 2nd giving up %lX\n"debug("usb_hub_configure: failed to get hub " \
		      "descriptor 2nd giving up %lX\n", dev->status)639usb_hub_configure: failed to get hub descriptor 2nd giving up %lX
"usb_hub_configure: failed to get hub " \
		      "descriptor 2nd giving up %lX\n"le16_to_cpu(get_unaligned( &descriptor->wHubCharacteristics))((__u16)(__le16)(((typeof(*(&descriptor->wHubCharacteristics)))({ __builtin_choose_expr(sizeof(*(&descriptor->wHubCharacteristics)) == 1, *(&descriptor->wHubCharacteristics), __builtin_choose_expr(sizeof(*(&descriptor->wHubCharacteristics)) == 2, get_unaligned_le16((&descriptor->wHubCharacteristics)), __builtin_choose_expr(sizeof(*(&descriptor->wHubCharacteristics)) == 4, get_unaligned_le32((&descriptor->wHubCharacteristics)), __builtin_choose_expr(sizeof(*(&descriptor->wHubCharacteristics)) == 8, get_unaligned_le64((&descriptor->wHubCharacteristics)), __bad_unaligned_access_size())))); }))))&hub->desc.wHubCharacteristics&descriptor->wHubCharacteristicsget_unaligned( &descriptor->wHubCharacteristics)((typeof(*(&descriptor->wHubCharacteristics)))({ __builtin_choose_expr(sizeof(*(&descriptor->wHubCharacteristics)) == 1, *(&descriptor->wHubCharacteristics), __builtin_choose_expr(sizeof(*(&descriptor->wHubCharacteristics)) == 2, get_unaligned_le16((&descriptor->wHubCharacteristics)), __builtin_choose_expr(sizeof(*(&descriptor->wHubCharacteristics)) == 4, get_unaligned_le32((&descriptor->wHubCharacteristics)), __builtin_choose_expr(sizeof(*(&descriptor->wHubCharacteristics)) == 8, get_unaligned_le64((&descriptor->wHubCharacteristics)), __bad_unaligned_access_size())))); }))USB_MAXCHILDREN+1USB_MAXCHILDREN+1+7(USB_MAXCHILDREN+1+7)(USB_MAXCHILDREN+1+7)/8"%d ports detected\n"dev->maxchilddebug("%d ports detected\n", dev->maxchild)664%d ports detected
hubCharacteristics"ganged power switching\n"debug("ganged power switching\n")669ganged power switching
"individual port power switching\n"debug("individual port power switching\n")672individual port power switching
"unknown reserved power switching mode\n"debug("unknown reserved power switching mode\n")676unknown reserved power switching mode
"part of a compound device\n"debug("part of a compound device\n")681part of a compound device
"standalone hub\n"debug("standalone hub\n")683standalone hub
"global over-current protection\n"debug("global over-current protection\n")687global over-current protection
"individual port over-current protection\n"debug("individual port over-current protection\n")690individual port over-current protection
"no over-current protection\n"debug("no over-current protection\n")no over-current protection
"Single TT\n"debug("Single TT\n")702Single TT
"TT per port\n"debug("TT per port\n")707TT per port
"Using single TT (err %d)\n"debug("Using single TT (err %d)\n", ret)710Using single TT (err %d)
"Unrecognized hub protocol %d\n"dev->descriptor.bDeviceProtocoldebug("Unrecognized hub protocol %d\n",
		      dev->descriptor.bDeviceProtocol)718Unrecognized hub protocol %d
666"TT requires at most %d FS bit times (%d ns)\n"8, hub->tt.think_timedebug("TT requires at most %d FS bit times (%d ns)\n",
			      8, hub->tt.think_time)TT requires at most %d FS bit times (%d ns)
1332666 * 216, hub->tt.think_timedebug("TT requires at most %d FS bit times (%d ns)\n",
		      16, hub->tt.think_time)7341998666 * 324, hub->tt.think_timedebug("TT requires at most %d FS bit times (%d ns)\n",
		      24, hub->tt.think_time)7392664666 * 432, hub->tt.think_timedebug("TT requires at most %d FS bit times (%d ns)\n",
		      32, hub->tt.think_time)"power on to power good time: %dms\n"descriptor->bPwrOn2PwrGood * 2debug("power on to power good time: %dms\n",
	      descriptor->bPwrOn2PwrGood * 2)749power on to power good time: %dms
"hub controller current requirement: %dmA\n"descriptor->bHubContrCurrentdebug("hub controller current requirement: %dmA\n",
	      descriptor->bHubContrCurrent)751hub controller current requirement: %dmA
"port %d is%s removable\n"i + 1, hub->desc.u.hs.DeviceRemovable[(i + 1) / 8] & (1 << ((i + 1) % 8)) ? " not" : ""debug("port %d is%s removable\n", i + 1,
		      hub->desc.u.hs.DeviceRemovable[(i + 1) / 8] & \
		      (1 << ((i + 1) % 8)) ? " not" : "")755port %d is%s removable
 not" not"sizeof(struct usb_hub_status)sizeof(struct usb_hub_status) > USB_BUFSIZ"usb_hub_configure: failed to get Status - " "too long: %d\n"debug("usb_hub_configure: failed to get Status - " \
		      "too long: %d\n", descriptor->bLength)759usb_hub_configure: failed to get Status - too long: %d
"usb_hub_configure: failed to get Status - " \
		      "too long: %d\n"EFBIG"usb_hub_configure: failed to get Status %lX\n"debug("usb_hub_configure: failed to get Status %lX\n",
		      dev->status)usb_hub_configure: failed to get Status %lX
usb_hub_status *hubsts"get_hub_status returned status %X, change %X\n"le16_to_cpu(hubsts->wHubStatus), le16_to_cpu(hubsts->wHubChange)debug("get_hub_status returned status %X, change %X\n",
	      le16_to_cpu(hubsts->wHubStatus),
	      le16_to_cpu(hubsts->wHubChange))get_hub_status returned status %X, change %X
hubsts->wHubStatushubsts->wHubChange"local power source is %s\n"(le16_to_cpu(hubsts->wHubStatus) & HUB_STATUS_LOCAL_POWER) ? "lost (inactive)" : "good"debug("local power source is %s\n",
	      (le16_to_cpu(hubsts->wHubStatus) & HUB_STATUS_LOCAL_POWER) ? \
	      "lost (inactive)" : "good")local power source is %s
lost (inactive)"lost (inactive)"good"good""%sover-current condition exists\n"(le16_to_cpu(hubsts->wHubStatus) & HUB_STATUS_OVERCURRENT) ? "" : "no "debug("%sover-current condition exists\n",
	      (le16_to_cpu(hubsts->wHubStatus) & HUB_STATUS_OVERCURRENT) ? \
	      "" : "no ")780%sover-current condition exists
"%s: failed to update hub device for HCD (%x)\n"debug("%s: failed to update hub device for HCD (%x)\n",
		      __func__, ret)791%s: failed to update hub device for HCD (%x)
hdev"set hub (%p) depth to %d\n"dev, depthdebug("set hub (%p) depth to %d\n", dev, depth)819set hub (%p) depth to %d
"%s: failed to set hub depth (%lX)\n"__func__, dev->statusdebug("%s: failed to set hub depth (%lX)\n",
				      __func__, dev->status)%s: failed to set hub depth (%lX)
usb_device_scan *usb_scansizeof(*usb_scan)Can't allocate memory for USB device!
"Can't allocate memory for USB device!\n"usb_get_hub_deviceusb_device_list_scan&usb_scan_list(&usb_scan_list)->nexttypeof(*usb_scan)list_for_each_entry_safe(usb_scan, tmp, &usb_scan_list, list)usb_scan->list.nexttmp->list.nexttypeof(*tmp)usb_scan_portstruct usb_port_statusportstsPAD_SIZE((1) * sizeof(struct usb_port_status), 1)(((((1) * sizeof(struct usb_port_status)) - 1) / (1) + 1) * 1)(1) * sizeof(struct usb_port_status)(uintptr_t)__portsts((uintptr_t)__portsts)(typeof((uintptr_t)__portsts))(16)-1usb_port_status *ALLOC_CACHE_ALIGN_BUFFER(struct usb_port_status, portsts, 1)__portsts"get_port_status failed\n"debug("get_port_status failed\n")445get_port_status failed
"devnum=%d port=%d: timeout\n"dev->devnum, i + 1debug("devnum=%d port=%d: timeout\n",
			      dev->devnum, i + 1)devnum=%d port=%d: timeout
portstatusportsts->wPortStatusportchangeportsts->wPortChange"Port %d Status %X Change %X\n"i + 1, portstatus, portchangedebug("Port %d Status %X Change %X\n", i + 1, portstatus, portchange)Port %d Status %X Change %X
472"port %d reset change\n"i + 1debug("port %d reset change\n", i + 1)482port %d reset change
"port %d BH reset change\n"debug("port %d BH reset change\n", i + 1)port %d BH reset change
"devnum=%d port=%d: USB dev found\n"debug("devnum=%d port=%d: USB dev found\n", dev->devnum, i + 1)493devnum=%d port=%d: USB dev found
"port %d enable change, status %x\n"i + 1, portstatusdebug("port %d enable change, status %x\n", i + 1, portstatus)498port %d enable change, status %x
"already running port %i disabled by hub (EMI?), re-enabling...\n"debug("already running port %i disabled by hub (EMI?), re-enabling...\n",
			      i + 1)already running port %i disabled by hub (EMI?), re-enabling...
"port %d suspend change\n"debug("port %d suspend change\n", i + 1)521port %d suspend change
"port %d over-current change\n"debug("port %d over-current change\n", i + 1)526port %d over-current change
PORT_OVERCURRENT_MAX_SCAN_COUNTPort %d over-current occurred %d times
"Port %d over-current occurred %d times\n"usb_hub_port_connect_change343"portstatus %x, change %x, %s\n"portstatus, le16_to_cpu(portsts->wPortChange), portspeed(portstatus)debug("portstatus %x, change %x, %s\n",
	      portstatus,
	      le16_to_cpu(portsts->wPortChange),
	      portspeed(portstatus))portstatus %x, change %x, %s
"usb_disconnect(&hub->children[port]);\n"debug("usb_disconnect(&hub->children[port]);\n")360usb_disconnect(&hub->children[port]);
ENOTCONN-107-ENOTCONNcannot reset port %i!?
"cannot reset port %i!?\n""hub: disabling port %d\n"port + 1debug("hub: disabling port %d\n", port + 1)415hub: disabling port %d
"%s: resetting '%s' port %d...\n"__func__, dev->dev->name, port + 1debug("%s: resetting '%s' port %d...\n", __func__, dev->dev->name,
	      port + 1)%s: resetting '%s' port %d...
triesMAX_TRIES HUB_SHORT_RESET_TIME"get_port_status failed status %lX\n"debug("get_port_status failed status %lX\n",
			      dev->status)get_port_status failed status %lX
portstatus, portchange, portspeed(portstatus)debug("portstatus %x, change %x, %s\n", portstatus, portchange,
							portspeed(portstatus))"STAT_C_CONNECTION = %d STAT_CONNECTION = %d" "  USB_PORT_STAT_ENABLE %d\n"(portchange & USB_PORT_STAT_C_CONNECTION) ? 1 : 0, (portstatus & USB_PORT_STAT_CONNECTION) ? 1 : 0, (portstatus & USB_PORT_STAT_ENABLE) ? 1 : 0debug("STAT_C_CONNECTION = %d STAT_CONNECTION = %d" \
		      "  USB_PORT_STAT_ENABLE %d\n",
		      (portchange & USB_PORT_STAT_C_CONNECTION) ? 1 : 0,
		      (portstatus & USB_PORT_STAT_CONNECTION) ? 1 : 0,
		      (portstatus & USB_PORT_STAT_ENABLE) ? 1 : 0)portstatSTAT_C_CONNECTION = %d STAT_CONNECTION = %d  USB_PORT_STAT_ENABLE %d
"STAT_C_CONNECTION = %d STAT_CONNECTION = %d" \
		      "  USB_PORT_STAT_ENABLE %d\n"HUB_LONG_RESET_TIME"Cannot enable port %i after %i retries, " "disabling port.\n"port + 1, MAX_TRIESdebug("Cannot enable port %i after %i retries, " \
		      "disabling port.\n", port + 1, MAX_TRIES)Cannot enable port %i after %i retries, disabling port.
"Cannot enable port %i after %i retries, " \
		      "disabling port.\n""Maybe the USB cable is bad?\n"debug("Maybe the USB cable is bad?\n")Maybe the USB cable is bad?
usb_hub_power_on"enabling power on all ports\n"debug("enabling power on all ports\n")enabling power on all ports
"port %d returns %lX\n"i + 1, dev->statusdebug("port %d returns %lX\n", i + 1, dev->status)port %d returns %lX
usb_pgood_delay"usb_pgood_delay"pgood_delay(unsigned)simple_strtol(env, NULL, 0)(unsigned)simple_strtol(env, ((void *)0), 0)max(pgood_delay,
			          (unsigned)simple_strtol(env, NULL, 0))"pgood_delay=%dms\n"debug("pgood_delay=%dms\n", pgood_delay)pgood_delay=%dms
(int)pgood_delaymax(100, (int)pgood_delay)"devnum=%d poweron: query_delay=%d connect_timeout=%d\n"dev->devnum, max(100, (int)pgood_delay), max(100, (int)pgood_delay) + 1000debug("devnum=%d poweron: query_delay=%d connect_timeout=%d\n",
	      dev->devnum, max(100, (int)pgood_delay),
	      max(100, (int)pgood_delay) + 1000)devnum=%d poweron: query_delay=%d connect_timeout=%d
USB_DIR_IN | USB_RT_PORTsizeof(struct usb_port_status)7168usb_get_hub_statusUSB_DIR_IN | USB_RT_HUBusb_set_port_featureusb_clear_port_featureusb_get_hub_descriptordtypeusb_set_hub_depthUSB_DIR_OUT | USB_RT_HUBusb_hub_is_superspeedusb_hub_reset_devicesusb_device_scanusb_generic_hubhub_id_tablestruct driverconst usb_device_id[2]usb_device_id[2]_u_boot_list_2_usb_driver_entry_2_usb_generic_hub.u_boot_list_2_usb_driver_entry_2_usb_generic_hubstruct usb_driver_entryconst usb_device_id[]usb_device_id[]"usb_hub"2400sizeof(struct usb_device)sizeof(struct usb_dev_platdata)sizeof(struct usb_hub_device)_u_boot_list_2_uclass_2_usb_hub.u_boot_list_2_uclass_2_usb_hubstruct uclass_driverconst udevice_id[2]udevice_id[2]_u_boot_list_2_driver_2_usb_generic_hub.u_boot_list_2_driver_2_usb_generic_hubconst udevice_id[]udevice_id[]usb-hub"usb-hub"usb_hub_idsusb_scan_listHUB_SHORT_RESET_TIMECONFIG_USB_EHCI_FARADAY/* Terminating entry *//* We found a hub *//* If it's not an interrupt endpoint, we'd better punt! *//* Output endpoint? Curiousier and curiousier.. *//* Multiple endpoints? What kind of mutant ninja-hub is this? *//*  specs is not defined, but it works *//* Some hubs have a subclass of 1, which AFAICT according to the *//* Is it a hub? *//*
	 * And now call the scanning code which loops over the generated list
	 *//*
	 * Only add the connected USB devices, including potential hubs,
	 * to a scanning list. This list will get scanned and devices that
	 * are detected (either via port connected or via port timeout)
	 * will get removed from this list. Scanning of the devices on this
	 * list will continue until all devices are removed.
	 *//*
	 * Reset any devices that may be in a bad state when applying
	 * the power.  This is a __weak function.  Resetting of the devices
	 * should occur in the board file of the device.
	 *//*
			 * This request sets the value that the hub uses to
			 * determine the index into the 'route string index'
			 * for this hub.
			 *//*
	 * A maximum of seven tiers are allowed in a USB topology, and the
	 * root hub occupies the first tier. The last tier ends with a normal
	 * USB device. USB 3.0 hubs use a 20-bit field called 'route string'
	 * to route packets to the designated downstream port. The hub uses a
	 * hub depth value multiplied by four as an offset into the 'route
	 * string' to locate the bits it uses to determine the downstream
	 * port number.
	 *//*
	 * Update USB host controller's internal representation of this hub
	 * after the hub descriptor is fetched.
	 *//* Note 8 FS bit times == (8 bits / 12000000 bps) ~= 666ns *//* USB 3.0 hubs don't have a TT *//* PowerMask = 1B *//* devices not removable by default *//* set the bitmap *//* adjust 16bit values *//* Get the the hub descriptor *//* "allocate" Hub device *//*
	 * This USB controller has finished scanning all its connected
	 * USB devices. Set "running" back to 0, so that other USB controllers
	 * will scan their devices too.
	 *//* Scan this port *//* We're done, once the list is empty again *//* Only run this loop once for each controller *//*
	 * We're done with this device, so let's remove this device from
	 * scanning list
	 *//* Otherwise the device will get removed *//*
		 * If the max-scan-count is not reached, return without removing
		 * the device from scan-list. This will re-issue a new scan.
		 *//* Only power-on this one port *//*
		 * EM interference sometimes causes bad shielded USB
		 * devices to be shutdown by the hub, this hack enables
		 * them again. Works at least with mouse driver
		 *//*
		 * The following hack causes a ghost device problem
		 * to Faraday EHCI
		 *//* A new USB device is ready at this point *//* Remove this device from scanning list *//*
	 * No connection change happened, wait a bit more.
	 *
	 * For some situation, the hub reports no connection change but a
	 * device is connected to the port (eg: CCS bit is set but CSC is not
	 * in the PORTSC register of a root hub), ignore such case.
	 *//*
	 * Don't talk to the device before the query delay is expired.
	 * This is needed for voltages to stabalize.
	 *//* Woops, disable the port *//* Run it through the hoops (find a driver, etc) *//* Reset the port *//* Return now if nothing is connected *//* Disconnect any existing devices under this port *//* Clear the connection change status *//* Check status *//* Switch to long reset delay for the next round *//*
		 * Perhaps we should check for the following here:
		 * - C_CONNECTION hasn't been set.
		 * - CONNECTION is still set.
		 *
		 * Doing so would ensure that the device is still connected
		 * to the bus, and hasn't been unplugged or replaced while the
		 * USB bus reset was going on.
		 *
		 * However, if we do that, then (at least) a San Disk Ultra
		 * USB 3.0 16GB device fails to reset on (at least) an NVIDIA
		 * Tegra Jetson TK1 board. For some reason, the device appears
		 * to briefly drop off the bus when this second bus reset is
		 * executed, yet if we retry this loop, it'll eventually come
		 * back after another reset or two.
		 *//* start with short reset delay *//**
 * usb_hub_port_reset() - reset a port given its usb_device pointer
 *
 * Reset a hub port and see if a device is present on that port, providing
 * sufficient time for it to show itself. The port status is returned.
 *
 * @dev:	USB device to reset
 * @port:	Port number to reset (note ports are numbered from 0 here)
 * @portstat:	Returns port status
 *//* Zero out global hub_dev in case its re-used again *//*
	 * Record the power-on timeout here. The max. delay (timeout)
	 * will be done based on this value in the USB port loop in
	 * usb_hub_configure() later.
	 *//*
	 * Do a minimum delay of the larger value of 100ms or pgood_delay
	 * so that the power can stablize before the devices are queried
	 *//*
	 * Wait for power to become stable,
	 * plus spec-defined max time for device to connect
	 * but allow this time to be increased via env variable as some
	 * devices break the spec and require longer warm-up times
	 *//*
	 * Don't set timeout / delay values here. This results
	 * in these values still being reset to 0.
	 *//*
	 * Translate the USB 3.0 hub port status field into the old version
	 * that U-Boot understands. Do this only when the hub is not root hub.
	 * For root hub, the port status field has already been translated
	 * in the host controller driver (see xhci_submit_root() in xhci.c).
	 *
	 * Note: this only supports driver model.
	 *//* USB port to scan *//* USB hub struct *//* USB hub device to scan *//****************************************************************************
 * HUB "Driver"
 * Probes device for being a hub and configurate it
 *//opt/src/common/usb_kbd.cusb_kbdusb_kbd_removeusbkbdDEVNAMEusb_kbd_pdata *ENOLINK-67-ENOLINK%s: warning, ret=%d"%s: warning, ret=%d"usb_kbd_probeprobe_usb_keyboard"USB KBD: register.\n"debug("USB KBD: register.\n")common/usb_kbd.c531USB KBD: register.
usb_kbd_devusb_kbd_probe_dev"USB KBD: found set protocol...\n"debug("USB KBD: found set protocol...\n")USB KBD: found set protocol...
sizeof(struct usb_kbd_pdata)USB KBD: Error allocating private data
"USB KBD: Error allocating private data\n"USB_KBD_BOOT_REPORT_SIZEroundup(USB_KBD_BOOT_REPORT_SIZE, USB_DMA_MINALIGN)ep->bEndpointAddressusb_rcvintpipe(dev, ep->bEndpointAddress)_min1usb_maxpacket(dev, data->intpipe)_min2min(usb_maxpacket(dev, data->intpipe),
			       USB_KBD_BOOT_REPORT_SIZE)"USB KBD: found set idle...\n"debug("USB KBD: found set idle...\n")489USB KBD: found set idle...
REPEAT_RATEREPEAT_RATE / 4"USB KBD: enable interrupt pipe...\n"debug("USB KBD: enable interrupt pipe...\n")USB KBD: enable interrupt pipe...
Failed to get keyboard state from device %04x:%04x
"Failed to get keyboard state from device %04x:%04x\n"usb_kbd_getcUSB_KBD_BUFFER_LENUSB_KBD_BUFFER_LEN - 1usb_kbd_testcusb_kbd_poll_for_eventusb_kbd_irq"USB KBD: Error %lX, len %d\n"dev->irq_status, dev->irq_act_lendebug("USB KBD: Error %lX, len %d\n",
		      dev->irq_status, dev->irq_act_len)USB KBD: Error %lX, len %d
usb_kbd_irq_workerUSB_KBD_CTRL~USB_KBD_CTRLLEFT_CNTRRIGHT_CNTRusb_kbd_service_keyUSB_KBD_BOOT_REPORT_SIZE - 2usb_kbd_translateREPEAT_DELAYUSB_KBD_CAPSLOCKCAPITAL_MASK-33~CAPITAL_MASKLEFT_SHIFTRIGHT_SHIFTLEFT_SHIFT | RIGHT_SHIFT(LEFT_SHIFT | RIGHT_SHIFT)const unsigned char[27]unsigned char[27]0x4fconst unsigned char[4]0x67const unsigned char[20]NUM_LOCKUSB_KBD_NUMLOCKCAPS_LOCKSCROLL_LOCKUSB_KBD_SCROLLLOCKdebug("%c", keycode)[B"\e[B"[A"\e[A"[C"\e[C"[D"\e[D"usb_kbd_setleduint32_tledsPAD_SIZE((1) * sizeof(uint32_t), 1)(((((1) * sizeof(uint32_t)) - 1) / (1) + 1) * 1)(1) * sizeof(uint32_t)(uintptr_t)__leds((uintptr_t)__leds)(typeof((uintptr_t)__leds))(32)-1ALLOC_ALIGN_BUFFER(uint32_t, leds, 1, USB_DMA_MINALIGN)__leds18446744073709551584USB_KBD_LEDMASKupusb_kbd_put_sequenceusb_kbd_put_queueoverwrite_consoleusb_kbd_pdatausb_kbd_bufferusb_out_pointerusb_in_pointerrepeat_delayintqlast_reportintintervalintpktsizeintpipekbd_id_table_u_boot_list_2_usb_driver_entry_2_usb_kbd.u_boot_list_2_usb_driver_entry_2_usb_kbdUSB_DEVICE_ID_MATCH_INT_CLASS |
			USB_DEVICE_ID_MATCH_INT_SUBCLASSUSB_DEVICE_ID_MATCH_INT_CLASS |
			USB_DEVICE_ID_MATCH_INT_SUBCLASS |
			USB_DEVICE_ID_MATCH_INT_PROTOCOL"usb_kbd"_u_boot_list_2_driver_2_usb_kbd.u_boot_list_2_driver_2_usb_kbdusb-keyboard"usb-keyboard"usb_kbd_idskbd_testc_tms0xeusb_kbd_arrow'6'usb_kbd_num_keypad'!''\b'usb_kbd_numkey_shifted'`'usb_kbd_numkey(USB_KBD_NUMLOCK | USB_KBD_CAPSLOCK | USB_KBD_SCROLLLOCK)"usbkbd"RIGHT_GUIRIGHT_ALTLEFT_GUILEFT_ALTdefined(CONFIG_SYS_USB_EVENT_POLL)defined(CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP) || \defined(CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP)!defined(CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP) && \CONFIG_SYS_USB_EVENT_POLL_VIA_INT_QUEUEnet_busy_flag/* Deregister the keyboard. *//* No USB Keyboard found *//* Get USB device. *//* Scan all USB Devices *//* Search for keyboard and register it if found. *//* Reassign the console *//* Check if this is the standard input device. *//* Register the keyboard *//* Try probing the keyboard *//* Success. *//* Abort, we don't want to use that non-functional keyboard. *//* We found a USB Keyboard, install it. *//* Set IRQ handler *//* Insert private data into USB device structure *//* allocate input buffer aligned and sized to USB DMA alignment *//* Clear private data *//* Check if endpoint 1 is interrupt endpoint *//* probes the USB device dev for keyboard type. *//* gets the character from the queue *//*
	 * If net_busy_flag is 1, NET transfer is running,
	 * then we check key-pressed every second (first check may be
	 * less than 1 second) to improve TFTP booting performance.
	 *//* test if a character is in the queue *//* Repeat last usb hid report every REPEAT_RATE ms for keyrepeat *//* We've consumed all queued int packets, create new *//* Submit a interrupt transfer request *//* Interrupt polling *//* Keyboard interrupt handler *//* Key is still pressed *//* Left or Right Ctrl pressed *//* No combo key pressed *//* Interrupt service routine *//* Left arrow key *//* Right arrow key *//* Up arrow key *//* Down arrow key *//* Report keycode if any *//* Numeric keypad *//* Arrow keys *//* Shift pressed *//* Handle CAPSLock + Shift pressed simultaneously *//* Alphanumeric values *//* Key released *//* Translate the scancode in ASCII *//*
 * Set the LEDs. Since this is used in the irq routine, the control job is
 * issued with a timeout of 0. This means, that the job is queued without
 * waiting for job completion.
 *//* Check for buffer full. *//* Puts character in the queue and sets up the in and out pointer. *//* The period of time between two calls of usb_kbd_testc(). *//*
 * USB Keyboard reports are 8 bytes in boot protocol.
 * Appendix B of HID Device Class Definition 1.11
 *//*
 * NOTE: It's important for the NUM, CAPS, SCROLL-lock bits to be in this
 *       order. See usb_kbd_setled() function!
 *//*
 * map arrow keys to ^F/^B ^N/^P, can't really use the proper
 * ANSI sequence for arrow keys because the queuing code breaks
 * when a single keypress expands to 3 queue elements
 *//* Keyboard maps *//* Device name *//* Size of the keyboard buffer *//* Modifier bits *//* 10 x REPEAT_RATE = 400msec *//* 40msec -> 25cps *//* Keyboard sampling rate *//*
 * If overwrite_console returns 1, the stdin, stderr and stdout
 * are switched to the serial port, else the settings in the
 * environment are used
 *//*
 * (C) Copyright 2001
 * Denis Peter, MPL AG Switzerland
 *
 * Part of this source has been derived from the Linux USB
 * project.
 *//opt/src/common/usb_storage.cusb_storageusb_mass_storage_probeusb_stor_get_infous_data *PAD_SIZE((2) * sizeof(u32), 1)(((((2) * sizeof(u32)) - 1) / (1) + 1) * 1)(2) * sizeof(u32)(uintptr_t)__cap((uintptr_t)__cap)(typeof((uintptr_t)__cap))(16)-1usb_stor_bufPAD_SIZE((36) * sizeof(u8), 1)(((((36) * sizeof(u8)) - 1) / (1) + 1) * 1)(36) * sizeof(u8)(uintptr_t)__usb_stor_buf((uintptr_t)__usb_stor_buf)(typeof((uintptr_t)__usb_stor_buf))(16)-1pccbALLOC_CACHE_ALIGN_BUFFER(u8, usb_stor_buf, 36)__usb_stor_buf" address %d\n"dev_desc->targetdebug(" address %d\n", dev_desc->target)common/usb_storage.c1425 address %d
"%s: usb_inquiry() failed\n"debug("%s: usb_inquiry() failed\n", __func__)1428%s: usb_inquiry() failed
perqmodi"%s: unknown/unsupported device\n"debug("%s: unknown/unsupported device\n", __func__)1440%s: unknown/unsupported device
"ISO Vers %X, Response Data %X\n"usb_stor_buf[2], usb_stor_buf[3]debug("ISO Vers %X, Response Data %X\n", usb_stor_buf[2],
	      usb_stor_buf[3])1458ISO Vers %X, Response Data %X
Device NOT ready
   Request Sense returned %02X %02X %02X
"Device NOT ready\n"
		       "   Request Sense returned %02X %02X %02X\n"ALLOC_CACHE_ALIGN_BUFFER(u32, cap, 2)__capREAD_CAP ERROR
"READ_CAP ERROR\n"2880USB_READY4294967294~USB_READY"Read Capacity returns: 0x%08x, 0x%08x\n"cap[0], cap[1]debug("Read Capacity returns: 0x%08x, 0x%08x\n", cap[0], cap[1])1476Read Capacity returns: 0x%08x, 0x%08x
cap[0](__force __u32)(__be32)(cap[0])(__u32)(__be32)(cap[0])((__u32)(__be32)(cap[0]))cap[1](__force __u32)(__be32)(cap[1])(__u32)(__be32)(cap[1])((__u32)(__be32)(cap[1]))"Capacity = 0x%08x, blocksz = 0x%08x\n"capacity, blkszdebug("Capacity = 0x%08x, blocksz = 0x%08x\n", capacity, blksz)1488Capacity = 0x%08x, blocksz = 0x%08x
dev_desc->blkszLOG2(dev_desc->blksz)34359738364042322160427825536042949017601493usb_storage_probe"Not mass storage\n"debug("Not mass storage\n")1305Not mass storage
sizeof(struct us_data)"\n\nUSB Mass Storage device detected\n"debug("\n\nUSB Mass Storage device detected\n")1313

USB Mass Storage device detected
"Transport: "debug("Transport: ")1324Transport: "Control/Bulk\n"debug("Control/Bulk\n")1327Control/Bulk
"Control/Bulk/Interrupt\n"debug("Control/Bulk/Interrupt\n")1333Control/Bulk/Interrupt
"Bulk/Bulk/Bulk\n"debug("Bulk/Bulk/Bulk\n")1338Bulk/Bulk/Bulk
USB Storage Transport unknown / not yet implemented
"USB Storage Transport unknown / not yet implemented\n""Endpoints In %d Out %d Int %d\n"ss->ep_in, ss->ep_out, ss->ep_intdebug("Endpoints In %d Out %d Int %d\n",
	      ss->ep_in, ss->ep_out, ss->ep_int)1376Endpoints In %d Out %d Int %d
"Problems with device\n"debug("Problems with device\n")1382Problems with device
Sorry, protocol %d not yet supported.
"Sorry, protocol %d not yet supported.\n"ss->pusb_devss->ep_intusb_rcvintpipe(ss->pusb_dev, ss->ep_int)usb_stor_write"\nusb_read: udev %d\n"block_dev->devnumdebug("\nusb_read: udev %d\n", block_dev->devnum)
usb_read: udev %d
srb"\nusb_write: dev %d startblk " LBAF ", blccnt " LBAF " buffer %lx\n""\nusb_write: dev %d startblk " "%" "l" "x" ", blccnt " "%" "l" "x" " buffer %lx\n"block_dev->devnum, start, blks, buf_addrdebug("\nusb_write: dev %d startblk " LBAF ", blccnt " LBAF " buffer %lx\n",
	      block_dev->devnum, start, blks, buf_addr)1248
usb_write: dev %d startblk %lx, blccnt %lx buffer %lx
retrysmallblks"Write ERROR\n"debug("Write ERROR\n")1266Write ERROR
"usb_write: end startblk " LBAF ", blccnt %x buffer %lx\n""usb_write: end startblk " "%" "l" "x" ", blccnt %x buffer %lx\n"start, smallblks, buf_addrdebug("usb_write: end startblk " LBAF ", blccnt %x buffer %lx\n",
	      start, smallblks, buf_addr)1280usb_write: end startblk %lx, blccnt %x buffer %lx
1284usb_stor_read1147"\nusb_read: dev %d startblk " LBAF ", blccnt " LBAF " buffer %lx\n""\nusb_read: dev %d startblk " "%" "l" "x" ", blccnt " "%" "l" "x" " buffer %lx\n"debug("\nusb_read: dev %d startblk " LBAF ", blccnt " LBAF " buffer %lx\n",
	      block_dev->devnum, start, blks, buf_addr)1165
usb_read: dev %d startblk %lx, blccnt %lx buffer %lx
retry_it"Read ERROR\n"debug("Read ERROR\n")Read ERROR
"usb_read: end startblk " LBAF ", blccnt %x buffer %lx\n""usb_read: end startblk " "%" "l" "x" ", blccnt %x buffer %lx\n"debug("usb_read: end startblk " LBAF ", blccnt %x buffer %lx\n",
	      start, smallblks, buf_addr)1195usb_read: end startblk %lx, blccnt %x buffer %lx
1199usb_write_10"write10: start %lx blocks %x\n"start, blocksdebug("write10: start %lx blocks %x\n", start, blocks)1094write10: start %lx blocks %x
usb_read_10"read10: start %lx blocks %x\n"debug("read10: start %lx blocks %x\n", start, blocks)1077read10: start %lx blocks %x
usb_read_capacityUSB_STOR_TRANSPORT_GOODusb_test_unit_ready 10usb_request_sense"Request Sense returned %02X %02X %02X\n"srb->sense_buf[2], srb->sense_buf[12], srb->sense_buf[13]debug("Request Sense returned %02X %02X %02X\n",
	      srb->sense_buf[2], srb->sense_buf[12],
	      srb->sense_buf[13])1010Request Sense returned %02X %02X %02X
usb_inquiry"inquiry returns %d\n"debug("inquiry returns %d\n", i)983inquiry returns %d
error in inquiry
"error in inquiry\n"usb_stor_set_max_xfer_blkUSHRT_MAX33553920USHRT_MAX * 512usb_stor_CB_transportpsrbreqsrbnotready"command / Data returned %d, status %lX\n"result, us->pusb_dev->statusdebug("command / Data returned %d, status %lX\n",
	      result, us->pusb_dev->status)841command / Data returned %d, status %lX
USB_STOR_TRANSPORT_ERROR" USB CBI Command Error\n"debug(" USB CBI Command Error\n")usdo_retry847 USB CBI Command Error
" USB CBI Command Good\n"debug(" USB CBI Command Good\n") USB CBI Command Good
"ERROR %lX\n"us->pusb_dev->statusdebug("ERROR %lX\n", us->pusb_dev->status)863ERROR %lX
"No auto request and good\n"debug("No auto request and good\n")871No auto request and good
"auto request returned %d\n"debug("auto request returned %d\n", result)884auto request returned %d
" AUTO REQUEST ERROR %ld\n"debug(" AUTO REQUEST ERROR %ld\n",
		      us->pusb_dev->status)891 AUTO REQUEST ERROR %ld
"autorequest returned 0x%02X 0x%02X 0x%02X 0x%02X\n"srb->sense_buf[0], srb->sense_buf[2], srb->sense_buf[12], srb->sense_buf[13]debug("autorequest returned 0x%02X 0x%02X 0x%02X 0x%02X\n",
	      srb->sense_buf[0], srb->sense_buf[2],
	      srb->sense_buf[12], srb->sense_buf[13])autorequest returned 0x%02X 0x%02X 0x%02X 0x%02X
USB_TRANSPORT_NOT_READY_RETRYcmd 0x%02X returned 0x%02X 0x%02X 0x%02X 0x%02X (NOT READY)
"cmd 0x%02X returned 0x%02X 0x%02X 0x%02X"
			       " 0x%02X (NOT READY)\n"USB_STOR_TRANSPORT_FAILEDUSB_TRANSPORT_UNKNOWN_RETRYcmd 0x%02X returned 0x%02X 0x%02X 0x%02X 0x%02X
"cmd 0x%02X returned 0x%02X 0x%02X 0x%02X"
			       " 0x%02X\n"usb_stor_BBB_transportstruct umass_bbb_cswcswPAD_SIZE((1) * sizeof(struct umass_bbb_csw), 1)(((((1) * sizeof(struct umass_bbb_csw)) - 1) / (1) + 1) * 1)(1) * sizeof(struct umass_bbb_csw)(uintptr_t)__csw((uintptr_t)__csw)(typeof((uintptr_t)__csw))(16)-1dir_inconst unsigned char[32]256/8srb->cmd[0]US_DIRECTION(srb->cmd[0])"COMMAND phase\n"debug("COMMAND phase\n")COMMAND phase
"failed to send CBW status %ld\n"debug("failed to send CBW status %ld\n",
		      us->pusb_dev->status)722failed to send CBW status %ld
pipeinus->pusb_devus->ep_inusb_rcvbulkpipe(us->pusb_dev, us->ep_in)3221225472pipeoutus->ep_outusb_sndbulkpipe(us->pusb_dev, us->ep_out)data_actlen"DATA phase\n"debug("DATA phase\n")735DATA phase
"DATA:stall\n"debug("DATA:stall\n")745DATA:stall
"usb_bulk_msg error status %ld\n"debug("usb_bulk_msg error status %ld\n",
		      us->pusb_dev->status)usb_bulk_msg error status %ld
"STATUS phase\n"debug("STATUS phase\n")STATUS phase
umass_bbb_csw *ALLOC_CACHE_ALIGN_BUFFER(struct umass_bbb_csw, csw, 1)__cswactlenUSB_CNTL_TIMEOUT*5"STATUS:stall\n"debug("STATUS:stall\n")STATUS:stall
csw->dCSWDataResidue1396855637csw->dCSWSignature"!CSWSIGNATURE\n"debug("!CSWSIGNATURE\n")799!CSWSIGNATURE
csw->dCSWTag"!Tag\n"debug("!Tag\n")803!Tag
">PHASE\n"debug(">PHASE\n")>PHASE
"=PHASE\n"debug("=PHASE\n")811=PHASE
"transferred %dB instead of %ldB\n"data_actlen, srb->datalendebug("transferred %dB instead of %ldB\n",
		      data_actlen, srb->datalen)transferred %dB instead of %ldB
"FAILED\n"debug("FAILED\n")stagainFAILED
usb_stor_BBB_clear_endpt_stallusb_sndctrlpipe(us->pusb_dev, 0)usb_stor_CBI_get_status	Did not get interrupt on CBI
"	Did not get interrupt on CBI\n""Got interrupt data 0x%x, transferred %d status 0x%lX\n"us->ip_data, us->pusb_dev->irq_act_len, us->pusb_dev->irq_statusdebug("Got interrupt data 0x%x, transferred %d status 0x%lX\n",
	      us->ip_data, us->pusb_dev->irq_act_len,
	      us->pusb_dev->irq_status)668Got interrupt data 0x%x, transferred %d status 0x%lX
usb_stor_CB_comdat"CBI gets a command: Try %d\n"5 - retrydebug("CBI gets a command: Try %d\n", 5 - retry)595CBI gets a command: Try %d
usb_sndctrlpipe(us->pusb_dev , 0)"CB_transport: control msg returned %d, status %lX\n"debug("CB_transport: control msg returned %d, status %lX\n",
		      result, us->pusb_dev->status)CB_transport: control msg returned %d, status %lX
" stall during command found," " clear pipe\n"debug(" stall during command found," \
				      " clear pipe\n")613 stall during command found, clear pipe
" stall during command found," \
				      " clear pipe\n"" error during command %02X" " Stat = %lX\n"srb->cmd[0], us->pusb_dev->statusdebug(" error during command %02X" \
			      " Stat = %lX\n", srb->cmd[0],
			      us->pusb_dev->status)621 error during command %02X Stat = %lX
" error during command %02X" \
			      " Stat = %lX\n"endpt"CB_transport: control msg returned %d," " direction is %s to go 0x%lx\n"result, dir_in ? "IN" : "OUT", srb->datalendebug("CB_transport: control msg returned %d," \
		      " direction is %s to go 0x%lx\n", result,
		      dir_in ? "IN" : "OUT", srb->datalen)CB_transport: control msg returned %d, direction is %s to go 0x%lx
"CB_transport: control msg returned %d," \
		      " direction is %s to go 0x%lx\n"IN"IN"OUT"OUT""CBI attempted to transfer data," " result is %d status %lX, len %d\n"result, us->pusb_dev->status, us->pusb_dev->act_lendebug("CBI attempted to transfer data," \
			      " result is %d status %lX, len %d\n",
			      result, us->pusb_dev->status,
				us->pusb_dev->act_len)635CBI attempted to transfer data, result is %d status %lX, len %d
"CBI attempted to transfer data," \
			      " result is %d status %lX, len %d\n"usb_stor_BBB_comdatstruct umass_bbb_cbwcbwPAD_SIZE((1) * sizeof(struct umass_bbb_cbw), 1)(((((1) * sizeof(struct umass_bbb_cbw)) - 1) / (1) + 1) * 1)(1) * sizeof(struct umass_bbb_cbw)(uintptr_t)__cbw((uintptr_t)__cbw)(typeof((uintptr_t)__cbw))(16)-1"usb_stor_BBB_comdat:cmdlen too large\n"debug("usb_stor_BBB_comdat:cmdlen too large\n")552usb_stor_BBB_comdat:cmdlen too large
umass_bbb_cbw *ALLOC_CACHE_ALIGN_BUFFER(struct umass_bbb_cbw, cbw, 1)__cbw1128420181cpu_to_le32CBWTag++srb->datalen"usb_stor_BBB_comdat:usb_bulk_msg error\n"debug("usb_stor_BBB_comdat:usb_bulk_msg error\n")usb_stor_BBB_comdat:usb_bulk_msg error
usb_stor_CB_reset"CB_reset\n"debug("CB_reset\n")505CB_reset
sizeof(cmd)"CB_reset result %d: status %lX clearing endpoint halt\n"debug("CB_reset result %d: status %lX clearing endpoint halt\n",
	      result, us->pusb_dev->status)518CB_reset result %d: status %lX clearing endpoint halt
usb_rcvbulkpipe(us->pusb_dev, us->ep_out)"CB_reset done\n"debug("CB_reset done\n")522CB_reset done
usb_stor_BBB_reset"BBB_reset\n"debug("BBB_reset\n")BBB_reset
"RESET:stall\n"debug("RESET:stall\n")RESET:stall
"BBB_reset result %d: status %lX reset\n"debug("BBB_reset result %d: status %lX reset\n",
	      result, us->pusb_dev->status)479BBB_reset result %d: status %lX reset
"BBB_reset result %d: status %lX clearing IN endpoint\n"debug("BBB_reset result %d: status %lX clearing IN endpoint\n",
	      result, us->pusb_dev->status)485BBB_reset result %d: status %lX clearing IN endpoint
"BBB_reset result %d: status %lX clearing OUT endpoint\n"debug("BBB_reset result %d: status %lX clearing OUT endpoint\n",
	      result, us->pusb_dev->status)BBB_reset result %d: status %lX clearing OUT endpoint
"BBB_reset done\n"debug("BBB_reset done\n")BBB_reset done
us_one_transfermax_sizethis_xfermaxtry"Bulk xfer 0x%lx(%d) try #%d\n"(ulong)map_to_sysmem(buf), this_xfer, 11 - maxtrydebug("Bulk xfer 0x%lx(%d) try #%d\n",
			      (ulong)map_to_sysmem(buf), this_xfer,
			      11 - maxtry)390Bulk xfer 0x%lx(%d) try #%d
partial"bulk_msg returned %d xferred %d/%d\n"result, partial, this_xferdebug("bulk_msg returned %d xferred %d/%d\n",
			      result, partial, this_xfer)395bulk_msg returned %d xferred %d/%d
"stalled ->clearing endpoint" "halt for pipe 0x%x\n"debug("stalled ->clearing endpoint" \
					      "halt for pipe 0x%x\n", pipe)404stalled ->clearing endpointhalt for pipe 0x%x
"stalled ->clearing endpoint" \
					      "halt for pipe 0x%x\n""bulk transferred" "with error %lX," " but data ok\n"debug("bulk transferred" \
						      "with error %lX," \
						      " but data ok\n",
						      us->pusb_dev->status)413bulk transferredwith error %lX, but data ok
"bulk transferred" \
						      "with error %lX," \
						      " but data ok\n""Device NAKed bulk_msg\n"debug("Device NAKed bulk_msg\n")420Device NAKed bulk_msg
"bulk transferred with error"debug("bulk transferred with error")423bulk transferred with error" %ld, but data ok\n"debug(" %ld, but data ok\n",
					      us->pusb_dev->status) %ld, but data ok
" %ld, data %d\n"us->pusb_dev->status, partialdebug(" %ld, data %d\n",
					      us->pusb_dev->status, partial) %ld, data %d
usb_stor_irq       scanning usb for storage devices... "       scanning usb for storage devices... "%d Storage Device(s) found
"%d Storage Device(s) found\n"usb_stor_probe_device"\n\nProbing for storage\n"debug("\n\nProbing for storage\n")

Probing for storage
blkdevsizeof(str)lun%d"lun%d"usb_storage_blk"usb_storage_blk""Cannot bind driver\n"debug("Cannot bind driver\n")Cannot bind driver
"%s: Found device %p\n"__func__, udevdebug("%s: Found device %p\n", __func__, udev)%s: Found device %p
"usb_stor_get_info: Invalid device\n"debug("usb_stor_get_info: Invalid device\n")usb_stor_get_info: Invalid device
usb_get_max_lunPAD_SIZE((1) * sizeof(unsigned char), 1)(((((1) * sizeof(unsigned char)) - 1) / (1) + 1) * 1)(1) * sizeof(unsigned char)(uintptr_t)__result((uintptr_t)__result)(typeof((uintptr_t)__result))(16)-1usb_rcvctrlpipe(us->pusb_dev, 0)USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_INALLOC_CACHE_ALIGN_BUFFER(unsigned char, result, 1)sizeof(char)"Get Max LUN -> len = %i, result = %i\n"len, (int) *resultdebug("Get Max LUN -> len = %i, result = %i\n", len, (int) *result)Get Max LUN -> len = %i, result = %i
  Device %d: "  Device %d: "No storage devices, perhaps not 'usb start'ed..?
"No storage devices, perhaps not 'usb start'ed..?\n"usb_show_progressdebug(".")uhci_show_temp_int_tdtrans_cmndus_datatrans_resetmax_xfer_blktransporttransport_resetirqintervalirqmaxpirqpipeip_wantedip_dataattention_doneep_intep_outep_inconst blk_opsconst blk_ops *blk_ops *_u_boot_list_2_driver_2_usb_storage_blk.u_boot_list_2_driver_2_usb_storage_blkusb_storage_opsusb_mass_storagemass_storage_id_table_u_boot_list_2_usb_driver_entry_2_usb_mass_storage.u_boot_list_2_usb_driver_entry_2_usb_mass_storage"usb_mass_storage"_u_boot_list_2_uclass_2_usb_mass_storage.u_boot_list_2_uclass_2_usb_mass_storage_u_boot_list_2_driver_2_usb_mass_storage.u_boot_list_2_driver_2_usb_mass_storageusb-mass-storage"usb-mass-storage"usb_mass_storage_idsusb_max_devsCBWTagusb_ccb0x77us_directionUS_DIRECTION(x)((us_direction[x>>3] >> (x & 7)) & 1)BBB_XPORT_TRACEBBB_COMDAT_TRACECONFIG_USB_EHCI_HCDCONFIG_USB_BIN_FIXUP/* asynch transfer allowed *//* asynch transfer not allowed *//* greater than 10 GByte *//* CONFIG_USB_BIN_FIXUP *//* drive is removable *//*
	 * Skip unknown devices (0x1f) and enclosure service devices (0x0d),
	 * they would not respond to test_unit_ready .
	 *//* Set the maximum transfer size per host controller setting *//* we had found an interrupt endpoint, prepare irq pipe
		 * set up the IRQ pipe and handler
		 *//* We only handle certain protocols.  Currently, these are
	 * the only ones.
	 * The SFF8070 accepts the requests used in u-boot
	 *//* set class specific stuff *//* Do some basic sanity checks, and bail if we find a problem *//* is it an interrupt endpoint? *//* is it an BULK endpoint? *//*
	 * We are expecting a minimum of 2 endpoints - in and out (bulk).
	 * An optional interrupt is OK (necessary for CBI protocol).
	 * We will ignore any others.
	 *//* set the handler pointers based on the protocol *//* Initialize the us_data structure with some useful info *//* At this point, we know we've got a live one *//* if it's not a mass storage, we go no further *//* let's examine the device now *//* Probe to see if a new device is actually a Storage device *//* If write fails retry for max retry count else
		 * return with number of blocks written successfully.
		 *//* Setup  device *//* XXX need some comment here *//*
 * Some USB storage devices queried for SCSI identification data respond with
 * binary strings, which if output to the console freeze the terminal. The
 * workaround is to modify the vendor and product strings read from such
 * device with proper values (as reported by 'usb info').
 *
 * Vendor and product length limits are taken from the definition of
 * struct blk_desc in include/part.h.
 *//* XXX retries *//*
		 * Check the Key Code Qualifier, if it matches
		 * "Not Ready - medium not present"
		 * (the sense Key equals 0x2 and the ASC is 0x3a)
		 * return immediately as the medium being absent won't change
		 * unless there is a user action.
		 *//* unimplemented, let's use default 20 *//*
	 * The U-Boot EHCI driver can handle any transfer length as long as
	 * there is enough free heap space left, but the SCSI READ(10) and
	 * WRITE(10) commands are limited to 65535 blocks.
	 *//* Not Ready *//* Recovered Error *//* Check the auto request result *//* ok, no sense *//* if this is an CBI Protocol, get IRQ *//* issue the command *//* issue an request_sense *//* do not issue an autorequest after request sense *//* HERE we have to check the result *//* do we have to issue an auto request? *//* if the status is good, report it *//* if the status is error, report it *//* misuse pipe to get the residue *//* do a retry *//* clear the STALL on the endpoint *//* special handling of STALL in STATUS phase *//* STATUS phase + error handling *//* continue on to STATUS phase *//* special handling of STALL in DATA phase *//* no data, go immediately to the STATUS phase *//* DATA phase + error handling *//* COMMAND phase *//* ENDPOINT_HALT = 0, so set value to 0 *//* clear a stall on an endpoint - special for BBB devices *//* switch *//* otherwise, we interpret the data normally *//* Good *//* UFI gives us ASC and ASCQ, like a request sense *//* return result *//* if (srb->datalen) *//* transfer the data payload for this command, if one exists*//* check the return code for the command *//* let's send the command via the control pipe *//* FIXME: we also need a CBI_command which sets up the completion
 * interrupt, and waits for it
 *//* DST SRC LEN!!! *//* copy the command data into the CBW command data buffer *//* always OUT to the ep *//* sanity checks *//*
 * Set up the command for a BBB device. Note that the actual SCSI
 * command is copied into cbw.CBWCDB.
 *//* long wait for reset *//* FIXME: this reset function doesn't really reset the port, and it
 * should. Actually it should probably do what it's doing here, and
 * reset the port physically
 *//*
	 * Reset recovery (5.3.4 in Universal Serial Bus Mass Storage Class)
	 *
	 * For Reset Recovery the host shall issue in the following order:
	 * a) a Bulk-Only Mass Storage Reset
	 * b) a Clear Feature HALT to the Bulk-In endpoint
	 * c) a Clear Feature HALT to the Bulk-Out endpoint
	 *
	 * This is done in 3 steps.
	 *
	 * If the reset doesn't succeed, the device should be port reset.
	 *
	 * This comment stolen from FreeBSD's /sys/dev/usb/umass.c.
	 *//* if we get here, we're done and successful *//* continue until this transfer is done *//* update to show what data was transferred *//* if our try counter reaches 0, bail out *//* if we stall, we need to clear it before
				 * we go on
				 *//* transfer the data *//* set up the transfer loop *//* setup the retry counter *//* calculate how long this will be -- maximum or a remainder *//* while we have data left to transfer *//* determine the maximum packet size for these transfers *//***********************************************************************
 * Data transfer routines
 ***********************************************************************//* for *//* get device *//*******************************************************************************
 * scan the usb and reports device info
 * to the user if mode = 1
 * returns current device or -1 if no
 *//*
	 * OK, it's a storage device.  Iterate over its LUNs and populate
	 * usb_dev_desc'
	 *//* We don't have space to even probe if we hit the maximum *//*
	 * We store the us_data in the mass storage device's platdata. It
	 * is shared by all LUNs (block devices) attached to this mass storage
	 * device.
	 *//* no more devices available *//*******************************************************************************
 * show info on storage devices; 'usb start/init' must be invoked earlier
 * as we only retrieve structures populated during devices initialization
 *//* maximum transfer blocks *//* transport routine *//* reset routine *//* current srb *//* Intervall for IRQ Pipe *//* max packed for irq Pipe *//* pipe for release_irq *//* for USB int requests *//* needed *//* what to do *//* interrupt data *//* force attn on first cmd *//* .............. *//* as in overview *//* interrupt . *//* out ....... *//* in endpoint *//* interface number *//* from filter initially *//* this usb_device *//* number of highest available usb device *//* direction table -- this indicates the direction of the data
 * transfer for each command code -- a 1 indicates input
 *//*
 * New Note:
 * Support for USB Mass Storage Devices (BBB) has been added. It has
 * only been tested with USB memory sticks.
 *//* Note:
 * Currently only the CBI transport protocoll has been implemented, and it
 * is only tested with a TEAC USB Floppy. Other Massstorages with CBI or CB
 * transport protocoll may work as well.
 *//*
 * Most of this source has been derived from the Linux USB
 * project:
 *   (c) 1999-2002 Matthew Dharm (mdharm-usb@one-eyed-alien.net)
 *   (c) 2000 David L. Brown, Jr. (usb-storage@davidb.org)
 *   (c) 1999 Michael Gee (michael@linuxspecific.com)
 *   (c) 2000 Yggdrasil Computing, Inc.
 *
 *
 * Adapted for U-Boot:
 *   (C) Copyright 2001 Denis Peter, MPL AG Switzerland
 * Driver model conversion:
 *   (C) Copyright 2015 Google, Inc
 *
 * For BBB support (C) Copyright 2003
 * Gary Jennejohn, DENX Software Engineering <garyj@denx.de>
 *
 * BBB support based on /sys/dev/usb/umass.c from
 * FreeBSD.
 *//opt/src/common/xyzModem.cCan't access file"Can't access file"Sorry, zModem not available yet"Sorry, zModem not available yet"Timed out"Timed out"End of file"End of file"Cancelled"Cancelled"Invalid framing"Invalid framing"CRC/checksum error"CRC/checksum error"Block sequence error"Block sequence error"Unknown error"Unknown error"CANBSPzm_dprintf ("Flushing serial line.\n")zm_dprintf ("!!!! TRANSFER ABORT !!!!\n")(cyg_int32) 250000250000zm_dprintf ("Engaging cleanup mode...\n")zm_dprintf ("Trailing gunk:\n")zm_dprintf ("\n")xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries
"xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries\n"CRC"CRC"Cksum"Cksum"zm_flush ()xyzModem_MAX_RETRIESzm_dprintf ("ACK block %d (%d)\n", xyz.blk, __LINE__)ACKNAKzm_dprintf ("Reading Final Header\n")zm_dprintf ("FINAL ACK (%d)\n", __LINE__)zm_dprintf ("ACK (%d)\n", __LINE__)zm_dprintf ("NAK (%d)\n", __LINE__) xyzModem_MAX_RETRIEScrc_retries xyzModem_MAX_RETRIES_WITH_CRC5 * 100000100000500000xyzModem_get_hdrcan_totalhdr_charshdr_foundSOHSTXxyzModem_CAN_COUNTEOTzm_dprintf ("ACK on EOT #%d\n", __LINE__)zm_dump (__LINE__)zm_save (c)zm_save (xyz.crc2)(unsigned char) 0xFFzm_dprintf ("Framing error - blk: %x/%x/%x\n", xyz.blk, xyz.cblk, (xyz.blk ^ xyz.cblk))zm_dump_buf (xyz.pkt, xyz.len)zm_dprintf ("CRC error - recvd: %02x%02x, computed: %x\n", xyz.crc1, xyz.crc2, cksum & 0xFFFF)zm_dprintf ("Checksum error - recvd: %x, computed: %x\n", xyz.crc1, cksum & 0xFF)zm_new ()zm_save (xyz.blk)zm_save (xyz.cblk)zm_save (xyz.crc1)xyzModem_flushparse_numdigit(char *) 0(char **) 0_tolower'Z'_from_hex_is_hexCYGACC_COMM_IF_PUTCCYGACC_COMM_IF_GETC_TIMEOUTnowxyzModem_CHAR_TIMEOUTcyg_int32read_lengthfile_lengthtx_ackat_eofcrc_modetotal_CANtotal_STXtotal_SOHtotal_retriesnext_blkcrc2crc1cblk__chanxyzZM_DEBUG(x)xyzModem_MAX_RETRIES_WITH_CRCdefined(DEBUG) && !defined(CONFIG_USE_TINY_PRINTF)xyzModem_zmodem/*
 * RedBoot interface
 *//*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       *//*
       * Consume any trailing crap left in the inbuffer from
       * previous received blocks. Since very few files are an exact multiple
       * of the transfer block size, there will almost always be some gunk here.
       * If we don't eat it now, RedBoot will think the user typed it.
       *//* Might support it some day I suppose. *//* Now consume the rest of what's waiting on the line. *//* number of Backspaces is a friendly way to get the other end to abort. *//* The X/YMODEM Spec seems to suggest that multiple CAN followed by an equal *//* getc *//* Need to be able to clean out the input buffer, so have to take the *//* Don't "read" data from the EOF protocol package *//* Need new header *//* Just re-ACK this so sender will get on with it *//*
		       * See if accumulated length exceeds that of the file.
		       * If so, reduce size (i.e., cut out pad bytes)
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       *//* This code tries to detect and remove them *//* Data blocks can be padded with ^Z (EOF) characters *//* Try and get 'size' bytes into the buffer *//* Extra delay for startup *//* The rest of the file name data block quietly discarded *//* get the length *//* skip filename *//* Y-modem file information header *//* X-modem doesn't have an information header - exit here *//* TODO: CHECK ! *//*    ZM_DEBUG(zm_out = zm_out_start); *//* If we get here, the message passes [structural] muster *//* Verify checksum/CRC *//* Validate the message *//* Header found, now read the data *//* Toss any current input *//* Data stream timed out *//* Ignore, waiting for start of header *//* EOT only supported if no noise *//* Wait for multiple CAN to avoid early quits *//* Find the start of a header *//* Wait for the line to go idle *//*
 * Note: this debug setup works by storing the strings in a fixed buffer
 *//* Malformatted number *//* Found a good delimiter *//* See if this character is one of the delimiters *//* Valid digit *//* Parse (scan) a number *//* Convert a character to lower case *//* Convert a single hex nibble *//* Validate a hex character *//* Wait for 3 CAN before quitting *//* 2 seconds *//* Expected block *//* Data & state local to the protocol *//* ^Z for DOS officionados *//* Values magic to the protocol *//* Assumption - run xyzModem protocol over the console port *//*
 *==========================================================================
 *
 *      xyzModem.c
 *
 *      RedBoot stream handler for xyzModem protocol
 *
 *==========================================================================
 *#####DESCRIPTIONBEGIN####
 *
 * Author(s):    gthomas
 * Contributors: gthomas, tsmith, Yoshinori Sato
 * Date:         2000-07-14
 * Purpose:
 * Description:
 *
 * This code is part of RedBoot (tm).
 *
 *####DESCRIPTIONEND####
 *
 *==========================================================================
 */// SPDX-License-Identifier: eCos-2.0es/opt/src/include/ubifs_uboot.hubifs_ubootubifs_closeubifs_readubifs_sizeubifs_existsubifs_lsubifs_set_blk_devubifs_loadubifs_is_mounteduboot_ubifs_umountuboot_ubifs_mountubifs_init__UBIFS_UBOOT_H__/* __UBIFS_UBOOT_H__ *//*
 * UBIFS u-boot wrapper functions header
 *
 * Copyright (C) 2006-2008 Nokia Corporation
 *
 * (C) Copyright 2008-2009
 * Stefan Roese, DENX Software Engineering, sr@denx.de.
 *
 * Authors: Artem Bityutskiy ( )
 *          Adrian Hunter
 */dir_namevol_name/opt/src/disk/part.cpart_set_generic_nameconst blk_descconst blk_desc *"sd"usbd"usbd"docd"docd"mmcsd"mmcsd"xx"xx"%s%c%d"%s%c%d"part_get_info_by_dev_and_name_or_numCouldn't find partition %s %s
"Couldn't find partition %s %s\n"part_get_info_by_dev_and_namepart_strCould not find %s %d
"Could not find %s %d\n"Could not find "%s" partition
"Could not find \"%s\" partition\n"part_get_info_by_namePART_TYPE_ALLpart_get_info_by_name_typepart_driver *part_drvblk_get_device_part_strhostfs"hostfs"BOOT_PART_TYPESandbox host"Sandbox host"PARTITION_UUIDSCONFIG_VAL(PARTITION_UUIDS)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_PARTITION_UUIDSCONFIG_VAL(PARTITION_UUIDS_MODULE)CONFIG_PARTITION_UUIDS_MODULEPARTITION_UUIDS_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_PARTITION_UUIDS_MODULE__ARG_PLACEHOLDER_CONFIG_PARTITION_UUIDS_MODULE__ARG_PLACEHOLDER_CONFIG_PARTITION_UUIDS_MODULE 1bootdevice"bootdevice"** No device specified **
"** No device specified **\n"dup_strPART_UNSPECIFIEDPART_AUTO/opt/src/disk<ubifs_uboot.h>dev_ifaceallow_whole_dev** Bad partition specification %s %s **
"** Bad partition specification %s %s **\n"PART_TYPE_UNKNOWN** Bad device size - %s %s **
"** Bad device size - %s %s **\n"** No partition table - %s %s **
"** No partition table - %s %s **\n"(*dev_desc)->blkszLOG2((*dev_desc)->blksz)** Invalid partition %d **
"** Invalid partition %d **\n"tmpinfoMAX_SEARCH_PARTITIONS + 1sizeof(info->type)** Invalid partition type "%.32s" (expect "U-Boot")
"** Invalid partition type \"%.32s\""
			" (expect \"" BOOT_PART_TYPE "\")\n"blk_get_device_by_strhwpart_str** Bad device specification %s %s **
"** Bad device specification %s %s **\n"** Bad HW partition specification %s %s **
"** Bad HW partition specification %s %s **\n"DEV_TYPE_UNKNOWN"** Bad device %s %s **\n"ifname, dev_hwpart_strdebug("** Bad device %s %s **\n", ifname, dev_hwpart_str)disk/part.c409** Bad device %s %s **
dev_hwpart_strpart_get_info_whole_diskWhole Disk"Whole Disk"part_get_info"## Unknown partition table type %x\n"dev_desc->part_typedebug("## Unknown partition table type %x\n",
		      dev_desc->part_type)335## Unknown partition table type %x
"## Driver %s does not have the get_info() method\n"drv->name"## Valid %s partition found ##\n"part_print"## Testing for valid %s partition ##\n"print_part_header
Partition Map for "\nPartition Map for "IDE"IDE"SATA"SATA"SCSI"SCSI"ATAPI"ATAPI"USB"USB"DOC"DOC"MMC"MMC"HOST"HOST"NVMe"NVMe"VirtIO"VirtIO""UNKNOWN" device %d  --   Partition Type: %s

" device %d  --   Partition Type: %s\n\n"MAC_PARTITIONCONFIG_VAL(MAC_PARTITION)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_MAC_PARTITIONCONFIG_MAC_PARTITIONCONFIG_VAL(MAC_PARTITION_MODULE)CONFIG_MAC_PARTITION_MODULEMAC_PARTITION_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_MAC_PARTITION_MODULE__ARG_PLACEHOLDER_CONFIG_MAC_PARTITION_MODULE__ARG_PLACEHOLDER_CONFIG_MAC_PARTITION_MODULE 1DOS_PARTITIONCONFIG_VAL(DOS_PARTITION)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_DOS_PARTITIONCONFIG_DOS_PARTITIONCONFIG_VAL(DOS_PARTITION_MODULE)CONFIG_DOS_PARTITION_MODULEDOS_PARTITION_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_DOS_PARTITION_MODULE__ARG_PLACEHOLDER_CONFIG_DOS_PARTITION_MODULE__ARG_PLACEHOLDER_CONFIG_DOS_PARTITION_MODULE 1ISO_PARTITIONCONFIG_VAL(ISO_PARTITION)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_ISO_PARTITIONCONFIG_ISO_PARTITIONCONFIG_VAL(ISO_PARTITION_MODULE)CONFIG_ISO_PARTITION_MODULEISO_PARTITION_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_ISO_PARTITION_MODULE__ARG_PLACEHOLDER_CONFIG_ISO_PARTITION_MODULE__ARG_PLACEHOLDER_CONFIG_ISO_PARTITION_MODULE 1AMIGA_PARTITIONCONFIG_VAL(AMIGA_PARTITION)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_AMIGA_PARTITIONCONFIG_AMIGA_PARTITIONCONFIG_VAL(AMIGA_PARTITION_MODULE)CONFIG_AMIGA_PARTITION_MODULEAMIGA_PARTITION_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_AMIGA_PARTITION_MODULE__ARG_PLACEHOLDER_CONFIG_AMIGA_PARTITION_MODULE__ARG_PLACEHOLDER_CONFIG_AMIGA_PARTITION_MODULE 1EFI_PARTITIONCONFIG_VAL(EFI_PARTITION)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_EFI_PARTITIONCONFIG_EFI_PARTITIONCONFIG_VAL(EFI_PARTITION_MODULE)CONFIG_EFI_PARTITION_MODULEEFI_PARTITION_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_EFI_PARTITION_MODULE__ARG_PLACEHOLDER_CONFIG_EFI_PARTITION_MODULE__ARG_PLACEHOLDER_CONFIG_EFI_PARTITION_MODULE 1part_initstruct part_driverpart_driverll_entry_start(struct part_driver, part_driver).u_boot_list_2_part_driver_1n_entsll_entry_count(struct part_driver, part_driver).u_boot_list_2_part_driver_3"%s: try '%s': ret=%d\n"__func__, entry->name, retdebug("%s: try '%s': ret=%d\n", __func__, entry->name, ret)%s: try '%s': ret=%d
dev_printnot available
"not available\n"(%d:%d) Vendor: %s Prod.: %s Rev: %s
"(%d:%d) Vendor: %s Prod.: %s Rev: %s\n"Model: %s Firm: %s Ser#: %s
"Model: %s Firm: %s Ser#: %s\n"Vendor: %s Rev: %s Prod: %s
"Vendor: %s Rev: %s Prod: %s\n"%s VirtIO Block Device
"%s VirtIO Block Device\n"device type DOC
"device type DOC\n"device type unknown
"device type unknown\n"Unhandled device type: %i
"Unhandled device type: %i\n"            Type: "            Type: "Removable "Removable "DEV_TYPE_HARDDISKHard Disk"Hard Disk"DEV_TYPE_CDROMCD ROM"CD ROM"DEV_TYPE_OPDISKOptical Device"Optical Device"DEV_TYPE_TAPETape"Tape"# %02X #"# %02X #"0Lmbmb_quotmb_remgbgb_quotgb_remlba512            Capacity: %lu.%lu MB = %lu.%lu GB (%lu x %lu)
"            Capacity: %lu.%lu MB = %lu.%lu GB (%lu x %lu)\n"            Capacity: not available
"            Capacity: not available\n"lba512_muldivbc_quotbc_remblk_get_devget_dev_hwpart"%s: No device for iface '%s', dev %d\n"__func__, ifname, devdebug("%s: No device for iface '%s', dev %d\n", __func__,
		      ifname, dev)%s: No device for iface '%s', dev %d
"%s: Failed to select h/w partition: err-%d\n"debug("%s: Failed to select h/w partition: err-%d\n", __func__,
		      ret)%s: Failed to select h/w partition: err-%d
part_driver_lookup_typelba512_tPRINTF(fmt,args...)PART_DEBUGdefined(CONFIG_SYS_64BIT_LBA)CONFIG_IS_ENABLED(MAC_PARTITION) || \CONFIG_IS_ENABLED(PARTITION_UUIDS)CONFIG_CMD_UBIFS/*
	 * Couldn't lookup by name, try looking up the partition description
	 * directly.
	 *//* Split the part_name if passed as "$dev_num#part_name". *//* Not all the first part before the # was parsed. *//**
 * Get partition info from device number and partition name.
 *
 * Parse a device number and partition name string in the form of
 * "device_num#partition_name", for example "0#misc". If the partition
 * is found, sets dev_desc and part_info accordingly with the information
 * of the partition with the given partition_name.
 *
 * @param[in] dev_iface Device interface
 * @param[in] dev_part_str Input string argument, like "0#misc"
 * @param[out] dev_desc Place to store the device description pointer
 * @param[out] part_info Place to store the partition information
 * @return 0 on success, or a negative on error
 *//* matched *//* no more entries in table *//*
			 * If we searched all possible partition IDs,
			 * return the first valid partition we found.
			 *//* If we found any acceptable partition *//*
			 * We now need to search further for best possible.
			 * If we what we just queried was the best so far,
			 * save the info since we over-write it next loop.
			 *//* Best possible partition? Stop searching. *//*
			 * First valid partition, or new better partition?
			 * If so, save partition ID.
			 *//*
		 * Find the first bootable partition.
		 * If none are bootable, fall back to the first valid partition.
		 *//*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 *//*
	 * Now there's known to be a partition table,
	 * not specifying a partition means to pick partition 1.
	 *//*
		 * If user specified a partition ID other than 0,
		 * or the calling command only accepts partitions,
		 * it's an error.
		 *//*
	 * No partition table on device,
	 * or user requested partition 0 (entire device).
	 *//*
		 * Less than whole string converted,
		 * or request for whole device, but caller requires partition.
		 *//* Something specified -> use exactly that *//* Convert partition ID string to number *//* Look up the device *//* Separate device and partition ID specification *//* If still no dev_part_str, it's an error *//* If no dev_part_str, use bootdevice environment variable *//*
	 * Special-case ubi, ubi goes through a mtd, rather than through
	 * a regular block device.
	 *//*
	 * Special-case a pseudo block device "hostfs", to allow access to the
	 * host's own filesystem.
	 *//*
	 * Updates the partition table for the specified hw partition.
	 * Always should be done, otherwise hw partition 0 will return stale
	 * data after displaying a non-zero hw partition.
	 *//* CONFIG_HAVE_BLOCK_DEVICE *//* The common case is no UUID support *//* any CONFIG_..._PARTITION *//* 2048 = (1024 * 1024) / 512 MB *//* round to 1 digit *//* number of blocks if 512bytes block size *//* x * m / d == x / d * m + (x % d) * m / d *//*
 * Overflowless variant of (block_count * mul_by / 2**div_by)
 * when div_by > mul_by
 *//*
 * reports device info to the user
 *//* Not found *//* Check all partition types */block_countmul_bydiv_by/opt/src/disk/part_amiga.hpart_amigaamiga_part_geometrybootcode_blockpartition_blockrigid_disk_blockboot_blocksbauddos_typeboot_prioritymax_transferbuf_mem_typenum_buffershigh_cyllow_cylinterleavepreallocblock_per_tracksector_per_blocksurfacessize_blockstable_sizeu32[123]unsigned int[123]load_datahost_idchk_sumsummed_longsu32[15]unsigned int[15]reserved_3u32[17]reserved_2drive_namedev_flagsreserved_1u32[10]unsigned int[10]reserved_5controller_revisioncontroller_productcontroller_vendordisk_revisiondisk_productdisk_vendorreserved_4high_rdsk_blockauto_park_secondscyl_blockshi_cylinderlo_cylinderrdb_blocks_hirdb_blocks_lostep_ratereduced_writewrite_pre_compu32[3]parkcylindersdrive_initfile_sys_header_listpartition_listbad_block_listblock_bytesAMIGA_ID_BOOT0x424f4f54AMIGA_ID_PART0x50415254AMIGA_ID_RDISK0x5244534BAMIGA_BLOCK_LIMITDEFAULT_SECTOR_SIZE_DISK_PART_AMIGA_HCONFIG_IS_ENABLED(ISO_PARTITION)/* _DISK_PART_AMIGA_H_ *//*
 * The environment array in the partition block
 * describes the partition
 *//*
 * Each partition on this drive is defined by such a block
 *//* logical drive geometry *//* Physical drive geometry *//*
 * Amiga disks have a very open structure. The head for the partition table information
 * is stored somewhere within the first 16 blocks on disk, and is called the
 * "RigidDiskBlock".
 *//* Make the buffers bigger if ISO partition support is enabled -- CD-ROMS
   have 2048 byte blocks *//*
 * (C) Copyright 2000
 * Hans-Joerg Frieden, Hyperion Entertainment
 * Hans-JoergF@hyperion-entertainment.com
 *//opt/src/disk/part_amiga.cpart_print_amigarigid_disk_block *rdb"part_print_amiga: no rdb found\n"Summary:  DiskBlockSize: %d
          Cylinders    : %d
          Sectors/Track: %d
          Heads        : %d

"Summary:  DiskBlockSize: %d\n"
	   "          Cylinders    : %d\n"
	   "          Sectors/Track: %d\n"
	   "          Heads        : %d\n\n"                 First   Num. 
Nr.  Part. Name  Block   Block  Type        Boot Priority
"                 First   Num. \n"
	   "Nr.  Part. Name  Block   Block  Type        Boot Priority\n"unsigned char[2048]partition_block *1346458196block_header *%-4d "%-4d ""PART block suspect at 0x%x, checking checksum\n""Trying to load block #0x%X\n"bootcode_block *Disk is bootable
"Disk is bootable\n""part_print_amiga: Scanning partition list\n""part_print_amiga: partition list at 0x%x\n"part_get_info_amigaamiga_part_geometry *u32(*)[17]unsigned int(*)[17]disk_type0xFF0000000x00FF00000x0000FF00find_partition"find_partition: no rdb found\n""PART block not found\n""Trying to find partition block %d\n""find_partition: Scanning partition list\n""find_partition: partition list at 0x%x\n"part_test_amigabootcode"part_test_amiga: bootable Amiga disk\n""part_test_amiga: non-bootable Amiga disk\n""part_test_amiga: no RDB found\n""part_test_amiga: Testing for an Amiga RDB partition\n"get_bootcodeamiga_scanlimit"amiga_scanlimit""part_amiga.h"1112493908sizeof(struct bootcode_block)"Found valid bootcode block\n""BOOT block at %d, checking checksum\n""Scanning for BOOT from 0 to %d\n""No boot code found on disk\n"get_rdisktrdb1380209483sizeof(struct rigid_disk_block)"FOUND\n""Rigid disk block suspect at %d, checking checksum\n""Done scanning, no RDB found\n"print_part_info%6d	%6d	"%6d\t%6d\t"	%5d
"\t%5d\n"print_disk_typesum_blockbstr_printbcpl_strcpyblock_headerAMIGA"AMIGA"PART_TYPE_AMIGAAMIGA_ENTRY_NUMBERS_u_boot_list_2_part_driver_2_amiga.u_boot_list_2_part_driver_2_amigaamigablock_bufferAMIGA_DEBUG/*
 * Get info about a partition
 *//*
 * Find partition number partnum on the given drive.
 *//*
 * Test if the given partition has an Amiga partition table/Rigid
 * Disk block
 *//*
 * Search for boot code
 * Again, the first boot block must be located somewhere in the first 16 blocks, or rooted in the
 * Ridgid disk block
 *//*
 * Search for the Rigid Disk Block. The rigid disk block is required
 * to be within the first 16 blocks of a drive, needs to have
 * the ID AMIGA_ID_RDISK ('RDSK') and needs to have a valid
 * sum-to-zero checksum
 *//*
 * Print the info contained within the given partition block
 *//*
 * Print an AmigaOS disk type. Disk types are a four-byte identifier
 * describing the file system. They are usually written as a three-letter
 * word followed by a backslash and a version number. For example,
 * DOS\0 would be the original file system. SFS\0 would be SmartFileSystem.
 * DOS\1 is FFS.
 *//*
 * Sum a block. The checksum of a block must end up at zero
 * to be valid. The chk_sum field is selected so that adding
 * it yields zero.
 *//*
 * Print a BCPL String. BCPL strings start with a byte with the length
 * of the string, and don't contain a terminating nul character
 *//*
 * Copy a bcpl to a c string
 *//*
 * (C) Copyright 2001
 * Hans-Joerg Frieden, Hyperion Entertainment
 * Hans-JoergF@hyperion-entertainment.com
 *//opt/src/disk/part_dos.hpart_dosdos_partition_tdos_partitionsize4start4end_cylend_sectorend_headsys_indcylboot_indDOS_PBRDOS_MBRDOS_PBR_MEDIA_TYPE_OFFSETDOS_PBR32_FSTYPE_OFFSETDOS_PBR_FSTYPE_OFFSETDOS_PART_MAGIC_OFFSET0x1feDOS_PART_TBL_OFFSET0x1beDOS_PART_DISKSIG_OFFSET_DISK_PART_DOS_H/* _DISK_PART_DOS_H *//* nr of sectors in partition		*//* starting sector counting from 0	*//* end cylinder				*//* end sector				*//* end head				*//* What partition type			*//* starting cylinder			*//* starting sector			*//* starting head			*//* 0x80 - active			*//opt/src/disk/part_dos.cwrite_mbr_partition%s: failed writing '%s' (1 blks at 0x0)
"%s: failed writing '%s' (1 blks at 0x0)\n"MBR"MBR"is_valid_dos_bufpart_get_info_dospart_print_dosPart	Start Sector	Num Sectors	UUID		Type
"Part\tStart Sector\tNum Sectors\tUUID\t\tType\n"part_get_info_extendedPAD_SIZE((dev_desc->blksz) * sizeof(unsigned char), 1)(((((dev_desc->blksz) * sizeof(unsigned char)) - 1) / (1) + 1) * 1)(dev_desc->blksz) * sizeof(unsigned char)ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz)MAX_EXT_PARTS** Nested DOS partitions detected, stopping **
"** Nested DOS partitions detected, stopping **\n"** Can't read partition table on %d:%lu **
"** Can't read partition table on %d:" LBAFU " **\n"DOS_PART_MAGIC_OFFSET + 1bad MBR sector signature 0x%02x%02x
"bad MBR sector signature 0x%02x%02x\n"440dos_partition_t *dos_partition *pt-129~0x80DOS_PART_DEFAULT_SECTOR%08x-%02x"%08x-%02x"lba_start"part_dos.h"ext_part_sectorrelativewhich_partdisksigprint_partition_extendedpart_test_doslegacy_mbrmbrPAD_SIZE((1) * sizeof(legacy_mbr), 1)(((((1) * sizeof(legacy_mbr)) - 1) / (1) + 1) * 1)(1) * sizeof(legacy_mbr)(uintptr_t)__mbr((uintptr_t)__mbr)(typeof((uintptr_t)__mbr))(16)-1legacy_mbr *_legacy_mbr *ALLOC_CACHE_ALIGN_BUFFER(legacy_mbr, mbr, 1)__mbrtest_block_typeDOS_PART_MAGIC_OFFSET + 0FAT"FAT"FAT32"FAT32"print_one_part%3d	%-10lu	%-10lu	%08x-%02x	%02x%s%s
"%3d\t%-10" LBAFlength "u\t%-10" LBAFlength
		"u\t%08x-%02x\t%02x%s%s\n"lba_size Extd" Extd" Boot" Boot"is_bootableis_extendedle32_to_intDOS"DOS"PART_TYPE_DOSDOS_ENTRY_NUMBERS_u_boot_list_2_part_driver_2_dos.u_boot_list_2_part_driver_2_dosdos/* write MBR *//* Check for DOS PBR if no partition is found *//* Follows the extended partitions *//* Reverse engr the fdisk part# assignment rule! *//* sprintf(info->type, "%d, pt->sys_ind); *//*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 *//* Print all primary/logical partitions *//* set a maximum recursion level *//*  Print a partition that is relative to its Extended partition table
 *//* Is MBR *//* is PBR *//* no DOS Signature at all *//* Convert char[4] in little endian format to the host format integer
 *//* should this be configurable? It looks like it's not very common at all
 * to use large numbers of partitions *//*
 * Support for harddisk partitions.
 *
 * To be compatible with LinuxPPC and Apple we use the standard Apple
 * SCSI disk partitioning scheme. For more information see:
 * http://developer.apple.com/techpubs/mac/Devices/Devices-126.html#MARKER-14-92
 *//*
 * (C) Copyright 2001
 * Raymond Lo, lo@routefree.com
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 *//opt/src/disk/part_efi.cis_pte_valid%s: Invalid Argument(s)
"%s: Invalid Argument(s)\n"unused_guidsizeof(unused_guid.b)"%s: Found an unused PTE GUID at 0x%08X\n"__func__, (unsigned int)(uintptr_t)ptedebug("%s: Found an unused PTE GUID at 0x%08X\n", __func__,
		      (unsigned int)(uintptr_t)pte)disk/part_efi.c1075%s: Found an unused PTE GUID at 0x%08X
alloc_read_gpt_entriespgpt_head->num_partition_entriespgpt_head->sizeof_partition_entry"%s: count = %u * %u = %lu\n"__func__, (u32) le32_to_cpu(pgpt_head->num_partition_entries), (u32) le32_to_cpu(pgpt_head->sizeof_partition_entry), (ulong)countdebug("%s: count = %u * %u = %lu\n", __func__,
	      (u32) le32_to_cpu(pgpt_head->num_partition_entries),
	      (u32) le32_to_cpu(pgpt_head->sizeof_partition_entry),
	      (ulong)count)%s: count = %u * %u = %lu
ptePAD_TO_BLOCKSIZE(count, dev_desc)%s: ERROR: Can't allocate %#lX bytes for GPT Entries
"%s: ERROR: Can't allocate %#lX bytes for GPT Entries\n"pgpt_head->partition_entry_lbablk_cntBLOCK_CNT(count, dev_desc)*** ERROR: Can't read GPT Entries ***
"*** ERROR: Can't read GPT Entries ***\n"is_gpt_validPAD_SIZE((1) * sizeof(legacy_mbr), dev_desc->blksz)(((((1) * sizeof(legacy_mbr)) - 1) / (dev_desc->blksz) + 1) * dev_desc->blksz)ALLOC_CACHE_ALIGN_BUFFER_PAD(legacy_mbr, mbr, 1, dev_desc->blksz)pgpt_headpgpt_pte*** ERROR: Can't read MBR header ***
"*** ERROR: Can't read MBR header ***\n"*** ERROR: Can't read GPT header ***
"*** ERROR: Can't read GPT header ***\n"emptysizeof(empty)GPT: Failed to allocate memory for PTE
"GPT: Failed to allocate memory for PTE\n"is_pmbr_validmbr->signature43605MSDOS_MBR_SIGNATUREpartition *partition[4]pmbr_part_validEFI_PMBR_OSTYPE_EFI_GPT__le32 *write_mbr_and_gpt_partitionsgpt_hGPT_PRIMARY_PARTITION_TABLE_LBAgpt_egpt_h->partition_entry_lbagpt_e_blk_cnt(le32_to_cpu(gpt_h->num_partition_entries) * le32_to_cpu(gpt_h->sizeof_partition_entry))(((__u32)(__le32)(gpt_h->num_partition_entries)) * ((__u32)(__le32)(gpt_h->sizeof_partition_entry)))gpt_h->num_partition_entriesgpt_h->sizeof_partition_entryBLOCK_CNT((le32_to_cpu(gpt_h->num_partition_entries) *
				   le32_to_cpu(gpt_h->sizeof_partition_entry)),
				  dev_desc)%s: failed writing '%s' (%d blks at 0x%lx)
"%s: failed writing '%s' (%d blks at 0x" LBAF ")\n"Primary GPT Header"Primary GPT Header"Primary GPT Entries"Primary GPT Entries"Backup GPT Entries"Backup GPT Entries"gpt_h->my_lbaBackup GPT Header"Backup GPT Header"is_valid_gpt_bufgpt_verify_partitions"More partitions than allowed!\n"pr_err("More partitions than allowed!\n")pr_fmt("More partitions than allowed!\n")More partitions than allowed!
PARTNAME_SZPARTNAME_SZ + 1efi_strefi_char16_t[36]unsigned short[36]efi_char16_t *"%s: part: %2d name - GPT: %16s, ENV: %16s "__func__, i, efi_str, partitions[i].namedebug("%s: part: %2d name - GPT: %16s, ENV: %16s ",
		      __func__, i, efi_str, partitions[i].name)750%s: part: %2d name - GPT: %16s, ENV: %16s sizeof(partitions->name)"Partition name: %s does not match %s!\n"efi_str, (char *)partitions[i].namepr_err("Partition name: %s does not match %s!\n",
			      efi_str, (char *)partitions[i].name)pr_fmt("Partition name: %s does not match %s!\n")Partition name: %s does not match %s!
gpt_part_sizegpt_e[i].ending_lbagpt_e[i].starting_lba"size(LBA) - GPT: %8llu, ENV: %8llu "(unsigned long long)gpt_part_size, (unsigned long long)partitions[i].sizedebug("size(LBA) - GPT: %8llu, ENV: %8llu ",
		      (unsigned long long)gpt_part_size,
		      (unsigned long long)partitions[i].size)764size(LBA) - GPT: %8llu, ENV: %8llu "Partition %s size: %llu does not match %llu!\n"efi_str, (unsigned long long)gpt_part_size, (unsigned long long)partitions[i].sizepr_err("Partition %s size: %llu does not match %llu!\n",
			      efi_str, (unsigned long long)gpt_part_size,
			      (unsigned long long)partitions[i].size)pr_fmt("Partition %s size: %llu does not match %llu!\n")Partition %s size: %llu does not match %llu!
782"start LBA - GPT: %8llu, ENV: %8llu\n"le64_to_cpu(gpt_e[i].starting_lba), (unsigned long long)partitions[i].startdebug("start LBA - GPT: %8llu, ENV: %8llu\n",
		      le64_to_cpu(gpt_e[i].starting_lba),
		      (unsigned long long)partitions[i].start)789start LBA - GPT: %8llu, ENV: %8llu
"Partition %s start: %llu does not match %llu!\n"efi_str, le64_to_cpu(gpt_e[i].starting_lba), (unsigned long long)partitions[i].startpr_err("Partition %s start: %llu does not match %llu!\n",
			      efi_str, le64_to_cpu(gpt_e[i].starting_lba),
			      (unsigned long long)partitions[i].start)pr_fmt("Partition %s start: %llu does not match %llu!\n")Partition %s start: %llu does not match %llu!
gpt_verify_headers%s: *** ERROR: Invalid GPT ***
"%s: *** ERROR: Invalid GPT ***\n"%s: *** ERROR: Invalid Backup GPT ***
"%s: *** ERROR: Invalid Backup GPT ***\n"gpt_convert_efi_name_to_charessgpt_restoresizeof(gpt_header)PAD_TO_BLOCKSIZE(sizeof(gpt_header), dev_desc)%s: calloc failed!
"%s: calloc failed!\n"GPT_ENTRY_NUMBERS * sizeof(gpt_entry)128 * sizeof(gpt_entry)PAD_TO_BLOCKSIZE(GPT_ENTRY_NUMBERS * sizeof(gpt_entry),
				dev_desc)sizeof(gpt_entry)PAD_TO_BLOCKSIZE(GPT_ENTRY_NUMBERS * sizeof(gpt_entry)16383gpt_fill_headerGPT_HEADER_SIGNATURE_UBOOT0x5452415020494645ULL6075990659671082565cpu_to_le64GPT_HEADER_REVISION_V1dev_desc->lba - 1dev_desc->lba - 34partition_entries_offset(dev_desc)le64_to_cpu(gpt_h->partition_entry_lba) + 32((__u64)(__le64)(gpt_h->partition_entry_lba)) + 32GPT_ENTRY_NUMBERSpartition_entries_offsetoffset_bytesCONFIG_EFI_PARTITION_ENTRIES_OFFPAD_TO_BLOCKSIZE(CONFIG_EFI_PARTITION_ENTRIES_OFF, dev_desc)offset_blksconfig_offsetu-boot,efi-partition-entries-offset"u-boot,efi-partition-entries-offset"PAD_TO_BLOCKSIZE(config_offset, dev_desc)"efi: partition entries offset (in blocks): %d\n"debug("efi: partition entries offset (in blocks): %d\n", offset_blks)593efi: partition entries offset (in blocks): %d
str_guidgpt_fill_ptegpt_h->first_usable_lbagpt_h->last_usable_lbahdr_endhdr_startpte_endpte_startPartition overlap
"Partition overlap\n"last_usable_lbaPartitions layout exceds disk size
"Partitions layout exceds disk size\n"offset - 1str_uuidbin_uuidPartition no. %d: invalid guid: %s
"Partition no. %d: invalid guid: %s\n"gpt_entry_attributes *_gpt_entry_attributes *sizeof(gpt_entry_attributes)efiname_lensizeof(gpt_e[i].partition_name)sizeof(efi_char16_t)sizeof(gpt_e[i].partition_name)
			/ sizeof(efi_char16_t)dosname_lensizeof(partitions[i].name)"%s: name: %s offset[%d]: 0x" LBAF " size[%d]: 0x" LBAF "\n""%s: name: %s offset[%d]: 0x" "%" "l" "x" " size[%d]: 0x" "%" "l" "x" "\n"__func__, partitions[i].name, i, offset, i, sizedebug("%s: name: %s offset[%d]: 0x" LBAF
		      " size[%d]: 0x" LBAF "\n",
		      __func__, partitions[i].name, i,
		      offset, i, size)%s: name: %s offset[%d]: 0x%lx size[%d]: 0x%lx
"%s: name: %s offset[%d]: 0x" LBAF
		      " size[%d]: 0x" LBAF "\n"write_gpt_table(gpt_h->num_partition_entries * sizeof(gpt_entry))"max lba: %x\n"(u32) dev_desc->lbadebug("max lba: %x\n", (u32) dev_desc->lba)397max lba: %x
calc_crc32gpt_h->header_sizepte_blk_cntBLOCK_CNT((gpt_h->num_partition_entries
					   * sizeof(gpt_entry)BLOCK_CNT((gpt_h->num_partition_entries
					   * sizeof(gpt_entry)), dev_desc)"GPT successfully written to block device!\n"debug("GPT successfully written to block device!\n")430GPT successfully written to block device!
** Can't write to device %d **
"** Can't write to device %d **\n"set_protective_mbrp_mbrALLOC_CACHE_ALIGN_BUFFER_PAD(legacy_mbr, p_mbr, 1, dev_desc->blksz)(uintptr_t)__p_mbr((uintptr_t)__p_mbr)(typeof((uintptr_t)__p_mbr))(16)-1__p_mbr"** Can't read from device %d **\n"dev_desc->devnumpr_err("** Can't read from device %d **\n", dev_desc->devnum)pr_fmt("** Can't read from device %d **\n")** Can't read from device %d **
MSDOS_MBR_BOOT_CODE_SIZEsizeof(*p_mbr)sizeof(*p_mbr) -
			MSDOS_MBR_BOOT_CODE_SIZEpart_test_efilegacymbrALLOC_CACHE_ALIGN_BUFFER_PAD(legacy_mbr, legacymbr, 1, dev_desc->blksz)(uintptr_t)__legacymbr((uintptr_t)__legacymbr)(typeof((uintptr_t)__legacymbr))(16)-1__legacymbrpart_get_info_efiPAD_SIZE((1) * sizeof(gpt_header), dev_desc->blksz)(((((1) * sizeof(gpt_header)) - 1) / (dev_desc->blksz) + 1) * dev_desc->blksz)ALLOC_CACHE_ALIGN_BUFFER_PAD(gpt_header, gpt_head, 1, dev_desc->blksz)%s: ***        Using Backup GPT ***
"%s: ***        Using Backup GPT ***\n"gpt_head->num_partition_entries"%s: *** ERROR: Invalid partition number %d ***\n"__func__, partdebug("%s: *** ERROR: Invalid partition number %d ***\n",
			__func__, part)%s: *** ERROR: Invalid partition number %d ***
gpt_pte[part - 1].starting_lbagpt_pte[part - 1].ending_lbasizeof(info->name)"%s: start 0x" LBAF ", size 0x" LBAF ", name %s\n""%s: start 0x" "%" "l" "x" ", size 0x" "%" "l" "x" ", name %s\n"__func__, info->start, info->size, info->namedebug("%s: start 0x" LBAF ", size 0x" LBAF ", name %s\n", __func__,
	      info->start, info->size, info->name)%s: start 0x%lx, size 0x%lx, name %s
part_print_efi"%s: gpt-entry at %p\n"__func__, gpt_ptedebug("%s: gpt-entry at %p\n", __func__, gpt_pte)%s: gpt-entry at %p
Part	Start LBA	End LBA		Name
"Part\tStart LBA\tEnd LBA\t\tName\n"	Attributes
"\tAttributes\n"	Type GUID
"\tType GUID\n"	Partition GUID
"\tPartition GUID\n"%3d	0x%08llx	0x%08llx	"%s"
"%3d\t0x%08llx\t0x%08llx\t\"%s\"\n"gpt_pte[i].starting_lbagpt_pte[i].ending_lba	attrs:	0x%016llx
"\tattrs:\t0x%016llx\n"uuid_bin	type:	%s
"\ttype:\t%s\n"	guid:	%s
"\tguid:\t%s\n"get_disk_guidguid_binprepare_backup_gpt_headerle64_to_cpu(gpt_h->last_usable_lba) + 1((__u64)(__le64)(gpt_h->last_usable_lba)) + 1validate_gpt_entriesgpt_h->partition_entry_array_crc32%s: 0x%x != 0x%x
"%s: 0x%x != 0x%x\n"GUID Partition Table Entry Array CRC is wrong"GUID Partition Table Entry Array CRC is wrong"validate_gpt_headergpt_h->signature%s signature is wrong: 0x%llX != 0x%llX
"%s signature is wrong: 0x%llX != 0x%llX\n"GUID Partition Table Header"GUID Partition Table Header"crc32_backupsizeof(crc32_backup)sizeof(gpt_h->header_crc32)%s CRC is wrong: 0x%x != 0x%x
"%s CRC is wrong: 0x%x != 0x%x\n"GPT: my_lba incorrect: %llX != %lx
"GPT: my_lba incorrect: %llX != " LBAF "\n"GPT: first_usable_lba incorrect: %llX > %lx
"GPT: first_usable_lba incorrect: %llX > " LBAF "\n"GPT: last_usable_lba incorrect: %llX > %lx
"GPT: last_usable_lba incorrect: %llX > " LBAF "\n""GPT: first_usable_lba: %llX last_usable_lba: %llX last lba: " LBAF "\n""GPT: first_usable_lba: %llX last_usable_lba: %llX last lba: " "%" "l" "x" "\n"le64_to_cpu(gpt_h->first_usable_lba), le64_to_cpu(gpt_h->last_usable_lba), lastlbadebug("GPT: first_usable_lba: %llX last_usable_lba: %llX last lba: "
	      LBAF "\n", le64_to_cpu(gpt_h->first_usable_lba),
	      le64_to_cpu(gpt_h->last_usable_lba), lastlba)GPT: first_usable_lba: %llX last_usable_lba: %llX last lba: %lx
"GPT: first_usable_lba: %llX last_usable_lba: %llX last lba: "
	      LBAF "\n"print_efinameefi_crc32EFI"EFI"PART_TYPE_EFI_u_boot_list_2_part_driver_2_a_efi.u_boot_list_2_part_driver_2_a_efia_efi0xC12A73280xF81F0x11d20xBA0x4B3240784680PARTITION_SYSTEM_GUID1265931549450635194562system_guid0xEBD0A0A20xB9E50x44330xB60xB70x990xC73956318370PARTITION_BASIC_DATA_GUIDlastlba15454368603684758917459partition_basic_data_guidCONFIG_IS_ENABLED(EFI_PARTITION)defined(CONFIG_EFI_PARTITION_ENTRIES_OFF)defined(CONFIG_OF_CONTROL)/*
 * Add an 'a_' prefix so it comes before 'dos' in the linker list. We need to
 * check EFI first, since a DOS partition is often used as a 'protective MBR'
 * with EFI.
 *//* Only one validation for now:
	 * The GUID Partition Type != Unused Entry (ALL-ZERO)
	 *//**
 * is_pte_valid(): validates a single Partition Table Entry
 * @gpt_entry - Pointer to a single Partition Table Entry
 *
 * Description: returns 1 if valid,  0 on error.
 *//* Read GPT Entries from device *//* Allocate memory for PTE, remember to FREE *//**
 * alloc_read_gpt_entries(): reads partition entries from disk
 * @dev_desc
 * @gpt - GPT header
 *
 * Description: Returns ptes on success,  NULL on error.
 * Allocates space for PTEs based on information found in @gpt.
 * Notes: remember to free pte when you're done!
 *//* We're done, all's well *//* Read and allocate Partition Table Entries *//* Read GPT Header from device *//* Read MBR Header from device *//* Confirm valid arguments prior to allocation. *//**
 * is_gpt_valid() - tests one GPT header and PTEs for validity
 *
 * lba is the logical block address of the GPT header to test
 * gpt is a GPT header ptr, filled on return.
 * ptes is a PTEs ptr, filled on return.
 *
 * Description: returns 1 if valid,  0 on error.
 * If valid, returns pointers to PTEs.
 *//*
 * is_pmbr_valid(): test Protective MBR for validity
 *
 * Returns: 1 if PMBR is valid, 0 otherwise.
 * Validity depends on two things:
 *  1) MSDOS signature is in the last two bytes of the MBR
 *  2) One partition of type 0xEE is found, checked by pmbr_part_valid()
 *//*
 * pmbr_part_valid(): Check for EFI partition signature
 *
 * Returns: 1 if EFI GPT partition type is found.
 *//*
 * Private functions
 *//* GPT Header (1 block) *//* write Backup GPT *//* write Primary GPT *//* MBR (1 block) *//* MBR is always at 0 *//* determine start of GPT Entries in the buffer *//* determine start of GPT Header in the buffer *//* Check if GPT and ENV start LBAs match *//*
		 * Start address is optional - check only if provided
		 * in '$partition' variable
		 *//* We do not check the extend partition size *//* Check if GPT and ENV sizes match *//* Check if GPT and ENV partition names match *//* Free pte before allocating again *//*
	 * This function validates AND
	 * fills in the GPT header and PTE
	 *//**
 * gpt_convert_efi_name_to_char() - convert u16 string to char string
 *
 * TODO: this conversion only supports ANSI characters
 *
 * @s:	target buffer
 * @es:	u16 string to be converted
 * @n:	size of target buffer
 *//* Write GPT partition table *//* Generate partition entries *//* Generate Primary GPT header (LBA1) *//*
	 * The earliest LBA this can be at is LBA#2 (i.e. right behind
	 * the (protective) MBR and the GPT header.
	 *//*
	 * Allow the offset of the first partition entires (in bytes
	 * from the start of the device) to be specified as a property
	 * of the device tree '/config' node.
	 *//*
	 * Some architectures require their SPL loader at a fixed
	 * address within the first 16KB of the disk.  To avoid an
	 * overlap with the partition entries of the EFI partition
	 * table, the first safe offset (in bytes, from the start of
	 * the disk) for the entries can be set in
	 * CONFIG_EFI_PARTITION_ENTRIES_OFF.
	 *//* partition attributes *//* partition type GUID *//* default partition type GUID *//* extend the last partition to maximuim *//* partition ending lba *//*
		 * If our partition overlaps with either the GPT
		 * header, or the partition entry, reject it.
		 *//* partition starting lba *//* Write the First GPT to the block right after the Legacy MBR *//* Generate CRC for the Primary GPT Header *//* Setup the Protective MBR *//* Write MBR sector to the MMC device *//* Append signature *//* Clear all data in MBR except of backed up boot code *//* Read MBR to backup boot code if it exists *//**
 * set_protective_mbr(): Set the EFI protective MBR
 * @param dev_desc - block device descriptor
 *
 * @return - zero on success, otherwise error
 *//* Read legacy MBR from block 0 and validate it *//* Remember to free pte *//* The ending LBA is inclusive, to calculate size, add 1 to it *//* The 'lbaint_t' casting may limit the maximum disk size to 2 TB *//* This function validates AND fills in the GPT header and PTE *//* "part" argument must be at least 1 *//* Stop at the first non valid PTE *//*
 * UUID is displayed as 32 hexadecimal digits, in 5 groups,
 * separated by hyphens, in the form 8-4-4-4-12 for a total of 36 characters
 *//*
 * Public Functions (include/part.h)
 *//* recalculate the values for the Backup GPT Header *//* Check the GUID Partition Table Entry Array CRC *//*
	 * Check that the first_usable_lba and that the last_usable_lba are
	 * within the disk.
	 *//*
	 * Check that the my_lba entry points to the LBA that contains the GPT
	 *//* Check the GUID Partition Table CRC *//* Check the GPT header signature *//*
 * Private function prototypes
 *//**
 * efi_crc32() - EFI version of crc32 function
 * @buf: buffer to calculate crc32 of
 * @len - length of buf
 *
 * Description: Returns EFI-style CRC32 value for @buf
 *//*
 * GUID for basic data partions.
 *//*
 * NOTE:
 *   when CONFIG_SYS_64BIT_LBA is not defined, lbaint_t is 32 bits; this
 *   limits the maximum size of addressable storage to < 2 Terra Bytes
 *//opt/src/disk/part_iso.hpart_isoprint_partition_cdiso_init_def_entry_tiso_init_def_entryiso_header_entry_tiso_header_entryiso_val_entry_tiso_val_entryiso_part_rec_tiso_part_reciso_sup_rec_tiso_sup_reciso_pri_rec_tiso_pri_reciso_boot_rec_tiso_boot_recrel_block_addrsec_cntsystypeld_segboot_mediaid_strnumentryplatformheader_idmanu_strpartsiz_BEpartsiz_LEpartloc_BEpartloc_LEvolidsysidunsigned char[5]stand_identdesctypefilestruc_vereffectiveexpiremodifycreationdatebibliofileidabstractfileidcopyrappiddataprepidpubidvolsetidunsigned char[34]rootdirfirstsek_BEpathtab2_BEfirstsek_BEpathtab1_BEfirstsek_LEpathtab2_LEfirstsek_LEpathtab1_LEpathtablen_BEpathtablen_LEsecsize_BEsecsize_LEseqnum_BEseqnum_LEsetsize_BEsetsize_LEescapeseqvolsiz_BEvolsiz_LEzeros1volumeflagszeros2ident_strPVD_OFFSETBRVD_PART_CD_H/* _PART_CD_H *//* relative Block address *//* sector count in VIRTUAL Blocks (0x200) *//* System Type copy of byte5 of part table *//* Load segment (flat model=addr/10) *//* boot Media Type: 0=no Emulation, 1=1.2MB floppy, 2=1.44MB floppy, 3=2.88MB floppy 4=hd (0x80) *//* Boot indicator 0x88=bootable 0=not bootable *//* Ident String of sectionr *//* number of entries *//* Platform: 0=x86, 1=PowerPC, 2=MAC *//* Header ID must be 0x90 or 0x91 *//* key[0]=55, key[1]=0xAA *//* Check sum (all words must be zero)  *//* Ident String of manufacturer/developer *//* Header ID must be 0x01 *//* volume partition size BE *//* volume partition size LE *//* volume partition location BE *//* volume partition location LE *//* volume partition Identifier *//* system Identifier *//* "CD001" *//* type of Volume descriptor: 0 = boot record, 1 = primary, 2 = Supplement, 3 = volume part 0xff trminator *//* file structur version *//* effective date *//* expiring date *//* modification date *//* creation date *//* bibliographic file identifier *//* abstract file identifier *//* copyright string *//* application identifier *//* data preparer identifier *//* Publisher identifier *//* Volume set identifier *//* directory record for root dir *//* location of optional occurrence of big endian type path table *//* location of first occurrence of big endian type path table *//* location of optional occurrence of little endian type path table *//* location of first occurrence of little endian type path table *//* Path Table size BE *//* Path Table size LE *//* sector size BE *//* sector size LE *//* volume sequence number BE *//* volume sequence number LE *//* volume set size BE *//* volume set size LE *//* Escape sequences *//* volume size Big Endian *//* volume size Little Endian *//* unused *//* volume Identifier *//* if bit 0 = 0 => all escape sequences are according ISO 2375 *//* absolute pointer to Boot Catalog *//* Ident String "EL TORITO SPECIFICATION" *//*
 * (C) Copyright 2001
 * Denis Peter, MPL AG Switzerland, d.peter@mpl.ch.
 *//opt/src/disk/part_iso.cpart_test_isopart_print_iso** No boot partition found on device %d **
"** No boot partition found on device %d **\n"Part   Start     Sect x Size Type
"Part   Start     Sect x Size Type\n" %2d %lu %lu %6ld %.32s
" %2d " LBAFU " " LBAFU " %6ld %.32s\n"part_get_info_isopart_get_info_iso_verbCD_SECTSIZEblkaddriso_pri_rec_t *iso_pri_rec *ppr** First descriptor is NOT a primary desc on %d:%d **
"** First descriptor is NOT a primary desc on %d:%d **\n"CD001"CD001"** Wrong ISO Ident: %s on %d:%d **
"** Wrong ISO Ident: %s on %d:%d **\n"lastsectppr->firstsek_LEpathtab1_LEppr->secsize_BE(__force __u16)(__be16)(ppr->secsize_BE)(__u16)(__be16)(ppr->secsize_BE)((__u16)(__be16)(ppr->secsize_BE))** No valid boot catalog found on %d:%d **
"** No valid boot catalog found on %d:%d **\n""Reading block %d\n"iso_boot_rec_t *iso_boot_rec *pbrEL TORITO SPECIFICATION"EL TORITO SPECIFICATION"** Wrong El Torito ident: %s on %d:%d **
"** Wrong El Torito ident: %s on %d:%d **\n"bootaddr** Can't read Boot Entry at %lX on %d:%d **
"** Can't read Boot Entry at %lX on %d:%d **\n"chksumbufchksumbuf[i]"part_iso.h"verb** Checksum Error in booting catalog validation entry on %d:%d **
"** Checksum Error in booting catalog validation entry on %d:%d **\n"iso_val_entry_t *iso_val_entry *pve0xAA** Key 0x55 0xAA error on %d:%d **
"** Key 0x55 0xAA error on %d:%d **\n"entry_numiso_init_def_entry_t *iso_init_def_entry *pide** Partition %d not found on device %d **
"** Partition %d not found on device %d **\n"** Partition %d is not bootable on device %d **
"** Partition %d is not bootable on device %d **\n"6002400>>27202880>>257605760>>2newblkaddr" Lastsect:%08lx\n"" Boot Entry at: %08lX\n"" part %d found @ %lx size %lx\n"part_num,info->start,info->sizeiso_dreadISO"ISO"PART_TYPE_ISOISO_ENTRY_NUMBERS_u_boot_list_2_part_driver_2_iso.u_boot_list_2_part_driver_2_isoisoCHECK_FOR_POWERPC_PLATTFORMISO_PART_DEBUG/* dummy (HD Emulation) *//* 2.88MByte Floppy *//* 1.44MByte Floppy *//* 1.2MByte Floppy *//* no emulation *//* if we reach this point entire sector has been
	 * searched w/o succsess *//* skip unused entries *//* Extension Indicator *//* Section Header Entry (last) *//* Section Header Entry *//* count partitions Entries (boot and non bootables *//* part found *//* Header Id for default Sections Entries *//* the bootcatalog (including validation Entry) is limited to 2048Bytes
	 * (63 boot entries + validation entry) *//* the validation entry seems to be ok, now search the "partition" *//* boot entry found *//* assuming same block size for all entries *//* the first sector (sector 0x10) must be a primary volume desc *//* primary desc *//* boot record *//* only boot records will be listed as valid partitions *//* Convert from 2048 to 512 sector size *//* enable this if CDs are written with the PowerPC Platform ID *//* #define	ISO_PART_DEBUG *//opt/src/disk/part_mac.hpart_macmac_partition_tmac_partitionmac_driver_entry_tmac_driver_entrymac_driver_desc_tmac_driver_descuchar[2048]iso_dummy__u16[188]unsigned short[188]part_paduchar[16]boot_cksumboot_entry2boot_load2boot_loadboot_sizeboot_startdata_countdata_startstart_blockmap_countsig_pad__u16[247]unsigned short[247]drvr_mapdrvr_cntblk_countblk_sizeMAC_STATUS_BOOTABLEAPPLE_AUX_TYPE"Apple_UNIX_SVR2"MAC_PARTITION_MAGIC0x504dMAC_DRIVER_MAGIC0x4552_DISK_PART_MAC_H/* _DISK_PART_MAC_H *//* partition is bootable *//* Reservere enough room for an ISO partition block to fit *//* reserved				*//* Type of Processor			*//* boot code checksum			*//* boot code entry point		*//* boot code load address		*//* size of boot code, in bytes		*//* first block of boot code		*//* partition status bits		*//* number of data blocks		*//* rel block # of first data block	*//* string type description		*//* partition name			*//* number of blocks in partition	*//* abs. starting block # of partition	*//* # blocks in partition map		*//* expected to be MAC_PARTITION_MAGIC	*//*
 * Each Partition Map entry (in blocks 1 ... N) has this format:
 *//* type field value for A/UX or other Unix partitions *//* OS Type				*//* size of driver, in 512 byte blocks	*//* block number of starting block	*//*
 * Device Driver Entry
 * (Cannot be included in mac_driver_desc because of alignment problems)
 *//* driver descriptor map		*//* number of driver descriptor entries	*//* device id				*//* device type				*//* number of blocks on device		*//* block size of device			*//* expected to be MAC_DRIVER_MAGIC	*//*
 * Driver Descriptor Structure, in block 0.
 * This block is (and shall remain) 512 bytes long.
 * Note that there is an alignment problem for the driver descriptor map!
 *//*
 * See also Linux sources, fs/partitions/mac.h
 *
 * This file describes structures and values related to the standard
 * Apple SCSI disk partitioning scheme. For more information see:
 * http://developer.apple.com/techpubs/mac/Devices/Devices-126.html#MARKER-14-92
 *//opt/src/disk/part_mac.cpart_get_info_macddescPAD_SIZE((1) * sizeof(mac_driver_desc_t), 1)(((((1) * sizeof(mac_driver_desc_t)) - 1) / (1) + 1) * 1)(1) * sizeof(mac_driver_desc_t)(uintptr_t)__ddesc((uintptr_t)__ddesc)(typeof((uintptr_t)__ddesc))(16)-1mpartPAD_SIZE((1) * sizeof(mac_partition_t), 1)(((((1) * sizeof(mac_partition_t)) - 1) / (1) + 1) * 1)(1) * sizeof(mac_partition_t)(uintptr_t)__mpart((uintptr_t)__mpart)(typeof((uintptr_t)__mpart))(16)-1mac_driver_desc_t *mac_driver_desc *ALLOC_CACHE_ALIGN_BUFFER(mac_driver_desc_t, ddesc, 1)__ddescmac_partition_t *mac_partition *char[2575]ALLOC_CACHE_ALIGN_BUFFER(mac_partition_t, mpart, 1)2575__mpartpart_mac_read_pdb** Can't read Partition Map on %d:%d **
"** Can't read Partition Map on %d:%d **\n"20557** Bad Signature on %d:%d: expected 0x%04x, got 0x%04x
"** Bad Signature on %d:%d: expected 0x%04x, got 0x%04x\n"** Invalid partition %d:%d [%d:1...%d:%d only]
"** Invalid partition %d:%d [%d:1...%d:%d only]\n"part_mac_read_ddb"** Can't read Driver Descriptor Block **\n"debug("** Can't read Driver Descriptor Block **\n")disk/part_mac.c** Can't read Driver Descriptor Block **
17746part_print_mac1024 * 1024(1024 * 1024)"part_mac.h"pdb_pddb_p512 * 1024Block Size=%d, Number of Blocks=%d, Total Capacity: %ld.%ld MB = %ld.%ld GB
DeviceType=0x%x, DeviceId=0x%x

   #:                 type name                   length   base       (size)
"Block Size=%d, Number of Blocks=%d, "
		"Total Capacity: %ld.%ld MB = %ld.%ld GB\n"
		"DeviceType=0x%x, DeviceId=0x%x\n\n"
		"   #:                 type name"
		"                   length   base       (size)\n"char[186]%4ld: "%4ld: "** Can't read Partition Map on %d:%ld **
"** Can't read Partition Map on %d:%ld **\n"** Bad Signature on %d:%ld - expected 0x%04x, got 0x%04x
"** Bad Signature on %d:%ld - expected 0x%04x, got 0x%04x\n"%20.32s %-18.32s %10u @ %-10u (%3ld%c)
"%20.32s %-18.32s %10u @ %-10u (%3ld%c)\n"part_test_macMAC"MAC"PART_TYPE_MACMAC_ENTRY_NUMBERS_u_boot_list_2_part_driver_2_mac.u_boot_list_2_part_driver_2_mac/* update partition count *//*
		 * We must always read the descritpor block for
		 * partition 1 first since this is the only way to
		 * know how many partitions we have.
		 *//*
 * Read Partition Descriptor Block
 *//*
 * Read Device Descriptor Block
 *//* kB; assumes blk_size == 512 *//* assuming at least one partition *//* MB *//*
		 * error reading Driver Descriptor Block,
		 * or no valid Signature
		 *//*
 * Test for a valid MAC partition
 *//* Remainder	*//* Quotient	*//* stdlib.h causes some compatibility problems; should fixe these! -- wd *//opt/src/include/adc.hadcadc_opsadc_uclass_platdataadc_channeladc_data_formatADC_DATA_FORMAT_BINADC_DATA_FORMAT_2Sadc_channel *channels_datachannel_datastart_channelsstart_channelvss_microvoltsvdd_microvoltsvss_polarity_negativevdd_polarity_negativevss_supplyvdd_supplychannel_maskmultidata_timeout_usdata_timeout_usdata_maskdata_formatADC_MAX_CHANNELADC_CHANNEL(x)(1 << x)_ADC_H_adc_raw_to_uVadc_stopadc_vss_valueadc_vdd_valueadc_channels_single_shotadc_channel_single_shotadc_channel_maskadc_data_maskadc_channels_dataadc_channel_dataadc_start_channelsadc_start_channel/**
 * adc_raw_to_uV() - converts raw value to microvolts for given ADC device.
 *
 * @dev:     ADC device used from conversion
 * @raw:     raw value to convert
 * @uV:	     converted value in microvolts
 * @return:  0 on success or -ve on error
 *//**
 * adc_stop() - stop operation for given ADC device.
 *
 * @dev:     ADC device to stop
 * @return:  0 if OK, -ve on error
 *//**
 * adc_vss_value() - get the ADC device's negative reference Voltage value
 *
 * Note: Depending on bool value 'vdd_supply_is_negative' of platform data,
 * the returned uV value can be negative, and it's not an error.
 *
 * @dev:     ADC device to check
 * @uV:      Voltage value with polarization sign (uV)
 * @return:  0 on success or -ve on error
*//**
 * adc_vdd_value() - get the ADC device's positive reference Voltage value
 *
 * Note: Depending on bool value 'vdd_supply_is_negative' of platform data,
 * the returned uV value can be negative, and it's not an error.
 *
 * @dev:     ADC device to check
 * @uV:      Voltage value with polarization sign (uV)
 * @return:  0 on success or -ve on error
*//**
 * adc_channels_single_shot() - get ADC conversion output data for the selected
 * device's channels. This function searches for the device by the given name,
 * starts the selected channels conversion and returns the output data as array
 * of type 'struct adc_channel'.
 *
 * Note: This function can be used if device implements one of ADC's single
 * or multi-channel operation API. If multi-channel operation is not supported,
 * then each selected channel is triggered by the sequence start/data in a loop.
 *
 * @name:         device's name to search
 * @channel_mask: channel selection - a bit mask
 * @channels:     pointer to conversion output data for the selected channels
 * @return:       0 if OK, -ve on error
 *//**
 * adc_channel_single_shot() - get output data of conversion for the ADC
 * device's channel. This function searches for the device with the given name,
 * starts the given channel conversion and returns the output data.
 *
 * Note: To use this function, device must implement metods:
 * - start_channel()
 * - channel_data()
 *
 * @name:    device's name to search
 * @channel: device's input channel to init
 * @data:    pointer to conversion output data
 * @return:  0 if OK, -ve on error
 *//**
 * adc_channel_mask() - get channel mask for given ADC device
 *
 * This can be used if adc uclass platform data is filled.
 *
 * @dev:       ADC device to check
 * @channel_mask: pointer to the returned channel bitmask
 * @return: 0 if OK, -ve on error
 *//**
 * adc_data_mask() - get data mask (ADC resolution bitmask) for given ADC device
 *
 * This can be used if adc uclass platform data is filled.
 *
 * @dev:       ADC device to check
 * @data_mask: pointer to the returned data bitmask
 * @return: 0 if OK, -ve on error
 *//**
 * adc_channels_data() - get conversion data for the channels selected by mask
 *
 * Note:
 * To use this function, device must implement methods:
 * - start_channels()
 * - channels_data()
 *
 * @dev:          ADC device to read
 * @channel_mask: channel selection - a bit mask
 * @channels:     pointer to structure array of returned data for each channel
 * @return:       0 if OK, -ve on error
 *//**
 * adc_channel_data() - get conversion data for the given device channel number.
 *
 * @dev:     ADC device to read
 * @channel: analog channel number
 * @data:    pointer to returned channel's data
 * @return:  0 if OK, -ve on error
 *//**
 * adc_start_channels() - start conversion for given device/channels and exit.
 *
 * Note:
 * To use this function, device must implement method: start_channels().
 *
 * @dev:          ADC device to start
 * @channel_mask: channel selection - a bit mask
 * @channel_mask: bit mask of analog channels
 * @return:       0 if OK, -ve on error
 *//**
 * adc_start_channel() - start conversion for given device/channel and exit.
 *
 * @dev:     ADC device
 * @channel: analog channel number
 * @return:  0 if OK, -ve on error
 *//**
	 * stop() - stop conversion of the given ADC device
	 *
	 * @dev:          ADC device to stop
	 * @return:       0 if OK, -ve on error
	 *//**
	 * channels_data() - get conversion data for the selected channels.
	 *
	 * This is optional, useful when multichannel conversion is supported
	 * by the hardware, by the single software trigger.
	 *
	 * For the proper implementation, please look at the 'Note' for the
	 * above method. The only difference is in used timeout value, which
	 * is defined by field 'multidata_timeout_us'.
	 *
	 * @dev:          ADC device to trigger
	 * @channel_mask: bit mask of selected analog channels
	 * @channels:     returned pointer to array of output data for channels
	 *                selected by the given mask
	 * @return:       0 if OK, -ve on error
	 *//**
	 * channel_data() - get conversion output data for the given channel.
	 *
	 * Note: The implementation of this function should only check, that
	 * the conversion data is available at the call time. If the hardware
	 * requires some delay to get the data, then this function should
	 * return with -EBUSY value. The ADC API will call it in a loop,
	 * until the data is available or the timeout expires. The maximum
	 * timeout for this operation is defined by the field 'data_timeout_us'
	 * in ADC uclasses platform data structure.
	 *
	 * @dev:          ADC device to trigger
	 * @channel:      selected analog channel number
	 * @data:         returned pointer to selected channel's output data
	 * @return:       0 if OK, -EBUSY if busy, and other negative on error
	 *//**
	 * start_channels() - start conversion with its default parameters
	 *                    for the channel numbers selected by the bit mask.
	 *
	 * This is optional, useful when the hardware supports multichannel
	 * conversion by the single software trigger.
	 *
	 * @dev:          ADC device to init
	 * @channel_mask: bit mask of selected analog channels
	 * @return:       0 if OK, -ve on error
	 *//**
	 * start_channel() - start conversion with its default parameters
	 *                   for the given channel number.
	 *
	 * @dev:          ADC device to init
	 * @channel:      analog channel number
	 * @return:       0 if OK, -ve on error
	 *//**
 * struct adc_ops - ADC device operations for single/multi-channel operation.
 *//**
 * struct adc_uclass_platdata - basic ADC info
 *
 * Note: The positive/negative reference Voltage is only a name and it doesn't
 * provide an information about the value polarity. It is possible, for both
 * values to be a negative or positive. For this purpose the uclass's platform
 * data provides a bool fields: 'vdd/vss_supply_is_negative'. This is useful,
 * since the regulator API returns only a positive Voltage values.
 *
 * To get the reference Voltage values with polarity, use functions:
 * - adc_vdd_value()
 * - adc_vss_value()
 * Those are useful for some cases of ADC's references, e.g.:
 * * Vdd: +3.3V; Vss: -3.3V -> 6.6 Vdiff
 * * Vdd: +3.3V; Vss: +0.3V -> 3.0 Vdiff
 * * Vdd: +3.3V; Vss:  0.0V -> 3.3 Vdiff
 * The last one is usually standard and doesn't require the fdt polarity info.
 *
 * For more informations read binding info:
 * - doc/device-tree-bindings/adc/adc.txt
 *
 * @data_mask              - conversion output data mask
 * @data_timeout_us        - single channel conversion timeout
 * @multidata_timeout_us   - multi channel conversion timeout
 * @channel_mask           - bit mask of available channels [0:31]
 * @vdd_supply             - positive reference Voltage supply (regulator)
 * @vss_supply             - negative reference Voltage supply (regulator)
 * @vdd_polarity_negative  - positive reference Voltage has negative polarity
 * @vss_polarity_negative  - negative reference Voltage has negative polarity
 * @vdd_microvolts         - positive reference Voltage value
 * @vss_microvolts         - negative reference Voltage value
 *//**
 * struct adc_channel - structure to hold channel conversion data.
 * Useful to keep the result of a multi-channel conversion output.
 *
 * @id   - channel id
 * @data - channel conversion data
 *//**
 * adc_data_format: define the ADC output data format, can be useful when
 * the device's input Voltage range is bipolar.
 * - ADC_DATA_FORMAT_BIN - binary offset
 * - ADC_DATA_FORMAT_2S  - two's complement
 *
 * Note: Device's driver should fill the 'data_format' field of its uclass's
 * platform data using one of the above data format types.
 *//* The last possible selected channel with 32-bit mask *//* ADC_CHANNEL() - ADC channel bit mask, to select only required channels *//*
 * Copyright (C) 2015 Samsung Electronics
 * Przemyslaw Marczak <p.marczak@samsung.com>
 *//opt/src/drivers/adc/adc-uclass.cadc-uclassadc_pre_probe"%s: Can't update Vdd. Error: %d"dev->name, retpr_err("%s: Can't update Vdd. Error: %d", dev->name, ret)pr_fmt("%s: Can't update Vdd. Error: %d")%s: Can't update Vdd. Error: %d"%s: Can't update Vss. Error: %d"pr_err("%s: Can't update Vss. Error: %d", dev->name, ret)pr_fmt("%s: Can't update Vss. Error: %d")%s: Can't update Vss. Error: %dadc_vss_platdata_setvss-polarity-negative"vss-polarity-negative"adc_uclass_platdata *vss-supply"vss-supply"vss-microvolts"vss-microvolts"adc_vdd_platdata_setvdd-polarity-negative"vdd-polarity-negative"vdd-supply"vdd-supply"vdd-microvolts"vdd-microvolts"vrefraw64do_div(raw64, data_mask)/opt/src/drivers/adc/opt/src/driversdrivers<adc.h>((raw64) >> 32) == 0value_signadc_vss_platdata_updateadc_vdd_platdata_updateUCLASS_ADC_adc_channels_single_shotconst adc_opsconst adc_ops *adc_ops *CHECK_MASKtimeout_usCHECK_NUMBERadc_supply_enablesupply_typevdd"vdd"vss"vss""%s: can't enable %s-supply!"dev->name, supply_typepr_err("%s: can't enable %s-supply!", dev->name, supply_type)pr_fmt("%s: can't enable %s-supply!")%s: can't enable %s-supply!check_channelError in %s/%s().
Wrong channel selection for device: %s
"Error in %s/%s().\nWrong channel selection for device: %s\n"drivers/adc/adc-uclass.c__FILE__, caller_function,"adc"ADC_UCLASS_PLATDATA_SIZE_u_boot_list_2_uclass_2_adc.u_boot_list_2_uclass_2_adcsdelay(x)(!CHECK_NUMBER)sizeof(struct adc_uclass_platdata)CONFIG_SANDBOX_ARCH/* Set ADC VSS platdata: polarity, uV, regulator (phandle). *//* Set ADC VDD platdata: polarity, uV, regulator (phandle). *//* No vss-supply phandle. *//* No vdd-supply phandle. *//* Optionally get regulators *//* Update the regulator Value. *//* Warning!
	 * This function can't return supply device before its bind.
	 * Please pay attention to proper fdt scan sequence. If ADC device
	 * will bind before its supply regulator device, then the below 'get'
	 * will return an error.
	 *//* Check channel bit. *//* TODO: use timer uclass (for early calls). *//* For the real ADC hardware, some ADC channels can be inactive.
	 * For example if device has 4 analog channels, and only channels
	 * 1-st and 3-rd are valid, then channel mask is: 0b1010, so request
	 * with mask 0b1110 should return an error.
	*//* TODO: add support for timer uclass (for early calls) */try_manualnumber_or_maskcaller_function/opt/src/include/sandbox-adc.hsandbox-adcsandbox_adc_statusSANDBOX_ADC_INACTIVESANDBOX_ADC_ACTIVEsandbox_adc_modeSANDBOX_ADC_MODE_SINGLE_CHANNELSANDBOX_ADC_MODE_MULTI_CHANNELSANDBOX_ADC_VSS_VALUESANDBOX_ADC_CHANNEL3_DATASANDBOX_ADC_CHANNEL2_DATASANDBOX_ADC_CHANNEL1_DATASANDBOX_ADC_CHANNEL0_DATASANDBOX_ADC_CHANNELSSANDBOX_ADC_DATA_MASKSANDBOX_ADC_DEVNAME"adc@0"_SANDBOX_ADC_H_/* 16-bits resolution *//opt/src/drivers/adc/sandbox.csandbox_adc_ofdata_to_platdata1 << SANDBOX_ADC_CHANNELS(1 << SANDBOX_ADC_CHANNELS)(1 << SANDBOX_ADC_CHANNELS) - 1sandbox_adc_probesandbox_adc_priv *sandbox_adc_stopsandbox_adc_channels_data"ADC in single-channel mode!"pr_err("ADC in single-channel mode!")pr_fmt("ADC in single-channel mode!")ADC in single-channel mode!"Request for an inactive channel!"pr_err("Request for an inactive channel!")pr_fmt("Request for an inactive channel!")Request for an inactive channel!sandbox_adc_channel_datasandbox_adc_start_channelssandbox_adc_start_channelsandbox_adc_privactive_channel_maskconversion_modeconversion_status"sandbox-adc"sizeof(struct sandbox_adc_priv)_u_boot_list_2_driver_2_sandbox_adc.u_boot_list_2_driver_2_sandbox_adcsandbox_adcsandbox,adc"sandbox,adc"sandbox_adc_idssandbox_adc_ops/* Mask available channel bits: [0:3] *//* Set sandbox test data *//* Deselect all channels *//* Set single-channel mode *//* Stop conversion *//* Start conversion *//* The conversion must be started before reading the data *//* Check channel selection *//* Return error for single-channel conversion mode *//* For single-channel conversion mode, check if channel was selected *//* Select channel *//**
 * struct sandbox_adc_priv - sandbox ADC device's operation status and data
 *
 * @conversion_status - conversion status: ACTIVE (started) / INACTIVE (stopped)
 * @conversion_mode   - conversion mode: single or multi-channel
 * @active_channel    - active channel number, valid for single channel mode
 * data[]             - channels data
 */<sandbox-adc.h>/opt/src/drivers/ata/sata.csata_bwrite18446744073709551578sata_breadsata_get_devCONFIG_SYS_SATA_MAX_DEVICEblk_desc[2]ahci_ops *Could not reset some SATA devices
"Could not reset some SATA devices\n"sizeof(struct blk_desc)sata_dev_desc[i].blkszLOG2(sata_dev_desc[i].blksz)sata_blk"sata_blk"_u_boot_list_2_driver_2_sata_blk.u_boot_list_2_driver_2_sata_blksata_blk_opsCONFIG_PARTITIONS/opt/src/drivers/ata/opt/src/drivers/ata/sata_sandbox.csata_sandbox/*
 * Copyright (C) 2015 Google, Inc
 * Written by Simon Glass <sjg@chromium.org>
 *//opt/src/arch/sandbox/include/asm/axi.haxi_emul_get_ops(dev)((struct axi_emul_ops *)(dev)->driver->ops)__asm_axi_haxi_get_storeaxi_sandbox_get_emul/* __asm_axi_h *//**
 * axi_get_store() - Get address of internal storage of a emulated AXI device
 * @dev:	Emulated AXI device to get the pointer of the internal storage
 *		for.
 * @storep:	Pointer to the internal storage of the emulated AXI device.
 *
 * To preset or read back the contents internal storage of the emulated AXI
 * device, this function returns the pointer to the storage. Changes to the
 * contents of the storage are reflected when using the AXI read/write API
 * methods, and vice versa, so by using this method expected read data can be
 * set up in advance, and written data can be checked in unit tests.
 *
 * Return: 0 if OK, -ve on error.
 *//**
 * axi_sandbox_get_emul() - Retrieve a pointer to a AXI emulation device
 * @bus:     The AXI bus from which to retrieve a emulation device
 * @address: The address of a transfer that should be handled by a emulation
 *	     device
 * @length:  The data width of a transfer that should be handled by a emulation
 *	     device
 * @emulp:   Pointer to a buffer receiving the emulation device that handles
 *	     the transfer specified by the address and length parameters
 *
 * To test the AXI uclass, we implement a simple AXI emulation device, which is
 * a virtual device on a AXI bus that exposes a simple storage interface: When
 * reading and writing from the device, the addresses are translated to offsets
 * within the device's storage. For write accesses the data is written to the
 * specified storage offset, and for read accesses the data is read from the
 * specified storage offset.
 *
 * A DTS entry might look like this:
 *
 * axi: axi@0 {
 *	compatible = "sandbox,axi";
 *	#address-cells = <0x1>;
 *	#size-cells = <0x1>;
 *	store@0 {
 *		compatible = "sandbox,sandbox_store";
 *		reg = <0x0 0x400>;
 *	};
 * };
 *
 * This function may then be used to retrieve the pointer to the sandbox_store
 * emulation device given the AXI bus device, and the data (address, data
 * width) of a AXI transfer which should be handled by a emulation device.
 *
 * Return: 0 of OK, -ENODEV if no device capable of handling the specified
 *	   transfer exists or the device could not be retrieved
 *//*
 * (C) Copyright 2018
 * Mario Six, Guntermann & Drunck GmbH, mario.six@gdsys.cc
 */storep/opt/src/drivers/axi/axi-emul-uclass.caxi-emul-uclassaxi_emul_ops *"%s: Unknown AXI transfer size '%d'"bus->name, sizedebug("%s: Unknown AXI transfer size '%d'", bus->name, size)drivers/axi/axi-emul-uclass.c%s: Unknown AXI transfer size '%d'ARRAY_SIZE(reg)"%s: Could not read 'reg' property of %s\n"bus->name, dev->namedebug("%s: Could not read 'reg' property of %s\n",
			      bus->name, dev->name)%s: Could not read 'reg' property of %s
"%s: Could not activate %s\n"debug("%s: Could not activate %s\n",
				      bus->name, dev->name)%s: Could not activate %s
UCLASS_AXI_EMULaxi_emul"axi_emul"_u_boot_list_2_uclass_2_axi_emul.u_boot_list_2_uclass_2_axi_emul/* ...and return it *//* If yes, activate it... *//*
		 * Does the transfer's address fall into this device's address
		 * space?
		 *//*
	 * Note: device_find_* don't activate the devices; they're activated
	 *	 as-needed below.
	 *//opt/src/drivers/axi<asm/axi.h>/opt/src/drivers/axi/axi-uclass.caxi-uclassaxi_ops *"axi"_u_boot_list_2_uclass_2_axi.u_boot_list_2_uclass_2_axi/opt/src/drivers/axi/axi_sandbox.caxi_sandboxaxi_sandbox_writeaxi_sandbox_readaxi_sandbox_bus"axi_sandbox_bus"const axi_opsconst axi_ops *_u_boot_list_2_driver_2_axi_sandbox_bus.u_boot_list_2_driver_2_axi_sandbox_busaxi_sandbox_opssandbox,axi"sandbox,axi"axi_sandbox_ids/* sentinel *//* Forward all writes to the AXI emulator *//* Get emulator device *//* Forward all reads to the AXI emulator *//*
 * This driver implements a AXI bus for the sandbox architecture for testing
 * purposes.
 *
 * The bus forwards every access to it to a special AXI emulation device (which
 * it gets via the axi_emul_get_ops function) that implements a simple
 * read/write storage.
 *
 * The emulator device must still be contained in the device tree in the usual
 * way, since configuration data for the storage is read from the DT.
 *//opt/src/drivers/axi/sandbox_store.csandbox_storesandbox_store_removesandbox_store_priv *sandbox_store_probe"%s: Could not read 'reg' property\n"debug("%s: Could not read 'reg' property\n", dev->name)drivers/axi/sandbox_store.c%s: Could not read 'reg' property
sandbox_store_get_storesandbox_store_writesandbox_store_readcopy_axi_data*((u16 *)src)(__force __u16)(__be16)(*((u16 *)src))(__u16)(__be16)(*((u16 *)src))((__u16)(__be16)(*((u16 *)src)))*((u32 *)src)(__force __u32)(__be32)(*((u32 *)src))(__u32)(__be32)(*((u32 *)src))((__u32)(__be32)(*((u32 *)src)))store"%s: Unknown AXI transfer size '%d'\n"__func__, sizedebug("%s: Unknown AXI transfer size '%d'\n", __func__, size)%s: Unknown AXI transfer size '%d'
sandbox_store_privsandbox_axi_store"sandbox_axi_store"const axi_emul_opsconst axi_emul_ops *sizeof(struct sandbox_store_priv)_u_boot_list_2_driver_2_sandbox_axi_store.u_boot_list_2_driver_2_sandbox_axi_storesandbox_store_opssandbox,sandbox_store"sandbox,sandbox_store"sandbox_store_ids/*
	 * Allocate the device's internal storage that will be read
	 * from/written to
	 *//**
 * copy_axi_data() - Copy data from source to destination with a given AXI
 *		     transfer width
 * @src:  Pointer to the data source from where data will be read
 * @dst:  Pointer to the data destination where data will be written to
 * @size: Size of the data to be copied given by a axi_size_t enum value
 *
 * Return: 0 if OK, -ve on error
 *//**
 * struct sandbox_store_priv - Private data structure of a AXI store device
 * @store: The buffer holding the device's internal memory, which is read from
 *	   and written to using the driver's methods
 *//opt/src/drivers/block/blk-uclass.cblk-uclassblk_post_probeuclass_foreach_dev_safe(dev, next, uc)next->uclass_node.nexttypeof(*next)sizeof(dev_name)%s.%s"%s.%s"blk_claim_devnum/opt/src/drivers/blockmax_devnum"%s: No block device found for parent '%s'\n"__func__, parent->namedebug("%s: No block device found for parent '%s'\n", __func__,
		      parent->name)drivers/block/blk-uclass.c495%s: No block device found for parent '%s'
"%s: Incorrect uclass %s for block device '%s'\n"__func__, uclass_get_name(id), dev->namedebug("%s: Incorrect uclass %s for block device '%s'\n",
		      __func__, uclass_get_name(id), dev->name)501%s: Incorrect uclass %s for block device '%s'
ENOTBLK-15-ENOTBLKblks_read"%s: if_type=%d, devnum=%d: %s, %d, %d\n"__func__, if_type, devnum, dev->name, desc->if_type, desc->devnumdebug("%s: if_type=%d, devnum=%d: %s, %d, %d\n", __func__,
		      if_type, devnum, dev->name, desc->if_type, desc->devnum)%s: if_type=%d, devnum=%d: %s, %d, %d
(n) >= (unsigned long)-MAX_ERRNO(n) >= (unsigned long)-4095IS_ERR_VALUE(n)
Device %d: "\nDevice %d: "unknown device
"unknown device\n"
IDE device %d: "\nIDE device %d: "Device %d: "Device %d: "found_morechild_dev&dev->child_head(&dev->child_head)->nexttypeof(*child_dev)device_foreach_child_safe(child_dev, next, dev)child_dev->sibling_node.nextnext->sibling_node.next"%s: No block device found\n"debug("%s: No block device found\n", __func__)%s: No block device found
"%s: Unknown interface type '%s'\n"__func__, if_typenamedebug("%s: Unknown interface type '%s'\n", __func__,
		      if_typename)%s: Unknown interface type '%s'
"%s: Unknown uclass for interface type'\n"if_typename_str[if_type]debug("%s: Unknown uclass for interface type'\n",
		      if_typename_str[if_type])descp%s: Unknown uclass for interface type'
const char *[13]char *[13]"%s: parent uclass %d, this dev %d\n"__func__, device_get_uclass_id(dev->parent), uclass_iddebug("%s: parent uclass %d, this dev %d\n", __func__,
			      device_get_uclass_id(dev->parent), uclass_id)%s: parent uclass %d, this dev %d
"%s: Device desc %p\n"__func__, descdebug("%s: Device desc %p\n", __func__, desc)%s: Device desc %p
"%s: No device found\n"debug("%s: No device found\n", __func__)%s: No device found
if_type_to_uclass_iduclass_id[13]uclass_id *if_typename_to_iftype"blk"_u_boot_list_2_uclass_2_blk.u_boot_list_2_uclass_2_blkUCLASS_IDEUCLASS_SCSIUCLASS_MMCUCLASS_AHCIUCLASS_ROOTUCLASS_NVMEUCLASS_EFIUCLASS_VIRTIOif_type_uclass_idatapi"atapi"doc"doc""mmc""sata""host""nvme""virtio"if_typename_strdefined(CONFIG_PARTITIONS) && defined(CONFIG_HAVE_BLOCK_DEVICE)/* list only known devices *//**
 * get_desc() - Get the block device descriptor for the given device number
 *
 * @if_type:	Interface type
 * @devnum:	Device number (0 = first)
 * @descp:	Returns block device descriptor on success
 * @return 0 on success, -ENODEV if there is no such device and no device
 * with a higher device number, -ENOENT if there is no such device but there
 * is one with a higher number, or other -ve on other error.
 *//* Find out the parent device uclass *//*
 * This function is complicated with driver model. We look up the interface
 * name in a local table. This gives us an interface type which we can match
 * against the uclass of the block device's parent.
 *//*
 * Copyright (C) 2016 Google, Inc
 * Written by Simon Glass <sjg@chromium.org>
 *//opt/src/drivers/block/blkcache.csizeof(*stats)block_cache_node *&block_cache"drop: start " LBAF ", count " LBAFU "\n""drop: start " "%" "l" "x" ", count " "%" "l" "u" "\n"node->start, node->blkcntdebug("drop: start " LBAF ", count " LBAFU "\n",
		      node->start, node->blkcnt)drivers/block/blkcache.cdrop: start %lx, count %lu
"fill: start " LBAF ", count " LBAFU "\n""fill: start " "%" "l" "x" ", count " "%" "l" "u" "\n"start, blkcntdebug("fill: start " LBAF ", count " LBAFU "\n",
	      start, blkcnt)fill: start %lx, count %lu
"hit: start " LBAF ", count " LBAFU "\n""hit: start " "%" "l" "x" ", count " "%" "l" "u" "\n"debug("hit: start " LBAF ", count " LBAFU "\n",
		      start, blkcnt)hit: start %lx, count %lu
"miss: start " LBAF ", count " LBAFU "\n""miss: start " "%" "l" "x" ", count " "%" "l" "u" "\n"debug("miss: start " LBAF ", count " LBAFU "\n",
	      start, blkcnt)miss: start %lx, count %lu
cache_findlh(&block_cache)->nexttypeof(*node)list_for_each_entry(node, &block_cache, lh)node->lh.nextblock_cache_node_statsblock_cache/* invalidate cache *//* pop LRU *//* don't cache big stuff *//* maintain MRU ordering *//opt/src/drivers/block/ide.cide_probeCONFIG_SYS_IDE_MAXDEVICEblk#%d"blk#%d"ide_blk"ide_blk"ide_blk_probeide_writeATA_DEVICE(device)IDE_TIME_OUTIDE read: device %d not ready
"IDE read: device %d not ready\n"0xFATA_STAT_DRQ | ATA_STAT_BUSYATA_STAT_DRQ | ATA_STAT_BUSY | ATA_STAT_ERR(ATA_STAT_DRQ | ATA_STAT_BUSY | ATA_STAT_ERR)Error (no IRQ) dev %d blk %lx: status %#02x
"Error (no IRQ) dev %d blk " LBAF
			       ": status %#02x\n"ide_read"ide_read dev %d start " LBAF ", blocks " LBAF " buffer at %lX\n""ide_read dev %d start " "%" "l" "x" ", blocks " "%" "l" "x" " buffer at %lX\n"device, blknr, blkcnt, (ulong) bufferdebug("ide_read dev %d start " LBAF ", blocks " LBAF " buffer at %lX\n",
	      device, blknr, blkcnt, (ulong) buffer)drivers/block/ide.c955ide_read dev %d start %lx, blocks %lx buffer at %lX
No Powersaving mode %X
"No Powersaving mode %X\n""Powersaving %02X\n"debug("Powersaving %02X\n", c)982Powersaving %02X
pwrsaveIDE_SPIN_UP_TIME_OUTWR_OUTide_input_dataATA_CURR_BASE(dev) + ATA_DATA_REG(0x100+ide_bus_offset[(dev / (2 / 1))]) + (0+((0) * 4))sect_bufwords << 1insw(ATA_CURR_BASE(dev) + ATA_DATA_REG, sect_buf, words << 1)ulong[1]CONFIG_SYS_IDE_MAXBUSide_output_dataoutsw(ATA_CURR_BASE(dev) + ATA_DATA_REG, sect_buf, words << 1)ide_input_swap_dataide_initCONFIG_SYS_IDE_MAXDEVICE /
			       CONFIG_SYS_IDE_MAXBUS(CONFIG_SYS_IDE_MAXDEVICE /
			       CONFIG_SYS_IDE_MAXBUS)Bus %d: "Bus %d: "ATA_DEVICE(dev)6000ATA_RESET_TIME * 100(ATA_RESET_TIME * 100)** Timeout **
"** Timeout **\n"ATA_STAT_BUSY | ATA_STAT_FAULT(ATA_STAT_BUSY | ATA_STAT_FAULT)not available  "not available  ""Status = 0x%02X "debug("Status = 0x%02X ", c)796Status = 0x%02X 800OK "OK "typeof(ide_dev_desc[i].log2blksz)LOG2_INVALID(typeof(ide_dev_desc[i].log2blksz))IDE_BUS(i)IDE_READ_Ewordside_inbATA_CURR_BASE(dev)"ide_inb (dev= %d, port= 0x%x) : @ 0x%08lx -> 0x%02x\n"dev, port, (ATA_CURR_BASE(dev) + CONFIG_SYS_ATA_PORT_ADDR(port)), valdebug("ide_inb (dev= %d, port= 0x%x) : @ 0x%08lx -> 0x%02x\n",
	      dev, port,
	      (ATA_CURR_BASE(dev) + CONFIG_SYS_ATA_PORT_ADDR(port)), val)738ide_inb (dev= %d, port= 0x%x) : @ 0x%08lx -> 0x%02x
ide_outb"ide_outb (dev= %d, port= 0x%x, val= 0x%02x) : @ 0x%08lx\n"dev, port, val, (ATA_CURR_BASE(dev) + CONFIG_SYS_ATA_PORT_ADDR(port))debug("ide_outb (dev= %d, port= 0x%x, val= 0x%02x) : @ 0x%08lx\n",
	      dev, port, val,
	      (ATA_CURR_BASE(dev) + CONFIG_SYS_ATA_PORT_ADDR(port)))711ide_outb (dev= %d, port= 0x%x, val= 0x%02x) : @ 0x%08lx
ide_identATA_STAT_FAULT | ATA_STAT_ERR(ATA_STAT_FAULT | ATA_STAT_ERR)hd_driveid_t *hd_driveid *sizeof(dev_desc->revision)sizeof(dev_desc->vendor)sizeof(dev_desc->product)ident_cpyide_wait_u_boot_list_2_uclass_2_ide.u_boot_list_2_uclass_2_ideide_supportedpci_device_id[2]_u_boot_list_2_pci_driver_entry_2_ide.u_boot_list_2_pci_driver_entry_2_idestruct pci_driver_entrypci_device_id[]PCI_CLASS_STORAGE_IDE << 80x0101 << 80xffff00PCI_DEVICE_CLASS(PCI_CLASS_STORAGE_IDE << 8, 0xffff00)PCI_DEVICE_CLASS(PCI_CLASS_STORAGE_IDE << 816776960_u_boot_list_2_driver_2_ide.u_boot_list_2_driver_2_ide_u_boot_list_2_driver_2_ide_blk.u_boot_list_2_driver_2_ide_blkide_blk_opside_dev_descide_bus_okCONFIG_SYS_ATA_IDE0_OFFSETide_bus_offsetide_reset()CONFIG_SYS_ATA_PORT_ADDR(port)(port)ATAPI_TIME_OUT7000SYNCEIEIOdefined(CONFIG_SYS_ATA_IDE0_OFFSET)defined(CONFIG_SYS_ATA_IDE1_OFFSET) && (CONFIG_SYS_IDE_MAXBUS > 1)CONFIG_SYS_ATA_PORT_ADDRCONFIG_IDE_RESETCONFIG_ATAPIdefined(CONFIG_IDE_SWAP_IO)__BIG_ENDIANdefined(CONFIG_IDE_AHB)CONFIG_IDE_PREINIT__MIPS__defined(CONFIG_OF_IDE_FIXUP)/*
			 * With CDROM, if there is no CD inserted, blksz will
			 * be zero, don't bother to create IDE block device.
			 *//* fill in device vendor/product/rev strings *//* clear IRQ *//* can't take over 500 ms *//* write high bits *//* Select device
	 *//* more than 28 bits used, use 48bit mode *//* may take up to 4 sec *//* first check if the drive is in Powersaving mode, if yes,
	 * increase the timeout value *//* power save *//* CONFIG_IDE_SWAP_IO *//* ! CONFIG_IDE_SWAP_IO *//* __LITTLE_ENDIAN *//* !MIPS *//* We only need to swap data if we are running on a big endian cpu. *//* initialize partition type *//* ATAPI Devices do not set DRDY *//* 10 ms *//* 100 ms *//* Select device
		 *//*
	 * Wait for IDE to get ready.
	 * According to spec, this can take up to 31 seconds!
	 *//* ATAPI Drives seems to need a proper IDE Reset *//* CONFIG_IDE_PREINIT *//* write data *//* write command *//* only used to test the powersaving mode,
				 * if enabled, the drive goes after 5 sec
				 * in standby mode *//* just to fill something in... *//* assuming HD *//* CONFIG_LBA48 *//* LBA 48 support *//* __BIG_ENDIAN *//*
	 * do not swap shorts on little endian
	 *
	 * See CF+ and CompactFlash Specification Revision 2.0:
	 * 6.2.1.6: Identfy Drive, Table 39, Word Address 57-58 for details.
	 *//* ! __BIG_ENDIAN *//* swap shorts *//* CONFIG_ATAPI *//*
	 * firmware revision, model, and serial number have Big Endian Byte
	 * order in Word. Convert all three to little endian.
	 *
	 * See CF+ and CompactFlash Specification Revision 2.0:
	 * 6.2.1.6: Identify Drive, Table 39 for more details
	 *//* see above - ugly to read *//*
			 * Select device
			 *//* 500 ms *//*
				 * Need to soft reset the device
				 * in case it's an ATAPI...
				 *//*
			 * Wait for completion
			 *//*
			 * Start Ident Command
			 *//*
			 * Wait for completion - ATAPI devices need more time
			 * to become ready
			 *//* ATAPI Signature found *//* check signature *//* Warning: This will be tricky to read *//* ATAPI devices cannot use 48bit addressing (ATA/ATAPI v7) *//* start *//* copy device ident strings *//* allocation Legnth *//* not yet valid *//* temp buf *//* Command descriptor block *//* LSB Block *//* MSB Block cnt *//* MSB Block *//* assuming CD part *//* we read max 2kbytes *//*
 * atapi_read:
 * we transfer only one block per command, since the multiple DRQ per
 * command is not yet implemented
 *//* not ready, but will be ready soon *//* Unit Attention *//* ok device ready *//* allocation Length *//* error *//* Ok *//*
 * sending the command to atapi_issue. If an status other than good
 * returns, an request_sense will be issued
 *//* seems that some CD ROMs need this... *//* ok now decide if it is an in or output *//* we transfer shorts *//* data transfer *//*
	 * if no data wait for DRQ = 0 BSY = 0
	 * if data wait for DRQ = 1 BSY = 0
	 *//* device must set bsy *//* ATAPI Command written wait for completition *//* write command block *//* DRQ must be 1, BSY 0 *//* no DMA, no overlaped *//* write taskfile *//*
 * issue an atapi command
 *//* break if error occurs (doesn't make sense to wait more) *//* prevents to read the status before valid *//* poll every 100 us *//*
 * Wait until (Status & mask) == res, or timeout (in ms)
 * Return last status
 * This is used since some ATAPI CD ROMs clears their Busy Bit first
 * and then they set their DRQ Bit
 *//* since ATAPI may use commands with not 4 bytes alligned length
 * we have our own transfer functions, 2 bytes alligned *//****************************************************************************
 * ATAPI Support
 *//* copy string, omitting trailing white space *//* skip leading white space *//* reserve space for '\0' *//*
 * copy src to dest, skipping leading and trailing blanks and null
 * terminate the string
 * "len" is the size of available memory including the terminating '\0'
 *//*
 * Wait until Busy bit is off, or timeout (in ms)
 * Return last status
 *//* CONFIG_IDE_RESET *//* wait 250 ms *//* de-assert RESET signal *//* the reset signal shall be asserted for et least 25 us *//* assert reset *//* 5 sec spin-up timeout *//* 7 sec timeout (5 sec seems to work...) *//* 2 sec timeout *//* Current offset for IDE0 / IDE1 bus access	*//opt/src/drivers/block/sandbox.chost_get_dev_errhost%d"host%d"Failed to access host backing file '%s'
"Failed to access host backing file '%s'\n"sandbox_host_blk"sandbox_host_blk"host_block_writeERROR: Invalid block %lx
"ERROR: Invalid block %lx\n"host_block_readsizeof(struct host_block_dev)_u_boot_list_2_driver_2_sandbox_host_blk.u_boot_list_2_driver_2_sandbox_host_blksandbox_host_blk_ops/* Remove and unbind the old device, if any *//*
 * Copyright (C) 2013 Henrik Nordstrom <henrik@henriknordstrom.net>
 */blk_devperr_file/opt/src/include/board.hboard_opsget_strget_intget_booldetectboard_get_ops(dev)((struct board_ops *)(dev)->driver->ops)board_getboard_get_strboard_get_intboard_get_boolboard_detect/**
 * board_get() - Return the board device for the board in question.
 * @devp: Pointer to structure to receive the board device.
 *
 * Since there can only be at most one board instance, the API can supply a
 * function that returns the unique device. This is especially useful for use
 * in board files.
 *
 * Return: 0 if OK, -ve on error.
 *//**
 * board_get_str() - Read a specific string data value that describes the
 *		     hardware setup.
 * @dev:	The board instance to gather the data.
 * @id:		A unique identifier for the string value to be read.
 * @size:	The size of the buffer to receive the string data.
 * @val:	Pointer to a buffer that receives the value read.
 *
 * Return: 0 if OK, -ve on error.
 *//**
 * board_get_int() - Read a specific int data value that describes the
 *		     hardware setup.
 * @dev:	The board instance to gather the data.
 * @id:		A unique identifier for the int value to be read.
 * @val:	Pointer to a buffer that receives the value read.
 *
 * Return: 0 if OK, -ve on error.
 *//**
 * board_get_bool() - Read a specific bool data value that describes the
 *		      hardware setup.
 * @dev:	The board instance to gather the data.
 * @id:		A unique identifier for the bool value to be read.
 * @val:	Pointer to a buffer that receives the value read.
 *
 * Return: 0 if OK, -ve on error.
 *//**
 * board_detect() - Run the hardware info detection procedure for this device.
 *
 * @dev:	The device containing the information
 *
 * Return: 0 if OK, -ve on error.
 *//**
	 * get_str() - Read a specific string data value that describes the
	 *	       hardware setup.
	 * @dev:	The board instance to gather the data.
	 * @id:		A unique identifier for the string value to be read.
	 * @size:	The size of the buffer to receive the string data.
	 * @val:	Pointer to a buffer that receives the value read.
	 *
	 * Return: 0 if OK, -ve on error.
	 *//**
	 * get_int() - Read a specific int data value that describes the
	 *	       hardware setup.
	 * @dev:       The board instance to gather the data.
	 * @id:        A unique identifier for the int value to be read.
	 * @val:       Pointer to a buffer that receives the value read.
	 *
	 * Return: 0 if OK, -ve on error.
	 *//**
	 * get_bool() - Read a specific bool data value that describes the
	 *		hardware setup.
	 * @dev:	The board instance to gather the data.
	 * @id:		A unique identifier for the bool value to be read.
	 * @val:	Pointer to a buffer that receives the value read.
	 *
	 * Return: 0 if OK, -ve on error.
	 *//**
	 * detect() - Run the hardware info detection procedure for this
	 *	      device.
	 * @dev:      The device containing the information
	 *
	 * This operation might take a long time (e.g. read from EEPROM,
	 * check the presence of a device on a bus etc.), hence this is not
	 * done in the probe() method, but later during operation in this
	 * dedicated method.
	 *
	 * Return: 0 if OK, -ve on error.
	 *//*
 * This uclass encapsulates hardware methods to gather information about a
 * board or a specific device such as hard-wired GPIOs on GPIO expanders,
 * read-only data in flash ICs, or similar.
 *
 * The interface offers functions to read the usual standard data types (bool,
 * int, string) from the device, each of which is identified by a static
 * numeric ID (which will usually be defined as a enum in a header file).
 *
 * If for example the board had a read-only serial number flash IC, we could
 * call
 *
 * ret = board_detect(dev);
 * if (ret) {
 *	debug("board device not found.");
 *	return ret;
 * }
 *
 * ret = board_get_int(dev, ID_SERIAL_NUMBER, &serial);
 * if (ret) {
 *	debug("Error when reading serial number from device.");
 *	return ret;
 * }
 *
 * to read the serial number.
 *//opt/src/drivers/board/board-uclass.cboard-uclassboard_ops *UCLASS_BOARD_u_boot_list_2_uclass_2_board.u_boot_list_2_uclass_2_board/opt/src/drivers/board<board.h>/opt/src/drivers/board/sandbox.hBOOL_CALLED_DETECTINT_TEST1INT_TEST2STR_VACATIONSPOT/*
 * (C) Copyright 2018
 * Mario Six,  Guntermann & Drunck GmbH, mario.six@gdsys.cc
 *//opt/src/drivers/board/sandbox.cboard_sandbox_probeboard_sandbox_get_strvacation_spotschar[6][64]char(*)[64]i1board_sandbox_priv *ARRAY_SIZE(vacation_spots)board_sandbox_get_intboard_sandbox_get_boolboard_sandbox_detectboard_sandbox_privtest_i2test_i1called_detectboard_sandbox"board_sandbox"const board_opsconst board_ops *sizeof(struct board_sandbox_priv)_u_boot_list_2_driver_2_board_sandbox.u_boot_list_2_driver_2_board_sandboxboard_sandbox_opssandbox,board_sandbox"sandbox,board_sandbox"board_sandbox_idschar[][64]R'lyehDreamlandsPlateau of LengCarcosaYuggothThe Nameless City/* Picks a vacation spot depending on i1 and i2 *//* Decrements with every call *//* Increments with every call *//* Checks if the dectect method has been called */"sandbox.h"/opt/src/drivers/bootcount/bootcount-uclass.cbootcount-uclassu-boot,bootcount-device"u-boot,bootcount-device"UCLASS_BOOTCOUNT"%s: failed to load bootcount\n"pr_fmt("%s: failed to load bootcount\n")pr_debug("%s: failed to load bootcount\n", __func__)%s: failed to load bootcount
"%s: failed to store 0x%lx\n"__func__, valpr_fmt("%s: failed to store 0x%lx\n")pr_debug("%s: failed to store 0x%lx\n", __func__, val)%s: failed to store 0x%lx
bootcount_ops *assert(ops)drivers/bootcount/bootcount-uclass.c_u_boot_list_2_uclass_2_bootcount.u_boot_list_2_uclass_2_bootcount/* Return the 0, if the call to dm_bootcount_get failed *//* If there was no user-selected device, use the first available one *//*
	 * If there's a preferred bootcount device selected by the user (by
	 * setting '/chosen/u-boot,bootcount-device' in the DTS), try to use
	 * it if available.
	 *//* Now implement the generic default functions *//*
 * (C) Copyright 2018 Theobroma Systems Design und Consulting GmbH
 *//opt/src/drivers/bootcount/opt/src/drivers/bootcount/rtc.cbootcount_rtc_probe"rtc"phandle_args"%s: rtc backing device not specified\n"debug("%s: rtc backing device not specified\n", dev->name)drivers/bootcount/rtc.c%s: rtc backing device not specified
"%s: could not get backing device\n"debug("%s: could not get backing device\n", dev->name)%s: could not get backing device
bootcount_rtc_priv *"offset"bootcount_rtc_get"%s: rtc_write16 failed\n"debug("%s: rtc_write16 failed\n", __func__)%s: rtc_write16 failed
bootcount_magic"%s: bootcount magic does not match on %04x\n"debug("%s: bootcount magic does not match on %04x\n", __func__, val)%s: bootcount magic does not match on %04x
bootcount_rtc_set48128bootcount_magic << 8bootcount_rtc_privbootcount-rtc"bootcount-rtc"sizeof(struct bootcount_rtc_priv)const bootcount_opsconst bootcount_ops *_u_boot_list_2_driver_2_bootcount_rtc.u_boot_list_2_driver_2_bootcount_rtcbootcount_rtcu-boot,bootcount-rtc"u-boot,bootcount-rtc"bootcount_rtc_idsbootcount_rtc_ops/opt/src/include/cache.hcache_get_infocache_info *cache_opscache_infocache_get_ops(dev)((struct cache_ops *)(dev)->driver->ops)__CACHE_H/**
 * cache_get_info() - Get information about a cache controller
 *
 * @dev:	Device to check (UCLASS_CACHE)
 * @info:	Returns cache info
 * @return 0 if OK, -ve on error
 *//**
	 * get_info() - Get basic cache info
	 *
	 * @dev:	Device to check (UCLASS_CACHE)
	 * @info:	Place to put info
	 * @return 0 if OK, -ve on error
	 *//* Base physical address of cache device. *//*
 * Structure for the cache controller
 *//*
 * Copyright (C) 2019 Intel Corporation <www.intel.com>
 *//opt/src/drivers/cache/sandbox_cache.csandbox_cachesandbox_get_info2874540200x11223344cache_sandbox"cache_sandbox"UCLASS_CACHEconst cache_opsconst cache_ops *cache_ops *_u_boot_list_2_driver_2_cache_sandbox.u_boot_list_2_driver_2_cache_sandboxsandbox,cache"sandbox,cache"sandbox_cache_idssandbox_cache_ops/opt/src/drivers/cache<cache.h>/opt/src/drivers/clk/clk-divider.cclk-divider<clk.h>clk *clk_register_dividerclkconst clk_div_tableconst clk_div_table *clk_div_table *_register_dividerCLK_DIVIDER_HIWORD_MASK"divider value exceeds LOWORD field\n"pr_warnpr_fmt("divider value exceeds LOWORD field\n")divider value exceeds LOWORD field
clk_divider *sizeof(*div)ccf_clk_dividerUBOOT_DM_CLK_CCF_DIVIDERSANDBOX_CLK_CCFCONFIG_VAL(SANDBOX_CLK_CCF)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_SANDBOX_CLK_CCFCONFIG_SANDBOX_CLK_CCFCONFIG_VAL(SANDBOX_CLK_CCF_MODULE)CONFIG_SANDBOX_CLK_CCF_MODULESANDBOX_CLK_CCF_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_SANDBOX_CLK_CCF_MODULE__ARG_PLACEHOLDER_CONFIG_SANDBOX_CLK_CCF_MODULE__ARG_PLACEHOLDER_CONFIG_SANDBOX_CLK_CCF_MODULE 1clk_divider_recalc_ratedev_get_clk_ptr(clk->dev)struct clk_dividerdividerconst clkconst clk *to_clk_divider(dev_get_clk_ptr(clk->dev))divider->widthclk_div_mask(divider->width)parent_ratedivider_recalc_rate!(flags & CLK_DIVIDER_ALLOW_ZERO)!(flags & (1UL << (2)))"%s: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set\n", clk_hw_get_name(hw)WARN(!(flags & CLK_DIVIDER_ALLOW_ZERO),
		     "%s: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set\n",
		     clk_hw_get_name(hw))%s: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set
"%s: Zero divisor and CLK_DIVIDER_ALLOW_ZERO not set\n"_tmp(u64)parent_rate((u64)parent_rate) + (div) - 1(div)DIV_ROUND_UP_ULL((u64)parent_rate, div)/opt/src/include/clk-uclass.h/opt/src/include/clk.h/opt/src/include/linux/clk-provider.h/opt/src/drivers/clk"clk.h"<linux/clk-provider.h><clk-uclass.h>parent_nameclk_divider_flagshw((_tmp) >> 32) == 0_get_divCLK_DIVIDER_ONE_BASEDCLK_DIVIDER_POWER_OF_TWOCLK_DIVIDER_MAX_AT_ZEROclk_div_mask(width)_get_table_divclktUCLASS_CLKconst clk_opsconst clk_ops *clk_ops *_u_boot_list_2_driver_2_ccf_clk_divider.u_boot_list_2_driver_2_ccf_clk_dividerclk_divider_ops"ccf_clk_divider"CONFIG_IS_ENABLED(SANDBOX_CLK_CCF)/* register the clock *//* struct clk_divider assignments *//* allocate the divider *//*
 * Copyright (C) 2019 DENX Software Engineering
 * Lukasz Majewski, DENX Software Engineering, lukma@denx.de
 *
 * Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
 * Copyright (C) 2011 Richard Zhao, Linaro <richard.zhao@linaro.org>
 * Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>
 *
 *//opt/src/drivers/clk/clk-fixed-factor.cclk-fixed-factorclk_register_fixed_factorclk_hw_register_fixed_factorclk_fixed_factor *fixsizeof(*fix)ccf_clk_fixed_factorUBOOT_DM_CLK_IMX_FIXED_FACTORclk_factor_recalc_ratestruct clk_fixed_factorto_clk_fixed_factor(dev_get_clk_ptr(clk->dev))fix->divdo_div(rate, fix->div)((rate) >> 32) == 0_u_boot_list_2_driver_2_imx_clk_fixed_factor.u_boot_list_2_driver_2_imx_clk_fixed_factorimx_clk_fixed_factorccf_clk_fixed_factor_ops"ccf_clk_fixed_factor"/* struct clk_fixed_factor assignments *//*
 * Copyright (C) 2019 DENX Software Engineering
 * Lukasz Majewski, DENX Software Engineering, lukma@denx.de
 *
 * Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
 *//opt/src/drivers/clk/clk-mux.cclk-muxclk_register_muxBIT(width)clk_register_mux_tableclk_hw_register_mux_tableCLK_MUX_HIWORD_MASK"mux value exceeds LOWORD field\n"pr_err("mux value exceeds LOWORD field\n")pr_fmt("mux value exceeds LOWORD field\n")mux value exceeds LOWORD field
clk_mux *sizeof(*mux)ccf_clk_muxUBOOT_DM_CLK_CCF_MUXclk_mux_get_parentstruct clk_muxto_clk_mux(clk)clk_mux_val_to_indexnum_parentsCLK_MUX_INDEX_BITCLK_MUX_INDEX_ONE_u_boot_list_2_driver_2_ccf_clk_mux.u_boot_list_2_driver_2_ccf_clk_muxclk_mux_ops"ccf_clk_mux"/*
	 * Read the current mux setup - so we assign correct parent.
	 *
	 * Changing parent would require changing internals of udevice struct
	 * for the corresponding clock (to do that define .set_parent() method.
	 *//* struct clk_mux assignments *//* U-boot specific assignments *//* allocate the mux *//*
 * U-Boot CCF porting node:
 *
 * The Linux kernel - as of tag: 5.0-rc3 is using also the imx_clk_fixup_mux()
 * version of CCF mux. It is used on e.g. imx6q to provide fixes (like
 * imx_cscmr1_fixup) for broken HW.
 *
 * At least for IMX6Q (but NOT IMX6QP) it is important when we set the parent
 * clock.
 *//*
 * Copyright (C) 2019 DENX Software Engineering
 * Lukasz Majewski, DENX Software Engineering, lukma@denx.de
 *
 * Copyright (C) 2011 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
 * Copyright (C) 2011 Richard Zhao, Linaro <richard.zhao@linaro.org>
 * Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>
 *
 * Simple multiplexer clock implementation
 */parent_namesclk_mux_flags/opt/src/include/dt-structs.hdt-structs__DT_STRUCTS/* These structures may only be used in SPL *//opt/src/drivers/clk/clk-uclass.cclk-uclassclk_get_by_idclk **clk_disable_bulkclk_bulk *"%s(clk=%p)\n"__func__, clkdebug("%s(clk=%p)\n", __func__, clk)drivers/clk/clk-uclass.c%s(clk=%p)
clk_enable_bulkclk_enable450clk_set_parent"%s(clk=%p, parent=%p)\n"__func__, clk, parentdebug("%s(clk=%p, parent=%p)\n", __func__, clk, parent)438%s(clk=%p, parent=%p)
<dt-structs.h>clkpclk_set_rate"%s(clk=%p, rate=%lu)\n"__func__, clk, ratedebug("%s(clk=%p, rate=%lu)\n", __func__, clk, rate)%s(clk=%p, rate=%lu)
clk_get_parent_ratepclkCLK_GET_RATE_NOCACHEclk_get_parentclk_get_rate377clk_freeclk_request"%s(dev=%p, clk=%p)\n"__func__, dev, clkdebug("%s(dev=%p, clk=%p)\n", __func__, dev, clk)%s(dev=%p, clk=%p)
clk_release_all"%s(clk[%d]=%p)\n"__func__, i, &clk[i]debug("%s(clk[%d]=%p)\n", __func__, i, &clk[i])%s(clk[%d]=%p)
clk_get_by_name"%s(dev=%p, name=%s, clk=%p)\n"__func__, dev, name, clkdebug("%s(dev=%p, name=%s, clk=%p)\n", __func__, dev, name, clk)%s(dev=%p, name=%s, clk=%p)
clock-names"clock-names""fdt_stringlist_search() failed: %d\n"debug("fdt_stringlist_search() failed: %d\n", index)fdt_stringlist_search() failed: %d
clk_set_defaults"%s(%s)\n"__func__, dev_read_name(dev)debug("%s(%s)\n", __func__, dev_read_name(dev))%s(%s)
clk_set_default_ratesassigned-clock-rates"assigned-clock-rates"num_ratesratesassigned-clocks"assigned-clocks""%s: could not get assigned clock %d for %s\n"__func__, index, dev_read_name(dev)debug("%s: could not get assigned clock %d for %s\n",
			      __func__, index, dev_read_name(dev))%s: could not get assigned clock %d for %s
"%s: failed to set rate on clock index %d (%ld) for %s\n"__func__, index, clk.id, dev_read_name(dev)debug("%s: failed to set rate on clock index %d (%ld) for %s\n",
			      __func__, index, clk.id, dev_read_name(dev))%s: failed to set rate on clock index %d (%ld) for %s
clk_set_default_parentsassigned-clock-parents"assigned-clock-parents"#clock-cells"#clock-cells""%s: could not read assigned-clock-parents for %p\n"__func__, devdebug("%s: could not read assigned-clock-parents for %p\n",
		      __func__, dev)%s: could not read assigned-clock-parents for %p
parent_clk"%s: could not get parent clock %d for %s\n"debug("%s: could not get parent clock %d for %s\n",
			      __func__, index, dev_read_name(dev))%s: could not get parent clock %d for %s
"%s: failed to reparent clock %d for %s\n"debug("%s: failed to reparent clock %d for %s\n",
			      __func__, index, dev_read_name(dev))%s: failed to reparent clock %d for %s
clk_get_bulkclocks"clocks"sizeof(struct clk)"%s: could release all clocks for %p\n"debug("%s: could release all clocks for %p\n",
		      __func__, dev)%s: could release all clocks for %p
clk_get_by_index_nodevclk_get_by_indexclk_get_by_indexed_prop"%s(dev=%p, index=%d, clk=%p)\n"__func__, dev, index, clkdebug("%s(dev=%p, index=%d, clk=%p)\n", __func__, dev, index, clk)%s(dev=%p, index=%d, clk=%p)
assert(clk)"%s: fdtdec_parse_phandle_with_args failed: err=%d\n"debug("%s: fdtdec_parse_phandle_with_args failed: err=%d\n",
		      __func__, ret)%s: fdtdec_parse_phandle_with_args failed: err=%d
clk_get_by_index_taildev_clk"%s: uclass_get_device_by_of_offset failed: err=%d\n"debug("%s: uclass_get_device_by_of_offset failed: err=%d\n",
		      __func__, ret)%s: uclass_get_device_by_of_offset failed: err=%d
bulk_get_err"of_xlate() failed: %d\n"debug("of_xlate() failed: %d\n", ret)of_xlate() failed: %d
"%s: Node '%s', property '%s', failed to request CLK index %d: %d\n"__func__, ofnode_get_name(node), list_name, index, retdebug("%s: Node '%s', property '%s', failed to request CLK index %d: %d\n",
	      __func__, ofnode_get_name(node), list_name, index, ret)%s: Node '%s', property '%s', failed to request CLK index %d: %d
clk_of_xlate_default"Invaild args_count: %d\n"args->args_countdebug("Invaild args_count: %d\n", args->args_count)Invaild args_count: %d
clk_dev_ops"clk"_u_boot_list_2_uclass_2_clk.u_boot_list_2_uclass_2_clk/* Read the 'rate' if not already set or if proper flag set*//* OF_CONTROL *//* check if clock has been previously requested *//* OF_PLATDATA *//* If this not in SPL and pre-reloc state, don't take any action. *//* If 0 is passed, this is a no-op *//*
		 * Not all drivers may support clock-reparenting (as of now).
		 * Ignore errors due to this.
		 *//* If -ENOENT, this is a no-op entry *//*
 * Copyright (C) 2015 Google, Inc
 * Written by Simon Glass <sjg@chromium.org>
 * Copyright (c) 2016, NVIDIA CORPORATION.
 * Copyright (c) 2018, Theobroma Systems Design und Consulting GmbH
 *//opt/src/drivers/clk/clk.cclk_hw_get_nameclk_generic_get_rateclk_register%s: UCLASS parent: 0x%p
"%s: UCLASS parent: 0x%p\n""%s: name: %s parent: %s [0x%p]\n"__func__, name, parent->name, parentdebug("%s: name: %s parent: %s [0x%p]\n", __func__, name, parent->name,
	      parent)drivers/clk/clk.c%s: name: %s parent: %s [0x%p]
%s: %s is not a valid driver name
"%s: %s is not a valid driver name\n"%s: CLK: %s driver bind error [%d]!
"%s: CLK: %s driver bind error [%d]!\n"/* Store back pointer to clk from udevice *//*
 * Copyright (C) 2019 DENX Software Engineering
 * Lukasz Majewski, DENX Software Engineering, lukma@denx.de
 *//opt/src/drivers/clk/clk_fixed_factor.cclk_fixed_factorclk_fixed_factor_ofdata_to_platdataffclock-div"clock-div"clock-mult"clock-mult"clk_fixed_factor_get_rateclk->dev(rate) >= (unsigned long)-MAX_ERRNO(rate) >= (unsigned long)-4095IS_ERR_VALUE(rate)ff->divdo_div(rate, ff->div)fixed_factor_clock"fixed_factor_clock"sizeof(struct clk_fixed_factor)_u_boot_list_2_driver_2_clk_fixed_factor.u_boot_list_2_driver_2_clk_fixed_factorfixed-factor-clock"fixed-factor-clock"clk_fixed_factor_matchclk_fixed_factor_opsto_clk_fixed_factor(dev)((struct clk_fixed_factor *)dev_get_platdata(dev))!CONFIG_IS_ENABLED(OF_PLATDATA)/*
 * Copyright (c) 2019 Western Digital Corporation or its affiliates.
 *
 * Author: Anup Patel <anup.patel@wdc.com>
 *//opt/src/drivers/clk/clk_fixed_rate.cclk_fixed_rateclk_fixed_rate_ofdata_to_platdataclk_fixed_rate *clock-frequency"clock-frequency"clk_fixed_rate_get_ratefixed_ratefixed_rate_clock"fixed_rate_clock"sizeof(struct clk_fixed_rate)_u_boot_list_2_driver_2_clk_fixed_rate.u_boot_list_2_driver_2_clk_fixed_ratefixed-clock"fixed-clock"clk_fixed_rate_matchclk_fixed_rate_opsto_clk_fixed_rate(dev)((struct clk_fixed_rate *)dev_get_platdata(dev))/* Make fixed rate clock accessible from higher level struct clk *//*
 * Copyright (C) 2016 Masahiro Yamada <yamada.masahiro@socionext.com>
 *//opt/src/arch/sandbox/include/asm/clk.hsandbox_clk_test_validsandbox_clk_test_release_bulksandbox_clk_test_freesandbox_clk_test_disable_bulksandbox_clk_test_disablesandbox_clk_test_enable_bulksandbox_clk_test_enablesandbox_clk_test_set_ratesandbox_clk_test_get_ratesandbox_clk_test_get_bulksandbox_clk_test_getsandbox_clk_test_idSANDBOX_CLK_TEST_ID_FIXEDSANDBOX_CLK_TEST_ID_SPISANDBOX_CLK_TEST_ID_I2CSANDBOX_CLK_TEST_ID_COUNTsandbox_clk_idSANDBOX_CLK_ID_SPISANDBOX_CLK_ID_I2CSANDBOX_CLK_ID_COUNT__SANDBOX_CLK_Hsandbox_clk_query_enablesandbox_clk_query_rate/**
 * sandbox_clk_test_valid - Ask the sandbox clock test device to check its
 * clocks are valid.
 *
 * @dev:	The sandbox clock test (client) devivce.
 * @return:	0 if OK, or a negative error code.
 *//**
 * sandbox_clk_test_release_bulk - Ask the sandbox clock test device to release
 * all clocks in it's clock bulk struct.
 *
 * @dev:	The sandbox clock test (client) devivce.
 * @return:	0 if OK, or a negative error code.
 *//**
 * sandbox_clk_test_free - Ask the sandbox clock test device to free its
 * clocks.
 *
 * @dev:	The sandbox clock test (client) devivce.
 * @return:	0 if OK, or a negative error code.
 *//**
 * sandbox_clk_test_disable_bulk - Ask the sandbox clock test device to disable
 * all clocks in it's clock bulk struct.
 *
 * @dev:	The sandbox clock test (client) devivce.
 * @return:	0 if OK, or a negative error code.
 *//**
 * sandbox_clk_test_disable - Ask the sandbox clock test device to disable a
 * clock.
 *
 * @dev:	The sandbox clock test (client) devivce.
 * @id:		The test device's clock ID to configure.
 * @return:	0 if OK, or a negative error code.
 *//**
 * sandbox_clk_test_enable_bulk - Ask the sandbox clock test device to enable
 * all clocks in it's clock bulk struct.
 *
 * @dev:	The sandbox clock test (client) devivce.
 * @return:	0 if OK, or a negative error code.
 *//**
 * sandbox_clk_test_enable - Ask the sandbox clock test device to enable a
 * clock.
 *
 * @dev:	The sandbox clock test (client) devivce.
 * @id:		The test device's clock ID to configure.
 * @return:	0 if OK, or a negative error code.
 *//**
 * sandbox_clk_test_set_rate - Ask the sandbox clock test device to set a
 * clock's rate.
 *
 * @dev:	The sandbox clock test (client) devivce.
 * @id:		The test device's clock ID to configure.
 * @return:	The new rate of the clock.
 *//**
 * sandbox_clk_test_get_rate - Ask the sandbox clock test device to query a
 * clock's rate.
 *
 * @dev:	The sandbox clock test (client) devivce.
 * @id:		The test device's clock ID to query.
 * @return:	The rate of the clock.
 *//**
 * sandbox_clk_test_get_bulk - Ask the sandbox clock test device to request its
 * clocks with the bulk clk API.
 *
 * @dev:	The sandbox clock test (client) devivce.
 * @return:	0 if OK, or a negative error code.
 *//**
 * sandbox_clk_test_get - Ask the sandbox clock test device to request its
 * clocks.
 *
 * @dev:	The sandbox clock test (client) devivce.
 * @return:	0 if OK, or a negative error code.
 *//**
 * sandbox_clk_query_enable - Query the enable state of a sandbox clock.
 *
 * @dev:	The sandbox clock provider device.
 * @id:		The clock to query.
 * @return:	The rate of the clock.
 *//**
 * sandbox_clk_query_rate - Query the current rate of a sandbox clock.
 *
 * @dev:	The sandbox clock provider device.
 * @id:		The clock to query.
 * @return:	The rate of the clock.
 *//**
 * enum sandbox_clk_test_id - Identity of the clocks consumed by the sandbox
 * clock test device.
 *
 * These are the IDs the clock consumer knows the clocks as.
 *//**
 * enum sandbox_clk_id - Identity of clocks implemented by the sandbox clock
 * provider.
 *
 * These IDs are within/relative-to the clock provider.
 *//*
 * Copyright (c) 2016, NVIDIA CORPORATION.
 *//opt/src/drivers/clk/clk_sandbox.cclk_sandboxsandbox_clk_priv *bool[2]18446744073709551594ulong[2]unsigned long[2]sandbox_clk_disablesandbox_clk_enablesandbox_clk_set_rateold_ratesandbox_clk_get_ratesandbox_clk_priv"clk_sandbox"sizeof(struct sandbox_clk_priv)_u_boot_list_2_driver_2_clk_sandbox.u_boot_list_2_driver_2_clk_sandboxsandbox,clk"sandbox,clk"sandbox_clk_idssandbox_clk_ops/*
 * (C) Copyright 2015 Google, Inc
 */<asm/clk.h>/opt/src/include/sandbox-clk.hsandbox-clksandbox_clk_muxCLK_SET_RATE_NO_REPARENTsandbox_clk_gate2CLK_SET_RATE_PARENTsandbox_clk_dividersandbox_clk_fixed_factorsandbox_pllv3_typeSANDBOX_PLLV3_GENERICSANDBOX_PLLV3_USBSANDBOX_CLK_PLL2SANDBOX_CLK_PLL3SANDBOX_CLK_PLL3_60MSANDBOX_CLK_PLL3_80MSANDBOX_CLK_ECSPI_ROOTSANDBOX_CLK_ECSPI0SANDBOX_CLK_ECSPI1SANDBOX_CLK_USDHC1_SELSANDBOX_CLK_USDHC2_SEL__SANDBOX_CLK_H__sandbox_clk_register_gate2sandbox_clk_pllv3/* __SANDBOX_CLK_H__ *//*
 * Copyright (C) 2019
 * Lukasz Majewski, DENX Software Engineering, lukma@denx.de
 */parentsbit_idxcgr_valclk_gate_flagsdiv_mask/opt/src/drivers/clk/clk_sandbox_ccf.cclk_sandbox_ccfsandbox_clk_ccf_probepll3_usb_otg"pll3_usb_otg"osc"osc"pll3_60m"pll3_60m"pll3_80m"pll3_80m"2 << 19(2 << 19)ecspi_root"ecspi_root"ecspi1"ecspi1"usdhc1_sel"usdhc1_sel"const char *const[2]usdhc_selsARRAY_SIZE(usdhc_sels)usdhc2_sel"usdhc2_sel"clk_gate2 *gatesizeof(*gate)"sandbox_clk_gate2"clk_gate2_disablestruct clk_gate2to_clk_gate2(dev_get_clk_ptr(clk->dev))clk_gate2_enableclk_pllv3 *pllsizeof(*pll)"sandbox_clk_pllv3"clk_pllv3_get_rateclk_gate2clk_pllv3div_shiftsandbox_clk_ccf"sandbox_clk_ccf"_u_boot_list_2_driver_2_sandbox_clk_ccf.u_boot_list_2_driver_2_sandbox_clk_ccfsandbox,clk-ccf"sandbox,clk-ccf"sandbox_clk_ccf_test_ids_u_boot_list_2_driver_2_sandbox_clk_gate2.u_boot_list_2_driver_2_sandbox_clk_gate2clk_gate2_ops_u_boot_list_2_driver_2_sandbox_clk_pll_generic.u_boot_list_2_driver_2_sandbox_clk_pll_genericsandbox_clk_pll_genericclk_pllv3_generic_opsto_clk_gate2(_clk)container_of(_clk, struct clk_gate2, clk)/* Select 'pll3_80m' *//* Select 'pll3_60m' *//* The HW adds +1 to the divider value (2+1) is the divider *//* The CCF core driver itself *//* --- Sandbox Gate --- *//* --- Sandbox Gate  --- *//* --- Sandbox PLLv3 --- *//*
 * Sandbox implementation of CCF primitives necessary for clk-uclass testing
 *
 * --- Sandbox PLLv3 ---
 *//*
 * Copyright (C) 2019
 * Lukasz Majewski, DENX Software Engineering, lukma@denx.de
 *
 * Common Clock Framework [CCF] driver for Sandbox
 */<sandbox-clk.h>clk_gate2_flags/opt/src/drivers/clk/clk_sandbox_test.cclk_sandbox_testsandbox_clk_test *sbctclk[3]sandbox_clk_testclks"sandbox_clk_test"UCLASS_MISCsizeof(struct sandbox_clk_test)_u_boot_list_2_driver_2_sandbox_clk_test.u_boot_list_2_driver_2_sandbox_clk_testsandbox,clk-test"sandbox,clk-test"sandbox_clk_test_idsfixed"fixed""spi""i2c"sandbox_clk_test_namesclk_validsoc_clk_dumpclk_release_bulkclk_get_by_index_platdataphandle_1_arg *phandle_1_argclk_bulk_CLK_H_CONFIG_IS_ENABLED(OF_CONTROL) && CONFIG_IS_ENABLED(CLK)(CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)) && \CLKCONFIG_VAL(CLK_MODULE)CONFIG_CLK_MODULE__ARG_PLACEHOLDER_CONFIG_CLK_MODULE__ARG_PLACEHOLDER_CONFIG_CLK_MODULE 1CLK_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_CLK_MODULECONFIG_VAL(CLK)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_CLKCONFIG_CLK/**
 * clk_get_by_id() - Get the clock by its ID
 *
 * @id:	The clock ID to search for
 *
 * @clkp:	A pointer to clock struct that has been found among added clocks
 *              to UCLASS_CLK
 * @return zero on success, or -ENOENT on error
 *//**
 * clk_valid() - check if clk is valid
 *
 * @clk:	the clock to check
 * @return true if valid, or false
 *//**
 * clk_disable_bulk() - Disable (turn off) all clocks in a clock bulk struct.
 *
 * @bulk:	A clock bulk struct that was previously successfully requested
 *		by clk_get_bulk().
 * @return zero on success, or -ve error code.
 *//**
 * clk_disable() - Disable (turn off) a clock.
 *
 * @clk:	A clock struct that was previously successfully requested by
 *		clk_request/get_by_*().
 * @return zero on success, or -ve error code.
 *//**
 * clk_enable_bulk() - Enable (turn on) all clocks in a clock bulk struct.
 *
 * @bulk:	A clock bulk struct that was previously successfully requested
 *		by clk_get_bulk().
 * @return zero on success, or -ve error code.
 *//**
 * clk_enable() - Enable (turn on) a clock.
 *
 * @clk:	A clock struct that was previously successfully requested by
 *		clk_request/get_by_*().
 * @return zero on success, or -ve error code.
 *//**
 * clk_set_parent() - Set current clock parent.
 *
 * @clk:	A clock struct that was previously successfully requested by
 *		clk_request/get_by_*().
 * @parent:	A clock struct that was previously successfully requested by
 *		clk_request/get_by_*().
 * @return new rate, or -ve error code.
 *//**
 * clk_set_rate() - Set current clock rate.
 *
 * @clk:	A clock struct that was previously successfully requested by
 *		clk_request/get_by_*().
 * @rate:	New clock rate in Hz.
 * @return new rate, or -ve error code.
 *//**
 * clk_get_parent_rate() - Get parent of current clock rate.
 *
 * @clk:	A clock struct that was previously successfully requested by
 *		clk_request/get_by_*().
 * @return clock rate in Hz, or -ve error code.
 *//**
 * clk_get_parent() - Get current clock's parent.
 *
 * @clk:	A clock struct that was previously successfully requested by
 *		clk_request/get_by_*().
 * @return pointer to parent's struct clk, or error code passed as pointer
 *//**
 * clk_get_rate() - Get current clock rate.
 *
 * @clk:	A clock struct that was previously successfully requested by
 *		clk_request/get_by_*().
 * @return clock rate in Hz, or -ve error code.
 *//**
 * clock_free - Free a previously requested clock.
 *
 * @clock:	A clock struct that was previously successfully requested by
 *		clk_request/get_by_*().
 * @return 0 if OK, or a negative error code.
 *//**
 * clk_request - Request a clock by provider-specific ID.
 *
 * This requests a clock using a provider-specific ID. Generally, this function
 * should not be used, since clk_get_by_index/name() provide an interface that
 * better separates clients from intimate knowledge of clock providers.
 * However, this function may be useful in core SoC-specific code.
 *
 * @dev:	The clock provider device.
 * @clock:	A pointer to a clock struct to initialize. The caller must
 *		have already initialized any field in this struct which the
 *		clock provider uses to identify the clock.
 * @return 0 if OK, or a negative error code.
 *//**
 * clk_release_bulk() - Disable (turn off)/Free an array of previously
 * requested clocks in a clock bulk struct.
 *
 * For each clock contained in the clock bulk struct, this function will check
 * if clock has been previously requested and then will disable and free it.
 *
 * @clk:	A clock bulk struct that was previously successfully
 *		requested by clk_get_bulk().
 * @return zero on success, or -ve error code.
 *//**
 * clk_set_defaults - Process 'assigned-{clocks/clock-parents/clock-rates}'
 *                    properties to configure clocks
 *
 * @dev:        A device to process (the ofnode associated with this device
 *              will be processed).
 *//**
 * clk_release_all() - Disable (turn off)/Free an array of previously
 * requested clocks.
 *
 * For each clock contained in the clock array, this function will check if
 * clock has been previously requested and then will disable and free it.
 *
 * @clk:	A clock struct array that was previously successfully
 *		requested by clk_request/get_by_*().
 * @count	Number of clock contained in the array
 * @return zero on success, or -ve error code.
 *//**
 * clock_get_by_name - Get/request a clock by name.
 *
 * This looks up and requests a clock. The name is relative to the client
 * device; each device is assumed to have n clocks associated with it somehow,
 * and this function finds and requests one of them. The mapping of client
 * device clock names to provider clocks may be via device-tree properties,
 * board-provided mapping tables, or some other mechanism.
 *
 * @dev:	The client device.
 * @name:	The name of the clock to request, within the client's list of
 *		clocks.
 * @clock:	A pointer to a clock struct to initialize.
 * @return 0 if OK, or a negative error code.
 *//**
 * clock_get_bulk - Get/request all clocks of a device.
 *
 * This looks up and requests all clocks of the client device; each device is
 * assumed to have n clocks associated with it somehow, and this function finds
 * and requests all of them in a separate structure. The mapping of client
 * device clock indices to provider clocks may be via device-tree properties,
 * board-provided mapping tables, or some other mechanism.
 *
 * @dev:	The client device.
 * @bulk	A pointer to a clock bulk struct to initialize.
 * @return 0 if OK, or a negative error code.
 *//**
 * clock_get_by_index_nodev - Get/request a clock by integer index
 * without a device.
 *
 * This is a version of clk_get_by_index() that does not use a device.
 *
 * @node:	The client ofnode.
 * @index:	The index of the clock to request, within the client's list of
 *		clocks.
 * @clock	A pointer to a clock struct to initialize.
 * @return 0 if OK, or a negative error code.
 *//**
 * clock_get_by_index - Get/request a clock by integer index.
 *
 * This looks up and requests a clock. The index is relative to the client
 * device; each device is assumed to have n clocks associated with it somehow,
 * and this function finds and requests one of them. The mapping of client
 * device clock indices to provider clocks may be via device-tree properties,
 * board-provided mapping tables, or some other mechanism.
 *
 * @dev:	The client device.
 * @index:	The index of the clock to request, within the client's list of
 *		clocks.
 * @clock	A pointer to a clock struct to initialize.
 * @return 0 if OK, or a negative error code.
 *//**
 * struct clk_bulk - A handle to (allowing control of) a bulk of clocks.
 *
 * Clients provide storage for the clock bulk. The content of the structure is
 * managed solely by the clock API. A clock bulk struct is
 * initialized by "get"ing the clock bulk struct.
 * The clock bulk struct is passed to all other bulk clock APIs to apply
 * the API to all the clock in the bulk struct.
 *
 * @clks: An array of clock handles.
 * @count: The number of clock handles in the clks array.
 *//*
	 * Written by of_xlate. In the future, we might add more fields here.
	 *//* in HZ *//**
 * struct clk - A handle to (allowing control of) a single clock.
 *
 * Clients provide storage for clock handles. The content of the structure is
 * managed solely by the clock API and clock drivers. A clock struct is
 * initialized by "get"ing the clock struct. The clock struct is passed to all
 * other clock APIs to identify which clock signal to operate upon.
 *
 * @dev: The device which implements the clock signal.
 * @rate: The clock rate (in HZ).
 * @flags: Flags used across common clock structure (e.g. CLK_)
 *         Clock IP blocks specific flags (i.e. mux, div, gate, etc) are defined
 *         in struct's for those devices (e.g. struct clk_mux).
 * @id: The clock signal ID within the provider.
 * @data: An optional data field for scenarios where a single integer ID is not
 *	  sufficient. If used, it can be populated through an .of_xlate op and
 *	  processed during the various clock ops.
 *
 * Should additional information to identify and configure any clock signal
 * for any provider be required in the future, the struct could be expanded to
 * either (a) add more fields to allow clock providers to store additional
 * information, or (b) replace the id field with an opaque pointer, which the
 * provider would dynamically allocated during its .of_xlate op, and process
 * during is .request op. This may require the addition of an extra op to clean
 * up the allocation.
 *//**
 * A clock is a hardware signal that oscillates autonomously at a specific
 * frequency and duty cycle. Most hardware modules require one or more clock
 * signal to drive their operation. Clock signals are typically generated
 * externally to the HW module consuming them, by an entity this API calls a
 * clock provider. This API provides a standard means for drivers to enable and
 * disable clocks, and to set the rate at which they oscillate.
 *
 * A driver that implements UCLASS_CLK is a clock provider. A provider will
 * often implement multiple separate clocks, since the hardware it manages
 * often has this capability. clk-uclass.h describes the interface which
 * clock providers must implement.
 *
 * Clock consumers/clients are the HW modules driven by the clock signals. This
 * header file describes the API used by drivers for those HW modules.
 *//*
 * Copyright (c) 2015 Google, Inc
 * Written by Simon Glass <sjg@chromium.org>
 * Copyright (c) 2016, NVIDIA CORPORATION.
 */clk_opsset_parentset_rateget_rateof_xlate_CLK_UCLASS_H/**
	 * disable() - Disable a clock.
	 *
	 * @clk:	The clock to manipulate.
	 * @return zero on success, or -ve error code.
	 *//**
	 * enable() - Enable a clock.
	 *
	 * @clk:	The clock to manipulate.
	 * @return zero on success, or -ve error code.
	 *//**
	 * set_parent() - Set current clock parent
	 *
	 * @clk:        The clock to manipulate.
	 * @parent:     New clock parent.
	 * @return zero on success, or -ve error code.
	 *//**
	 * set_rate() - Set current clock rate.
	 *
	 * @clk:	The clock to manipulate.
	 * @rate:	New clock rate in Hz.
	 * @return new rate, or -ve error code.
	 *//**
	 * get_rate() - Get current clock rate.
	 *
	 * @clk:	The clock to query.
	 * @return clock rate in Hz, or -ve error code
	 *//**
	 * free - Free a previously requested clock.
	 *
	 * This is the implementation of the client clk_free() API.
	 *
	 * @clock:	The clock to free.
	 * @return 0 if OK, or a negative error code.
	 *//**
	 * request - Request a translated clock.
	 *
	 * The clock core calls this function as the second step in
	 * implementing a client's clk_get_by_*() call, following a successful
	 * xxx_xlate() call, or as the only step in implementing a client's
	 * clk_request() call.
	 *
	 * @clock:	The clock struct to request; this has been fille in by
	 *		a previoux xxx_xlate() function call, or by the caller
	 *		of clk_request().
	 * @return 0 if OK, or a negative error code.
	 *//**
	 * of_xlate - Translate a client's device-tree (OF) clock specifier.
	 *
	 * The clock core calls this function as the first step in implementing
	 * a client's clk_get_by_*() call.
	 *
	 * If this function pointer is set to NULL, the clock core will use a
	 * default implementation, which assumes #clock-cells = <1>, and that
	 * the DT cell contains a simple integer clock ID.
	 *
	 * At present, the clock API solely supports device-tree. If this
	 * changes, other xxx_xlate() functions may be added to support those
	 * other mechanisms.
	 *
	 * @clock:	The clock struct to hold the translation result.
	 * @args:	The clock specifier values from device tree.
	 * @return 0 if OK, or a negative error code.
	 *//**
 * struct clk_ops - The functions that a clock driver must implement.
 *//* See clk.h for background documentation. */clk-providerdev_get_clk_ptrclk_dmclk_dividerclk_div_tableclk_muxio_divider_valio_mux_valto_clk_fixed_factor(_clk)container_of(_clk, struct clk_fixed_factor, clk)CLK_DIVIDER_READ_ONLYCLK_DIVIDER_ROUND_CLOSESTCLK_DIVIDER_ALLOW_ZEROto_clk_divider(_clk)container_of(_clk, struct clk_divider, clk)((1 << (width)) - 1)to_clk_mux(_clk)container_of(_clk, struct clk_mux, clk)CLK_MUX_ROUND_CLOSESTCLK_MUX_READ_ONLYCLK_DUTY_CYCLE_PARENTCLK_OPS_PARENT_ENABLECLK_IS_CRITICALCLK_SET_RATE_UNGATECLK_RECALC_NEW_RATESCLK_GET_ACCURACY_NOCACHECLK_IS_BASICCLK_IGNORE_UNUSEDCLK_SET_PARENT_GATECLK_SET_RATE_GATE__LINUX_CLK_PROVIDER_H/* __LINUX_CLK_PROVIDER_H *//*
	 * Fields from struct clk_init_data - this struct has been
	 * omitted to avoid too deep level of CCF for bootloader
	 *//* mux can't be changed *//* duty cycle call may be forwarded to the parent clock *//* parents need enable during gate/ungate, set rate and re-parent *//* do not gate, ever *//* clock needs to run to set rate *//* recalc rates after notifications *//* do not use the cached clk accuracy *//* don't re-parent on rate change *//* do not use the cached clk rate *//* Basic clk, can't do a to_clk_foo() *//* do not gate even if unused *//* propagate rate change up one level *//* must be gated across re-parent *//* must be gated across rate change *//*
 * flags used across common struct clk.  these flags should only affect the
 * top-level framework.  custom flags for dealing with hardware specifics
 * belong in struct clk_foo
 *
 * Please update clk_flags[] in drivers/clk/clk.c when making changes here!
 *//*
 * Copyright (C) 2019 DENX Software Engineering
 * Lukasz Majewski, DENX Software Engineering, lukma@denx.de
 *
 * Copyright (c) 2010-2011 Jeremy Kerr <jeremy.kerr@canonical.com>
 * Copyright (C) 2011-2012 Linaro Ltd <mturquette@linaro.org>
 *//opt/src/drivers/clk/imx/clk.himx_clk_muximx_clk_fixup_muximx_clk_pfdimx_clk_dividerimx_clk_gate2imx_clk_pllv3imx_pllv3_typeIMX_PLLV3_GENERICIMX_PLLV3_SYSIMX_PLLV3_USBIMX_PLLV3_USB_VF610IMX_PLLV3_AVIMX_PLLV3_ENETIMX_PLLV3_ENET_IMX7IMX_PLLV3_SYS_VF610IMX_PLLV3_DDR_IMX7__MACH_IMX_CLK_Hclk_register_gate2/* __MACH_IMX_CLK_H *//opt/src/drivers/clk/imximxfixup/opt/src/drivers/clk/imx/clk-gate2.cclk-gate2UBOOT_DM_CLK_IMX_GATE2gate->reg_u_boot_list_2_driver_2_clk_gate2.u_boot_list_2_driver_2_clk_gate2"imx_clk_gate2"/*
 * Copyright (C) 2019 DENX Software Engineering
 * Lukasz Majewski, DENX Software Engineering, lukma@denx.de
 *
 * Copyright (C) 2010-2011 Canonical Ltd <jeremy.kerr@canonical.com>
 * Copyright (C) 2011-2012 Mike Turquette, Linaro Ltd <mturquette@linaro.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * Gated clock implementation
 *
 *//opt/src/drivers/clk/imx/clk-pfd.cclk-pfdclk_pfd *pfdsizeof(*pfd)UBOOT_DM_CLK_IMX_PFDclk_pfd_recalc_ratestruct clk_pfdpfd->regfracto_clk_pfd(dev_get_clk_ptr(clk->dev))do_div(tmp, frac)((tmp) >> 32) == 0clk_pfd_u_boot_list_2_driver_2_clk_pfd.u_boot_list_2_driver_2_clk_pfdclk_pfd_opsOTG0xcCLRSETto_clk_pfd(_clk)container_of(_clk, struct clk_pfd, clk)"imx_clk_pfd"/*
 * Copyright (C) 2019 DENX Software Engineering
 * Lukasz Majewski, DENX Software Engineering, lukma@denx.de
 *
 * Copyright 2012 Freescale Semiconductor, Inc.
 * Copyright 2012 Linaro Ltd.
 *
 * The code contained herein is licensed under the GNU General Public
 * License. You may obtain a copy of the GNU General Public License
 * Version 2 or later at the following locations:
 *
 * http://www.opensource.org/licenses/gpl-license.html
 * http://www.gnu.org/copyleft/gpl.html
 *//opt/src/drivers/clk/imx/clk-pllv3.cclk-pllv3UBOOT_DM_CLK_IMX_PLLV3524ENOTSUPP-524-ENOTSUPPstruct clk_pllv3pll->baseto_clk_pllv3(dev_get_clk_ptr(clk->dev))_u_boot_list_2_driver_2_clk_pllv3_generic.u_boot_list_2_driver_2_clk_pllv3_genericclk_pllv3_genericto_clk_pllv3(_clk)container_of(_clk, struct clk_pllv3, clk)"imx_clk_pllv3"/opt/src/drivers/core/device-remove.cdevice-removeassert(drv)drivers/core/device-remove.c%s: Device '%s' failed child_post_remove()"%s: Device '%s' failed child_post_remove()"~DM_FLAG_ACTIVATED%s: Device '%s' failed to remove, but children are gone
"%s: Device '%s' failed to remove, but children are gone\n"%s: Device '%s' failed to post_probe on error path
"%s: Device '%s' failed to post_probe on error path\n"flags_removeDM_FLAG_ACTIVE_DMA | DM_FLAG_OS_PREPARE(DM_FLAG_ACTIVE_DMA | DM_FLAG_OS_PREPARE)/opt/src/drivers/coreerr_removedrv_flagsassert(dev)typeof(*pos)list_for_each_entry_safe(pos, n, &dev->child_head, sibling_node)pos->sibling_node.nextn->sibling_node.nexttypeof(*n)saved_ret/* We can't put the children back *//*
	 * Remove the device if called with the "normal" remove flag set,
	 * or if the remove flag matches any of the drivers remove flags
	 *//**
 * device_free() - Free memory buffers allocated by a device
 * @dev:	Device that is to be started
 *//*
 * Device manager
 *
 * Copyright (c) 2014 Google, Inc
 *
 * (C) Copyright 2012
 * Pavel Herrmann <morpheus.ibis@gmail.com>
 *//opt/src/include/dm/of_access.hof_accessof_get_stdoutof_alias_get_highest_idof_alias_get_idof_alias_scanof_count_phandle_with_argsof_parse_phandle_with_argsof_phandle_args *of_parse_phandleof_property_count_stringsof_property_read_string_indexof_property_read_string_helperof_property_match_stringof_read_u32_arrayof_read_u64of_read_u32of_find_node_by_phandleof_find_node_by_prop_valueof_find_compatible_nodeof_find_node_by_pathof_find_node_opts_by_pathof_get_parentof_device_is_availableof_device_is_compatibleof_get_propertyof_find_propertyof_simple_size_cellsof_simple_addr_cellsof_n_size_cellsof_n_addr_cellsof_node_putof_find_all_nodesof_node_get(x)for_each_of_allnodes(dn)for_each_of_allnodes_from(NULL, dn)for_each_of_allnodes_from(from,dn)for (dn = of_find_all_nodes(from); dn; dn = of_find_all_nodes(dn))_DM_OF_ACCESS_H/**
 * of_get_stdout() - Get node to use for stdout
 *
 * @return node referred to by stdout-path alias, or NULL if none
 *//**
 * of_alias_get_highest_id - Get highest alias id for the given stem
 * @stem:	Alias stem to be examined
 *
 * The function travels the lookup table to get the highest alias id for the
 * given alias stem.
 * @return alias ID, if found, else -1
 *//**
 * of_alias_get_id - Get alias id for the given device_node
 *
 * Travels the lookup table to get the alias id for the given device_node and
 * alias stem.
 *
 * @np:		Pointer to the given device_node
 * @stem:	Alias stem of the given device_node
 * @return alias ID, if found, else -ENODEV
 *//**
 * of_alias_scan() - Scan all properties of the 'aliases' node
 *
 * The function scans all the properties of the 'aliases' node and populates
 * the lookup table with the properties.  It returns the number of alias
 * properties found, or an error code in case of failure.
 *
 * @return 9 if OK, -ENOMEM if not enough memory
 *//**
 * of_count_phandle_with_args() - Count the number of phandle in a list
 *
 * @np:		pointer to a device tree node containing a list
 * @list_name:	property name that contains a list
 * @cells_name:	property name that specifies phandles' arguments count
 * @return number of phandle found, -ENOENT if
 *	@list_name does not exist, -EINVAL if a phandle was not found,
 *	@cells_name could not be found, the arguments were truncated or there
 *	were too many arguments.
 *
 * Returns number of phandle found on success, on error returns appropriate
 * errno value.
 *
 *//**
 * of_parse_phandle_with_args() - Find a node pointed by phandle in a list
 *
 * @np:		pointer to a device tree node containing a list
 * @list_name:	property name that contains a list
 * @cells_name:	property name that specifies phandles' arguments count
 * @index:	index of a phandle to parse out
 * @out_args:	optional pointer to output arguments structure (will be filled)
 * @return 0 on success (with @out_args filled out if not NULL), -ENOENT if
 *	@list_name does not exist, -EINVAL if a phandle was not found,
 *	@cells_name could not be found, the arguments were truncated or there
 *	were too many arguments.
 *
 * This function is useful to parse lists of phandles and their arguments.
 * Returns 0 on success and fills out_args, on error returns appropriate
 * errno value.
 *
 * Caller is responsible to call of_node_put() on the returned out_args->np
 * pointer.
 *
 * Example:
 *
 * phandle1: node1 {
 *	#list-cells = <2>;
 * }
 *
 * phandle2: node2 {
 *	#list-cells = <1>;
 * }
 *
 * node3 {
 *	list = <&phandle1 1 2 &phandle2 3>;
 * }
 *
 * To get a device_node of the `node2' node you may call this:
 * of_parse_phandle_with_args(node3, "list", "#list-cells", 1, &args);
 *//**
 * of_parse_phandle - Resolve a phandle property to a device_node pointer
 * @np: Pointer to device node holding phandle property
 * @phandle_name: Name of property holding a phandle value
 * @index: For properties holding a table of phandles, this is the index into
 *         the table
 *
 * Returns the device_node pointer with refcount incremented.  Use
 * of_node_put() on it when done.
 *//**
 * of_property_count_strings() - Find and return the number of strings from a
 * multiple strings property.
 * @np:		device node from which the property value is to be read.
 * @propname:	name of the property to be searched.
 *
 * Search for a property in a device tree node and retrieve the number of null
 * terminated string contain in it. Returns the number of strings on
 * success, -EINVAL if the property does not exist, -ENODATA if property
 * does not have a value, and -EILSEQ if the string is not null-terminated
 * within the length of the property data.
 *//**
 * of_property_read_string_index() - Find and read a string from a multiple
 * strings property.
 * @np:		device node from which the property value is to be read.
 * @propname:	name of the property to be searched.
 * @index:	index of the string in the list of strings
 * @out_string:	pointer to null terminated return string, modified only if
 *		return value is 0.
 *
 * Search for a property in a device tree node and retrieve a null
 * terminated string value (pointer to data, not a copy) in the list of strings
 * contained in that property.
 * Returns 0 on success, -EINVAL if the property does not exist, -ENODATA if
 * property does not have a value, and -EILSEQ if the string is not
 * null-terminated within the length of the property data.
 *
 * The out_string pointer is modified only if a valid string can be decoded.
 *//**
 * of_property_match_string() - Find string in a list and return index
 *
 * This function searches a string list property and returns the index
 * of a specific string value.
 *
 * @np: pointer to node containing string list property
 * @propname: string list property name
 * @string: pointer to string to search for in string list
 * @return 0 on success, -EINVAL if the property does not exist, -ENODATA
 * if property does not have a value, and -EOVERFLOW is longer than sz.
 *//**
 * of_read_u32_array() - Find and read an array of 32 bit integers
 *
 * Search for a property in a device node and read 32-bit value(s) from
 * it.
 *
 * @np:		device node from which the property value is to be read.
 * @propname:	name of the property to be searched.
 * @out_values:	pointer to return value, modified only if return value is 0.
 * @sz:		number of array elements to read
 * @return 0 on success, -EINVAL if the property does not exist, -ENODATA
 * if property does not have a value, and -EOVERFLOW is longer than sz.
 *//**
 * of_read_u64() - Find and read a 64-bit integer from a property
 *
 * Search for a property in a device node and read a 64-bit value from
 * it.
 *
 * @np:		device node from which the property value is to be read.
 * @propname:	name of the property to be searched.
 * @outp:	pointer to return value, modified only if return value is 0.
 *
 * @return 0 on success, -EINVAL if the property does not exist,
 * -ENODATA if property does not have a value, and -EOVERFLOW if the
 * property data isn't large enough.
 *//**
 * of_read_u32() - Find and read a 32-bit integer from a property
 *
 * Search for a property in a device node and read a 32-bit value from
 * it.
 *
 * @np:		device node from which the property value is to be read.
 * @propname:	name of the property to be searched.
 * @outp:	pointer to return value, modified only if return value is 0.
 *
 * @return 0 on success, -EINVAL if the property does not exist,
 * -ENODATA if property does not have a value, and -EOVERFLOW if the
 * property data isn't large enough.
 *//**
 * of_find_node_by_phandle() - Find a node given a phandle
 *
 * @handle:	phandle of the node to find
 *
 * @return node pointer, or NULL if not found
 *//**
 * of_find_node_by_prop_value() - find a node with a given property value
 *
 * Find a node based on a property value.
 * @from: Node to start searching from or NULL. the node you pass will not be
 *	searched, only the next one will; typically, you pass what the previous
 *	call returned.
 * @propname: property name to check
 * @propval: property value to search for
 * @proplen: length of the value in propval
 * @return node pointer or NULL if not found
 *//**
 * of_find_compatible_node() - find a node based on its compatible string
 *
 * Find a node based on type and one of the tokens in its "compatible" property
 * @from: Node to start searching from or NULL. the node you pass will not be
 *	searched, only the next one will; typically, you pass what the previous
 *	call returned.
 * @type: The type string to match "device_type" or NULL to ignore
 * @compatible:	The string to match to one of the tokens in the device
 *	"compatible" list.
 * @return node pointer or NULL if not found
 *//**
 * of_find_node_opts_by_path() - Find a node matching a full OF path
 *
 * @path: Either the full path to match, or if the path does not start with
 *	'/', the name of a property of the /aliases node (an alias). In the
 *	case of an alias, the node matching the alias' value will be returned.
 * @opts: Address of a pointer into which to store the start of an options
 *	string appended to the end of the path with a ':' separator. Can be NULL
 *
 * Valid paths:
 *	/foo/bar	Full path
 *	foo		Valid alias
 *	foo/bar		Valid alias + relative path
 *
 * @return a node pointer or NULL if not found
 *//**
 * of_get_parent() - Get a node's parent, if any
 *
 * @node: Node to check
 * @eturns a node pointer, or NULL if none
 *//**
 * of_device_is_available() - check if a device is available for use
 *
 * @device: Node to check for availability
 *
 * @return true if the status property is absent or set to "okay", false
 * otherwise
 *//**
 * of_device_is_compatible() - Check if the node matches given constraints
 * @device: pointer to node
 * @compat: required compatible string, NULL or "" for any match
 * @type: required device_type value, NULL or "" for any match
 * @name: required node name, NULL or "" for any match
 *
 * Checks if the given @compat, @type and @name strings match the
 * properties of the given @device. A constraints can be skipped by
 * passing NULL or an empty string as the constraint.
 *
 * @return 0 for no match, and a positive integer on match. The return
 * value is a relative score with larger values indicating better
 * matches. The score is weighted for the most specific compatible value
 * to get the highest score. Matching type is next, followed by matching
 * name. Practically speaking, this results in the following priority
 * order for matches:
 *
 * 1. specific compatible && type && name
 * 2. specific compatible && type
 * 3. specific compatible && name
 * 4. specific compatible
 * 5. general compatible && type && name
 * 6. general compatible && type
 * 7. general compatible && name
 * 8. general compatible
 * 9. type && name
 * 10. type
 * 11. name
 *//**
 * of_get_property() - get a property value
 *
 * Find a property with a given name for a given node and return the value.
 *
 * @np: Pointer to device node holding property
 * @name: Name of property
 * @lenp: If non-NULL, returns length of property
 * @return pointer to property value, or NULL if not found
 *//**
 * of_find_property() - find a property in a node
 *
 * @np: Pointer to device node holding property
 * @name: Name of property
 * @lenp: If non-NULL, returns length of property
 * @return pointer to property, or NULL if not found
 *//**
 * of_simple_size_cells() - Get the size cells property in a node
 *
 * This function matches fdt_size_cells().
 *
 * @np: Node pointer to check
 * @return value of #size-cells property in this node, or 2 if none
 *//**
 * of_simple_addr_cells() - Get the address cells property in a node
 *
 * This function matches fdt_address_cells().
 *
 * @np: Node pointer to check
 * @return value of #address-cells property in this node, or 2 if none
 *//**
 * of_n_size_cells() - Get the number of size cells for a node
 *
 * This walks back up the tree to find the closest #size-cells property
 * which controls the given node.
 *
 * @np: Node pointer to check
 * @return number of size cells this node uses
 *//**
 * of_n_addr_cells() - Get the number of address cells for a node
 *
 * This walks back up the tree to find the closest #address-cells property
 * which controls the given node.
 *
 * @np: Node pointer to check
 * @return number of address cells this node uses
 *//* Dummy functions to mirror Linux. These are not used in U-Boot *//**
 * of_find_all_nodes - Get next node in global list
 * @prev:	Previous node or NULL to start iteration
 *		of_node_put() will be called on it
 *
 * Returns a node pointer with refcount incremented, use
 * of_node_put() on it when done.
 *//*
 * Originally from Linux v4.9
 * Copyright (C) 1996-2005 Paul Mackerras.
 *
 * Updates for PPC64 by Peter Bergner & David Engebretsen, IBM Corp.
 * Updates for SPARC64 by David S. Miller
 * Derived from PowerPC and Sparc prom.h files by Stephen Rothwell, IBM Corp.
 *
 * Copyright (c) 2017 Google, Inc
 * Written by Simon Glass <sjg@chromium.org>
 *
 * Modified for U-Boot
 * Copyright (c) 2017 Google, Inc
 */phandle_nameout_strs/opt/src/include/power-domain.hpower-domainpower_domain_offpower_domain *power_domain_onpower_domain_freepower_domain_get_by_indexpower_domain_getpower_domain_POWER_DOMAIN_HCONFIG_IS_ENABLED(POWER_DOMAIN)POWER_DOMAINCONFIG_VAL(POWER_DOMAIN)CONFIG_VAL(POWER_DOMAIN_MODULE)CONFIG_POWER_DOMAIN_MODULE__ARG_PLACEHOLDER_CONFIG_POWER_DOMAIN_MODULE__ARG_PLACEHOLDER_CONFIG_POWER_DOMAIN_MODULE 1POWER_DOMAIN_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_POWER_DOMAIN_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_POWER_DOMAINCONFIG_POWER_DOMAIN/**
 * power_domain_off - Disable power to a power domain.
 *
 * @power_domain:	A power domain struct that was previously successfully
 *		requested by power_domain_get().
 * @return 0 if OK, or a negative error code.
 *//**
 * power_domain_on - Enable power to a power domain.
 *
 * @power_domain:	A power domain struct that was previously successfully
 *		requested by power_domain_get().
 * @return 0 if OK, or a negative error code.
 *//**
 * power_domain_free - Free a previously requested power domain.
 *
 * @power_domain:	A power domain struct that was previously successfully
 *		requested by power_domain_get().
 * @return 0 if OK, or a negative error code.
 *//**
 * power_domain_get_by_index - Get the indexed power domain for a device.
 *
 * @dev:		The client device.
 * @power_domain:	A pointer to a power domain struct to initialize.
 * @index:		Power domain index to be powered on.
 *
 * @return 0 if OK, or a negative error code.
 *//**
 * power_domain_get - Get/request the power domain for a device.
 *
 * This looks up and requests a power domain. Each device is assumed to have
 * a single (or, at least one) power domain associated with it somehow, and
 * that domain, or the first/default domain. The mapping of client device to
 * provider power domain may be via device-tree properties, board-provided
 * mapping tables, or some other mechanism.
 *
 * @dev:	The client device.
 * @power_domain	A pointer to a power domain struct to initialize.
 * @return 0 if OK, or a negative error code.
 *//**
 * struct power_domain - A handle to (allowing control of) a single power domain.
 *
 * Clients provide storage for power domain handles. The content of the
 * structure is managed solely by the power domain API and power domain
 * drivers. A power domain struct is initialized by "get"ing the power domain
 * struct. The power domain struct is passed to all other power domain APIs to
 * identify which power domain to operate upon.
 *
 * @dev: The device which implements the power domain.
 * @id: The power domain ID within the provider.
 * @priv: Private data corresponding to each power domain.
 *//**
 * A power domain is a portion of an SoC or chip that is powered by a
 * switchable source of power. In many cases, software has control over the
 * power domain, and can turn the power source on or off. This is typically
 * done to save power by powering off unused devices, or to enable software
 * sequencing of initial powerup at boot. This API provides a means for
 * drivers to turn power domains on and off.
 *
 * A driver that implements UCLASS_POWER_DOMAIN is a power domain controller or
 * provider. A controller will often implement multiple separate power domains,
 * since the hardware it manages often has this capability.
 * power-domain-uclass.h describes the interface which power domain controllers
 * must implement.
 *
 * Depending on the power domain controller hardware, changing the state of a
 * power domain may require performing related operations on other resources.
 * For example, some power domains may require certain clocks to be enabled
 * whenever the power domain is powered on, or during the time when the power
 * domain is transitioning state. These details are implementation-specific
 * and should ideally be encapsulated entirely within the provider driver, or
 * configured through mechanisms (e.g. device tree) that do not require client
 * drivers to provide extra configuration information.
 *
 * Power domain consumers/clients are the drivers for HW modules within the
 * power domain. This header file describes the API used by those drivers.
 *
 * In many cases, a single complex IO controller (e.g. a PCIe controller) will
 * be the sole logic contained within a power domain. In such cases, it is
 * logical for the relevant device driver to directly control that power
 * domain. In other cases, multiple controllers, each with their own driver,
 * may be contained in a single power domain. Any logic require to co-ordinate
 * between drivers for these multiple controllers is beyond the scope of this
 * API at present. Equally, this API does not define or implement any policy
 * by which power domains are managed.
 *//opt/src/drivers/core/device.c&gd->uclass_root(&gd->uclass_root)->nexttypeof(*uc)list_for_each_entry(uc, &gd->uclass_root, sibling_node)uc->sibling_node.next&parent->child_head(&parent->child_head)->nextlist_for_each_entry(dev, &parent->child_head, sibling_node)<power-domain.h><dm/of_access.h>dev->sibling_node.nextstruct udevicelist_entry(dev->sibling_node.next, struct udevice,
				   sibling_node)list_first_entry(&parent->child_head, struct udevice,
					 sibling_node)_device_find_global_by_ofnodedevice_find_by_ofnodedevice_get_device_tail%s: null device
"%s: null device\n"drivers/core/device.cUCLASS_POWER_DOMAINpd%s: Device '%s' failed to remove on error path
"%s: Device '%s' failed to remove on error path\n"alloc_privROUND(size, ARCH_DMA_MINALIGN)platdata_sizedevice_bind_common"Missing uclass for driver %s\n"debug("Missing uclass for driver %s\n", drv->name)fail_uclassof_platdata_sizeMissing uclass for driver %s
sizeof(struct udevice)DM_SEQ_ALIASCONFIG_VAL(DM_SEQ_ALIAS)CONFIG_IS_ENABLED(DM_SEQ_ALIAS)CONFIG_VAL(DM_SEQ_ALIAS_MODULE)CONFIG_DM_SEQ_ALIAS_MODULE__ARG_PLACEHOLDER_CONFIG_DM_SEQ_ALIAS_MODULEDM_SEQ_ALIAS_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_DM_SEQ_ALIAS_MODULE__ARG_PLACEHOLDER_CONFIG_DM_SEQ_ALIAS_MODULE 1__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_DM_SEQ_ALIASCONFIG_DM_SEQ_ALIASCONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)"Bound device %s to %s\n"dev->name, parent->namepr_fmt("Bound device %s to %s\n")pr_debug("Bound device %s to %s\n", dev->name, parent->name)Bound device %s to %s
unbind() method failed on dev '%s' on error path
"unbind() method failed on dev '%s' on error path\n"Failed to unbind dev '%s' on error path
"Failed to unbind dev '%s' on error path\n"CONFIG_MICROBLAZE/*
		 * We didn't find it in probed devices. See if there is one
		 * that will request this seq if probed.
		 *//**
 * device_find_by_ofnode() - Return device associated with given ofnode
 *
 * The returned device is *not* activated.
 *
 * @node: The ofnode for which a associated device should be looked up
 * @devp: Pointer to structure to hold the found device
 * Return: 0 if OK, -ve on error
 *//*
		 * Process 'assigned-{clocks/clock-parents/clock-rates}'
		 * properties
		 *//* Only handle devices that have a valid ofnode *//*
	 * Process pinctrl for everything except the root device, and
	 * continue regardless of the result of pinctrl. Don't process pinctrl
	 * settings for pinctrl devices since the device may not yet be
	 * probed.
	 *//*
		 * The device might have already been probed during
		 * the call to device_probe() on its parent device
		 * (e.g. PCI bridge devices). Test the flags again
		 * so that we don't mess up the device.
		 *//* Ensure all parents are probed *//* Allocate private data if requested and not reentered *//*
			 * Ensure that the zero bytes are flushed to memory.
			 * This prevents problems if the driver uses this as
			 * both an input and an output buffer:
			 *
			 * 1. Zeroes written to buffer (here) and sit in the
			 *	cache
			 * 2. Driver issues a read command to DMA
			 * 3. CPU runs out of cache space and evicts some cache
			 *	data in the buffer, writing zeroes to RAM from
			 *	the memset() above
			 * 4. DMA completes
			 * 5. Buffer now has some DMA data and some zeroes
			 * 6. Data being read is now incorrect
			 *
			 * To prevent this, ensure that the cache is clean
			 * within this range at the start. The driver can then
			 * use normal flush-after-write, invalidate-before-read
			 * procedures.
			 *
			 * TODO(sjg@chromium.org): Drop this microblaze
			 * exception.
			 *//* There is no child unbind() method, so no clean-up required *//* if we fail to bind we remove device from successors and free it *//* put dev into parent's successor list *//*
		 * Some devices, such as a SPI bus, I2C bus and serial ports
		 * are numbered using aliases.
		 *
		 * This is just a 'requested' sequence, and will be
		 * resolved (and ->seq updated) when the device is probed.
		 *//*
 * Device manager
 *
 * Copyright (c) 2013 Google, Inc
 *
 * (C) Copyright 2012
 * Pavel Herrmann <morpheus.ibis@gmail.com>
 */fail_alloc1fail_alloc2fail_alloc3fail_uclass_bindfail_bindfail_child_post_bindfail_uclass_post_bind/opt/src/drivers/core/devres.cWARN_ON(rc)drivers/core/devres.cdevm_kmalloc_release!dataunlikely(!data)devm_kmalloc_matchdump_resources- %s
"- %s\n"dr&dev->devres_headdevres *    %p (%lu byte) %s  %s
"    %p (%lu byte) %s  %s\n"PROBE"PROBE"BIND"BIND"(&dev->devres_head)->nexttypeof(*dr)list_for_each_entry(dr, &dev->devres_head, entry)dr->entry.nexttypeof(*child)list_for_each_entry(child, &dev->child_head, sibling_node)child->sibling_node.nextrelease_nodesREL"REL"(head)->prevlist_for_each_entry_safe_reverse(dr, tmp, head, entry)dr->entry.prevtmp->entry.prevprobe_only!resunlikely(!res)const unsigned long longconst unsigned long long[]const unsigned long long(*)[]unsigned long long(*)[]struct devrescontainer_of(res, struct devres, data)REM"REM"new_drcontainer_of(new_res, struct devres, data)(&dev->devres_head)->prevlist_for_each_entry_reverse(dr, &dev->devres_head, entry)ADD"ADD"!list_empty(&dr->entry)BUG_ON(!list_empty(&dr->entry))"BUG at %s:%d/%s()!\n"BUG at %s:%d/%s()!
BUG!tot_sizesizeof(struct devres)!drunlikely(!dr)devres_log%s: DEVRES %3s %p %s (%lu bytes)
"%s: DEVRES %3s %p %s (%lu bytes)\n"set_node_dbginfo/* noop *//*
 * Managed kmalloc/kfree
 *//* CONFIG_DEBUG_DEVRES *//**
 * struct devres - Bookkeeping info for managed device resource
 * @entry: List to associate this structure with a device
 * @release: Callback invoked when this resource is released
 * @probe: Flag to show when this resource was allocated
	   (true = probe, false = bind)
 * @name: Name of release function
 * @size: Size of resource data
 * @data: Resource data
 *//*
 * Copyright (C) 2015 Masahiro Yamada <yamada.masahiro@socionext.com>
 *
 * Based on the original work in Linux by
 * Copyright (c) 2006  SUSE Linux Products GmbH
 * Copyright (c) 2006  Tejun Heo <teheo@suse.de>
 *//opt/src/drivers/core/dump.cuclass %d: %s
"uclass %d: %s\n"dm_display_line%i %c %s @ %08lx"%i %c %s @ %08lx", seq %d, (req %d)", seq %d, (req %d)" Class     Index  Probed  Driver                Name
" Class     Index  Probed  Driver                Name\n"-----------------------------------------------------------
"-----------------------------------------------------------\n"show_devices %-10.10s  %2d  [ %c ]   %-20.20s  " %-10.10s  %2d  [ %c ]   %-20.20s  "|   "|   "`-- "`-- "|-- "|-- "/**
 * dm_display_line() - Display information about a single device
 *
 * Displays a single line of information with an option prefix
 *
 * @dev:	Device to display
 *//* print the first 20 characters to not break the tree-format. */last_flag/opt/src/drivers/core/fdtaddr.creg-names"reg-names"OF_TRANSLATECONFIG_VAL(OF_TRANSLATE)CONFIG_IS_ENABLED(OF_TRANSLATE)CONFIG_VAL(OF_TRANSLATE_MODULE)CONFIG_OF_TRANSLATE_MODULE__ARG_PLACEHOLDER_CONFIG_OF_TRANSLATE_MODULEOF_TRANSLATE_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_OF_TRANSLATE_MODULE__ARG_PLACEHOLDER_CONFIG_OF_TRANSLATE_MODULE 1__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_OF_TRANSLATECONFIG_OF_TRANSLATE"bad #address-cells\n"debug("bad #address-cells\n")drivers/core/fdtaddr.cbad #address-cells
"bad #size-cells\n"debug("bad #size-cells\n")bad #size-cells
sizeof(fdt32_t)"Req index out of range\n"debug("Req index out of range\n")Req index out of range
SIMPLE_BUSCONFIG_VAL(SIMPLE_BUS)CONFIG_IS_ENABLED(SIMPLE_BUS)CONFIG_VAL(SIMPLE_BUS_MODULE)CONFIG_SIMPLE_BUS_MODULE__ARG_PLACEHOLDER_CONFIG_SIMPLE_BUS_MODULESIMPLE_BUS_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_SIMPLE_BUS_MODULE__ARG_PLACEHOLDER_CONFIG_SIMPLE_BUS_MODULE 1__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_SIMPLE_BUSCONFIG_SIMPLE_BUSUCLASS_SIMPLE_BUS/*
	 * Get the base address via the existing function which handles
	 * all Kconfig cases
	 *//*
	 * Only get the size in this first call. We'll get the addr in the
	 * next call to the exisiting dev_get_xxx function which handles
	 * all config options.
	 *//*
	 * Some platforms need a special address translation. Those
	 * platforms (e.g. mvebu in SPL) can configure a translation
	 * offset by setting this value in the GD and enaling this
	 * feature via CONFIG_TRANSLATION_OFFSET. This value will
	 * get added to all addresses returned by devfdt_get_addr().
	 *//*
		 * Use the "simple" translate function for less complex
		 * bus setups.
		 *//* Non translatable if #size-cells == 0 *//*
			 * Use the full-fledged translate function for complex
			 * bus setups.
			 *//*
 * Device addresses
 *
 * Copyright (c) 2017 Google, Inc
 *
 * (C) Copyright 2012
 * Pavel Herrmann <morpheus.ibis@gmail.com>
 *//opt/src/drivers/core/lists.c"bind node %s\n"pr_fmt("bind node %s\n")pr_debug("bind node %s\n", name)bind node %s
compat_listcompat_length"Device '%s' has no compatible string\n"pr_fmt("Device '%s' has no compatible string\n")pr_debug("Device '%s' has no compatible string\n",
				 name)Device '%s' has no compatible string
Device tree error at node '%s'
"Device tree error at node '%s'\n""   - attempt to match compatible string '%s'\n"pr_fmt("   - attempt to match compatible string '%s'\n")pr_debug("   - attempt to match compatible string '%s'\n",
			 compat)   - attempt to match compatible string '%s'
ll_entry_start(struct driver, driver).u_boot_list_2_driver_1ll_entry_count(struct driver, driver).u_boot_list_2_driver_3const udevice_id **udevice_id **"   - found match at '%s'\n"entry->namepr_fmt("   - found match at '%s'\n")pr_debug("   - found match at '%s'\n", entry->name)   - found match at '%s'
"Driver '%s' refuses to bind\n"pr_fmt("Driver '%s' refuses to bind\n")pr_debug("Driver '%s' refuses to bind\n", entry->name)Driver '%s' refuses to bind
Error binding driver '%s': %d
"Error binding driver '%s': %d\n""No match for node '%s'\n"pr_fmt("No match for node '%s'\n")pr_debug("No match for node '%s'\n", name)No match for node '%s'
driver_check_compatibledebug("Cannot find driver '%s'\n", drv_name)of_idpdrivers/core/lists.cll_entry_start(struct driver_info, driver_info).u_boot_list_2_driver_info_1ll_entry_count(struct driver_info, driver_info).u_boot_list_2_driver_info_3No match for driver '%s'
"No match for driver '%s'\n"ll_entry_start(struct uclass_driver, uclass).u_boot_list_2_uclass_1ll_entry_count(struct uclass_driver, uclass).u_boot_list_2_uclass_3/*
	 * Walk through the compatible string list, attempting to match each
	 * compatible string in order such that we match in order of priority
	 * from the first string to the last.
	 *//**
 * driver_check_compatible() - Check if a driver matches a compatible string
 *
 * @param of_match:	List of compatible strings to match
 * @param of_idp:	Returns the match that was found
 * @param compat:	The compatible string to search for
 * @return 0 if there is a match, -ENOENT if no match
 *//opt/src/include/linux/ioport.hioportwalk_system_ram_rangeiomem_is_exclusiveiomem_map_sanity_check__devm_release_region__devm_request_regioncheck_region__release_region__check_region__request_regionconst resourceconst resource *3840IORESOURCE_TYPE_BITSresource_sizeresource_alignmentadjust_resourceallocate_resourceinsert_resource_expand_to_fitinsert_resourcereserve_region_with_splitrelease_resourcerequest_resourceresource_listpci_devpci_dev *resource_list *devm_release_mem_region(dev,start,n)__devm_release_region(dev, &iomem_resource, (start), (n))devm_release_region(dev,start,n)__devm_release_region(dev, &ioport_resource, (start), (n))devm_request_mem_region(dev,start,n,name)__devm_request_region(dev, &iomem_resource, (start), (n), (name))devm_request_region(dev,start,n,name)__devm_request_region(dev, &ioport_resource, (start), (n), (name))release_mem_region(start,n)__release_region(&iomem_resource, (start), (n))check_mem_region(start,n)__check_region(&iomem_resource, (start), (n))release_region(start,n)__release_region(&ioport_resource, (start), (n))rename_region(region,newname)do { (region)->name = (newname); } while (0)request_mem_region_exclusive(start,n,name)__request_region(&iomem_resource, (start), (n), (name), IORESOURCE_EXCLUSIVE)request_mem_region(start,n,name)__request_region(&iomem_resource, (start), (n), (name), 0)__request_mem_region(start,n,name,excl)__request_region(&iomem_resource, (start), (n), (name), excl)request_region(start,n,name)__request_region(&ioport_resource, (start), (n), (name), 0)IORESOURCE_PCI_FIXED(1<<4)IORESOURCE_ROM_BIOS_COPYIORESOURCE_ROM_COPYIORESOURCE_ROM_SHADOWIORESOURCE_ROM_ENABLEIORESOURCE_IO_FIXEDIORESOURCE_IO_16BIT_ADDRIORESOURCE_MEM_EXPANSIONROM(1<<6)IORESOURCE_MEM_SHADOWABLE(1<<5)IORESOURCE_MEM_32BIT(3<<3)IORESOURCE_MEM_8AND16BIT(2<<3)IORESOURCE_MEM_16BITIORESOURCE_MEM_8BIT(0<<3)IORESOURCE_MEM_TYPE_MASKIORESOURCE_MEM_RANGELENGTHIORESOURCE_MEM_CACHEABLEIORESOURCE_MEM_WRITEABLEIORESOURCE_DMA_TYPEF(3<<6)IORESOURCE_DMA_TYPEB(2<<6)IORESOURCE_DMA_TYPEAIORESOURCE_DMA_COMPATIBLE(0<<6)IORESOURCE_DMA_SPEED_MASKIORESOURCE_DMA_WORDIORESOURCE_DMA_BYTEIORESOURCE_DMA_MASTERIORESOURCE_DMA_16BIT(2<<0)IORESOURCE_DMA_8AND16BITIORESOURCE_DMA_8BIT(0<<0)IORESOURCE_DMA_TYPE_MASK(3<<0)IORESOURCE_IRQ_OPTIONALIORESOURCE_IRQ_SHAREABLEIORESOURCE_IRQ_LOWLEVELIORESOURCE_IRQ_HIGHLEVELIORESOURCE_IRQ_LOWEDGEIORESOURCE_IRQ_HIGHEDGEIORESOURCE_BUSYIORESOURCE_AUTOIORESOURCE_UNSETIORESOURCE_DISABLEDIORESOURCE_EXCLUSIVEIORESOURCE_MEM_64IORESOURCE_STARTALIGNIORESOURCE_SIZEALIGNIORESOURCE_SHADOWABLEIORESOURCE_RANGELENGTHIORESOURCE_CACHEABLEIORESOURCE_READONLYIORESOURCE_PREFETCHIORESOURCE_DMAIORESOURCE_IRQIORESOURCE_MEMIORESOURCE_IO0x00000f00IORESOURCE_BITS0x000000ff_LINUX_IOPORT_Hiomem_resourceioport_resource/* _LINUX_IOPORT_H *//* Wrappers for managed devices *//* Compatibility cruft *//* Convenience shorthand with allocation *//* PC/ISA/whatever - the normal PC address spaces: IO and memory *//* Do not move resource *//* PCI control bits.  Shares IORESOURCE_BITS with above PCI ROM.  *//* ROM is BIOS copy, resource field overlaid *//* ROM is alloc'd copy, resource field overlaid *//* ROM is copy at C000:0 *//* ROM is enabled, same as PCI_ROM_ADDRESS_ENABLE *//* PCI ROM control bits (IORESOURCE_BITS) *//* PnP I/O specific bits (IORESOURCE_BITS) *//* dup: IORESOURCE_SHADOWABLE *//* dup: IORESOURCE_RANGELENGTH *//* dup: IORESOURCE_CACHEABLE *//* dup: IORESOURCE_READONLY *//* PnP memory I/O specific bits (IORESOURCE_BITS) *//* PnP DMA specific bits (IORESOURCE_BITS) *//* PnP IRQ specific bits (IORESOURCE_BITS) *//* Driver has marked this resource busy *//* Userland may not map this resource *//* start field is alignment *//* size indicates alignment *//* No side effects *//* Resource type *//* Bus-specific bits *//*
 * IO resources have these defined flags.
 *//*
 * Resources are tree-like, allowing
 * nesting etc..
 *//*
 * ioport.h	Definitions of routines for detecting, reserving and
 *		allocating system resources.
 *
 * Authors:	Linus Torvalds
 */start_pfnnr_pagesalignfalignf_data/opt/src/drivers/core/of_access.capp&aliases_lookupalias_prop *(&aliases_lookup)->nexttypeof(*app)list_for_each_entry(app, &aliases_lookup, link)app->link.next&of_mutex/chosen"/chosen"/chosen@0"/chosen@0"stdout-path"stdout-path"ppof_aliasesfor_each_property_of_node(of_aliases, pp)*(end-1)isdigit(*(end-1))sizeof(*ap)of_alias_add<linux/ioport.h>stem_len"adding DT alias:%s: stem=%s id=%i node=%s\n"ap->alias, ap->stem, ap->id, of_node_full_name(np)debug("adding DT alias:%s: stem=%s id=%i node=%s\n",
	      ap->alias, ap->stem, ap->id, of_node_full_name(np))drivers/core/of_access.c730adding DT alias:%s: stem=%s id=%i node=%s
__of_parse_phandle_with_argslist_endcur_index"%s: could not find phandle\n"np->full_namedebug("%s: could not find phandle\n",
					      np->full_name)614%s: could not find phandle
"%s: could not get %s for %s\n"np->full_name, cells_name, node->full_namedebug("%s: could not get %s for %s\n",
					      np->full_name, cells_name,
					      node->full_name)623%s: could not get %s for %s
"%s: arguments longer than property\n"debug("%s: arguments longer than property\n",
				      np->full_name)%s: arguments longer than property
count > OF_MAX_PHANDLE_ARGScount > 16WARN_ON(count > OF_MAX_PHANDLE_ARGS)654const propertyconst property *EILSEQ-84-EILSEQ"comparing %s with %s\n"string, pdebug("comparing %s with %s\n", string, p)comparing %s with %s
"%s: %s: "__func__, propnamedebug("%s: %s: ", __func__, propname)%s: %s: const __be64const __be64 *sizeof(*outp)"(not found)\n"debug("(not found)\n")(not found)
"%#llx (%lld)\n"(unsigned long long)*outp, (unsigned long long)*outpdebug("%#llx (%lld)\n", (unsigned long long)*outp,
              (unsigned long long)*outp)skip%#llx (%lld)
sizeof(*out_values)"size %zd\n"debug("size %zd\n", sz)size %zd
"%#x (%d)\n"*outp, *outpdebug("%#x (%d)\n", *outp, *outp)463%#x (%d)
of_find_property_value_of_sizeEOVERFLOW-75-EOVERFLOWfor_each_of_allnodes(np)of_device_has_prop_valuegd->of_root__of_find_node_by_path/:"/:"__for_each_child_of_node(parent, child)__of_get_next_childnode->parentstatlenstrlen(compat)scoreINT_MAXINT_MAX/2device->typedevice->nameof_prop_next_stringcurvalias_propof_stdout_optionsof_stdoutof_chosenaliases_lookupfor_each_property_of_node(dn,pp)for (pp = dn->properties; pp != NULL; pp = pp->next)__for_each_child_of_node(parent,child)for (child = __of_get_next_child(parent, NULL); child != NULL; child = __of_get_next_child(parent, child))/* Allocate an alias_prop with enough space for the stem *//*
		 * walk the alias backwards to extract the id and work out
		 * the 'stem' string
		 *//* Skip those we do not want to proceed *//*
	 * Unlock node before returning result; will be one of:
	 * -ENOENT : index is for empty phandle
	 * -EINVAL : parsing error on data
	 * [1..n]  : Number of phandle (count mode; when index = -1)
	 *//* Found it! return success *//*
		 * All of the error cases above bail out of the loop, so at
		 * this point, the parsing is successful. If the requested
		 * index matches, then fill the out_args structure and return,
		 * or return -ENOENT for an empty entry.
		 *//*
			 * Make sure that the arguments actually fit in the
			 * remaining property data length
			 *//*
			 * Find the provider node and parse the #*-cells
			 * property to determine the argument length.
			 *
			 * This is not needed if the cell count is hard-coded
			 * (i.e. cells_name not set, but cell_count is set),
			 * except when we're going to return the found node
			 * below.
			 *//*
		 * If phandle is 0, then it is an empty entry with no
		 * arguments.  Skip forward to the next entry.
		 *//* Loop over the phandles until all the requested entry is found *//* Retrieve the phandle list property *//**
 * of_property_read_string_helper() - Utility helper for parsing string properties
 * @np:		device node from which the property value is to be read.
 * @propname:	name of the property to be searched.
 * @out_strs:	output array of string pointers.
 * @sz:		number of array elements to read.
 * @skip:	Number of strings to skip over at beginning of list.
 *
 * Don't call this function directly. It is a utility helper for the
 * of_property_read_string*() family of functions.
 *//* Found it; return index *//**
 * of_find_property_value_of_size() - find property of given size
 *
 * Search for a property in a device node and validate the requested size.
 *
 * @np:		device node from which the property value is to be read.
 * @propname:	name of the property to be searched.
 * @len:	requested length of property value
 *
 * @return the property value on success, -EINVAL if the property does not
 * exist, -ENODATA if property does not have a value, and -EOVERFLOW if the
 * property data isn't large enough.
 *//* Increment past '/' delimiter *//* Step down the tree matching path components *//* of_aliases must not be NULL *//* The path could begin with an alias *//*
	 * coverity[dead_error_line : FALSE]
	 * Dead code here since our current implementation of of_node_get()
	 * always returns NULL (Coverity CID 163245). But we leave it as is
	 * since we may want to implement get/put later.
	 *//* Matching name is a bit better than not *//* Matching type is better than matching name *//* Compatible match has highest priority *//* Might be null at the end of the tree *//*
		 * Walk back up looking for a sibling, or the end of the
		 * structure
		 *//* Return a default of 2 to match fdt_size_cells()*//* Return a default of 2 to match fdt_address_cells()*//* No #size-cells property for the root node *//* No #address-cells property for the root node *//**
 * struct alias_prop - Alias property in 'aliases' node
 *
 * The structure represents one alias property of 'aliases' node as
 * an entry in aliases_lookup list.
 *
 * @link:	List node to link the structure in aliases_lookup list
 * @alias:	Alias property name
 * @np:		Pointer to device_node that the alias stands for
 * @id:		Index value from end of alias name
 * @stem:	Alias string without the index
 *//* pointer to options given after the alias (separated by :) or NULL if none *//* node pointed to by the stdout-path alias *//* "/chosen" node *//* "/aliaes" node *//* list of struct alias_prop aliases *//*
 * Originally from Linux v4.9
 * Paul Mackerras	August 1996.
 * Copyright (C) 1996-2005 Paul Mackerras.
 *
 * Adapted for 64bit PowerPC by Dave Engebretsen and Peter Bergner.
 *   {engebret|bergner}@us.ibm.com
 *
 * Adapted for sparc and sparc64 by David S. Miller davem@davemloft.net
 *
 * Reconsolidated from arch/x/kernel/prom.c by Stephen Rothwell and
 * Grant Likely.
 *
 * Modified for U-Boot
 * Copyright (c) 2017 Google, Inc
 *
 * This file follows drivers/of/base.c with functions in the same order as the
 * Linux version.
 *//opt/src/drivers/core/of_addr.cof_addrof_address_to_resource__of_address_to_resourceIORESOURCE_IO | IORESOURCE_MEM(IORESOURCE_IO | IORESOURCE_MEM)taddrsizeof(struct resource)of_translate_dma_addressof_translate_address"** translation for device %s **\n"of_node_full_name(dev)debug("** translation for device %s **\n", of_node_full_name(dev))drivers/core/of_addr.c** translation for device %s **
"Bad cell count for %s\n"debug("Bad cell count for %s\n", of_node_full_name(dev))Bad cell count for %s
__be32[4]__be32 *"bus is %s (na=%d, ns=%d) on %s\n"bus->name, na, ns, of_node_full_name(parent)debug("bus is %s (na=%d, ns=%d) on %s\n", bus->name, na, ns,
	      of_node_full_name(parent))bus is %s (na=%d, ns=%d) on %s
/opt/src/include/dm/of_addr.h<dm/of_addr.h>translating address:"translating address:""reached root node\n"debug("reached root node\n")reached root node
debug("Bad cell count for %s\n",
			      of_node_full_name(dev))"parent bus is %s (na=%d, ns=%d) on %s\n"pbus->name, pna, pns, of_node_full_name(parent)debug("parent bus is %s (na=%d, ns=%d) on %s\n", pbus->name,
		      pna, pns, of_node_full_name(parent))parent bus is %s (na=%d, ns=%d) on %s
one level translation:"one level translation:""no ranges; cannot translate\n"debug("no ranges; cannot translate\n")no ranges; cannot translate
"empty ranges; 1:1 translation\n"debug("empty ranges; 1:1 translation\n")empty ranges; 1:1 translation
"walking ranges...\n"debug("walking ranges...\n")walking ranges...
"not found !\n"debug("not found !\n")not found !
parent translation for:"parent translation for:""with offset: %llx\n"(unsigned long long)offsetdebug("with offset: %llx\n", (unsigned long long)offset)with offset: %llx
of_empty_ranges_quirkof_get_addressOF_CHECK_ADDR_COUNT(na)psizeonesizedev_count_cellsBUG()of_bus_default_get_flagsnapnsp"default map, cp=%llx, s=%llx, da=%llx\n"(unsigned long long)cp, (unsigned long long)s, (unsigned long long)dadebug("default map, cp=%llx, s=%llx, da=%llx\n",
	      (unsigned long long)cp, (unsigned long long)s,
	      (unsigned long long)da)default map, cp=%llx, s=%llx, da=%llx
of_bus_default_count_cellsget_flags(OF_CHECK_ADDR_COUNT(na) && (ns) > 0)((na) > 0 && (na) <= OF_MAX_ADDR_CELLS)/* Get optional "reg-names" property to add a name to a resource *//* Count address cells & copy address locally *//* Increase refcount at current level *//*
	 * Normally, an absence of a "ranges" property means we are
	 * crossing a non-translatable boundary, and thus the addresses
	 * below the current cannot be converted to CPU physical ones.
	 * Unfortunately, while this is very clear in the spec, it's not
	 * what Apple understood, and they do have things like /uni-n or
	 * /ht nodes with no "ranges" property and a lot of perfectly
	 * useable mapped devices below them. Thus we treat the absence of
	 * "ranges" as equivalent to an empty "ranges" property which means
	 * a 1:1 translation at that level. It's up to the caller not to try
	 * to translate addresses that aren't supposed to be translated in
	 * the first place. --BenH.
	 *
	 * As far as we know, this damage only exists on Apple machines, so
	 * This code is only enabled on powerpc. --gcl
	 *//* Get "reg" or "assigned-addresses" property *//*
 * Array of bus-specific translators
 *//* Callbacks for bus specific translators *//*
 * Taken from Linux v4.9 drivers/of/address.c
 *
 * Modified for U-Boot
 * Copyright (c) 2017 Google, Inc
 *//opt/src/drivers/core/of_extra.c/config"/config""%s: Cannot find /config node\n"debug("%s: Cannot find /config node\n", __func__)drivers/core/of_extra.c%s: Cannot find /config node
sizeof(prop_name)%s-memory%s"%s-memory%s""%s: No memory type for '%s', using /memory\n"__func__, prop_namedebug("%s: No memory type for '%s', using /memory\n", __func__,
		      prop_name)%s: No memory type for '%s', using /memory
/memory"/memory""%s: Failed to find node '%s'\n"__func__, memdebug("%s: Failed to find node '%s'\n", __func__, mem)%s: Failed to find node '%s'
"%s: Failed to decode memory region %s\n"debug("%s: Failed to decode memory region %s\n", __func__,
		      mem)%s: Failed to decode memory region %s
%s-offset%s"%s-offset%s"offset_size"%s: Failed to decode memory region '%s'\n"debug("%s: Failed to decode memory region '%s'\n", __func__,
		      prop_name)%s: Failed to decode memory region '%s'
__func__, ofnode_get_name(node), prop_namedebug("%s: %s: %s\n", __func__, ofnode_get_name(node), prop_name)const fdt_addr_tconst fdt_addr_t *sizeof(fdt_addr_t)sizeof(fdt_addr_t) * 2"cell=%p, len=%d\n"cell, lendebug("cell=%p, len=%d\n", cell, len)cell=%p, len=%d
fdt_addr_to_cpu(*cell)cell[1](__force __u32)(__be32)(cell[1])(__u32)(__be32)(cell[1])((__u32)(__be32)(cell[1]))fdt_size_to_cpu(cell[1])"%s: base=%08lx, size=%lx\n"__func__, (ulong)*basep, (ulong)*sizepdebug("%s: base=%08lx, size=%lx\n", __func__, (ulong)*basep,
	      (ulong)*sizep)%s: base=%08lx, size=%lx
image-pos"image-pos""Node '%s' has bad/missing 'image-pos' property\n"ofnode_get_name(node)debug("Node '%s' has bad/missing 'image-pos' property\n",
		      ofnode_get_name(node))Node '%s' has bad/missing 'image-pos' property
log_ret(-ENOENT)"Node '%s' has bad/missing 'size' property\n"debug("Node '%s' has bad/missing 'size' property\n",
		      ofnode_get_name(node))Node '%s' has bad/missing 'size' property
"used"compress"compress""Unknown compression algo"log_msg_ret("Unknown compression algo",
					   -EINVAL)"Unknown compression algo", __retUnknown compression algouncomp-size"uncomp-size"/*
	 * Not strictly correct - the memory may have multiple banks. We just
	 * use the first
	 *//opt/src/drivers/core/ofnode.cofnode_valid(node)assert(ofnode_valid(node))drivers/core/ofnode.c"%s: %s = %s"__func__, propname, valuedebug("%s: %s = %s", __func__, propname, value)872%s: %s = %spp_lastsizeof(struct property)fressizeof(*res)u-boot,dm-pre-reloc"u-boot,dm-pre-reloc"u-boot,dm-pre-proper"u-boot,dm-pre-proper"u-boot,dm-spl"u-boot,dm-spl"u-boot,dm-tpl"u-boot,dm-tpl"pciVVVV,DDDD"pciVVVV,DDDD""pci"592"pci address #%d: %08lx %08lx %08lx\n"i, (ulong)fdt32_to_cpu(cell[0]), (ulong)fdt32_to_cpu(cell[1]), (ulong)fdt32_to_cpu(cell[2])debug("pci address #%d: %08lx %08lx %08lx\n", i,
			      (ulong)fdt32_to_cpu(cell[0]),
			      (ulong)fdt32_to_cpu(cell[1]),
			      (ulong)fdt32_to_cpu(cell[2]))612pci address #%d: %08lx %08lx %08lx
cell[0](__force __u32)(__be32)(cell[0])(__u32)(__be32)(cell[0])((__u32)(__be32)(cell[0]))cell[2](__force __u32)(__be32)(cell[2])(__u32)(__be32)(cell[2])((__u32)(__be32)(cell[2]))fdt32_to_cpu(*cell)fdt32_to_cpu(cell[0])fdt32_to_cpu(cell[1])FDT_PCI_ADDR_CELLS +
				 FDT_PCI_SIZE_CELLS(FDT_PCI_ADDR_CELLS +
				 FDT_PCI_SIZE_CELLS)sizeof(*dt)hback-porch"hback-porch"hfront-porch"hfront-porch""hactive"hsync-len"hsync-len"vback-porch"vback-porch"vfront-porch"vfront-porch""vactive"vsync-len"vsync-len"vsync-active"vsync-active"hsync-active"hsync-active"de-active"de-active"pixelclk-active"pixelclk-active"interlaced"interlaced"doublescan"doublescan"doubleclk"doubleclk"decode_timing_property"%s: could not find property %s\n"ofnode_get_name(node), namedebug("%s: could not find property %s\n",
		      ofnode_get_name(node), name)443%s: could not find property %s
chosen_nodeofnode_from_of_phandle_argsOF_MAX_PHANDLE_ARGS == MAX_PHANDLE_ARGS16 == 16assert(OF_MAX_PHANDLE_ARGS == MAX_PHANDLE_ARGS)358sizeof(out->args)ofnode_from_fdtdec_phandle_argsdtprop_valIS_ENABLED(CONFIG_OF_TRANSLATE)__func__, subnode_namedebug("%s: %s: ", __func__, subnode_name)ooffsetofnode_valid(subnode) ? ofnode_get_name(subnode) : "<none>"debug("%s\n", ofnode_valid(subnode) ?
	      ofnode_get_name(subnode) : "<none>")<none>"<none>""<not found>\n"debug("<not found>\n")<not found>
"<invalid>\n"debug("<invalid>\n")<invalid>
debug("%s\n", str)prop ? "true" : "false"debug("%s\n", prop ? "true" : "false")sizeof(*cell)(__force __u64)(__be64)(cell[0])(__u64)(__be64)(cell[0])((__u64)(__be64)(cell[0]))fdt64_to_cpu(cell[0])debug("%#llx (%lld)\n", (unsigned long long)*outp,
	      (unsigned long long)*outp)defined(CONFIG_SPL_BUILD) || defined(CONFIG_TPL_BUILD)/* Property does not exist -> append new property *//* Property exists -> change value *//*
	 * In regular builds individual spl and tpl handling both
	 * count as handled pre-relocation for later second init.
	 *//* for SPL and TPL the remaining nodes after the fdtgrep 1st pass
	 * had property dm-pre-reloc or u-boot,dm-spl/tpl.
	 * They are removed in final dtb (fdtgrep 2nd pass)
	 *//*
			 * check if the string is something like pciVVVV,DDDD.RR
			 * or just pciVVVV,DDDD
			 *//*
	 * If we follow the pci bus bindings strictly, we should check
	 * the value of the node's parent node's #address-cells and
	 * #size-cells. They need to be 3 and 2 accordingly. However,
	 * for simplicity we skip the check here.
	 *//opt/src/drivers/core/read.cuc_name/opt/src/drivers/core/read_extra.cread_extra/* This file can hold non-inlined dev_read_...() functions *//opt/src/include/regmap.hregmapregmap_init_mem_platdatafdt_val_t *regmap *regmap **regmap_rangeregmap_endianness_tREGMAP_NATIVE_ENDIANREGMAP_LITTLE_ENDIANREGMAP_BIG_ENDIANregmap_size_tREGMAP_SIZE_8REGMAP_SIZE_16REGMAP_SIZE_32REGMAP_SIZE_64regmap_range[0]range_countendiannessregmap_read_poll_timeout(map,addr,val,cond,sleep_us,timeout_ms)regmap_read_poll_timeout_test(map, addr, val, cond, sleep_us, timeout_ms, 0)regmap_read_poll_timeout_test(map,addr,val,cond,sleep_us,timeout_ms,test_add_time)({ unsigned long __start = get_timer(0); int __ret; for (;;) { __ret = regmap_read((map), (addr), &(val)); if (__ret) break; if (cond) break; if (IS_ENABLED(CONFIG_SANDBOX) && test_add_time) timer_test_add_offset(test_add_time); if ((timeout_ms) && get_timer(__start) > (timeout_ms)) { __ret = regmap_read((map), (addr), &(val)); break; } if ((sleep_us)) udelay((sleep_us)); } __ret ?: ((cond) ? 0 : -ETIMEDOUT); })regmap_get(map,type,member,valp)regmap_range_get(map, 0, type, member, valp)regmap_range_get(map,range,type,member,valp)regmap_raw_read_range(map, range, offsetof(type, member), (void *)valp, sizeof(((type *)0)->member))regmap_set(map,type,member,val)regmap_range_set(map, 0, type, member, val)regmap_range_set(map,range,type,member,val)do { typeof(((type *)0)->member) __tmp = val; regmap_raw_write_range(map, range, offsetof(type, member), &__tmp, sizeof(((type *)0)->member)); } while (0)__REGMAP_Hregmap_uninitregmap_get_rangeregmap_init_mem_indexregmap_init_memregmap_update_bitsregmap_raw_read_rangeregmap_raw_write_rangeregmap_raw_readregmap_raw_writeregmap_readregmap_write/**
 * regmap_uninit() - free a previously inited regmap
 *
 * @map:	Regmap to free
 * Return: 0 if OK, -ve on error
 *//**
 * regmap_get_range() - Obtain the base memory address of a regmap range
 *
 * @map:	Regmap to query
 * @range_num:	Range to look up
 * Return: Pointer to the range in question if OK, NULL on error
 *//**
 * regmap_init_mem_platdata() - Set up a new memory register map for
 *				of-platdata
 *
 * @dev:	Device that uses this map
 * @reg:	List of address, size pairs
 * @count:	Number of pairs (e.g. 1 if the regmap has a single entry)
 * @mapp:	Returns allocated map
 * Return: 0 if OK, -ve on error
 *
 * This creates a new regmap with a list of regions passed in, rather than
 * using the device tree. It only supports 32-bit machines.
 *
 * Use regmap_uninit() to free it.
 *
 *//**
 * regmap_init_mem() - Set up a new register map that uses memory access
 *
 * @node:	Device node that uses this map
 * @mapp:	Returns allocated map
 * Return: 0 if OK, -ve on error
 *
 * Use regmap_uninit() to free it.
 *//**
 * regmap_update_bits() - Perform a read/modify/write using a mask
 *
 * @map:	The map returned by regmap_init_mem*()
 * @offset:	Offset of the memory
 * @mask:	Mask to apply to the read value
 * @val:	Value to apply to the value to write
 * Return: 0 if OK, -ve on error
 *//**
 * regmap_read_poll_timeout - Poll until a condition is met or a timeout occurs
 *
 * @map:	Regmap to read from
 * @addr:	Offset to poll
 * @val:	Unsigned integer variable to read the value into
 * @cond:	Break condition (usually involving @val)
 * @sleep_us:	Maximum time to sleep between reads in us (0 tight-loops).
 * @timeout_ms:	Timeout in ms, 0 means never timeout
 * @test_add_time: Used for sandbox testing - amount of time to add after
 *		starting the loop (0 if not testing)
 *
 * Returns 0 on success and -ETIMEDOUT upon a timeout or the regmap_read
 * error return value in case of a error read. In the two former cases,
 * the last read value at @addr is stored in @val. Must not be called
 * from atomic context if sleep_us or timeout_us are used.
 *
 * This is modelled after the regmap_read_poll_timeout macros in linux but
 * with millisecond timeout.
 *
 * The _test version is for sandbox testing only. Do not use this in normal
 * code as it advances the timer.
 *//**
 * regmap_get() - Get a value from a regmap described by a struct
 * @map:    Regmap from which a value should be read
 * @type:   Structure type that describes the memory layout of the regmap
 *          range
 * @member: Member of the describing structure that should be read in the
 *          regmap
 * @valp:   Variable that receives the value read from the regmap
 *//**
 * regmap_range_get() - Get a value from a regmap range described by a struct
 * @map:    Regmap from which a value should be read
 * @range:  Range of the regmap from which a value should be read
 * @type:   Structure type that describes the memory layout of the regmap
 *          range
 * @member: Member of the describing structure that should be read in the
 *          regmap range
 * @valp:   Variable that receives the value read from the regmap range
 *//**
 * regmap_set() - Set a value in a regmap described by a struct
 * @map:    Regmap in which a value should be set
 * @type:   Structure type that describes the memory layout of the regmap
 * @member: Member of the describing structure that should be set in the regmap
 * @val:    Value which should be written to the regmap
 *//**
 * regmap_range_set() - Set a value in a regmap range described by a struct
 * @map:    Regmap in which a value should be set
 * @range:  Range of the regmap in which a value should be set
 * @type:   Structure type that describes the memory layout of the regmap range
 * @member: Member of the describing structure that should be set in the regmap
 *          range
 * @val:    Value which should be written to the regmap range
 *//**
 * regmap_raw_read_range() - Read a value of specified length from a range of a
 *			     regmap
 *
 * @map:	Regmap to read from
 * @range_num:	Number of the range in the regmap to write to
 * @offset:	Offset in the regmap to read from
 * @valp:	Pointer to the buffer to receive the data read from the regmap
 *		at the specified offset
 * @val_len:	Length of the data to be read from the regmap
 *
 * Return: 0 if OK, -ve on error
 *//**
 * regmap_raw_write_range() - Write a value of specified length to a range of a
 *			      regmap
 *
 * @map:	Regmap to write to
 * @range_num:	Number of the range in the regmap to write to
 * @offset:	Offset in the regmap to write to
 * @val:	Value to write to the regmap at the specified offset
 * @val_len:	Length of the data to be written to the regmap
 *
 * Return: 0 if OK, -ve on error
 *//**
 * regmap_raw_read() - Read a value of specified length from a regmap
 *
 * @map:	Regmap to read from
 * @offset:	Offset in the regmap to read from
 * @valp:	Pointer to the buffer to receive the data read from the regmap
 *		at the specified offset
 * @val_len:	Length of the data to be read from the regmap
 *
 * Note that this function will, as opposed to regmap_read, read data of
 * arbitrary length from the regmap, and not just 32-bit values, and is thus a
 * generalized version of regmap_read.
 *
 * Return: 0 if OK, -ve on error
 *//**
 * regmap_raw_write() - Write a value of specified length to a regmap
 *
 * @map:	Regmap to write to
 * @offset:	Offset in the regmap to write to
 * @val:	Value to write to the regmap at the specified offset
 * @val_len:	Length of the data to be written to the regmap
 *
 * Note that this function will, as opposed to regmap_write, write data of
 * arbitrary length to the regmap, and not just 32-bit values, and is thus a
 * generalized version of regmap_write.
 *
 * Return: 0 if OK, -ve on error
 *//**
 * regmap_read() - Read a 32-bit value from a regmap
 *
 * @map:	Regmap to read from
 * @offset:	Offset in the regmap to read from
 * @valp:	Pointer to the buffer to receive the data read from the regmap
 *		at the specified offset
 *
 * Note that this function will only read values of 32 bit width from the
 * regmap; if the size of data to be read is different, the regmap_raw_read
 * function can be used.
 *
 * Return: 0 if OK, -ve on error
 *//**
 * regmap_write() - Write a 32-bit value to a regmap
 *
 * @map:	Regmap to write to
 * @offset:	Offset in the regmap to write to
 * @val:	Data to write to the regmap at the specified offset
 *
 * Note that this function will only write values of 32 bit width to the
 * regmap; if the size of data to be read is different, the regmap_raw_write
 * function can be used.
 *
 * Return: 0 if OK, -ve on error
 *//*
 * Interface to provide access to registers either through a direct memory
 * bus or through a peripheral bus like I2C, SPI.
 *//**
 * struct regmap - a way of accessing hardware/bus registers
 *
 * @range_count:	Number of ranges available within the map
 * @ranges:		Array of ranges
 *//**
 * struct regmap_range - a register map range
 *
 * @start:	Start address
 * @size:	Size in bytes
 *//**
 * enum regmap_endianness_t - Endianness for regmap reads and writes
 *
 * @REGMAP_NATIVE_ENDIAN: Native endian read/write accesses
 * @REGMAP_LITTLE_ENDIAN: Little endian read/write accesses
 * @REGMAP_BIG_ENDIAN: Big endian read/write accesses
 *//**
 * enum regmap_size_t - Access sizes for regmap reads and writes
 *
 * @REGMAP_SIZE_8: 8-bit read/write access size
 * @REGMAP_SIZE_16: 16-bit read/write access size
 * @REGMAP_SIZE_32: 32-bit read/write access size
 * @REGMAP_SIZE_64: 64-bit read/write access size
 *//**
 * DOC: Overview
 *
 * Regmaps are an abstraction mechanism that allows device drivers to access
 * register maps irrespective of the underlying bus architecture. This entails
 * that for devices that support multiple busses (e.g. I2C and SPI for a GPIO
 * expander chip) only one driver has to be written. This driver will
 * instantiate a regmap with a backend depending on the bus the device is
 * attached to, and use the regmap API to access the register map through that
 * bus transparently.
 *
 * Read and write functions are supplied, which can read/write data of
 * arbitrary length from/to the regmap.
 *
 * The endianness of regmap accesses is selectable for each map through device
 * tree settings via the boolean "little-endian", "big-endian", and
 * "native-endian" properties.
 *
 * Furthermore, the register map described by a regmap can be split into
 * multiple disjoint areas called ranges. In this way, register maps with
 * "holes", i.e. areas of addressable memory that are not part of the register
 * map, can be accessed in a concise manner.
 *
 * Currently, only a bare "mem" backend for regmaps is supported, which
 * accesses the register map as regular IO-mapped memory.
 */range_nummappval_len_DM_OF_ADDR_H/**
 * of_address_to_resource() - translate device tree address to resource
 *
 * Note that if your address is a PIO address, the conversion will fail if
 * the physical address can't be internally converted to an IO token with
 * pci_address_to_pio(), that is because it's either called to early or it
 * can't be matched to any host bridge IO space
 *
 * @np: node to check
 * @index: index of address to read (0 = first)
 * @r: place to put resource information
 * @return 0 if OK, -ve on error
 *//**
 * of_get_address() - obtain an address from a node
 *
 * Extract an address from a node, returns the region size and the address
 * space flags too. The PCI version uses a BAR number instead of an absolute
 * index.
 *
 * @np: Node to check
 * @index: Index of address to read (0 = first)
 * @size: place to put size on success
 * @flags: place to put flags on success
 * @return pointer to address which can be read
 *//**
 * of_translate_dma_address() - translate a device-tree DMA address to a CPU
 *				address
 *
 * Translate a DMA address from the device-tree into a CPU physical address,
 * this walks up the tree and applies the various bus mappings on the way.
 *
 * Note: We consider that crossing any level with #size-cells == 0 to mean
 * that translation is impossible (that is we are not dealing with a value
 * that can be mapped to a cpu physical address). This is not really specified
 * that way, but this is traditionally the way IBM at least do things
 *
 * @np: node to check
 * @in_addr: pointer to input DMA address
 * @return translated DMA address or OF_BAD_ADDR on error
 *//**
 * of_translate_address() - translate a device-tree address to a CPU address
 *
 * Translate an address from the device-tree into a CPU physical address,
 * this walks up the tree and applies the various bus mappings on the  way.
 *
 * Note: We consider that crossing any level with #size-cells == 0 to mean
 * that translation is impossible (that is we are not dealing with a value
 * that can be mapped to a cpu physical address). This is not really specified
 * that way, but this is traditionally the way IBM at least do things
 *
 * @np: node to check
 * @in_addr: pointer to input address
 * @return translated address or OF_BAD_ADDR on error
 *//opt/src/drivers/core/regmap.c"%s: range index %d larger than range count\n"__func__, range_numdebug("%s: range index %d larger than range count\n",
		      __func__, range_num)drivers/core/regmap.c408%s: range index %d larger than range count
ERANGE-34-ERANGEregmap_range *"%s: offset/size combination invalid\n"debug("%s: offset/size combination invalid\n", __func__)%s: offset/size combination invalid
"%s: regmap size %zu unknown\n"__func__, val_lendebug("%s: regmap size %zu unknown\n", __func__, val_len)%s: regmap size %zu unknown
__write_32cpu_to_le32(*val)((__le32)(__u32)(*val))be32cpu_to_be32(*val)((__be32)(__builtin_constant_p((__u32)((*val))) ? ((__u32)( (((__u32)(((*val))) & (__u32)0x000000ffUL) << 24) | (((__u32)(((*val))) & (__u32)0x0000ff00UL) << 8) | (((__u32)(((*val))) & (__u32)0x00ff0000UL) >> 8) | (((__u32)(((*val))) & (__u32)0xff000000UL) >> 24) )) : __fswab32(((*val)))))(*val)((*val))out_be32(addr, *val)<regmap.h>__write_16le16cpu_to_le16(*val)((__le16)(__u16)(*val))be16cpu_to_be16(*val)((__be16)(__builtin_constant_p((__u16)((*val))) ? ((__u16)( (((__u16)(((*val))) & (__u16)0x00ffU) << 8) | (((__u16)(((*val))) & (__u16)0xff00U) >> 8) )) : __fswab16(((*val)))))out_be16(addr, *val)__write_8299__read_32(__force __u32)(__be32)(iotrace_readl((const void *)(addr)))(__u32)(__be32)(iotrace_readl((const void *)(addr)))((__u32)(__be32)(iotrace_readl((const void *)(addr))))in_be32(addr)__read_16(__force __u16)(__be16)(iotrace_readw((const void *)(addr)))(__u16)(__be16)(iotrace_readw((const void *)(addr)))((__u16)(__be16)(iotrace_readw((const void *)(addr))))in_be16(addr)__read_8addr_len"%s: Error while reading the addr length (ret = %d)\n"ofnode_get_name(node), addr_lendebug("%s: Error while reading the addr length (ret = %d)\n",
		      ofnode_get_name(node), addr_len)%s: Error while reading the addr length (ret = %d)
size_len"%s: Error while reading the size length: (ret = %d)\n"ofnode_get_name(node), size_lendebug("%s: Error while reading the size length: (ret = %d)\n",
		      ofnode_get_name(node), size_len)%s: Error while reading the size length: (ret = %d)
both_len"%s: Both addr and size length are zero\n"debug("%s: Both addr and size length are zero\n",
		      ofnode_get_name(node))%s: Both addr and size length are zero
"%s: Error while reading reg size (ret = %d)\n"ofnode_get_name(node), lendebug("%s: Error while reading reg size (ret = %d)\n",
		      ofnode_get_name(node), len)%s: Error while reading reg size (ret = %d)
"%s: Not enough data in reg property\n"debug("%s: Not enough data in reg property\n",
		      ofnode_get_name(node))%s: Not enough data in reg property
little-endian"little-endian"big-endian"big-endian"native-endian"native-endian"init_range"%s: Could not read resource of range %d (ret = %d)\n"ofnode_get_name(node), index, retdebug("%s: Could not read resource of range %d (ret = %d)\n",
			      ofnode_get_name(node), index, ret)%s: Could not read resource of range %d (ret = %d)
"%s: Could not read start of range %d\n"ofnode_get_name(node), indexdebug("%s: Could not read start of range %d\n",
			      ofnode_get_name(node), index)%s: Could not read start of range %d
regmap_allocsizeof(*map)sizeof(map->ranges[0])defined(in_le64) && defined(in_be64) && defined(readq)defined(out_le64) && defined(out_be64) && defined(writeq)/* Default: native endianness *//**
 * init_range() - Initialize a single range of a regmap
 * @node:     Device node that will use the map in question
 * @range:    Pointer to a regmap_range structure that will be initialized
 * @addr_len: The length of the addr parts of the reg property
 * @size_len: The length of the size parts of the reg property
 * @index:    The index of the range to initialize
 *
 * This function will read the necessary 'reg' information from the device tree
 * (the 'addr' part, and the 'length' part), and initialize the range in
 * quesion.
 *
 * Return: 0 if OK, -ve on error
 *//**
 * regmap_alloc() - Allocate a regmap with a given number of ranges.
 *
 * @count: Number of ranges to be allocated for the regmap.
 * Return: A pointer to the newly allocated regmap, or NULL on error.
 *//opt/src/drivers/core/root.cIS_ENABLED(CONFIG_OF_LIVE)"dm_init() failed: %d\n"debug("dm_init() failed: %d\n", ret)drivers/core/root.c375dm_init() failed: %d
"dm_scan_platdata() failed: %d\n"debug("dm_scan_platdata() failed: %d\n", ret)380dm_scan_platdata() failed: %d
"dm_extended_scan_dt() failed: %d\n"debug("dm_extended_scan_dt() failed: %d\n", ret)dm_extended_scan_dt() failed: %d
"dm_scan_fdt() failed: %d\n"debug("dm_scan_fdt() failed: %d\n", ret)347dm_scan_fdt() failed: %d
/clocks"/clocks""scan for /clocks failed: %d\n"debug("scan for /clocks failed: %d\n", ret)353scan for /clocks failed: %d
/firmware"/firmware""scan for /firmware failed: %d\n"debug("scan for /firmware failed: %d\n", ret)359scan for /firmware failed: %d
dm_scan_fdt_ofnode_pathdm_scan_fdt_node"parsing subnodes of \"%s\"\n"pr_fmt("parsing subnodes of \"%s\"\n")pr_debug("parsing subnodes of \"%s\"\n", node_name)parsing subnodes of "%s"
"   - ignoring disabled device\n"pr_fmt("   - ignoring disabled device\n")pr_debug("   - ignoring disabled device\n")   - ignoring disabled device
"%s: ret=%d\n"node_name, retdebug("%s: ret=%d\n", node_name, ret)%s: ret=%d
Some drivers failed to bind
"Some drivers failed to bind\n"dm_scan_fdt_live"parsing subnodes of \"chosen\"\n"pr_fmt("parsing subnodes of \"chosen\"\n")pr_debug("parsing subnodes of \"chosen\"\n")parsing subnodes of "chosen"
np->name, retdebug("%s: ret=%d\n", np->name, ret)node_parentSome drivers were not found
"Some drivers were not found\n"Virtual root driver already exists!
"Virtual root driver already exists!\n"Virtual root driver does not exist!
"Virtual root driver does not exist!\n""root"_u_boot_list_2_uclass_2_root.u_boot_list_2_uclass_2_rootroot_driver"root_driver"_u_boot_list_2_driver_2_root_driver.u_boot_list_2_driver_2_root_driverroot_info/* This is the root uclass *//* This is the root driver - all drivers are children of this *//*
		 * The "chosen" and "firmware" nodes aren't devices
		 * themselves but may contain some:
		 *//**
 * dm_scan_fdt_node() - Scan the device tree and bind drivers for a node
 *
 * This scans the subnodes of a device tree node and and creates a driver
 * for each one.
 *
 * @parent: Parent device for the devices that will be created
 * @blob: Pointer to device tree blob
 * @offset: Offset of node to scan
 * @pre_reloc_only: If true, bind only drivers with the DM_FLAG_PRE_RELOC
 * flag. If false bind all drivers.
 * @return 0 if OK, -ve on error
 *//* CONFIG_IS_ENABLED(OF_LIVE) *//* "chosen" node isn't a device itself but may contain some: *//* FIXME maybe also need to fix these ops *//* OPS are fixed in every uclass post_probe function *//* The sentinel node has moved, so update things that point to it *//opt/src/drivers/core/simple-bus.csimple-bussimple_bus_post_bindARRAY_SIZE(cell)simple_bus_plat *simple_bus_platgeneric_simple_bus"generic_simple_bus"const udevice_id[3]udevice_id[3]_u_boot_list_2_driver_2_simple_bus_drv.u_boot_list_2_driver_2_simple_bus_drvsimple_bus_drv"simple-bus"simple-mfd"simple-mfd"generic_simple_bus_idssimple_bus"simple_bus"sizeof(struct simple_bus_plat)_u_boot_list_2_uclass_2_simple_bus.u_boot_list_2_uclass_2_simple_bus/opt/src/include/syscon.hsysconsyscon_opssyscon_uc_infosyscon_get_ops(dev)((struct syscon_ops *)(dev)->driver->ops)__SYSCON_Hsyscon_node_to_regmapsyscon_get_first_rangesyscon_regmap_lookup_by_phandlesyscon_get_regmap_by_driver_datasyscon_get_by_driver_datasyscon_get_regmap/**
 * syscon_node_to_regmap - get regmap from syscon
 *
 * @node:		Device node of syscon
 *//**
 * syscon_get_first_range() - get the first memory range from a syscon regmap
 *
 * @driver_data:	Driver data value to look up
 * @return first region of register map correponding to @driver_data, or
 *			-ve error code
 *//**
 * syscon_regmap_lookup_by_phandle() - Look up a controller by a phandle
 *
 * This operates by looking up the given name in the device (device
 * tree property) of the device using the system controller.
 *
 * @dev:	Device using the system controller
 * @name:	Name of property referring to the system controller
 * @return	A pointer to the regmap if found, ERR_PTR(-ve) on error
 *//**
 * syscon_get_regmap_by_driver_data() - Look up a controller by its ID
 *
 * Each system controller can be accessed by its driver data, which is
 * assumed to be unique through the scope of all system controllers that
 * are in use. This function looks up the regmap given this driver data.
 *
 * @driver_data:	Driver data value to look up
 * @return register map correponding to @driver_data, or -ve error code
 *//**
 * syscon_get_regmap_by_driver_data() - Look up a controller by its ID
 *
 * Each system controller can be accessed by its driver data, which is
 * assumed to be unique through the scope of all system controllers that
 * are in use. This function looks up the controller given this driver data.
 *
 * @driver_data:	Driver data value to look up
 * @devp:		Returns the controller correponding to @driver_data
 * @return 0 on success, -ENODEV if the ID was not found, or other -ve error
 *	   code
 *//**
 * syscon_get_regmap() - Get access to a register map
 *
 * @dev:	Device to check (UCLASS_SCON)
 * @info:	Returns regmap for the device
 * @return 0 if OK, -ve on error
 *//*
 * We don't support 64-bit machines. If they are so resource-contrained that
 * they need to use OF_PLATDATA, something is horribly wrong with the
 * education of our hardware engineers.
 *
 * Update: 64-bit is now supported and we have an education crisis.
 *//* So far there are no ops so this is a placeholder *//**
 * struct syscon_uc_info - Information stored by the syscon UCLASS_UCLASS
 *
 * @regmap:	Register map for this controller
 *//opt/src/drivers/core/syscon-uclass.csyscon-uclassUCLASS_SYSCON"unable to find regmap\n"dev_dbg(dev, "unable to find regmap\n")LOGLEVEL__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_LOGLEVELCONFIG_LOGLEVELunable to find regmap
syscon_uc_info *"unable to find syscon device\n"dev_dbg(dev, "unable to find syscon device\n")unable to find syscon device
syscon_probe_by_ofnode"syscon""invalid compatible for syscon device\n"dev_dbg(dev, "invalid compatible for syscon device\n")invalid compatible for syscon device
"unable to bound syscon device\n"dev_dbg(dev, "unable to bound syscon device\n")<syscon.h>unable to bound syscon device
"unable to probe syscon device\n"dev_dbg(dev, "unable to probe syscon device\n")unable to probe syscon device
syscon_pre_probe_u_boot_list_2_driver_2_generic_syscon.u_boot_list_2_driver_2_generic_syscongeneric_syscongeneric_syscon_idssizeof(struct syscon_uc_info)_u_boot_list_2_uclass_2_syscon.u_boot_list_2_uclass_2_syscon/*
 * Linux-compatible syscon-to-regmap
 * The syscon node can be bound to another driver, but still works
 * as a syscon provider.
 *//* found node with "syscon" compatible, not bounded to SYSCON *//* force bound to syscon class *//* bound to driver with same ofnode or to root if not found *//* found node with "syscon" compatible, not bounded to SYSCON UCLASS *//*
	 * With OF_PLATDATA we really have no way of knowing the format of
	 * the device-specific platform data. So we assume that it starts with
	 * a 'reg' member, and this holds a single address and size. Drivers
	 * using OF_PLATDATA will need to ensure that this is true.
	 *//* Special case for PCI devices, which don't have a regmap *//*
 * Caution:
 * This API requires the given device has alerady been bound to syscon driver.
 * For example,
 *    compatible = "syscon", "simple-mfd";
 * works, but
 *    compatible = "simple-mfd", "syscon";
 * does not.  The behavior is different from Linux.
 *//opt/src/drivers/core/uclass.cdev->seq == -1assert(dev->seq == -1)drivers/core/uclass.c677Device '%s': seq %d is in use by '%s'
"Device '%s': seq %d is in use by '%s'\n""Looking for %s\n"log(LOGC_DM, LOGL_DEBUG, "Looking for %s\n", ofnode_get_name(node))Looking for %s
"   - result for %s: %s (ret=%d)\n"ofnode_get_name(node), dev ? dev->name : "(none)", retlog(LOGC_DM, LOGL_DEBUG, "   - result for %s: %s (ret=%d)\n",
	    ofnode_get_name(node), dev ? dev->name : "(none)", ret)506   - result for %s: %s (ret=%d)
(none)"(none)"437find_drvfind_phandle356"      - checking %s\n"log(LOGC_DM, LOGL_DEBUG_CONTENT, "      - checking %s\n",
		    dev->name)      - checking %s
ofnode_get_name(node), *devp ? (*devp)->name : "(none)", retlog(LOGC_DM, LOGL_DEBUG, "   - result for %s: %s (ret=%d)\n",
	    ofnode_get_name(node), *devp ? (*devp)->name : "(none)", ret)376"%s: %d %d\n"__func__, find_req_seq, seq_or_req_seqdebug("%s: %d %d\n", __func__, find_req_seq, seq_or_req_seq)%s: %d %d
"   - %d %d '%s'\n"dev->req_seq, dev->seq, dev->namedebug("   - %d %d '%s'\n", dev->req_seq, dev->seq, dev->name)   - %d %d '%s'
"   - found\n"debug("   - found\n")   - found
"   - not found\n"debug("   - not found\n")   - not found
list_entry(dev->uclass_node.next, struct udevice, uclass_node)list_first_entry(&uc->dev_head, struct udevice, uclass_node)typeof(*iter)uclass_foreach_dev(iter, uc)iter->uclass_node.nextlist_first_entry(&uc->dev_head, struct udevice,
				       uclass_node)uclass_add"Cannot find uclass for id %d: please add the UCLASS_DRIVER() declaration for this UCLASS_... id\n"debug("Cannot find uclass for id %d: please add the UCLASS_DRIVER() declaration for this UCLASS_... id\n",
		      id)Cannot find uclass for id %d: please add the UCLASS_DRIVER() declaration for this UCLASS_... id
EPFNOSUPPORT-96-EPFNOSUPPORTsizeof(*uc)UCLASS_NOPnop"nop"_u_boot_list_2_uclass_2_nop.u_boot_list_2_uclass_2_nop!CONFIG_IS_ENABLED(OF_CONTROL) || CONFIG_IS_ENABLED(OF_PLATDATA)/* Our requested sequence number is available *//* There is no need to undo the parent's post_bind call *//*
	 * We cannot use list_for_each_entry_safe() here. If a device in this
	 * uclass has a child device also in this uclass, it will be also be
	 * unbound (by the recursion in the call to device_unbind() below).
	 * We can loop until the list is empty.
	 *//*
		 * Use a strange error to make this case easier to find. When
		 * a uclass is not available it can prevent driver model from
		 * starting up and this failure is otherwise hard to debug.
		 *//**
 * uclass_add() - Create new uclass in list
 * @id: Id number to create
 * @ucp: Returns pointer to uclass, or NULL on error
 * @return 0 on success, -ve on error
 *
 * The new uclass is added to the list. There must be only one uclass for
 * each id.
 *//*
	 * TODO(sjg@chromium.org): Optimise this, perhaps moving the found
	 * node to the start of the list, or creating a linear array mapping
	 * id to node.
	 */fail_mem/opt/src/drivers/core/util.c/opt/src/drivers/cpu/cpu-uclass.ccpu-uclassuclass_cpu_init/cpus"/cpus"cpu_bus"cpu_bus""cpus"cpu_ops *"%s: No CPU found (err = %d)\n"debug("%s: No CPU found (err = %d)\n", __func__, ret)drivers/cpu/cpu-uclass.c%s: No CPU found (err = %d)
"%s: Error while probing CPU (err = %d)\n"debug("%s: Error while probing CPU (err = %d)\n",
			      __func__, ret)%s: Error while probing CPU (err = %d)
"cpu"_u_boot_list_2_uclass_2_cpu.u_boot_list_2_uclass_2_cpusizeof(struct cpu_platdata)_u_boot_list_2_driver_2_cpu_bus.u_boot_list_2_driver_2_cpu_bus/opt/src/drivers/cpu/opt/src/drivers/cpu/cpu_sandbox.ccpu_sandboxcpu_sandbox_probecpu_sandbox_get_vendorLanguid Example Garbage Inc."Languid Example Garbage Inc."cpu_sandbox_get_countcpu_sandbox_get_info176442 * 427408842 * 42 * 42311169642 * 42 * 42 * 4213069123242 * 42 * 42 * 42 * 4211116385940x42424242cpu_sandbox_get_descLEG Inc. SuperMegaUltraTurbo CPU No. 1"LEG Inc. SuperMegaUltraTurbo CPU No. 1""cpu_sandbox"const cpu_opsconst cpu_ops *_u_boot_list_2_driver_2_cpu_sandbox.u_boot_list_2_driver_2_cpu_sandboxsandbox,cpu_sandbox"sandbox,cpu_sandbox"cpu_sandbox_idscpu_sandbox_ops/opt/src/drivers/crypto/fsl/sec.cCONFIG_SYS_FSL_SEC_COMPAT == 2 || CONFIG_SYS_FSL_SEC_COMPAT >= 4CONFIG_SYS_FSL_SEC_COMPAT == 2CONFIG_SYS_FSL_SEC_COMPAT >= 4/* Add SEC ERA information in compatible *//* This is '0' prior to CAAM ERA-6 *//* SEC4 *//* else we got called for possible uprev *//* delete it if not on an E-processor *//* locate crypto node based on lowest common compatible *//* SEC 3.3 *//* SEC 3.1 *//* SEC 3.0 *//* SEC 2.4 *//* SEC 2.2 *//* SEC 2.1 *//* SEC 2.0 *//* SEC 2.x/3.x *//*
 * update crypto node properties to a specified revision of the SEC
 * called with sec_rev == 0 if not on an E processor
 *//*
 * Copyright 2014 Freescale Semiconductor, Inc.
 *//opt/src/drivers/crypto/fslfsl/opt/src/drivers/crypto/opt/src/drivers/crypto/rsa_mod_exp/mod_exp_sw.cmod_exp_swkey_prop *"%s: RSA failed to verify: %d\n"debug("%s: RSA failed to verify: %d\n", __func__, ret)drivers/crypto/rsa_mod_exp/mod_exp_sw.c%s: RSA failed to verify: %d
"mod_exp_sw"_u_boot_list_2_driver_info_2_mod_exp_sw.u_boot_list_2_driver_info_2_mod_exp_swUCLASS_MOD_EXPconst mod_exp_opsconst mod_exp_ops *mod_exp_ops *_u_boot_list_2_driver_2_mod_exp_sw.u_boot_list_2_driver_2_mod_exp_swmod_exp_ops_sw/*
 * (C) Copyright 2014 Freescale Semiconductor, Inc.
 * Author: Ruchika Gupta <ruchika.gupta@freescale.com>
 *//opt/src/include/u-boot/rsa-mod-exp.h/opt/src/drivers/crypto/rsa_mod_exprsa_mod_exp<u-boot/rsa-mod-exp.h>rsa-mod-exprsa_mod_exp_swmod_exp_opskey_propmod_expexp_lenpublic_exponent_RSA_MOD_EXP_Hdefined(CONFIG_CMD_ZYNQ_RSA)/**
	 * Perform Modular Exponentiation
	 *
	 * Operation: out[] = sig ^ exponent % modulus
	 *
	 * @dev:	RSA Device
	 * @sig:	RSA PKCS1.5 signature
	 * @sig_len:	Length of signature in number of bytes
	 * @node:	Node with RSA key elements like modulus, exponent,
	 *		R^2, n0inv
	 * @out:	Result in form of byte array of len equal to sig_len
	 *
	 * This function computes exponentiation over the signature.
	 * Returns: 0 if exponentiation is successful, or a negative value
	 * if it wasn't.
	 *//**
 * struct struct mod_exp_ops - Driver model for RSA Modular Exponentiation
 *				operations
 *
 * The uclass interface is implemented by all crypto devices which use
 * driver model.
 *//**
 * rsa_mod_exp_sw() - Perform RSA Modular Exponentiation in sw
 *
 * Operation: out[] = sig ^ exponent % modulus
 *
 * @sig:	RSA PKCS1.5 signature
 * @sig_len:	Length of signature in number of bytes
 * @node:	Node with RSA key elements like modulus, exponent, R^2, n0inv
 * @out:	Result in form of byte array of len equal to sig_len
 *//* Exponent length in number of uint8_t *//* Key length in bits *//* public exponent as byte array *//* modulus as byte array *//* R^2 can be treated as byte array *//**
 * struct key_prop - holder for a public key properties
 *
 * The struct has pointers to modulus (Typically called N),
 * The inverse, R^2, exponent. These can be typecasted and
 * used as byte arrays or converted to the required format
 * as per requirement of RSA implementation.
 *//opt/src/drivers/crypto/rsa_mod_exp/mod_exp_uclass.cmod_exp_uclass"rsa_mod_exp"_u_boot_list_2_uclass_2_mod_exp.u_boot_list_2_uclass_2_mod_exp/*
 * (C) Copyright 2014 Freescale Semiconductor, Inc
 * Author: Ruchika Gupta <ruchika.gupta@freescale.com>
 *//opt/src/drivers/demo/demo-pdata.cdemo-pdatademo_shape_drv"demo_shape_drv"const dm_demo_pdataconst dm_demo_pdata *dm_demo_pdata *_u_boot_list_2_driver_info_2_demo4.u_boot_list_2_driver_info_2_demo4demo4demo_simple_drv"demo_simple_drv"_u_boot_list_2_driver_info_2_demo3.u_boot_list_2_driver_info_2_demo3demo3_u_boot_list_2_driver_info_2_demo2.u_boot_list_2_driver_info_2_demo2demo2_u_boot_list_2_driver_info_2_demo1.u_boot_list_2_driver_info_2_demo1demo1_u_boot_list_2_driver_info_2_demo0.u_boot_list_2_driver_info_2_demo0demo0yellow"yellow"6.06.yellow_hexagon"green"3.03.green_triangle"red"4.04.red_square/opt/src/drivers/demo/opt/src/drivers/demo/demo-shape.cdemo-shapeshapedm_shape_removeshape_data *gpio_desc[8]dm_shape_probelight-gpios"light-gpios"priv->gpio_descARRAY_SIZE(priv->gpio_desc)GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE"%s: %d GPIOs\n"__func__, priv->gpio_countdebug("%s: %d GPIOs\n", __func__, priv->gpio_count)drivers/demo/demo-shape.c%s: %d GPIOs
shape_ofdata_to_platdatacharacter"character"shape_statusshape_helloconst shapeconst shape[3]shape[3]shapesARRAY_SIZE(shapes)const shape *shape *HEIGHTWIDTHinsideHEIGHT / 2HEIGHT / 2 - 1WIDTH - HEIGHT / 2WIDTH - HEIGHT / 2 + 1shape_datadenddstartnum_charsconst demo_opsconst demo_ops *demo_ops *sizeof(struct shape_data)sizeof(struct dm_demo_pdata)_u_boot_list_2_driver_2_demo_shape_drv.u_boot_list_2_driver_2_demo_shape_drv"demo-shape"demo_shape_idshape_ops/* Parse the data that only we need *//* Parse the data that is common with all demo devices *//* Crazy little function to draw shapes on the console *//* Number of non-space characters output so far *//* Shape size *//opt/src/drivers/demo/demo-simple.cdemo-simpledemo_shape_ofdata_to_platdatasimple_helloHello from %08x: %s %d
"Hello from %08x: %s %d\n"_u_boot_list_2_driver_2_demo_simple_drv.u_boot_list_2_driver_2_demo_simple_drv"demo-simple"simple_ops/opt/src/drivers/demo/demo-uclass.cdemo-uclassdn"sides""colour""%s: Invalid device tree data\n"debug("%s: Invalid device tree data\n", __func__)drivers/demo/demo-uclass.c%s: Invalid device tree data
"demo"_u_boot_list_2_uclass_2_demo.u_boot_list_2_uclass_2_demo/opt/src/include/dma.hdma_dev_privdma_directionDMA_MEM_TO_MEMDMA_MEM_TO_DEVDMA_DEV_TO_MEMDMA_DEV_TO_DEVDMA_SUPPORTS_DEV_TO_DEVDMA_SUPPORTS_DEV_TO_MEMDMA_SUPPORTS_MEM_TO_DEVDMA_SUPPORTS_MEM_TO_MEM_DMA_H_CONFIG_DMA_CHANNELSCONFIG_IS_ENABLED(OF_CONTROL) && CONFIG_IS_ENABLED(DMA)dma_memcpydma_get_devicedma_senddma *dma_receivedma_prepare_rcv_bufdma_disabledma_enabledma_freedma_requestdma_get_by_namedma_get_by_indexDMACONFIG_VAL(DMA_MODULE)CONFIG_DMA_MODULE__ARG_PLACEHOLDER_CONFIG_DMA_MODULE__ARG_PLACEHOLDER_CONFIG_DMA_MODULE 1DMA_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_DMA_MODULECONFIG_VAL(DMA)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_DMACONFIG_DMA/* _DMA_H_ *//*
 * dma_memcpy - try to use DMA to do a mem copy which will be
 *		much faster than CPU mem copy
 *
 * @dst - destination pointer
 * @src - souce pointer
 * @len - data length to be copied
 * @return - on successful transfer returns no of bytes
	     transferred and on failure return error code.
 *//*
 * dma_get_device - get a DMA device which supports transfer
 * type of transfer_type
 *
 * @transfer_type - transfer type should be one/multiple of
 *		    DMA_SUPPORTS_*
 * @devp - udevice pointer to return the found device
 * @return - will return on success and devp will hold the
 *	     pointer to the device
 *//* CONFIG_DMA_CHANNELS *//**
 * dma_send() - Send a DMA transfer.
 *
 * @dma: A DMA struct that was previously successfully requested by
 *	 dma_request/get_by_*().
 * @src: The source pointer.
 * @len: Length of the data to be sent (number of bytes).
 * @metadata: DMA driver's channel specific data
 * @return zero on success, or -ve error code.
 *//**
 * dma_receive() - Receive a DMA transfer.
 *
 * @dma: A DMA struct that was previously successfully requested by
 *	 dma_request/get_by_*().
 * @dst: The destination pointer.
 * @metadata: DMA driver's channel specific data
 * @return length of received data on success, or zero - no data,
 * or -ve error code.
 *//**
 * dma_prepare_rcv_buf() - Prepare/add receive DMA buffer.
 *
 * It allows to implement zero-copy async DMA_DEV_TO_MEM (receive) transactions
 * if supported by DMA providers.
 *
 * @dma: A DMA struct that was previously successfully requested by
 *	 dma_request/get_by_*().
 * @dst: The receive buffer pointer.
 * @size: The receive buffer size
 * @return zero on success, or -ve error code.
 *//**
 * dma_disable() - Disable (turn off) a DMA channel.
 *
 * @dma: A DMA struct that was previously successfully requested by
 *	 dma_request/get_by_*().
 * @return zero on success, or -ve error code.
 *//**
 * dma_enable() - Enable (turn on) a DMA channel.
 *
 * @dma: A DMA struct that was previously successfully requested by
 *	 dma_request/get_by_*().
 * @return zero on success, or -ve error code.
 *//**
 * dma_free - Free a previously requested DMA.
 *
 * @dma: A DMA struct that was previously successfully requested by
 *	 dma_request/get_by_*().
 * @return 0 if OK, or a negative error code.
 *//**
 * dma_request - Request a DMA by provider-specific ID.
 *
 * This requests a DMA using a provider-specific ID. Generally, this function
 * should not be used, since dma_get_by_index/name() provide an interface that
 * better separates clients from intimate knowledge of DMA providers.
 * However, this function may be useful in core SoC-specific code.
 *
 * @dev: The DMA provider device.
 * @dma: A pointer to a DMA struct to initialize. The caller must
 *	 have already initialized any field in this struct which the
 *	 DMA provider uses to identify the DMA channel.
 * @return 0 if OK, or a negative error code.
 *//**
 * dma_get_by_name - Get/request a DMA by name.
 *
 * This looks up and requests a DMA. The name is relative to the client
 * device; each device is assumed to have n DMAs associated with it somehow,
 * and this function finds and requests one of them. The mapping of client
 * device DMA names to provider DMAs may be via device-tree properties,
 * board-provided mapping tables, or some other mechanism.
 *
 * @dev:	The client device.
 * @name:	The name of the DMA to request, within the client's list of
 *		DMA channels.
 * @dma:	A pointer to a DMA struct to initialize.
 * @return 0 if OK, or a negative error code.
 *//**
 * dma_get_by_index - Get/request a DMA by integer index.
 *
 * This looks up and requests a DMA. The index is relative to the client
 * device; each device is assumed to have n DMAs associated with it somehow,
 * and this function finds and requests one of them. The mapping of client
 * device DMA indices to provider DMAs may be via device-tree properties,
 * board-provided mapping tables, or some other mechanism.
 *
 * @dev:	The client device.
 * @index:	The index of the DMA to request, within the client's list of
 *		DMA channels.
 * @dma:	A pointer to a DMA struct to initialize.
 * @return 0 if OK, or a negative error code.
 *//*
	 * Written by of_xlate. We assume a single id is enough for now. In the
	 * future, we might add more fields here.
	 *//**
 * struct dma - A handle to (allowing control of) a single DMA.
 *
 * Clients provide storage for DMA handles. The content of the structure is
 * managed solely by the DMA API and DMA drivers. A DMA struct is
 * initialized by "get"ing the DMA struct. The DMA struct is passed to all
 * other DMA APIs to identify which DMA channel to operate upon.
 *
 * @dev: The device which implements the DMA channel.
 * @id: The DMA channel ID within the provider.
 *
 * Currently, the DMA API assumes that a single integer ID is enough to
 * identify and configure any DMA channel for any DMA provider. If this
 * assumption becomes invalid in the future, the struct could be expanded to
 * either (a) add more fields to allow DMA providers to store additional
 * information, or (b) replace the id field with an opaque pointer, which the
 * provider would dynamically allocated during its .of_xlate op, and process
 * during is .request op. This may require the addition of an extra op to clean
 * up the allocation.
 *//**
 * A DMA is a feature of computer systems that allows certain hardware
 * subsystems to access main system memory, independent of the CPU.
 * DMA channels are typically generated externally to the HW module
 * consuming them, by an entity this API calls a DMA provider. This API
 * provides a standard means for drivers to enable and disable DMAs, and to
 * copy, send and receive data using DMA.
 *
 * A driver that implements UCLASS_DMA is a DMA provider. A provider will
 * often implement multiple separate DMAs, since the hardware it manages
 * often has this capability. dma_uclass.h describes the interface which
 * DMA providers must implement.
 *
 * DMA consumers/clients are the HW modules driven by the DMA channels. This
 * header file describes the API used by drivers for those HW modules.
 *
 * DMA consumer DMA_MEM_TO_DEV (transmit) usage example (based on networking).
 * Note. dma_send() is sync operation always -  it'll start transfer and will
 * poll for it to complete:
 *	- get/request dma channel
 *	struct dma dma_tx;
 *	ret = dma_get_by_name(common->dev, "tx0", &dma_tx);
 *	if (ret) ...
 *
 *	- enable dma channel
 *	ret = dma_enable(&dma_tx);
 *	if (ret) ...
 *
 *	- dma transmit DMA_MEM_TO_DEV.
 *	struct ti_drv_packet_data packet_data;
 *
 *	packet_data.opt1 = val1;
 *	packet_data.opt2 = val2;
 *	ret = dma_send(&dma_tx, packet, length, &packet_data);
 *	if (ret) ..
 *
 * DMA consumer DMA_DEV_TO_MEM (receive) usage example (based on networking).
 * Note. dma_receive() is sync operation always - it'll start transfer
 * (if required) and will poll for it to complete (or for any previously
 * configured dev2mem transfer to complete):
 *	- get/request dma channel
 *	struct dma dma_rx;
 *	ret = dma_get_by_name(common->dev, "rx0", &dma_rx);
 *	if (ret) ...
 *
 *	- enable dma channel
 *	ret = dma_enable(&dma_rx);
 *	if (ret) ...
 *
 *	- dma receive DMA_DEV_TO_MEM.
 *	struct ti_drv_packet_data packet_data;
 *
 *	len = dma_receive(&dma_rx, (void **)packet, &packet_data);
 *	if (ret < 0) ...
 *
 * DMA consumer DMA_DEV_TO_MEM (receive) zero-copy usage example (based on
 * networking). Networking subsystem allows to configure and use few receive
 * buffers (dev2mem), as Networking RX DMA channels usually implemented
 * as streaming interface
 *	- get/request dma channel
 *	struct dma dma_rx;
 *	ret = dma_get_by_name(common->dev, "rx0", &dma_rx);
 *	if (ret) ...
 *
 *	for (i = 0; i < RX_DESC_NUM; i++) {
 *		ret = dma_prepare_rcv_buf(&dma_rx,
 *					  net_rx_packets[i],
 *					  RX_BUF_SIZE);
 *		if (ret) ...
 *	}
 *
 *	- enable dma channel
 *	ret = dma_enable(&dma_rx);
 *	if (ret) ...
 *
 *	- dma receive DMA_DEV_TO_MEM.
 *	struct ti_drv_packet_data packet_data;
 *
 *	len = dma_receive(&dma_rx, (void **)packet, &packet_data);
 *	if (ret < 0) ..
 *
 *	-- process packet --
 *
 *	- return buffer back to DAM channel
 *	ret = dma_prepare_rcv_buf(&dma_rx,
 *				  net_rx_packets[rx_next],
 *				  RX_BUF_SIZE);
 *//*
 * struct dma_dev_priv - information about a device used by the uclass
 *
 * @supported: mode of transfers that DMA can support, should be
 *	       one/multiple of DMA_SUPPORTS_*
 *//*
 * enum dma_direction - dma transfer direction indicator
 * @DMA_MEM_TO_MEM: Memcpy mode
 * @DMA_MEM_TO_DEV: From Memory to Device
 * @DMA_DEV_TO_MEM: From Device to Memory
 * @DMA_DEV_TO_DEV: From Device to Device
 *//*
 * Copyright (C) 2018 lvaro Fernndez Rojas <noltari@gmail.com>
 * Copyright (C) 2015 - 2018 Texas Instruments Incorporated <www.ti.com>
 * Written by Mugunthan V N <mugunthanvnm@ti.com>
 *
 */transfer_type/opt/src/include/dma-uclass.hdma-uclassdma_opstransferprepare_rcv_buf_DMA_UCLASS_H/* _DMA_UCLASS_H *//**
	 * transfer() - Issue a DMA transfer. The implementation must
	 *   wait until the transfer is done.
	 *
	 * @dev: The DMA device
	 * @direction: direction of data transfer (should be one from
	 *   enum dma_direction)
	 * @dst: The destination pointer.
	 * @src: The source pointer.
	 * @len: Length of the data to be copied (number of bytes).
	 * @return zero on success, or -ve error code.
	 *//**
	 * send() - Send a DMA transfer.
	 *
	 * @dma: The DMA Channel to manipulate.
	 * @src: The source pointer.
	 * @len: Length of the data to be sent (number of bytes).
	 * @metadata: DMA driver's specific data
	 * @return zero on success, or -ve error code.
	 *//**
	 * receive() - Receive a DMA transfer.
	 *
	 * @dma: The DMA Channel to manipulate.
	 * @dst: The destination pointer.
	 * @metadata: DMA driver's specific data
	 * @return zero on success, or -ve error code.
	 *//**
	 * prepare_rcv_buf() - Prepare/Add receive DMA buffer.
	 *
	 * @dma: The DMA Channel to manipulate.
	 * @dst: The receive buffer pointer.
	 * @size: The receive buffer size
	 * @return zero on success, or -ve error code.
	 *//**
	 * disable() - Disable a DMA Channel.
	 *
	 * @dma: The DMA Channel to manipulate.
	 * @return zero on success, or -ve error code.
	 *//**
	 * enable() - Enable a DMA Channel.
	 *
	 * @dma: The DMA Channel to manipulate.
	 * @return zero on success, or -ve error code.
	 *//**
	 * free - Free a previously requested dma.
	 *
	 * This is the implementation of the client dma_free() API.
	 *
	 * @dma: The DMA to free.
	 * @return 0 if OK, or a negative error code.
	 *//**
	 * request - Request a translated DMA.
	 *
	 * The DMA core calls this function as the second step in
	 * implementing a client's dma_get_by_*() call, following a successful
	 * xxx_xlate() call, or as the only step in implementing a client's
	 * dma_request() call.
	 *
	 * @dma: The DMA struct to request; this has been filled in by
	 *   a previoux xxx_xlate() function call, or by the caller of
	 *   dma_request().
	 * @return 0 if OK, or a negative error code.
	 *//**
	 * of_xlate - Translate a client's device-tree (OF) DMA specifier.
	 *
	 * The DMA core calls this function as the first step in implementing
	 * a client's dma_get_by_*() call.
	 *
	 * If this function pointer is set to NULL, the DMA core will use a
	 * default implementation, which assumes #dma-cells = <1>, and that
	 * the DT cell contains a simple integer DMA Channel.
	 *
	 * At present, the DMA API solely supports device-tree. If this
	 * changes, other xxx_xlate() functions may be added to support those
	 * other mechanisms.
	 *
	 * @dma: The dma struct to hold the translation result.
	 * @args:	The dma specifier values from device tree.
	 * @return 0 if OK, or a negative error code.
	 *//*
 * struct dma_ops - Driver model DMA operations
 *
 * The uclass interface is implemented by all DMA devices which use
 * driver model.
 *//* See dma.h for background documentation. */<dma.h>/opt/src/drivers/dma/dma-uclass.cconst dma_opsconst dma_ops *dma_ops *roundup(len, ARCH_DMA_MINALIGN)dma_dev_priv *UCLASS_DMA"No DMA device found that supports %x type\n"pr_err("No DMA device found that supports %x type\n",
		      transfer_type)pr_fmt("No DMA device found that supports %x type\n")No DMA device found that supports %x type
"%s(dma=%p)\n"__func__, dmadebug("%s(dma=%p)\n", __func__, dma)drivers/dma/dma-uclass.c%s(dma=%p)
/opt/src/drivers/dma<dma-uclass.h>"%s(dev=%p, dma=%p)\n"__func__, dev, dmadebug("%s(dev=%p, dma=%p)\n", __func__, dev, dma)%s(dev=%p, dma=%p)
"%s(dev=%p, name=%s, dma=%p)\n"__func__, dev, name, dmadebug("%s(dev=%p, name=%s, dma=%p)\n", __func__, dev, name, dma)%s(dev=%p, name=%s, dma=%p)
dma-names"dma-names""dev_read_stringlist_search() failed: %d\n"pr_err("dev_read_stringlist_search() failed: %d\n", index)pr_fmt("dev_read_stringlist_search() failed: %d\n")dev_read_stringlist_search() failed: %d
"%s(dev=%p, index=%d, dma=%p)\n"__func__, dev, index, dmadebug("%s(dev=%p, index=%d, dma=%p)\n", __func__, dev, index, dma)%s(dev=%p, index=%d, dma=%p)
assert(dma)dmas"dmas"#dma-cells"#dma-cells""%s: dev_read_phandle_with_args failed: err=%d\n"pr_err("%s: dev_read_phandle_with_args failed: err=%d\n",
		       __func__, ret)pr_fmt("%s: dev_read_phandle_with_args failed: err=%d\n")%s: dev_read_phandle_with_args failed: err=%d
dev_dma"%s: uclass_get_device_by_ofnode failed: err=%d\n"pr_err("%s: uclass_get_device_by_ofnode failed: err=%d\n",
		       __func__, ret)pr_fmt("%s: uclass_get_device_by_ofnode failed: err=%d\n")%s: uclass_get_device_by_ofnode failed: err=%d
pr_err("of_xlate() failed: %d\n", ret)pr_fmt("of_xlate() failed: %d\n")dma_of_xlate_defaultpr_err("Invaild args_count: %d\n", args->args_count)pr_fmt("Invaild args_count: %d\n")dma_dev_ops"dma"sizeof(struct dma_dev_priv)_u_boot_list_2_uclass_2_dma.u_boot_list_2_uclass_2_dma/* Invalidate the area, so no writeback into the RAM races with DMA *//*
 * Direct Memory Access U-Class driver
 *
 * Copyright (C) 2018 lvaro Fernndez Rojas <noltari@gmail.com>
 * Copyright (C) 2015 - 2018 Texas Instruments Incorporated <www.ti.com>
 * Written by Mugunthan V N <mugunthanvnm@ti.com>
 *
 * Author: Mugunthan V N <mugunthanvnm@ti.com>
 *//opt/src/drivers/dma/sandbox-dma-test.csandbox-dma-testsandbox_dma_probeDMA_SUPPORTS_MEM_TO_MEM |
			     DMA_SUPPORTS_MEM_TO_DEVDMA_SUPPORTS_MEM_TO_MEM |
			     DMA_SUPPORTS_MEM_TO_DEV |
			     DMA_SUPPORTS_DEV_TO_MEMsandbox_dma_dev *udSANDBOX_DMA_CH_CNT"Number of channels: %u\n"ud->ch_countpr_err("Number of channels: %u\n", ud->ch_count)pr_fmt("Number of channels: %u\n")Number of channels: %u
sandbox_dma_chan *sandbox_dma_chan[3]DMA chan%d
"DMA chan%d\n"sandbox_dma_prepare_rcv_bufsandbox_dma_receiveuchar[1024]SANDBOX_DMA_BUF_SIZE"%s(dma id=%lu len=%zu meta=%08x %p)\n"__func__, dma->id, ud->data_len, ud->meta, *dstdebug("%s(dma id=%lu len=%zu meta=%08x %p)\n",
	      __func__, dma->id, ud->data_len, ud->meta, *dst)drivers/dma/sandbox-dma-test.c%s(dma id=%lu len=%zu meta=%08x %p)
sandbox_dma_send"%s(dma id=%lu)\n"__func__, dma->iddebug("%s(dma id=%lu)\n", __func__, dma->id)%s(dma id=%lu)
"%s(dma id=%lu len=%zu meta=%08x)\n"__func__, dma->id, len, ud->metadebug("%s(dma id=%lu len=%zu meta=%08x)\n",
	      __func__, dma->id, len, ud->meta)%s(dma id=%lu len=%zu meta=%08x)
sandbox_dma_disable"%s(dma id=%lu enabled=%d)\n"__func__, dma->id, uc->enableddebug("%s(dma id=%lu enabled=%d)\n", __func__, dma->id, uc->enabled)%s(dma id=%lu enabled=%d)
sandbox_dma_enablesandbox_dma_free"%s(dma id=%lu in_use=%d)\n"__func__, dma->id, uc->in_usedebug("%s(dma id=%lu in_use=%d)\n", __func__, dma->id, uc->in_use)%s(dma id=%lu in_use=%d)
sandbox_dma_requestsandbox_dma_of_xlate"%s(dma id=%u)\n"__func__, args->args[0]debug("%s(dma id=%u)\n", __func__, args->args[0])%s(dma id=%u)
"%s(dma id=%lu dir=%d)\n"__func__, dma->id, uc->dirdebug("%s(dma id=%lu dir=%d)\n", __func__, dma->id, uc->dir)%s(dma id=%lu dir=%d)
sandbox_dma_transfersandbox_dma_chansandbox_dma_devin_usemetabuf_rxch_countsandbox-dma"sandbox-dma"sizeof(struct sandbox_dma_dev)_u_boot_list_2_driver_2_sandbox_dma.u_boot_list_2_driver_2_sandbox_dmasandbox_dmasandbox,dma"sandbox,dma"sandbox_dma_idssandbox_dma_ops/*
 * Direct Memory Access U-Class Simulation driver
 *
 * Copyright (C) 2018 Texas Instruments Incorporated <www.ti.com>
 *
 * Author: Grygorii Strashko <grygorii.strashko@ti.com>
 *//opt/src/drivers/fastboot/fb_command.cfb_commandreboot_bootloaderCannot set reboot flag"Cannot set reboot flag"
downloading of %d bytes finished
"\ndownloading of %d bytes finished\n"Received invalid data length"Received invalid data length"pre_dot_numBYTES_PER_DOTnow_dot_numdownloadExpected command parameter"Expected command parameter"Expected nonzero image size"Expected nonzero image size"Starting download of %d bytes
"Starting download of %d bytes\n"DATA"DATA"getvarcmd_parameterconst struct <unnamed>[7]struct <unnamed>[7]"command %s not recognized.\n"pr_err("command %s not recognized.\n", cmd_string)pr_fmt("command %s not recognized.\n")command %s not recognized.
unrecognized command"unrecognized command"dispatch"getvar""download"reboot-bootloader"reboot-bootloader"set_active"set_active"commandsfastboot_bytes_expectedfastboot_bytes_receivedCONFIG_IS_ENABLED(FASTBOOT_FLASH_MMC)CONFIG_IS_ENABLED(FASTBOOT_FLASH_NAND)/**
 * oem_format() - Execute the OEM format command
 *
 * @cmd_parameter: Pointer to command parameter
 * @response: Pointer to fastboot response buffer
 *//**
 * reboot_bootloader() - Sets reboot bootloader flag.
 *
 * @cmd_parameter: Pointer to command parameter
 * @response: Pointer to fastboot response buffer
 *//**
 * erase() - erase the indicated partition.
 *
 * @cmd_parameter: Pointer to partition name
 * @response: Pointer to fastboot response buffer
 *
 * Erases the partition indicated by cmd_parameter (clear to 0x00s). Writes
 * to response.
 *//**
 * flash() - write the downloaded image to the indicated partition.
 *
 * @cmd_parameter: Pointer to partition name
 * @response: Pointer to fastboot response buffer
 *
 * Writes the previously downloaded image to the partition indicated by
 * cmd_parameter. Writes to response.
 *//* Download complete. Respond with "OKAY" *//* Download data to fastboot_buf_addr *//**
 * fastboot_data_download() - Copy image data to fastboot_buf_addr.
 *
 * @fastboot_data: Pointer to received fastboot data
 * @fastboot_data_len: Length of received fastboot data
 * @response: Pointer to fastboot response buffer
 *
 * Copies image data from fastboot_data to fastboot_buf_addr. Writes to
 * response. fastboot_bytes_received is updated to indicate the number
 * of bytes that have been transferred.
 *
 * On completion sets image_size and ${filesize} to the total size of the
 * downloaded image.
 *//*
	 * Nothing to download yet. Response is of the form:
	 * [DATA|FAIL]$cmd_parameter
	 *
	 * where cmd_parameter is an 8 digit hexadecimal number
	 *//**
 * fastboot_download() - Start a download transfer from the client
 *
 * @cmd_parameter: Pointer to command parameter
 * @response: Pointer to fastboot response buffer
 *//**
 * getvar() - Read a config/version variable
 *
 * @cmd_parameter: Pointer to command parameter
 * @response: Pointer to fastboot response buffer
 *//**
 * okay() - Send bare OKAY response
 *
 * @cmd_parameter: Pointer to command parameter
 * @response: Pointer to fastboot response buffer
 *
 * Send a bare OKAY fastboot response. This is used where the command is
 * valid, but all the work is done after the response has been sent (e.g.
 * boot, reboot etc.)
 *//**
 * fastboot_handle_command - Handle fastboot command
 *
 * @cmd_string: Pointer to command string
 * @response: Pointer to fastboot response buffer
 *
 * Return: Executed command, or -1 if not recognized
 *//**
 * fastboot_bytes_expected - number of bytes expected in the current download
 *//**
 * fastboot_bytes_received - number of bytes received in the current download
 *//**
 * image_size - final fastboot image size
 *//opt/src/include/fastboot-internal.h/opt/src/include/fb_mmc.h/opt/src/include/fb_nand.h/opt/src/drivers/fastboot<fb_nand.h><fb_mmc.h><fastboot-internal.h>/opt/src/include/net/fastboot.hfastboot_start_server__NET_FASTBOOT_H__/* __NET_FASTBOOT_H__ *//**
 * Wait for incoming fastboot comands.
 *//*
 *	Global functions and variables.
 *//* SPDX-License-Identifier: BSD-2-Clause
 *
 * Copyright (C) 2016 The Android Open Source Project
 *//opt/src/include/net/opt/src/drivers/fastboot/fb_common.cfb_common(void *)CONFIG_FASTBOOT_BUF_ADDRfastboot_bootcmd"fastboot_bootcmd"char *const[3]boot_addr_startbootm_argssizeof(boot_addr_start)sizeof(boot_addr_start) - 1Booting kernel at %s...


"Booting kernel at %s...\n\n\n"fastboot_get_progress_callbackOKAY"OKAY"FAIL"FAIL"fastboot_progress_callbackfastboot_buf_sizefastboot_buf_addr/*
		 * This only happens if image is somehow faulty so we start
		 * over. We deliberately leave this policy to the invocation
		 * of fastbootcmd if that's what's being run
		 *//**
 * fastboot_get_progress_callback() - Return progress callback
 *
 * Return: Pointer to function called during long operations
 *//**
 * fastboot_progress_callback - callback executed during long operations
 *//**
 * fastboot_buf_size - size of the fastboot download buffer
 *//**
 * fastboot_buf_addr - base address of the fastboot download buffer
 */<net/fastboot.h>fastboot-internal_FASTBOOT_INTERNAL_H_fastboot_getvar/**
 * fastboot_getvar() - Writes variable indicated by cmd_parameter to response.
 *
 * @cmd_parameter: Pointer to command parameter
 * @response: Pointer to fastboot response buffer
 *
 * Look up cmd_parameter first as an environment variable of the form
 * fastboot.<cmd_parameter>, if that exists return use its value to set
 * response.
 *
 * Otherwise lookup the name of variable and execute the appropriate
 * function to return the requested value.
 */fb_mmcfastboot_mmc_erasefastboot_mmc_flash_writefastboot_mmc_get_part_info_FB_MMC_H_/**
 * fastboot_mmc_flash_erase() - Erase eMMC for fastboot
 *
 * @cmd: Named partition to erase
 * @response: Pointer to fastboot response buffer
 *//**
 * fastboot_mmc_flash_write() - Write image to eMMC for fastboot
 *
 * @cmd: Named partition to write image to
 * @download_buffer: Pointer to image data
 * @download_bytes: Size of image data
 * @response: Pointer to fastboot response buffer
 *//**
 * fastboot_mmc_get_part_info() - Lookup eMMC partion by name
 *
 * @part_name: Named partition to lookup
 * @dev_desc: Pointer to returned blk_desc pointer
 * @part_info: Pointer to returned disk_partition_t
 * @response: Pointer to fastboot response buffer
 *//*
 * Copyright 2014 Broadcom Corporation.
 */download_bufferdownload_bytespart_namefb_nandfastboot_nand_erasefastboot_nand_flash_writefastboot_nand_get_part_info_FB_NAND_H_/**
 * fastboot_nand_flash_erase() - Erase NAND for fastboot
 *
 * @cmd: Named device to erase
 * @response: Pointer to fastboot response buffer
 *//**
 * fastboot_nand_flash_write() - Write image to NAND for fastboot
 *
 * @cmd: Named device to write image to
 * @download_buffer: Pointer to image data
 * @download_bytes: Size of image data
 * @response: Pointer to fastboot response buffer
 *//**
 * fastboot_nand_get_part_info() - Lookup NAND partion by name
 *
 * @part_name: Named device to lookup
 * @part_info: Pointer to returned part_info pointer
 * @response: Pointer to fastboot response buffer
 *//*
 * Copyright 2014 Broadcom Corporation.
 * Copyright 2015 Free Electrons.
 *//opt/src/drivers/fastboot/fb_getvar.cfb_getvarmissing var"missing var"var_parameterenvstrsizeof(envstr)sizeof(envstr) - 1fastboot.%sFASTBOOT_ENV_PREFIX "%s"const struct <unnamed>[11]struct <unnamed>[11]getvar_dispatchARRAY_SIZE(getvar_dispatch)"WARNING: unknown variable: %s\n"pr_fmt("WARNING: unknown variable: %s\n")WARNING: unknown variable: %s
Variable not implemented"Variable not implemented"getvar_slot_suffixesa,b"a,b"getvar_current_slot"a"getvar_platform"platform"platform not set"platform not set"getvar_productBoard not set"Board not set"getvar_version_basebandN/A"N/A"getvar_serialnoValue not set"Value not set"getvar_downloadsize0x%08x"0x%08x"getvar_bootloader_versionU-Boot 2019.10-rc1-dirtygetvar_version0.4variableFASTBOOT_FLASH_MMCCONFIG_VAL(FASTBOOT_FLASH_MMC)CONFIG_FASTBOOT_FLASH_MMC__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_FASTBOOT_FLASH_MMC__ARG_PLACEHOLDER_CONFIG_FASTBOOT_FLASH_MMC__ARG_PLACEHOLDER_CONFIG_FASTBOOT_FLASH_MMC 1CONFIG_VAL(FASTBOOT_FLASH_MMC_MODULE)CONFIG_FASTBOOT_FLASH_MMC_MODULEFASTBOOT_FLASH_MMC_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_FASTBOOT_FLASH_MMC_MODULE__ARG_PLACEHOLDER_CONFIG_FASTBOOT_FLASH_MMC_MODULE__ARG_PLACEHOLDER_CONFIG_FASTBOOT_FLASH_MMC_MODULE 1bootloader-version"bootloader-version"version-bootloader"version-bootloader"downloadsize"downloadsize"max-download-size"max-download-size"serialno"serialno"version-baseband"version-baseband""product"current-slot"current-slot"slot-suffixes"slot-suffixes"FASTBOOT_ENV_PREFIX"fastboot."/* At this point response is filled with okay or fail string *//* part exists but not slotted *//* part exists and slotted *//* part_name_wslot = part_name + "_a" *//* A/B not implemented, for now always return "a" *//**
 * Get partition number and size for any storage type.
 *
 * Can be used to check if partition with specified name exists.
 *
 * If error occurs, this function guarantees to fill @p response with fail
 * string. @p response can be rewritten in caller, if needed.
 *
 * @param[in] part_name Info for which partition name to look for
 * @param[in,out] response Pointer to fastboot response buffer
 * @param[out] size If not NULL, will contain partition size (in blocks)
 * @return Partition number or negative value on error
 *//opt/src/drivers/firmware/firmware-sandbox.cfirmware-sandboxsandbox_firmware"sandbox_firmware"UCLASS_FIRMWARE_u_boot_list_2_driver_2_sandbox_firmware.u_boot_list_2_driver_2_sandbox_firmwaresandbox,firmware"sandbox,firmware"generic_sandbox_firmware_ids/*
 * sandbox firmware driver
 *
 * Copyright (C) 2018 Xilinx, Inc.
 *//opt/src/drivers/firmware/opt/src/drivers/firmware/firmware-uclass.cfirmware-uclass_u_boot_list_2_uclass_2_firmware.u_boot_list_2_uclass_2_firmware/* Firmware access is platform-dependent.  No generic code in uclass *//opt/src/include/dt-bindings/gpio/gpio.hGPIO_TRANSITORYGPIO_PERSISTENTGPIO_OPEN_SOURCE(GPIO_SINGLE_ENDED | GPIO_LINE_OPEN_SOURCE)GPIO_OPEN_DRAIN(GPIO_SINGLE_ENDED | GPIO_LINE_OPEN_DRAIN)GPIO_LINE_OPEN_DRAINGPIO_LINE_OPEN_SOURCEGPIO_SINGLE_ENDEDGPIO_PUSH_PULLGPIO_ACTIVE_LOWGPIO_ACTIVE_HIGH_DT_BINDINGS_GPIO_GPIO_H/* Bit 3 express GPIO suspend/resume and reset persistence *//*
 * Open Drain/Collector is the combination of single-ended open drain interface.
 * Open Source/Emitter is the combination of single-ended open source interface.
 *//* Bit 2 express Open drain or open source *//* Bit 1 express single-endedness *//* Bit 0 express polarity *//*
 * This header provides constants for most GPIO bindings.
 *
 * Most GPIO bindings include a flags cell as part of the GPIO specifier.
 * In most cases, the format of the flags cell uses the standard values
 * defined in this header.
 *//opt/src/include/dt-bindings/gpio/opt/src/include/dt-bindingsdt-bindings/opt/src/drivers/gpio/gpio-uclass.cgpio-uclassgpio_post_bindCONFIG_GPIO_HOG__ARG_PLACEHOLDER_CONFIG_GPIO_HOGIS_ENABLED(CONFIG_GPIO_HOG)CONFIG_GPIO_HOG_MODULE__ARG_PLACEHOLDER_CONFIG_GPIO_HOG_MODULE__ARG_PLACEHOLDER_CONFIG_GPIO_HOG_MODULE 1__ARG_PLACEHOLDER_CONFIG_GPIO_HOG 1gpio-hog"gpio-hog"gpio_hog"gpio_hog"gpio_pre_removegpio_dev_priv *gpio_post_probegpio_renumber#gpio-cells"#gpio-cells""%s: Node '%s', property '%s', GPIO count failed: %d\n"__func__, dev->name, list_name, retdebug("%s: Node '%s', property '%s', GPIO count failed: %d\n",
		      __func__, dev->name, list_name, ret)/opt/src/drivers/gpio<dt-bindings/gpio/gpio.h>removed_devdrivers/gpio/gpio-uclass.c928%s: Node '%s', property '%s', GPIO count failed: %d
_gpio_request_by_name_nodevgpio_request_tail"%s: uclass_get_device_by_ofnode failed\n"debug("%s: uclass_get_device_by_ofnode failed\n",
			      __func__)818%s: uclass_get_device_by_ofnode failed
"%s: gpio_find_and_xlate failed\n"debug("%s: gpio_find_and_xlate failed\n", __func__)%s: gpio_find_and_xlate failed
%s.%s%d"%s.%s%d""%s: dm_gpio_requestf failed\n"debug("%s: dm_gpio_requestf failed\n", __func__)830%s: dm_gpio_requestf failed
"%s: dm_gpio_set_dir failed\n"debug("%s: dm_gpio_set_dir failed\n", __func__)835add_indexgpio_dev%s: dm_gpio_set_dir failed
"%s: Node '%s', property '%s', failed to request GPIO index %d: %d\n"__func__, nodename, list_name, index, retdebug("%s: Node '%s', property '%s', failed to request GPIO index %d: %d\n",
	      __func__, nodename, list_name, index, ret)842%s: Node '%s', property '%s', failed to request GPIO index %d: %d
vectorbitmask__compiletime_assert_670GPIOF_COUNT != ARRAY_SIZE(gpio_function)GPIOF_COUNT != (sizeof(gpio_function) / sizeof((gpio_function)[0]))"BUILD_BUG_ON failed: " "GPIOF_COUNT != ARRAY_SIZE(gpio_function)"!(GPIOF_COUNT != (sizeof(gpio_function) / sizeof((gpio_function)[0])))670BUILD_BUG_ON(GPIOF_COUNT != ARRAY_SIZE(gpio_function))const char *const[5]gpio_functionGPIOF_COUNT != ARRAY_SIZE(gpio_function))%s%d: %s"%s%d: %s"dm_gpio_ops *: %d [%c]%s%s": %d [%c]%s%s"__compiletime_assert_628skip_unusedARRAY_SIZE(gpio_function)assert(priv)set_dir"set_dir"desc->dev"set_open_drain""get_open_drain""set_value""get_value"dir_output"dir_output"desc.devdir_input"dir_input"check_reserved%s: %s: error: gpio %s%d not reserved
"%s: %s: error: gpio %s%d not reserved\n"_dm_gpio_freedm_gpio_requestfgpio_find_and_xlatenumeric*nameisdigit(*name)gpio_to_device"gpio"sizeof(struct gpio_dev_priv)_u_boot_list_2_uclass_2_gpio.u_boot_list_2_uclass_2_gpio"input""output""unused""func"!defined(CONFIG_SPL_BUILD) || !defined(CONFIG_USE_TINY_PRINTF)BUILD_BUG_ON failed: GPIOF_COUNT != ARRAY_SIZE(gpio_function)/* Ensure that we have a base for each bank *//* We need to renumber the GPIOs when any driver is probed/removed *//* For now, we don't do any checking of dev *//*
	 * This isn't ideal since we don't use dev->name in the debug()
	 * calls in gpio_request_by_name(), but we can do this until
	 * gpio_request_list_by_name_nodev() can be dropped.
	 *//* We ran out of GPIOs in the list *//**
 * gpio_request_tail: common work for requesting a gpio.
 *
 * ret:		return value from previous work in function which calls
 *		this function.
 *		This seems bogus (why calling this function instead not
 *		calling it and end caller function instead?).
 *		Because on error in caller function we want to set some
 *		default values in gpio desc and have a common error
 *		debug message, which provides this function.
 * nodename:	Name of node for which gpio gets requested
 *		used for gpio label name.
 * args:	pointer to output arguments structure
 * list_name:	Name of GPIO list
 *		used for gpio label name.
 * index:	gpio index in gpio list
 *		used for gpio label name.
 * desc:	pointer to gpio descriptor, filled from this
 *		function.
 * flags:	gpio flags to use.
 * add_index:	should index added to gpio label name
 * gpio_dev:	pointer to gpio device from which the gpio
 *		will be requested. If NULL try to get the
 *		gpio device with uclass_get_device_by_ofnode()
 *
 * return:	In error case this function sets default values in
 *		gpio descriptor, also emmits a debug message.
 *		On success it returns 0 else the error code from
 *		function calls, or the error code passed through
 *		ret to this function.
 *
 *//*
 * get a number comprised of multiple GPIO values. gpio_num_array points to
 * the array of gpio pin numbers to scan, terminated by -1.
 *//* Must be called on an active device *//**
 * gpio_set_value() - [COMPAT] Configure logical value on GPIO pin
 * gpio:	GPIO number
 * value:	Logical value to be set on the GPIO pin.
 *
 * This function implements the API that's compatible with current
 * GPIO API used in U-Boot. The request is forwarded to particular
 * GPIO driver. Returns 0 on success, negative value on error.
 *//**
 * gpio_get_value() - [COMPAT] Sample GPIO pin and return it's value
 * gpio:	GPIO number
 *
 * This function implements the API that's compatible with current
 * GPIO API used in U-Boot. The request is forwarded to particular
 * GPIO driver. Returns the value of the GPIO pin, or negative value
 * on error.
 *//*
	 * Update desc->flags here, so that GPIO_ACTIVE_LOW is honoured in
	 * futures
	 *//* feature not supported -> ignore setting *//**
 * gpio_direction_output() - [COMPAT] Set GPIO direction to output and set value
 * gpio:	GPIO number
 * value:	Logical value to be set on the GPIO pin
 *
 * This function implements the API that's compatible with current
 * GPIO API used in U-Boot. The request is forwarded to particular
 * GPIO driver. Returns 0 on success, negative value on error.
 *//**
 * gpio_direction_input() - [COMPAT] Set GPIO direction to input
 * gpio:	GPIO number
 *
 * This function implements the API that's compatible with current
 * GPIO API used in U-Boot. The request is forwarded to particular
 * GPIO driver. Returns 0 on success, negative value on error.
 *//**
 * gpio_free() - [COMPAT] Relinquish GPIO
 * gpio:	GPIO number
 *
 * This function implements the API that's compatible with current
 * GPIO API used in U-Boot. The request is forwarded to particular
 * GPIO driver. Returns 0 on success, negative value on error.
 *//**
 * gpio_requestf() - [COMPAT] Request GPIO
 * @gpio:	GPIO number
 * @fmt:	Format string for the requested GPIO
 * @...:	Arguments for the printf() format string
 *
 * This function implements the API that's compatible with current
 * GPIO API used in U-Boot. The request is forwarded to particular
 * GPIO driver. Returns 0 on success, negative value on error.
 *//**
 * gpio_request() - [COMPAT] Request GPIO
 * gpio:	GPIO number
 * label:	Name for the requested GPIO
 *
 * The label is copied and allocated so the caller does not need to keep
 * the pointer around.
 *
 * This function implements the API that's compatible with current
 * GPIO API used in U-Boot. The request is forwarded to particular
 * GPIO driver. Returns 0 on success, negative value on error.
 *//* Allow GPIOs to be numbered from 0 *//* No such GPIO *//**
 * gpio_to_device() - Convert global GPIO number to device, number
 *
 * Convert the GPIO number to an entry in the list of GPIOs
 * or GPIO blocks registered with the GPIO controller. Returns
 * entry on success, NULL on error.
 *
 * @gpio:	The numeric representation of the GPIO
 * @desc:	Returns description (desc->flags will always be 0)
 * @return 0 if found, -ENOENT if not found
 *//opt/src/drivers/gpio/pm8916_gpio.cpm8916_gpiopm8941_pwrkey_ofdata_to_platdatagpio-bank-name"gpio-bank-name"pm8916_key"pm8916_key"pm8941_pwrkey_probepm8916_gpio_bank *REG_TYPEREG_SUBTYPEpm8941_pwrkey_get_valuePON_INT_RT_STSKPDPWR_ON_INT_BITBIT(KPDPWR_ON_INT_BIT)RESIN_ON_INT_BITBIT(RESIN_ON_INT_BIT)pm8941_pwrkey_get_functionpm8916_gpio_ofdata_to_platdatagpio-count"gpio-count"pm8916"pm8916"pm8916_gpio_probepm8916_gpio_set_valueREG_OFFSET(offset)REG_CTLREG_CTL_OUTPUT_MASKpm8916_gpio_get_valueREG_STATUSREG_STATUS_VAL_MASKpm8916_gpio_get_functionREG_CTL_MODE_MASKREG_CTL_MODE_INPUTREG_CTL_MODE_INOUTREG_CTL_MODE_OUTPUT/opt/src/include/spmi/spmi.h<spmi/spmi.h>pm8916_gpio_direction_outputpm8916_gpio_direction_inputpm8916_gpio_set_directionREG_EN_CTLREG_EN_CTL_ENABLEREG_DIG_PULL_CTLREG_DIG_PULL_NO_PUREG_DIG_VIN_CTLREG_DIG_VIN_VIN0REG_DIG_OUT_CTLREG_DIG_OUT_CTL_CMOSREG_DIG_OUT_CTL_DRIVE_LREG_DIG_OUT_CTL_CMOS |
				     REG_DIG_OUT_CTL_DRIVE_Lpm8916_gpio_bankpwrkey_pm8916"pwrkey_pm8916"const dm_gpio_opsconst dm_gpio_ops *sizeof(struct pm8916_gpio_bank)_u_boot_list_2_driver_2_pwrkey_pm8941.u_boot_list_2_driver_2_pwrkey_pm8941pwrkey_pm8941qcom,pm8916-pwrkey"qcom,pm8916-pwrkey"qcom,pm8994-pwrkey"qcom,pm8994-pwrkey"pm8941_pwrkey_idspm8941_pwrkey_opsgpio_pm8916"gpio_pm8916"_u_boot_list_2_driver_2_gpio_pm8916.u_boot_list_2_driver_2_gpio_pm8916qcom,pm8916-gpio"qcom,pm8916-gpio"qcom,pm8994-gpio"qcom,pm8994-gpio"pm8916_gpio_idspm8916_gpio_ops(0x0 << 4)REG_OFFSET(x)((x) * 0x100)/* Do a sanity check *//* Reset button *//* Power button *//* Add pmic buttons as GPIO as well - there is no generic way for now *//* 22 GPIO's *//* Set the output value of the gpio *//* Enable the GPIO *//* Set the right dig out control *//* Select the VIN - VIN0, pin is input so it doesn't matter *//* Configure output pin drivers if needed *//* Set the right pull (no pull) *//* Select the mode *//* Disable the GPIO *//* Peripheral ID on SPMI bus *//* MODE_CTL *//* Type and subtype are shared for all pm8916 peripherals *//* Register maps *//* Register offset for each gpio *//*
 * Qualcomm pm8916 pmic gpio driver - part of Qualcomm PM8916 PMIC
 *
 * (C) Copyright 2015 Mateusz Kulikowski <mateusz.kulikowski@gmail.com>
 *//opt/src/drivers/gpio/sandbox.cgpio_sandbox_removegpio_sandbox_probeCONFIG_SANDBOX_GPIO_COUNTsizeof(struct gpio_state)sandbox_gpio_ofdata_to_platdatasandbox,gpio-count"sandbox,gpio-count"sb_gpio_xlatesb_gpio_get_functionsb_gpio_set_open_drain"%s: offset:%u, value = %d\n"__func__, offset, valuedebug("%s: offset:%u, value = %d\n", __func__, offset, value)drivers/gpio/sandbox.c%s: offset:%u, value = %d
sandbox_gpio: error: set_open_drain on input gpio %u
"sandbox_gpio: error: set_open_drain on input gpio %u\n"sb_gpio_get_open_drain"%s: offset:%u\n"__func__, offsetdebug("%s: offset:%u\n", __func__, offset)%s: offset:%u
sb_gpio_set_valuesandbox_gpio: error: set_value on input gpio %u
"sandbox_gpio: error: set_value on input gpio %u\n"sb_gpio_get_valuesb_gpio_direction_outputsb_gpio_direction_inputGPIOF_ODRGPIOF_HIGH"sandbox_gpio: get_value on output gpio %u\n"debug("sandbox_gpio: get_value on output gpio %u\n", offset)sandbox_gpio: get_value on output gpio %u
set_gpio_flagget_gpio_flagget_gpio_flagsinvalid_flagssandbox_gpio: error: invalid gpio %u
"sandbox_gpio: error: invalid gpio %u\n"gpio_state *gpio_state_u_boot_list_2_driver_2_gpio_sandbox.u_boot_list_2_driver_2_gpio_sandboxsandbox,gpio"sandbox,gpio"sandbox_gpio_idsgpio_sandbox_ops/* Tell the uclass how many GPIOs we have *//* write GPIO ODR value to port 'offset' *//* read GPIO ODR value of port 'offset' *//* write GPIO OUT value to port 'offset' *//* read GPIO IN value of port 'offset' *//* set GPIO port 'offset' as an output, with polarity 'value' *//* set GPIO port 'offset' as an input *//*
 * These functions implement the public interface within U-Boot
 *//*
 * Back-channel sandbox-internal-only access to GPIO state
 *//* Access routines for GPIO state *//* flags (GPIOF_...) *//* label given by requester *//* Currently set to open drain mode *//* Currently set high *//* Currently set as an output *//* Flags for each GPIO *//opt/src/include/hwspinlock.hhwspinlock_opsrelaxhwspinlock *_HWSPINLOCK_H_CONFIG_IS_ENABLED(DM_HWSPINLOCK)hwspinlock_unlockhwspinlock_lock_timeouthwspinlock_get_by_indexDM_HWSPINLOCKCONFIG_VAL(DM_HWSPINLOCK_MODULE)CONFIG_DM_HWSPINLOCK_MODULE__ARG_PLACEHOLDER_CONFIG_DM_HWSPINLOCK_MODULE__ARG_PLACEHOLDER_CONFIG_DM_HWSPINLOCK_MODULE 1DM_HWSPINLOCK_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_DM_HWSPINLOCK_MODULECONFIG_VAL(DM_HWSPINLOCK)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_DM_HWSPINLOCKCONFIG_DM_HWSPINLOCK/* _HWSPINLOCK_H_ *//**
	 * Relax - optional
	 *       Platform-specific relax method, called by hwspinlock core
	 *       while spinning on a lock, between two successive call to
	 *       lock
	 *
	 * @dev:	hwspinlock Device
	 *//**
	 * Unlock the hardware spinlock
	 *
	 * @dev:	hwspinlock Device
	 * @index:	index of the lock to be unlocked
	 * @return 0 if OK, -ve on error
	 *//**
	 * Lock the hardware spinlock
	 *
	 * @dev:	hwspinlock Device
	 * @index:	index of the lock to be used
	 * @return 0 if OK, -ve on error
	 *//**
	 * of_xlate - Translate a client's device-tree (OF) hardware specifier.
	 *
	 * The hardware core calls this function as the first step in
	 * implementing a client's hwspinlock_get_by_*() call.
	 *
	 * @hws:	The hardware spinlock struct to hold the translation
	 *			result.
	 * @args:	The hardware spinlock specifier values from device tree.
	 * @return 0 if OK, or a negative error code.
	 *//**
 * struct hwspinlock_ops - Driver model hwspinlock operations
 *
 * The uclass interface is implemented by all hwspinlock devices which use
 * driver model.
 *//* CONFIG_DM_HWSPINLOCK *//**
 * Unlock the hardware spinlock
 *
 * @hws:	A hardware spinlock struct that previously requested by
 *		hwspinlock_get_by_index
 * @return: 0 if OK, -ve on error
 *//**
 * Lock the hardware spinlock
 *
 * @hws:	A hardware spinlock struct that previously requested by
 *		hwspinlock_get_by_index
 * @timeout:	Timeout value in msecs
 * @return: 0 if OK, -ETIMEDOUT if timeout, -ve on other errors
 *//**
 * hwspinlock_get_by_index - Get a hardware spinlock by integer index
 *
 * This looks up and request a hardware spinlock. The index is relative to the
 * client device; each device is assumed to have n hardware spinlock associated
 * with it somehow, and this function finds and requests one of them.
 *
 * @dev:	The client device.
 * @index:	The index of the hardware spinlock to request, within the
 *		client's list of hardware spinlock.
 * @hws:	A pointer to a hardware spinlock struct to initialize.
 * @return 0 if OK, or a negative error code.
 *//**
 * struct hwspinlock - A handle to (allowing control of) a single hardware
 * spinlock.
 *
 * @dev: The device which implements the hardware spinlock.
 * @id: The hardware spinlock ID within the provider.
 *//**
 * Implement a hwspinlock uclass.
 * Hardware spinlocks are used to perform hardware protection of
 * critical sections and synchronisation between multiprocessors.
 *//* SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause */hws/opt/src/drivers/hwspinlock/hwspinlock-uclass.chwspinlock-uclasshwspinlock_post_bindassert(hws)drivers/hwspinlock/hwspinlock-uclass.cconst hwspinlock_opsconst hwspinlock_ops *hwspinlock_ops *ETIMEDOUT-110-ETIMEDOUThwlocks"hwlocks"#hwlock-cells"#hwlock-cells""%s: dev_read_phandle_with_args: err=%d\n"dev_dbg(dev, "%s: dev_read_phandle_with_args: err=%d\n",
			__func__, ret)%s: dev_read_phandle_with_args: err=%d
UCLASS_HWSPINLOCKdev_hwsdev_dbg(dev,
			"%s: uclass_get_device_by_of_offset failed: err=%d\n",
			__func__, ret)dev_dbg(dev, "of_xlate() failed: %d\n", ret)hwspinlock_of_xlate_defaulthwspinlock_dev_ops"hwspinlock"/opt/src/drivers/hwspinlock<hwspinlock.h>_u_boot_list_2_uclass_2_hwspinlock.u_boot_list_2_uclass_2_hwspinlock// SPDX-License-Identifier: GPL-2.0+ OR BSD-3-Clause/opt/src/drivers/hwspinlock/sandbox_hwspinlock.csandbox_hwspinlocksandbox_unlocksandbox_lockhwspinlock_sandbox"hwspinlock_sandbox"_u_boot_list_2_driver_2_hwspinlock_sandbox.u_boot_list_2_driver_2_hwspinlock_sandboxsandbox,hwspinlock"sandbox,hwspinlock"sandbox_hwspinlock_idssandbox_hwspinlock_ops/opt/src/include/power/tps65090.htps65090TPS65090_ST1_OTCTPS65090_ST1_OCCTPS65090_ST1_STATE_SHIFTTPS65090_ST1_STATE_MASK0xf << TPS65090_ST1_STATE_SHIFTIRQ1_VBATGCG_CTRL0_ENC_MASKMAX_FET_NUMMAX_CTRL_READ_TRIESFET_CTRL_TOFETFET_CTRL_PGFETFET_CTRL_WAIT3 << 2FET_CTRL_ADENFETFET_CTRL_ENFETREG_IRQ1REG_CG_CTRL0REG_CG_STATUS10xaREG_FET_BASEREG_FET1_CTRLREG_FET2_CTRLREG_FET3_CTRLREG_FET4_CTRLREG_FET5_CTRLREG_FET6_CTRLREG_FET7_CTRLTPS65090_NUM_REGSTPS65090_FET_DRIVER"tps65090_fet"TPS65090_I2C_ADDR__TPS65090_PMIC_H_/* __TPS65090_PMIC_H_ *//* Drivers name *//* Status register fields *//* Enable FET *//* Enable output auto discharge *//* Overcurrent timeout max *//* Power good for FET status *//* Timeout, startup, overload *//* TPS65090 FET_CTRL register values *//* Not a real register, FETs count from here *//* TPS65090 register addresses *//* I2C device address for TPS65090 PMU *//opt/src/drivers/i2c/cros_ec_ldo.ccros_ec_ldocros_ec_ldo_xfer"%s: Invalid message\n"debug("%s: Invalid message\n", __func__)drivers/i2c/cros_ec_ldo.c%s: Invalid message
fet_id"%s: Invalid FET %d\n"__func__, fet_iddebug("%s: Invalid FET %d\n", __func__, fet_id)%s: Invalid FET %d
is_readFET_CTRL_ENFET | FET_CTRL_PGFETcros_ec_ldo_set_bus_speedcros_ec_ldo_tunnel"cros_ec_ldo_tunnel"const dm_i2c_opsconst dm_i2c_ops *dm_i2c_ops *_u_boot_list_2_driver_2_cros_ec_ldo.u_boot_list_2_driver_2_cros_ec_ldogoogle,cros-ec-ldo-tunnel"google,cros-ec-ldo-tunnel"cros_ec_i2c_idscros_ec_i2c_ops/* Indicate that the message is unimplemented *//*
	 * Look for reads and writes of the LDO registers. In either case the
	 * first message is a write with the register number as the first byte.
	 *//opt/src/drivers/i2c<power/tps65090.h>/opt/src/drivers/i2c/cros_ec_tunnel.ccros_ec_tunnelcros_ec_i2c_ofdata_to_platdatacros_ec_i2c_bus *google,remote-bus"google,remote-bus"cros_ec_i2c_xfercros_ec_i2c_set_bus_speedcros_ec_i2c_busremote_bus"cros_ec_tunnel"sizeof(struct cros_ec_i2c_bus)_u_boot_list_2_driver_2_cros_ec_tunnel.u_boot_list_2_driver_2_cros_ec_tunnelgoogle,cros-ec-i2c-tunnel"google,cros-ec-i2c-tunnel"/opt/src/drivers/i2c/i2c-emul-uclass.ci2c-emul-uclassUCLASS_I2C_EMULsandbox,emul"sandbox,emul""No emulators for device '%s'\n", dev->name"No emulators for device '%s'\n"log_err("No emulators for device '%s'\n", dev->name)drivers/i2c/i2c-emul-uclass.cNo emulators for device '%s'
i2c_emul_uc_platdata *uc_plati2c_emul_uc_platdatai2c_emul_parent_drv"i2c_emul_parent_drv"UCLASS_I2C_EMUL_PARENT_u_boot_list_2_driver_2_i2c_emul_parent_drv.u_boot_list_2_driver_2_i2c_emul_parent_drvsandbox,i2c-emul-parent"sandbox,i2c-emul-parent"i2c_emul_parent_idsi2c_emul_parent"i2c_emul_parent"_u_boot_list_2_uclass_2_i2c_emul_parent.u_boot_list_2_uclass_2_i2c_emul_parenti2c_emul"i2c_emul"sizeof(struct i2c_emul_uc_platdata)_u_boot_list_2_uclass_2_i2c_emul.u_boot_list_2_uclass_2_i2c_emul/*
 * This uclass is a child of the i2c bus. Its platdata is not defined here so
 * is defined by its parent, UCLASS_I2C, which uses struct dm_i2c_chip. See
 * per_child_platdata_auto_alloc_size in UCLASS_DRIVER(i2c).
 *//**
 * struct i2c_emul_uc_platdata - information about the emulator for this device
 *
 * This is used by devices in UCLASS_I2C_EMUL to record information about the
 * device being emulated. It is accessible with dev_get_uclass_platdata()
 *
 * @dev: Device being emulated
 *//*
 * i2c emulation works using an 'emul' node at the bus level. Each device in
 * that node is in the UCLASS_I2C_EMUL uclass, and emulates one i2c device. A
 * pointer to the device it emulates is in the 'dev' property of the emul device
 * uclass platdata (struct i2c_emul_platdata), put there by i2c_emul_find().
 * When sandbox wants an emulator for a device, it calls i2c_emul_find() which
 * searches for the emulator with the correct address. To find the device for an
 * emulator, call i2c_emul_get_device().
 *
 * The 'emul' node is in the UCLASS_I2C_EMUL_PARENT uclass. We use a separate
 * uclass so avoid having strange devices on the I2C bus.
 *//opt/src/drivers/i2c/i2c-gpio.ci2c-gpioi2c_gpio_ofdata_to_platdatagpios"gpios"i2c_gpio_bus *gpio_desc[2]PIN_COUNTbus->gpiosARRAY_SIZE(bus->gpios)i2c-gpio,delay-us"i2c-gpio,delay-us"DEFAULT_UDELAY"Can't get %s gpios! Error: %d"pr_err("Can't get %s gpios! Error: %d", dev->name, ret)pr_fmt("Can't get %s gpios! Error: %d")Can't get %s gpios! Error: %di2c_gpio_set_bus_speedsclPIN_SCLsdaPIN_SDAi2c_gpio_probe"%s: bus: %d (%s) chip: %x flags: %x ret: %d\n"__func__, dev->seq, dev->name, chip, chip_flags, retdebug("%s: bus: %d (%s) chip: %x flags: %x ret: %d\n",
	      __func__, dev->seq, dev->name, chip, chip_flags, ret)drivers/i2c/i2c-gpio.c%s: bus: %d (%s) chip: %x flags: %x ret: %d
i2c_gpio_xfernext_is_readEREMOTEIO-121-EREMOTEIOi2c_gpio_read_data"%s: chip %x buffer: %p len %d\n"__func__, chip, buffer, lendebug("%s: chip %x buffer: %p len %d\n", __func__, chip, buffer, len)%s: chip %x buffer: %p len %d
i2c_gpio_write_data"%s: chip %x buffer %p len %d\n"debug("%s: chip %x buffer %p len %d\n", __func__, chip, buffer, len)%s: chip %x buffer %p len %d
"i2c_write, no chip responded %02X\n"debug("i2c_write, no chip responded %02X\n", chip)i2c_write, no chip responded %02X
failuresi2c_send_slave_addri2c_gpio_read_bytei2c_gpio_write_bytenacki2c_gpio_sda_highi2c_gpio_send_reseti2c_gpio_send_acki2c_gpio_send_stopi2c_gpio_send_startend_with_repeated_starti2c_gpio_read_biti2c_gpio_write_biti2c_gpio_scl_seti2c_gpio_sda_seti2c_gpio_sda_geti2c_gpio_bus"i2c-gpio"sizeof(struct i2c_gpio_bus)_u_boot_list_2_driver_2_i2c_gpio.u_boot_list_2_driver_2_i2c_gpioi2c_gpioi2c_gpio_idsi2c_gpio_opsI2C_NOACKI2C_ACKRETRIES/* send start and the slave chip address *//**
 * if ack == I2C_ACK, ACK the byte so can continue reading, else
 * send I2C_NOACK to end the read.
 *//* not a nack is an ack *//* Look for an <ACK>(negative logic) and return it *//* Send 8 bits and look for an acknowledgement *//* Set sda high with low clock, before reading slave data *//**
 * Send a reset sequence consisting of 9 clocks with the data signal high
 * to clock any confused device back into an idle state.  Also send a
 * <stop> at the end of the sequence for belts & suspenders.
 *//* ack should be I2C_ACK or I2C_NOACK *//* STOP: Low -> High on SDA while SCL is High *//* START: High -> Low on SDA while SCL is High *//* sda, scl *//**
	  * udelay - delay [us] between GPIO toggle operations,
	  * which is 1/4 of I2C speed clock period.
	 *//*
 * (C) Copyright 2015, Samsung Electronics
 * Przemyslaw Marczak <p.marczak@samsung.com>
 *
 * This file is based on: drivers/i2c/soft-i2c.c,
 * with added driver-model support and code cleanup.
 */bit/opt/src/drivers/i2c/i2c-uclass.ci2c-uclassi2c_uclass_initi2c_priv *"%s: highest alias id is %d\n"__func__, priv->max_iddebug("%s: highest alias id is %d\n", __func__, priv->max_id)drivers/i2c/i2c-uclass.c688%s: highest alias id is %d
i2c_post_bind"%s: %s, req_seq=%d\n"__func__, dev->name, dev->req_seqdebug("%s: %s, req_seq=%d\n", __func__, dev->name, dev->req_seq)659%s: %s, req_seq=%d
"%s: %s, new req_seq=%d\n"debug("%s: %s, new req_seq=%d\n", __func__, dev->name, dev->req_seq)665%s: %s, new req_seq=%d
i2c_child_post_bindi2c_post_probedm_i2c_bus *i2c_pre_probeu-boot,i2c-transaction-bytes"u-boot,i2c-transaction-bytes""%s: I2C bus: %s max transaction bytes: %d\n"__func__, dev->name, i2c->max_transaction_bytesdebug("%s: I2C bus: %s max transaction bytes: %d\n", __func__,
	      dev->name, i2c->max_transaction_bytes)%s: I2C bus: %s max transaction bytes: %d
u-boot,i2c-offset-len"u-boot,i2c-offset-len""%s: I2C Node '%s' has no 'reg' property %s\n"__func__, dev_read_name(dev), dev->namedebug("%s: I2C Node '%s' has no 'reg' property %s\n", __func__,
		      dev_read_name(dev), dev->name)587%s: I2C Node '%s' has no 'reg' property %s
i2c_deblock_gpioARRAY_SIZE(gpios)"%s: I2C Node '%s' has no 'gpios' property %s\n"__func__, dev_read_name(bus), bus->namedebug("%s: I2C Node '%s' has no 'gpios' property %s\n",
		      __func__, dev_read_name(bus), bus->name)529%s: I2C Node '%s' has no 'gpios' property %s
"%s: I2C Node '%s' has no 'gpio' pinctrl state. %s\n"debug("%s: I2C Node '%s' has no 'gpio' pinctrl state. %s\n",
		      __func__, dev_read_name(bus), bus->name)540%s: I2C Node '%s' has no 'gpio' pinctrl state. %s
ret0"%s: I2C Node '%s' has no 'default' pinctrl state. %s\n"debug("%s: I2C Node '%s' has no 'default' pinctrl state. %s\n",
		      __func__, dev_read_name(bus), bus->name)549%s: I2C Node '%s' has no 'default' pinctrl state. %s
i2c_deblock_gpio_loop 9out_no_pinctrlsda_pinscl_pini2c_gpio_get_pini2c_gpio_set_pinGPIOD_IS_OUT |
					   GPIOD_ACTIVE_LOWGPIOD_IS_OUT |
					   GPIOD_ACTIVE_LOW |
					   GPIOD_IS_OUT_ACTIVEI2C_MAX_OFFSET_LEN"%s: bus='%s', address %02x, ret=%d\n"__func__, bus->name, chip_addr, retdebug("%s: bus='%s', address %02x, ret=%d\n", __func__, bus->name,
	      chip_addr, ret)381%s: bus='%s', address %02x, ret=%d
"%s:  i2c_get_chip: ret=%d\n"debug("%s:  i2c_get_chip: ret=%d\n", __func__, ret)%s:  i2c_get_chip: ret=%d
"Cannot find I2C bus %d\n"debug("Cannot find I2C bus %d\n", busnum)Cannot find I2C bus %d
354"Cannot detect I2C chip %02x on bus %d\n"chip_addr, busnumdebug("Cannot detect I2C chip %02x on bus %d\n", chip_addr,
		      busnum)pin357Cannot detect I2C chip %02x on bus %d
"Cannot find I2C chip %02x on bus %d\n"debug("Cannot find I2C chip %02x on bus %d\n", chip_addr,
		      busnum)364Cannot find I2C chip %02x on bus %d
"%s: Searching bus '%s' for address %02x: "__func__, bus->name, chip_addrdebug("%s: Searching bus '%s' for address %02x: ", __func__,
	      bus->name, chip_addr)%s: Searching bus '%s' for address %02x: "found, ret=%d\n"debug("found, ret=%d\n", ret)found, ret=%d
"not found\n"debug("not found\n")not found
i2c_bind_drivergeneric_%x"generic_%x"i2c_generic_chip_drv"i2c_generic_chip_drv""%s:  device_bind_driver: ret=%d\n"debug("%s:  device_bind_driver: ret=%d\n", __func__, ret)%s:  device_bind_driver: ret=%d
"%s:  device_probe: ret=%d\n"debug("%s:  device_probe: ret=%d\n", __func__, ret)%s:  device_probe: ret=%d
i2c_probe_chipi2c_msg[1]i2c_msg[2]offset_bufmsg_counti2c_write_bytewiseuint8_t[5]I2C_MAX_OFFSET_LEN + 1i2c_read_bytewiseerr_binderr_probei2c_setup_offsetEADDRNOTAVAIL-99-EADDRNOTAVAILchip->offset_len <= I2C_MAX_OFFSET_LENchip->offset_len <= 4assert(chip->offset_len <= I2C_MAX_OFFSET_LEN)   %s %x len=%x"   %s %x len=%x"R"R"W"W": %x": %x"i2c_privUCLASS_I2C_GENERIC_u_boot_list_2_driver_2_i2c_generic_chip_drv.u_boot_list_2_driver_2_i2c_generic_chip_drvi2c_generic"i2c_generic"_u_boot_list_2_uclass_2_i2c_generic.u_boot_list_2_uclass_2_i2c_genericsizeof(struct i2c_priv)sizeof(struct dm_i2c_bus)sizeof(struct dm_i2c_chip)_u_boot_list_2_uclass_2_i2c.u_boot_list_2_uclass_2_i2c/* Get the last allocated alias. *//* Just for sure *//* if there is no alias ID, use the first free */// CONFIG_DM_GPIO/* Then, send I2C stop *//*  Toggle SCL until slave release SDA *//*
	 * If we have a method, call it. If not then the driver probably wants
	 * to deal with speed changes on the next transfer. It can easily read
	 * the current speed from this uclass
	 *//* The chip was found, see if we have a driver, and probe it *//* First probe that chip *//* detect the presence of the chip on the bus *//*
	 * If the device failed to probe, unbind it. There is nothing there
	 * on the bus so we don't want to leave it lying around
	 *//* Tell the device what we know about it *//* Probe with a zero-length message *//**
 * i2c_probe_chip() - probe for a chip on a bus
 *
 * @bus:	Bus to probe
 * @chip_addr:	Chip address to probe
 * @flags:	Flags for the chip
 * @return 0 if found, -ENOSYS if the driver is invalid, -EREMOTEIO if the chip
 * does not respond to probe
 *//*
	 * The simple approach would be to send two messages here: one to
	 * set the offset and one to write the bytes. However some drivers
	 * will not be expecting this, and some chips won't like how the
	 * driver presents this on the I2C bus.
	 *
	 * The API does not support separate offset and data. We could extend
	 * it with a flag indicating that there is data in the next message
	 * that needs to be processed in the same transaction. We could
	 * instead add an additional buffer to each message. For now, handle
	 * this in the uclass since it isn't clear what the impact on drivers
	 * would be with this extra complication. Unfortunately this means
	 * copying the message.
	 *
	 * Use the stack for small messages, malloc() for larger ones. We
	 * need to allow space for the offset (up to 4 bytes) and the message
	 * itself.
	 *//**
 * i2c_setup_offset() - Set up a new message with a chip offset
 *
 * @chip:	Chip to use
 * @offset:	Byte offset within chip
 * @offset_buf:	Place to put byte offset
 * @msg:	Message buffer
 * @return 0 if OK, -EADDRNOTAVAIL if the offset length is 0. In that case the
 * message is still set up but will not contain an offset.
 *//* Useful debugging function *//opt/src/drivers/i2c/muxes/i2c-arb-gpio-challenge.ci2c-arb-gpio-challengei2c_arbitrator_removei2c_arbitrator_priv *i2c_arbitrator_probe__func__, dev->namedebug("%s: %s\n", __func__, dev->name)drivers/i2c/muxes/i2c-arb-gpio-challenge.cslew-delay-us"slew-delay-us"wait-retry-us"wait-retry-us"wait-free-us"wait-free-us"our-claim-gpio"our-claim-gpio"their-claim-gpios"their-claim-gpios"debug("%s: ret=%d\n", __func__, ret)i2c_arbitrator_select__func__, mux->namedebug("%s: %s\n", __func__, mux->name)start_retrywaiting/opt/src/drivers/i2c/muxesmuxeserr_ec_gpioI2C: Could not claim bus, timeout %lu
"I2C: Could not claim bus, timeout %lu\n"i2c_arbitrator_deselecti2c_arbitrator_privwait_free_mswait_retry_msslew_delay_usec_claimap_claimi2c_arbitrator"i2c_arbitrator"UCLASS_I2C_MUXconst i2c_mux_opsconst i2c_mux_ops *i2c_mux_ops *sizeof(struct i2c_arbitrator_priv)_u_boot_list_2_driver_2_i2c_arbitrator.u_boot_list_2_driver_2_i2c_arbitrator"i2c-arb-gpio-challenge"i2c_arbitrator_idsi2c_arbitrator_ops/* Give up, release our claim *//* It didn't release, so give up, wait, and try again *//* We got it, so return *//* Wait for the EC to release it *//* Indicate that we want to claim the bus *//* Start a round of trying to claim the bus *//opt/src/drivers/i2c/muxes/i2c-mux-uclass.ci2c-mux-uclassi2c_mux_bus_xferpriv->i2c_bus"%s: %s, bus %s\n"__func__, dev->name, priv->i2c_bus->namedebug("%s: %s, bus %s\n", __func__, dev->name, priv->i2c_bus->name)drivers/i2c/muxes/i2c-mux-uclass.c%s: %s, bus %s
i2c_mux *ret2i2c_mux_bus_probei2c_mux_bus_set_bus_speedi2c_mux_deselecti2c_mux_bus *i2c_mux_selecti2c_mux_post_probe"%s: bus=%p/%s\n"__func__, priv->i2c_bus, priv->i2c_bus->namedebug("%s: bus=%p/%s\n", __func__, priv->i2c_bus,
		      priv->i2c_bus->name)%s: bus=%p/%s
i2c-parent"i2c-parent"debug("%s: bus=%p/%s\n", __func__, priv->i2c_bus, priv->i2c_bus->name)i2c_mux_post_bindarrow->"->"parent_name_lenarrow_lenmux_name_leni2c_mux_bus_drv"i2c_mux_bus_drv""   - bind ret=%d, %s, req_seq %d\n"ret, dev ? dev->name : NULL, dev->req_seqdebug("   - bind ret=%d, %s, req_seq %d\n", ret,
		      dev ? dev->name : NULL, dev->req_seq)   - bind ret=%d, %s, req_seq %d
i2c_mux_child_post_bindi2c_mux_busi2c_muxselected"i2c_mux"sizeof(struct i2c_mux)sizeof(struct i2c_mux_bus)_u_boot_list_2_uclass_2_i2c_mux.u_boot_list_2_uclass_2_i2c_mux_u_boot_list_2_driver_2_i2c_mux_bus.u_boot_list_2_driver_2_i2c_mux_busi2c_mux_bus_ops/* if parent is of i2c uclass already, we'll take that, otherwise
	 * look if we find an i2c-parent phandle
	 *//* Set up the mux ready for use *//* Compose bus name *//* Calculate lenghts of strings *//*
	 * There is no compatible string in the sub-nodes, so we must manually
	 * bind these
	 *//* Find the I2C buses selected by this mux *//* Find out the mux channel number *//**
 * struct i2c_mux_bus: Information about each bus the mux controls
 *
 * @channel: Channel number used to select this bus
 *//**
 * struct i2c_mux: Information the uclass stores about an I2C mux
 *
 * @selected:	Currently selected mux, or -1 for none
 * @i2c_bus: I2C bus to use for communcation
 *//opt/src/drivers/i2c/sandbox_i2c.csandbox_i2csandbox_i2c_xfersandbox_i2c_priv *dm_i2c_ops **400000"%s: Max speed exceeded\n"debug("%s: Max speed exceeded\n", __func__)drivers/i2c/sandbox_i2c.c%s: Max speed exceeded
get_emulplat->emulsandbox_i2c_privi2c_sandbox"i2c_sandbox"sizeof(struct sandbox_i2c_priv)_u_boot_list_2_driver_2_i2c_sandbox.u_boot_list_2_driver_2_i2c_sandboxsandbox,i2c"sandbox,i2c"sandbox_i2c_idssandbox_i2c_ops/*
		* For testing, don't allow writing above 100KHz for writes and
		* 400KHz for reads.
		*//* Special test code to return success but with no emulation *//*
 * Simulate an I2C port
 *
 * Copyright (c) 2014 Google, Inc
 */opsp/opt/src/include/key_matrix.hkey_matrix_initkey_matrix *key_matrix_decode_fdtkey_matrix_decodekey_matrix_key *key_matrix_keyghost_filterfn_posfn_keycodeplain_keycodekey_countnum_colsnum_rows_KEY_MATRIX_H/**
 * Set up a new key matrix.
 *
 * @param config	Keyboard matrix config
 * @param rows		Number of rows in key matrix
 * @param cols		Number of columns in key matrix
 * @param ghost_filter	Non-zero to enable ghost filtering
 * @return 0 if ok, -1 on error
 *//**
 * Read the keyboard configuration out of the fdt.
 *
 * Decode properties of named "linux,<type>keymap" where <type> is either
 * empty, or "fn-". Then set up the plain key map (and the FN keymap if
 * present).
 *
 * @param config        Keyboard matrix config
 * @param blob          FDT blob
 * @param node          Node containing compatible data
 * @return 0 if ok, -1 on error
 *//**
 * Decode a set of pressed keys into key codes
 *
 * Given a list of keys that are pressed, this converts this list into
 * a list of key codes. Each of the keys has a valid flag, which can be
 * used to mark a particular key as invalid (so that it is ignored).
 *
 * The plain keymap is used, unless the Fn key is detected along the way,
 * at which point we switch to the Fn key map.
 *
 * If key ghosting is detected, we simply ignore the keys and return 0.
 *
 * @param config        Keyboard matrix config
 * @param keys		List of keys to process (each is row, col)
 * @param num_keys	Number of keys to process
 * @param keycode	Returns a list of key codes, decoded from input
 * @param max_keycodes	Size of key codes array (suggest 8)
 *
 *//* 1 if valid, 0 to ignore this *//* column number (0 = first) *//* row number (0 = first) *//* Information about a particular key (row, column pair) in the matrix *//* non-zero to enable ghost filter *//* position of Fn key in key (or -1) *//* ...when Fn held down *//* key code for each row / column *//*
	 * Information about keycode mappings. The plain_keycode array must
	 * exist but fn may be NULL in which case it is not decoded.
	 *//* number of keys in the matrix (= rows * cols) *//* Dimensions of the keyboard matrix, in rows and columns *//* Information about a matrix keyboard *//*
 * Keyboard matrix helper functions
 *
 * Copyright (c) 2012 The Chromium OS Authors.
 */keysnum_keysmax_keycodes/opt/src/drivers/input/cros_ec_keyb.ccros_ec_keybcros_ec_kbd_probecros_ec_keyb_priv *"%s: Cannot decode node (ret=%d)\n"debug("%s: Cannot decode node (ret=%d)\n", __func__, ret)drivers/input/cros_ec_keyb.c%s: Cannot decode node (ret=%d)
input_config *keyboard_priv *KBC_REPEAT_DELAY_MSKBC_REPEAT_RATE_MS"%s: cannot init key matrix\n"debug("%s: cannot init key matrix\n", __func__)%s: cannot init key matrix
"%s: Could not decode key matrix from fdt\n"debug("%s: Could not decode key matrix from fdt\n", __func__)%s: Could not decode key matrix from fdt
"%s: Matrix keyboard %dx%d ready\n"__func__, priv->key_rows, priv->key_colsdebug("%s: Matrix keyboard %dx%d ready\n", __func__, priv->key_rows,
	      priv->key_cols)%s: Matrix keyboard %dx%d ready
cros-ec-keyb"cros-ec-keyb"cros_ec_keyb_decode_fdtkeypad,num-rows"keypad,num-rows"keypad,num-columns"keypad,num-columns""%s: Invalid key matrix size %d x %d\n"__func__, config->key_rows, config->key_colsdebug("%s: Invalid key matrix size %d x %d\n", __func__,
		      config->key_rows, config->key_cols)/opt/src/include/input.h/opt/src/include/keyboard.h/opt/src/drivers/input<key_matrix.h><keyboard.h><input.h>%s: Invalid key matrix size %d x %d
google,needs-ghost-filter"google,needs-ghost-filter"cros_ec_kbc_checkirq_pendingsentkey_matrix_key[8]KBC_MAX_KEYSsamelast_num_keyslast_keyssizeof(keys)num_keycodeskeycodescheck_for_keys"%s: keyboard scan failed\n"debug("%s: keyboard scan failed\n", __func__)%s: keyboard scan failed
last_scan_validlast_scansizeof(scan)sizeof(last_scan)cros_ec_keyb_privkey_colskey_rowsmatrixcros_ec_kbd"cros_ec_kbd"const keyboard_opsconst keyboard_ops *keyboard_ops *sizeof(struct cros_ec_keyb_priv)_u_boot_list_2_driver_2_cros_ec_kbd.u_boot_list_2_driver_2_cros_ec_kbdgoogle,cros-ec-keyb"google,cros-ec-keyb"cros_ec_kbd_idscros_ec_kbd_ops/* Register the device. cros_ec_init_keyboard() will be called soon *//*
	 * Get keyboard rows and columns - at present we are limited to
	 * 8 columns by the protocol (one byte per row scan)
	 *//**
 * Decode MBKP keyboard details from the device tree
 *
 * @param blob		Device tree blob
 * @param node		Node to decode from
 * @param config	Configuration data read from fdt
 * @return 0 if ok, -1 on error
 *//*
		 * For those ECs without an interrupt, stop scanning when we
		 * see that the scan is the same as last time.
		 *//*
			 * EC doesn't want to be asked, so use keys from last
			 * time.
			 *//*
	 * Loop until the EC has no more keyscan records, or we have
	 * received at least one character. This means we know that tstc()
	 * will always return non-zero if keys have been pressed.
	 *
	 * Without this loop, a key release (which generates no new ascii
	 * characters) will cause us to exit this function, and just tstc()
	 * may return 0 before all keys have been read from the EC.
	 *//**
 * Check the keyboard, and send any keys that are pressed.
 *
 * This is called by input_tstc() and input_getc() when they need more
 * characters
 *
 * @param input		Input configuration
 * @return 1, to indicate that we have something to look at
 *//*
	 * This is a bit odd. The EC has no way to tell us that it has run
	 * out of key scans. It just returns the same scan over and over
	 * again. So the only way to detect that we have run out is to detect
	 * that this scan is the same as the last.
	 *//**
 * Check the keyboard controller and return a list of key matrix positions
 * for which a key is pressed
 *
 * @param dev		Keyboard device
 * @param keys		List of keys that we have detected
 * @param max_count	Maximum number of keys to return
 * @param samep		Set to true if this scan repeats the last, else false
 * @return number of pressed keys, 0 for none, -EIO on error
 *//* 1 to enable ghost filter, else 0 *//* Number of keyboard columns *//* Number of keyboard rows *//* The key matrix layer *//* The input layer *//* Maximum keys held down at once *//*
 * Chromium OS Matrix Keyboard
 *
 * Copyright (c) 2012 The Chromium OS Authors.
 */samep/opt/src/include/i8042.hi8042ALTBRKE1ESCEXTCTRLSHIFTCAPSNUMSTPESEXSTCPAKNMCNSHASKBD_RESET_TRIESKBD_TIMEOUTKBD_GERKBD_USKBD_PORKBD_ACKKBC_TEST_OKCMD_RESET_KBDCMD_DRAIN_OUTPUT0xf4CMD_SET_KBD_LEDCMD_KBD_EN0xaeCMD_KBD_DISCMD_SELF_TESTCMD_WR_CONFIGCMD_RD_CONFIGCONFIG_AT_TRANSCONFIG_MCLK_DISCONFIG_KCLK_DISCONFIG_SET_BISTCONFIG_MIRQ_ENCONFIG_KIRQ_ENSTATUS_IBFSTATUS_OBFI8042_CMD_REG0x64I8042_STS_REGI8042_DATA_REG_I8042_H_/* _I8042_H_ *//* right alt *//* make break flag for keyboard *//* extended scan code 0xe1 *//* escape key press *//* extended scan code 0xe0 *//* control*//* shift *//* capslock *//* numeric lock *//* scroll lock stop output*//* normal key *//* escape and extended code index *//* extended code index *//* stop output index *//* capslock index *//* right alt key *//* numeric lock index *//* control index *//* shift index *//* normal character index *//* 1 sec *//* german layout *//* default US layout *//* keyboard scan codes *//* i8042 command result *//* reset keyboard *//* drain output buffer *//* set keyboard led *//* keyboard enable *//* keyboard disable *//* controller self-test *//* write configuration byte *//* read configuration byte *//* i8042 commands *//* Configuration byte bit defines *//* Status register bit defines *//* keyboard ctrl write *//* keyboard status read *//* keyboard i/o buffer *//* defines *//* i8042.h - Intel 8042 keyboard driver header *//*
 * (C) Copyright 2002 ELTEC Elektronik AG
 * Frank Gottschling <fgottschling@eltec.de>
 *//opt/src/drivers/input/i8042.ci8042_kbd_probeintel,duplicate-por"intel,duplicate-por"i8042_kbd_priv *QUIRK_DUP_PORi8042-kbd"i8042-kbd""%s: input_stdio_register() failed\n"debug("%s: input_stdio_register() failed\n", __func__)drivers/input/i8042.c332%s: input_stdio_register() failed
"%s: ready\n"debug("%s: ready\n", __func__)%s: ready
i8042_kbd_remove"i8042_disable() failed. fine, continue.\n"log_debug("i8042_disable() failed. fine, continue.\n")i8042_disable() failed. fine, continue.
i8042_start"i8042 keyboard controller is not present\n"debug("i8042 keyboard controller is not present\n")i8042 keyboard controller is not present
keymappenv"keymap"try<i8042.h>"%s: started\n"debug("%s: started\n", __func__)%s: started
i8042_kbd_checkin8(I8042_STS_REG)in8(I8042_DATA_REG)i8042_disableout8(I8042_CMD_REG, CMD_KBD_DIS)i8042_flushkbd_controller_presentkbd_resetCONFIG_KIRQ_EN | CONFIG_MIRQ_EN(CONFIG_KIRQ_EN | CONFIG_MIRQ_EN)~(CONFIG_KIRQ_EN | CONFIG_MIRQ_EN)"%s: Keyboard failure\n"debug("%s: Keyboard failure\n", __func__)%s: Keyboard failure
kbd_cmd_writekbd_cmd_readkbd_readkbd_writei8042_kbd_update_ledsout8(I8042_DATA_REG, CMD_SET_KBD_LED)quirkleds & 0x7out8(I8042_DATA_REG, leds & 0x7)kbd_output_fullkbd_timeoutKBD_TIMEOUT * 1000kbd_input_emptyi8042_kbd_privi8042_kbd"i8042_kbd"sizeof(struct i8042_kbd_priv)_u_boot_list_2_driver_2_i8042_kbd.u_boot_list_2_driver_2_i8042_kbdintel,i8042-keyboard"intel,i8042-keyboard"i8042_kbd_idsi8042_kbd_ops0x490x4dext_key_mapout8(p,v)outb(v, p)in8(p)inb(p)/* Register the device. i8042_start() will be called soon *//**
 * Set up the i8042 keyboard. This is called by the stdio device handler
 *
 * We want to do this init when the keyboard is actually used rather than
 * at start-up, since keyboard input may not currently be selected.
 *
 * Once the keyboard starts there will be a period during which we must
 * wait for the keyboard to init. We do this only when a key is first
 * read - see kbd_wait_for_fifo_init().
 *
 * @return 0 if ok, -ve on error
 *//* Init keyboard device (default US layout) *//* i8042_kbd_init - reset keyboard and init state flags *//* not found ? *//* Disable keyboard *//**
 * Disables the keyboard so that key strokes no longer generate scancodes to
 * the host.
 *
 * @return 0 if ok, -1 if keyboard input was found while disabling
 *//* Try to pull next byte if not timeout *//* wait for no longer than 100us *//*
	 * The delay is to give the keyboard controller some time
	 * to fill the next byte.
	 *//** Flush all buffer from keyboard controller to host*//* enable keyboard *//* Sometimes get a second byte *//* set AT translation and disable irq *//* keyboard reset *//* controller self test *//**
 * check_leds() - Check the keyboard LEDs and update them it needed
 *
 * @ret:	Value to return
 * @return value of @ret
 *//* map end *//* editpad del *//* editpad ins *//* editpad pgdn *//* editpad dn *//* editpad end *//* editpad right *//* editpad left *//* editpad pgup *//* editpad up *//* editpad home *//* break *//* print screen *//* keypad slash *//* right control *//* keypad enter *//* quirks that we support *//* true if an extended keycode is expected next *//* locals *//* i8042.c - Intel 8042 keyboard driver routines */input_configinput_key_xlateINPUT_LED_SCROLLINPUT_LED_NUMINPUT_LED_CAPSINPUT_MAX_MODIFIERSINPUT_BUFFER_LENrepeat_rate_msrepeat_delay_msnext_repeat_msallow_repeatsread_keysinput_key_xlate[4]num_prev_keycodesprev_keycodesnum_tablesleds_changedmodifiersfifo_outfifo_infiforight_keycodeleft_keycodeinput_initinput_add_tablesinput_leds_changedinput_allow_repeatsinput_set_delaysinput_stdio_registerinput_getcinput_tstcinput_add_tableinput_add_keycodeinput_send_keycodes/**
 * Set up the input handler with basic key maps.
 *
 * @param config	Input state
 * @param leds		Initial LED value (INPUT_LED_ mask), 0 suggested
 * @return 0 if ok, -1 on error
 *//**
 * Set up the key map tables
 *
 * This must be called after input_init() or keycode decoding will not work.
 *
 * @param config	Input state
 * @param german	true to use German keyboard layout, false for US
 * @return 0 if ok, -1 on error
 *//**
 * Check if keyboard LEDs need to be updated
 *
 * This can be called after input_tstc() to see if keyboard LEDs need
 * updating.
 *
 * @param config	Input state
 * @return -1 if no LEDs need updating, other value if they do
 *//**
 * Tell the input layer whether to allow the caller to determine repeats
 *
 * Generally the input library handles processing of a list of scanned keys.
 * Repeated keys need to be generated based on a timer in this case, since all
 * that is provided is a list of keys current depressed.
 *
 * Keyboards which do their own scanning will resend codes when they want to
 * inject a repeating key. This function can be called at start-up to select
 * this behaviour.
 *
 * @param config	Input state
 * @param allow_repeats	true to repeat depressed keys every time
 *			input_send_keycodes() is called, false to do normal
 *			keyboard repeat processing with a timer.
 *//**
 * Set up the keyboard autorepeat delays
 *
 * @param repeat_delay_ms	Delay before key auto-repeat starts (in ms)
 * @param repeat_rate_ms	Delay between successive key repeats (in ms)
 *//**
 * Register a new device with stdio and switch to it if wanted
 *
 * @param dev	Pointer to device
 * @return 0 if ok, -1 on error
 *//**
 * Read a key
 *
 * TODO: U-Boot wants 0 for no key, but Ctrl-@ is a valid key...
 *
 * @param config	Input state
 * @return key, or 0 if no key, or -1 if error
 *//**
 * Test if keys are available to be read
 *
 * @param config	Input state
 * @return 0 if no keys available, 1 if keys are available
 *//**
 * Add a new key translation table to the input
 *
 * @param config	Input state
 * @param left_keycode	Key to hold to get into this table
 * @param right_keycode	Another key to hold to get into this table
 * @param xlate		Conversion table from key codes to ASCII
 * @param num_entries	Number of entries in xlate table
 *//**
 * Add a new keycode to an existing list of keycodes
 *
 * This can be used to handle keyboards which do their own scanning. An
 * internal list of depressed keys is maintained by the input library. Then
 * this function is called to add a new key to the list (when a 'make code' is
 * received), or remove a key (when a 'break code' is received).
 *
 * This function looks after maintenance of the list of active keys, and calls
 * input_send_keycodes() with its updated list.
 *
 * @param config	Input state
 * @param new_keycode	New keycode to add/remove
 * @param release	true if this key was released, false if depressed
 * @return number of ascii characters sent, or 0 if none, or -1 for an
 *	internal error
 *//**
 * Convert a list of key codes into ASCII and send them
 *
 * @param config	Input state
 * @param keycode	List of key codes to examine
 * @param num_keycodes	Number of key codes
 * @return number of ascii characters sent, or 0 if none, or -1 for an
 *	internal error
 *//* Autorepeat rate in ms *//* Time before autorepeat starts *//* Next time we repeat a key *//* Don't filter out repeats *//**
	 * Function the input helper calls to scan the keyboard
	 *
	 * @param config	Input state
	 * @return 0 if no keys read, otherwise number of keys read, or 1 if
	 *		unknown
	 *//* number of prev keys *//* keys held last time *//* number of modifier tables *//* LEDs that just changed *//* active LEDs (INPUT_LED_...) *//* active state keys (FLAGS_...) *//* Which modifiers are active (1 bit for each MOD_... value) *//* number of entries in this table *//* keycode to ASCII table *//* keycode of the modifiers which select this table, -1 if none *//*
 * This table translates key codes to ASCII. Most of the entries are ASCII
 * codes, but entries after KEY_FIRST_MOD indicate that this key is a
 * modifier key, like shift, ctrl. KEY_FIRST_MOD + MOD_SHIFT is the shift
 * key, for example.
 *//* Keyboard LEDs *//*
 * Keyboard input helper functions (too small to be called a layer)
 *
 * Copyright (c) 2011 The Chromium OS Authors.
 */germannew_keycodekeyboardkeyboard_opskeyboard_privupdate_ledskeyboard_get_ops(dev)((struct keyboard_ops *)(dev)->driver->ops)__KEYBOARD_H/* __KEYBOARD_H *//**
	 * update_leds() - update keyboard LEDs
	 *
	 * This is called when the LEDs have changed and need to be updated.
	 * For example, if 'caps lock' is pressed then this method will be
	 * called with the new LED value.
	 *
	 * @dev:	Device to update
	 * @leds:	New LED mask (see INPUT_LED_... in input.h)
	 *//**
	 * getc() - get a key
	 *
	 * TODO(sjg@chromium.org): At present this method may wait if it calls
	 * input_getc().
	 *
	 * @dev:	Device to read from
	 * @return -EAGAIN if no key is available, otherwise key value read
	 *	   (as ASCII).
	 *//**
	 * tstc() - check if a key is available
	 *
	 * @dev:	Device to check
	 * @return 0 if no key is available, 1 if a key is available, -ve on
	 *	   error
	 *//**
	 * stop() - disable the keyboard when no-longer needed
	 *
	 * @dev:	Device to disable
	 * @return 0 if OK, -ve on error
	 *//**
	 * start() - enable the keyboard ready for use
	 *
	 * @dev:	Device to enable
	 * @return 0 if OK, -ve on error
	 *//**
 * struct keyboard_ops - keyboard device operations
 *//*
	 * This is set up by the uclass but will only be used if the driver
	 * sets input.dev to its device pointer (it is initially NULL).
	 *//**
 * struct keyboard_priv - information about a keyboard, for the uclass
 *
 * @sdev:	stdio device
 * @input:	input configuration (the driver may use this if desired)
 *//opt/src/include/linux/input.h_LINUX_INPUT_H/*
 * Copyright (c) 1999-2002 Vojtech Pavlik
 *//opt/src/drivers/input/input.cENV_SUPPORTCONFIG_VAL(ENV_SUPPORT)CONFIG_ENV_SUPPORT__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_ENV_SUPPORT__ARG_PLACEHOLDER_CONFIG_ENV_SUPPORT__ARG_PLACEHOLDER_CONFIG_ENV_SUPPORT 1CONFIG_VAL(ENV_SUPPORT_MODULE)CONFIG_ENV_SUPPORT_MODULEENV_SUPPORT_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_ENV_SUPPORT_MODULE__ARG_PLACEHOLDER_CONFIG_ENV_SUPPORT_MODULE__ARG_PLACEHOLDER_CONFIG_ENV_SUPPORT_MODULE 1sizeof(*config)KBD_GERMANKBD_ENGLISHkbd_entry *kbd_entry[7]"%s: Too many modifier tables\n"debug("%s: Too many modifier tables\n", __func__)drivers/input/input.c589%s: Too many modifier tables
input_key_xlate *int[5]INPUT_MAX_MODIFIERS + 1"\ncodes for %02x/%d: "new_keycode, releasedebug("\ncodes for %02x/%d: ", new_keycode, release)574
codes for %02x/%d: "%02x "keycode[i]debug("%02x ", keycode[i])%02x _input_send_keycodesANSI_CHAR_MAXis_repeatdelay_msinput_keycodes_to_asciiKEY_MASKKEY_RELEASEFLAG_CAPS_LOCK'z'FLAG_NUM_LOCK"%s: Output char buffer overflow size=%d, need=%d\n"__func__, max_chars, ch_countdebug("%s: Output char buffer overflow size=%d, need=%d\n",
		      __func__, max_chars, ch_count)%s: Output char buffer overflow size=%d, need=%d
input_keycode_to_ansi364kbd_to_ansi364ARRAY_SIZE(kbd_to_ansi364)escapeinput_check_keycodes"%s: No xlate tables: cannot decode keys\n"debug("%s: No xlate tables: cannot decode keys\n", __func__)do_sendoutput_chmax_chars%s: No xlate tables: cannot decode keys
sort_array_by_orderingsizeof(*dest)dest_countdest_count == countassert(dest_count == count)361array_searchprocess_modifierconfig->num_tables > 0assert(config->num_tables > 0)tabflipFLAG_SCROLL_LOCK"Update keyboard's LED failed\n"debug("Update keyboard's LED failed\n")Update keyboard's LED failed
input_queue_ascii" {%02x} "debug(" {%02x} ", ch) {%02x} orderocountkbd_entrykbd_maskkbd_scan_code"\033[A""\033[B""\033[C""\033[D"kbd_entry[]kbd_plain_xlatekbd_plain_xlate_germankbd_shift_xlatekbd_shift_xlate_germankbd_ctrl_xlatekbd_right_alt_xlate_germanconst uchar[100]unsigned char[100]ARRAY_SIZE(kbd_plain_xlate)const uchar[132]unsigned char[132]ARRAY_SIZE(kbd_plain_xlate_german)ARRAY_SIZE(kbd_shift_xlate)ARRAY_SIZE(kbd_shift_xlate_german)KBD_ENGLISH | KBD_GERMANARRAY_SIZE(kbd_ctrl_xlate)ARRAY_SIZE(kbd_right_alt_xlate_german)0xe6const uchar[]!defined(CONFIG_SPL_BUILD) || CONFIG_IS_ENABLED(ENV_SUPPORT)/* reassign the console *//* check if this is the standard input device *//* Don't output any ASCII characters if this is a key release *//* Add the old keycodes which are not removed by this new one *//*
		 * Same as last time - is it time for another repeat?
		 * TODO(sjg@chromium.org) We drop repeats here and since
		 * the caller may not call in again for a while, our
		 * auto-repeat speed is not quite correct. We should
		 * insert another character if we later realise that we
		 * have missed a repeat slot.
		 *//* ok, so return keys *//* ban digit numbers if 'Num Lock' is not on *//*
		 * For a normal key (with an ASCII value), add it; otherwise
		 * translate special key to escape sequence if possible.
		 *//* Start conversion by looking for the first new keycode (by same). *//* deal with modifiers first *//**
 * Converts and queues a list of key codes in escaped ASCII string form
 * Convert a list of key codes into ASCII
 *
 * You must call input_check_keycodes() before this. It turns the keycode
 * list into a list of ASCII characters and sends them to the input layer.
 *
 * Characters which were seen last time do not generate fresh ASCII output.
 * The output (calls to queue_ascii) may be longer than num_keycodes, if the
 * keycode contains special keys that was encoded to longer escaped sequence.
 *
 * @param config	Input state
 * @param keycode	List of key codes to examine
 * @param num_keycodes	Number of key codes
 * @param output_ch	Buffer to place output characters into. It should
 *			be at last ANSI_CHAR_MAX * num_keycodes, to allow for
 *			ANSI sequences.
 * @param max_chars	Maximum number of characters to add to output_ch
 * @param same		Number of key codes which are the same
 * @return number of characters written into output_ch, or -1 if we would
 *	exceed max_chars chars.
 *//**
 * Checks and converts a special key code into ANSI 3.64 escape sequence.
 *
 * @param config	Input state
 * @param keycode	Key code to examine
 * @param output_ch	Buffer to place output characters into. It should
 *			be at least ANSI_CHAR_MAX bytes long, to allow for
 *			an ANSI sequence.
 * @param max_chars	Maximum number of characters to add to output_ch
 * @return number of characters output, if the key was converted, otherwise 0.
 *	This may be larger than max_chars, in which case the overflow
 *	characters are not output.
 *//* sort the keycodes into the same order as the previous ones *//* Select the 'plain' xlate table to start with *//**
 * Check a list of key codes against the previous key scan
 *
 * Given a list of new key codes, we check how many of these are the same
 * as last time.
 *
 * @param config	Input state
 * @param keycode	List of key codes to examine
 * @param num_keycodes	Number of key codes
 * @param same		Returns number of key codes which are the same
 *//* now move over the elements that are not in the ordering *//* work through the ordering, move over the elements we agree on *//* setup output items, copy items to be sorted into our temp area *//* number of elements which are the same *//**
 * Sort an array so that those elements that exist in the ordering are
 * first in the array, and in the same order as the ordering. The algorithm
 * is O(count * ocount) and designed for small arrays.
 *
 * TODO: Move this to common / lib?
 *
 * @param dest		Array with elements to sort, also destination array
 * @param count		Number of elements to sort
 * @param order		Array containing ordering elements
 * @param ocount	Number of ordering elements
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 *//**
 * Search an int array for a key value
 *
 * @param array	Array to search
 * @param count	Number of elements in array
 * @param key	Key value to find
 * @return element where value was first found, -1 if none
 *//* Handle the lighted keys *//* Start with the main table, and see what modifiers change it *//**
 * Process a modifier/special key press or release and decide which key
 * translation array should be used as a result.
 *
 * TODO: Should keep track of modifier press/release
 *
 * @param config	Input state
 * @param key		Key code to process
 * @param release	0 if a press, 1 if a release
 * @return pointer to keycode->ascii translation table that should be used
 *//* buffer full *//* Maximum number of output characters that an ANSI sequence expands to *//*
 * Scan key code to ANSI 3.64 escape sequence table.  This table is
 * incomplete in that it does not include all possible extra keys.
 *//* Number of entries in xlate *//* Ascii code for each keycode *//* Right keycode to select this map *//* Left keycode to select this map *//* Which languages this is for *//* scan 50-57 *//* scan 48-4F *//* scan 40-47 *//* scan 38-3F *//* scan 30-37 *//* scan 28-2F *//* scan 20-27 *//* scan 18-1F *//* scan 10-17 *//* scan 08-0F *//* scan 00-07 *//* scan 78-7F *//* scan 70-77 *//* scan 68-6F *//* scan 60-67 *//* scan 58-5F *//*
 * German keymap. Special letters are mapped according to code page 437.
 *//* 0x50 - 0x5F *//* 0x40 - 0x4f *//* 0x30 - 0x3f *//* 0x20 - 0x2f *//* 0x10 - 0x1f *//* 0x00 - 0x0f *//*
 * These takes map key codes to ASCII. 0xff means no key, or special key.
 * Three tables are provided - one for plain keys, one for when the shift
 * 'modifier' key is pressed and one for when the ctrl modifier key is
 * pressed.
 *//* Special flag ORed with key code to indicate release *//* These correspond to the lights on the keyboard *//*
 * Translate key codes into ASCII
 *
 * Copyright (c) 2011 The Chromium OS Authors.
 * (C) Copyright 2004 DENX Software Engineering, Wolfgang Denk, wd@denx.de
 *//opt/src/drivers/input/key_matrix.cconfig->key_count > 0assert(config->key_count > 0)drivers/input/key_matrix.clinux,keymap"linux,keymap""%s: cannot find keycode-plain map\n"debug("%s: cannot find keycode-plain map\n", __func__)%s: cannot find keycode-plain map
464linux,fn-keymap"linux,fn-keymap""%s: Decoded key maps %p, %p from fdt\n"__func__, config->plain_keycode, config->fn_keycodedebug("%s: Decoded key maps %p, %p from fdt\n", __func__,
	      config->plain_keycode, config->fn_keycode)%s: Decoded key maps %p, %p from fdt
create_keymap"%s: failed to malloc %d bytes\n"__func__, config->key_countdebug("%s: failed to malloc %d bytes\n", __func__,
			config->key_count)%s: failed to malloc %d bytes
*data(__force __u32)(__be32)(*data)(__u32)(__be32)(*data)((__u32)(__be32)(*data))fdt32_to_cpu(*data)map_keycodekey_code"   map %d, %d: pos=%d, keycode=%d\n"row, col, entry, key_codedebug("   map %d, %d: pos=%d, keycode=%d\n", row, col,
		      entry, key_code)   map %d, %d: pos=%d, keycode=%d
key_matrix_key[]"%s: num_keys = %d\n"__func__, num_keysdebug("%s: num_keys = %d\n", __func__, num_keys)%s: num_keys = %d
"  valid=%d, row=%d, col=%d\n"key->valid, key->row, key->coldebug("  valid=%d, row=%d, col=%d\n", key->valid, key->row,
		      key->col)  valid=%d, row=%d, col=%d
"    keycode=%d\n"keymap[pos]debug("    keycode=%d\n", keymap[pos])    keycode=%d
"    ghosting detected!\n"debug("    ghosting detected!\n")    ghosting detected!
"  %d valid keycodes found\n"debug("  %d valid keycodes found\n", valid)  %d valid keycodes found
has_ghostingkey_in_same_colkey_in_same_row/* Conversion error -> fail *//* fn keymap is optional *//* Basic keymap is required *//**
 * Create a new keycode map from some provided data
 *
 * This decodes a keycode map in the format used by the fdt, which is one
 * word per entry, with the row, col and keycode encoded in that word.
 *
 * We create a (row x col) size byte array with each entry containing the
 * keycode for that (row, col). We also search for map_keycode and return
 * its position if found (this is used for finding the Fn key).
 *
 * @param config        Key matrix dimensions structure
 * @param data          Keycode data
 * @param len           Number of entries in keycode table
 * @param map_keycode   Key code to find in the map
 * @param pos           Returns position of map_keycode, if found, else -1
 * @return map  Pointer to allocated map
 *//* For a ghost key config, ignore the keypresses for this iteration. *//* Convert the (row, col) values into a keycode *//*
		 * Find 2 keys such that one key is in the same row
		 * and the other is in the same column as the i-th key.
		 *//**
 * Determine if the current keypress configuration can cause key ghosting
 *
 * We figure this out by seeing if we have two or more keys in the same
 * column, as well as two or more keys in the same row.
 *
 * @param config	Keyboard matrix config
 * @param keys		List of keys to check
 * @param valid		Number of valid keypresses to check
 * @return 0 if no ghosting is possible, 1 if it is
 *//*
 * Manage Keyboard Matrices
 *
 * Copyright (c) 2012 The Chromium OS Authors.
 * (C) Copyright 2004 DENX Software Engineering, Wolfgang Denk, wd@denx.de
 *//opt/src/drivers/input/keyboard-uclass.ckeyboard-uclasskeyboard_pre_probesizeof(sdev->name)"%s: Cannot set up input, ret=%d - please add DEBUG to drivers/input/input.c to figure out the cause\n"debug("%s: Cannot set up input, ret=%d - please add DEBUG to drivers/input/input.c to figure out the cause\n",
		      __func__, ret)drivers/input/keyboard-uclass.c%s: Cannot set up input, ret=%d - please add DEBUG to drivers/input/input.c to figure out the cause
keyboard_getckeyboard_tstckeyboard_stopkeyboard_start"keyboard"sizeof(struct keyboard_priv)_u_boot_list_2_uclass_2_keyboard.u_boot_list_2_uclass_2_keyboard/* Just get input to do this for us if we can *//opt/src/drivers/led/led-uclass.cled-uclassdefault_statedefault-state"default-state"led_ops *4294967258"led"sizeof(struct led_uc_plat)_u_boot_list_2_uclass_2_led.u_boot_list_2_uclass_2_led/* default-state = "keep" : device is only probed *//* Ignore the top-level LED node *//opt/src/drivers/led/opt/src/drivers/led/led_gpio.cled_gpioled_gpio_bind"%s: node %s has no label\n"__func__, ofnode_get_name(node)debug("%s: node %s has no label\n", __func__,
			      ofnode_get_name(node))drivers/led/led_gpio.c%s: node %s has no label
gpio_led"gpio_led"led_gpio_removeled_gpio_probeled_gpio_priv *gpio_led_get_state4294967175gpio_led_set_stateled_gpio_privconst led_opsconst led_ops *sizeof(struct led_gpio_priv)_u_boot_list_2_driver_2_led_gpio.u_boot_list_2_driver_2_led_gpiogpio-leds"gpio-leds"led_gpio_idsgpio_led_ops/*
	 * The GPIO driver may have already been removed. We will need to
	 * address this more generally.
	 *//opt/src/include/mailbox.hmailboxmbox_chancon_priv_MAILBOX_Hmbox_recvmbox_chan *mbox_sendmbox_freembox_get_by_namembox_get_by_index/**
 * mbox_recv - Receive any available message from a mailbox channel
 *
 * This function will wait (up to the specified @timeout_us) for a message to
 * be sent by the remote entity, and write the content of any such message
 * into a caller-provided buffer.
 *
 * @chan:	A channel object that was previously successfully requested by
 *		calling mbox_get_by_*().
 * @data:	A pointer to the buffer to receive the message. The format and
 *		size of the memory region pointed at by @data is determined by
 *		the mailbox provider. Providers that solely transfer
 *		notifications will ignore this parameter.
 * @timeout_us:	The maximum time to wait for a message to be available, in
 *		micro-seconds. A value of 0 does not wait at all.
 * @return 0 if OK, -ENODATA if no message was available, or a negative error
 * code.
 *//**
 * mbox_send - Send a message over a mailbox channel
 *
 * This function will send a message to the remote entity. It may return before
 * the remote entity has received and/or processed the message.
 *
 * @chan:	A channel object that was previously successfully requested by
 *		calling mbox_get_by_*().
 * @data:	A pointer to the message to transfer. The format and size of
 *		the memory region pointed at by @data is determined by the
 *		mailbox provider. Providers that solely transfer notifications
 *		will ignore this parameter.
 * @return 0 if OK, or a negative error code.
 *//**
 * mbox_free - Free a previously requested mailbox channel.
 *
 * @chan:	A channel object that was previously successfully requested by
 *		calling mbox_get_by_*().
 * @return 0 if OK, or a negative error code.
 *//**
 * mbox_get_by_name - Get/request a mailbox by name
 *
 * This looks up and requests a mailbox channel. The name is relative to the
 * client device; each device is assumed to have n mailbox channels associated
 * with it somehow, and this function finds and requests one of them. The
 * mapping of client device channel names to provider channels may be via
 * device-tree properties, board-provided mapping tables, or some other
 * mechanism.
 *
 * @dev:	The client device.
 * @name:	The name of the mailbox channel to request, within the client's
 *		list of channels.
 * @chan	A pointer to a channel object to initialize.
 * @return 0 if OK, or a negative error code.
 *//**
 * mbox_get_by_index - Get/request a mailbox by integer index
 *
 * This looks up and requests a mailbox channel. The index is relative to the
 * client device; each device is assumed to have n mailbox channels associated
 * with it somehow, and this function finds and requests one of them. The
 * mapping of client device channel indices to provider channels may be via
 * device-tree properties, board-provided mapping tables, or some other
 * mechanism.
 *
 * @dev:	The client device.
 * @index:	The index of the mailbox channel to request, within the
 *		client's list of channels.
 * @chan	A pointer to a channel object to initialize.
 * @return 0 if OK, or a negative error code.
 *//* Written by of_xlate.*//**
 * struct mbox_chan - A handle to a single mailbox channel.
 *
 * Clients provide storage for channels. The content of the channel structure
 * is managed solely by the mailbox API and mailbox drivers. A mailbox channel
 * is initialized by "get"ing the mailbox. The channel struct is passed to all
 * other mailbox APIs to identify which mailbox to operate upon.
 *
 * @dev: The device which implements the mailbox.
 * @id: The mailbox channel ID within the provider.
 * @con_priv: Hook for controller driver to attach private data
 *
 * Currently, the mailbox API assumes that a single integer ID is enough to
 * identify and configure any mailbox channel for any mailbox provider. If this
 * assumption becomes invalid in the future, the struct could be expanded to
 * either (a) add more fields to allow mailbox providers to store additional
 * information, or (b) replace the id field with an opaque pointer, which the
 * provider would dynamically allocated during its .of_xlate op, and process
 * during is .request op. This may require the addition of an extra op to clean
 * up the allocation.
 *//**
 * A mailbox is a hardware mechanism for transferring small fixed-size messages
 * and/or notifications between the CPU on which U-Boot runs and some other
 * device such as an auxiliary CPU running firmware or a hardware module.
 *
 * Data transfer is optional; a mailbox may consist solely of a notification
 * mechanism. When data transfer is implemented, it is via HW registers or
 * FIFOs, rather than via RAM-based buffers. The mailbox API generally
 * implements any communication protocol enforced solely by hardware, and
 * leaves any higher-level protocols to other layers.
 *
 * A mailbox channel is a bi-directional mechanism that can send a message or
 * notification to a single specific remote entity, and receive messages or
 * notifications from that entity. The size, content, and format of such
 * messages is defined by the mailbox implementation, or the remote entity with
 * which it communicates; there is no general standard at this API level.
 *
 * A driver that implements UCLASS_MAILBOX is a mailbox provider. A provider
 * will often implement multiple separate mailbox channels, since the hardware
 * it manages often has this capability. mailbox-uclass.h describes the
 * interface which mailbox providers must implement.
 *
 * Mailbox consumers/clients generate and send, or receive and process,
 * messages. This header file describes the API used by clients.
 *//opt/src/include/mailbox-uclass.hmailbox-uclassmbox_ops_MAILBOX_UCLASS_H/**
	* recv - Receive any available message from the channel.
	*
	* This function does not block. If not message is immediately
	* available, the function should return an error.
	*
	* @chan:	The channel to receive to the message from.
	* @data:	A pointer to the buffer to hold the received message.
	* @return 0 if OK, -ENODATA if no message was available, or a negative
	* error code.
	*//**
	* send - Send a message over a mailbox channel
	*
	* @chan:	The channel to send to the message to.
	* @data:	A pointer to the message to send.
	* @return 0 if OK, or a negative error code.
	*//**
	 * free - Free a previously requested channel.
	 *
	 * This is the implementation of the client mbox_free() API.
	 *
	 * @chan:	The channel to free.
	 * @return 0 if OK, or a negative error code.
	 *//**
	 * request - Request a translated channel.
	 *
	 * The mailbox core calls this function as the second step in
	 * implementing a client's mbox_get_by_*() call, following a successful
	 * xxx_xlate() call.
	 *
	 * @chan:	The channel to request; this has been filled in by a
	 *		previoux xxx_xlate() function call.
	 * @return 0 if OK, or a negative error code.
	 *//**
	 * of_xlate - Translate a client's device-tree (OF) mailbox specifier.
	 *
	 * The mailbox core calls this function as the first step in
	 * implementing a client's mbox_get_by_*() call.
	 *
	 * If this function pointer is set to NULL, the mailbox core will use
	 * a default implementation, which assumes #mbox-cells = <1>, and that
	 * the DT cell contains a simple integer channel ID.
	 *
	 * At present, the mailbox API solely supports device-tree. If this
	 * changes, other xxx_xlate() functions may be added to support those
	 * other mechanisms.
	 *
	 * @chan:	The channel to hold the translation result.
	 * @args:	The mailbox specifier values from device tree.
	 * @return 0 if OK, or a negative error code.
	 *//**
 * struct mbox_ops - The functions that a mailbox driver must implement.
 *//* See mailbox.h for background documentation. */<mailbox.h>/opt/src/drivers/mailbox/mailbox-uclass.c"%s(chan=%p, data=%p, timeout_us=%ld)\n"__func__, chan, data, timeout_usdebug("%s(chan=%p, data=%p, timeout_us=%ld)\n", __func__, chan, data,
	      timeout_us)drivers/mailbox/mailbox-uclass.c%s(chan=%p, data=%p, timeout_us=%ld)
mbox_ops *"%s(chan=%p, data=%p)\n"__func__, chan, datadebug("%s(chan=%p, data=%p)\n", __func__, chan, data)%s(chan=%p, data=%p)
"%s(chan=%p)\n"__func__, chandebug("%s(chan=%p)\n", __func__, chan)%s(chan=%p)
"%s(dev=%p, name=%s, chan=%p)\n"__func__, dev, name, chandebug("%s(dev=%p, name=%s, chan=%p)\n", __func__, dev, name, chan)%s(dev=%p, name=%s, chan=%p)
mbox-names"mbox-names"/opt/src/drivers/mailbox<mailbox-uclass.h>"%s(dev=%p, index=%d, chan=%p)\n"__func__, dev, index, chandebug("%s(dev=%p, index=%d, chan=%p)\n", __func__, dev, index, chan)%s(dev=%p, index=%d, chan=%p)
mboxes"mboxes"#mbox-cells"#mbox-cells""%s: dev_read_phandle_with_args failed: %d\n"debug("%s: dev_read_phandle_with_args failed: %d\n", __func__,
		      ret)%s: dev_read_phandle_with_args failed: %d
UCLASS_MAILBOXdev_mbox"%s: uclass_get_device_by_of_offset failed: %d\n"debug("%s: uclass_get_device_by_of_offset failed: %d\n",
		      __func__, ret)%s: uclass_get_device_by_of_offset failed: %d
"ops->request() failed: %d\n"debug("ops->request() failed: %d\n", ret)ops->request() failed: %d
mbox_of_xlate_defaultmbox_dev_ops"mailbox"_u_boot_list_2_uclass_2_mailbox.u_boot_list_2_uclass_2_mailbox/*
	 * Account for partial us ticks, but if timeout_us is 0, ensure we
	 * still don't wait at all.
	 *//opt/src/drivers/mailbox/sandbox-mbox-test.csandbox-mbox-testsandbox_mbox_test_freesandbox_mbox_test *sbmtsandbox_mbox_test_recvsandbox_mbox_test_sendsandbox_mbox_test_getsandbox_mbox_test"sandbox_mbox_test"sizeof(struct sandbox_mbox_test)_u_boot_list_2_driver_2_sandbox_mbox_test.u_boot_list_2_driver_2_sandbox_mbox_testsandbox,mbox-test"sandbox,mbox-test"sandbox_mbox_test_ids/opt/src/arch/sandbox/include/asm/mbox.hmboxSANDBOX_MBOX_PING_XOR0x12345678__SANDBOX_MBOX_H/opt/src/drivers/mailbox/sandbox-mbox.csandbox-mboxsandbox_mbox_probe"%s(dev=%p)\n"debug("%s(dev=%p)\n", __func__, dev)drivers/mailbox/sandbox-mbox.c%s(dev=%p)
sandbox_mbox_bindsandbox_mbox_recvsandbox_mbox *sbmsandbox_mbox_chan[2]SANDBOX_MBOX_CHANNELSsandbox_mbox_chan *pmsgsandbox_mbox_send305419896sandbox_mbox_free<asm/mbox.h>sandbox_mbox_requestsandbox_mboxsandbox_mbox_chanchansrx_msgrx_msg_valid"sandbox_mbox"sizeof(struct sandbox_mbox)_u_boot_list_2_driver_2_sandbox_mbox.u_boot_list_2_driver_2_sandbox_mboxsandbox_mbox_mbox_opssandbox,mbox"sandbox,mbox"sandbox_mbox_ids/opt/src/drivers/misc/cros_ec.cEC_HOST_EVENT_MASK(EC_HOST_EVENT_LID_CLOSED)~EC_HOST_EVENT_MASK(EC_HOST_EVENT_LID_CLOSED)EC: %sabled lid close event
"EC: %sabled lid close event\n"ec_params_config_power_button *sizeof(params)ec_params_charge_state *sizeof(p)ec_response_charge_state *sizeof(r)-EC_RES_INVALID_PARAM-EC_RES_INVALID_COMMAND"PARAM_LIMIT_POWER not supported by EC\n"log_warning("PARAM_LIMIT_POWER not supported by EC\n")drivers/misc/cros_ec.c1421PARAM_LIMIT_POWER not supported by EC
sizeof(r.get_param)"Chrome EC: clear events_b mask to 0x%016llx\n", mask"Chrome EC: clear events_b mask to 0x%016llx\n"log_debug("Chrome EC: clear events_b mask to 0x%016llx\n", mask)1400Chrome EC: clear events_b mask to 0x%016llx
cros_ec_clear_masktype < ARRAY_SIZE(event_map)type < (sizeof(event_map) / sizeof((event_map)[0]))const struct <unnamed>[9]struct <unnamed>[9]event_mapassert(type < ARRAY_SIZE(event_map))/opt/src/drivers/misc1387cros_ec_get_mask1375cros_ec_is_uhepi_supporteduhepi_supportUHEPI_SUPPORTEDUHEPI_NOT_SUPPORTED"Chrome EC: UHEPI %s\n", uhepi_support == UHEPI_SUPPORTED ? "supported" : "not supported""Chrome EC: UHEPI %s\n"uhepi_support == UHEPI_SUPPORTED ? "supported" : "not supported"log_debug("Chrome EC: UHEPI %s\n",
			  uhepi_support == UHEPI_SUPPORTED ? "supported" :
			  "not supported")1363Chrome EC: UHEPI %s
"supported"not supported"not supported"cros_ec_handle_non_uhepi_cmdINVALID_HCMDec_params_host_event_mask *sizeof(req)ec_response_host_event_mask *sizeof(rsp)cros_ec_uhepi_cmdec_params_host_event *ec_response_host_event *cros_ec_check_featurervec_response_get_features *sizeof(r.flags)8 * sizeof(r.flags)EC_FEATURE_MASK_0(feature)ec_params_i2c_passthru *sizeof(*p)ec_params_i2c_passthru_msg *sizeof(*msg)read_lenread_ptrec_response_i2c_passthru *sizeof(*r)hcmdRead length too big for buffer
"Read length too big for buffer\n"Params too large for buffer
"Params too large for buffer\n"Transfer failed with status=0x%x
"Transfer failed with status=0x%x\n"Truncated read response
"Truncated read response\n""flash""Failed to find flash node\n"debug("Failed to find flash node\n")1174Failed to find flash node
"Failed to decode flash node in chrome-ec\n"debug("Failed to decode flash node in chrome-ec\n")1179Failed to decode flash node in chrome-ec
erase-value"erase-value"wp-ro"wp-ro""Unknown EC flash region name '%s'\n"debug("Unknown EC flash region name '%s'\n", name)Unknown EC flash region name '%s'
"Failed to decode flash region in chrome-ec'\n"debug("Failed to decode flash region in chrome-ec'\n")1201Failed to decode flash region in chrome-ec'
cros_ec_dev *ec-interrupt"ec-interrupt"optimise-flash-write"optimise-flash-write""%s: Could not detect CROS-EC version\n"debug("%s: Could not detect CROS-EC version\n", __func__)%s: Could not detect CROS-EC version
-CROS_EC_ERR_CHECK_VERSION1157-CROS_EC_ERR_READ_ID"Google Chrome EC v%d CROS-EC driver ready, id '%s'\n"cdev->protocol_version, iddebug("Google Chrome EC v%d CROS-EC driver ready, id '%s'\n",
	      cdev->protocol_version, id)1163Google Chrome EC v%d CROS-EC driver ready, id '%s'
ec_params_ldo_get *ec_response_ldo_get *ec_response_ldo_get **sizeof(*resp)ec_params_ldo_set *ec_params_battery_cutoff *ec_params_vbnvcontext *"Expected %d bytes, got %d\n", size, len"Expected %d bytes, got %d\n"size, lenlog_err("Expected %d bytes, got %d\n", size, len)1071Expected %d bytes, got %d
rw_offsetrw_sizeend - offburstcros_ec_flash_read_blockec_params_flash_read *"EFS: EC is verifying updated image...\n"log_info("EFS: EC is verifying updated image...\n")956EFS: EC is verifying updated image...
ec_params_efs_verify *"EFS: Verification success\n"log_info("EFS: Verification success\n")961EFS: Verification success
"EFS: EC doesn't support EFS_VERIFY command\n"log_info("EFS: EC doesn't support EFS_VERIFY command\n")965EFS: EC doesn't support EFS_VERIFY command
"EFS: Verification failed\n"log_info("EFS: Verification failed\n")EFS: Verification failed
cros_ec_data_is_erased!(size & 3)assert(!(size & 3))cros_ec_flash_write_burst_sizecros_ec_flash_write_blockec_params_flash_write *data && p->size <= EC_FLASH_WRITE_VER0_SIZEdata && p->size <= 64assert(data && p->size <= EC_FLASH_WRITE_VER0_SIZE)850ec_params_flash_erase *ec_params_flash_region_info *ec_response_flash_region_info *ec_response_flash_region_info **ec_params_hello *ec_response_hello *ec_response_hello **ec_command_inptr() returned error
"ec_command_inptr() returned error\n"169090600x01020304Received invalid handshake %x
"Received invalid handshake %x\n"cros_ec_check_versiondm_cros_ec_ops *%s: ERROR: old EC interface not supported
"%s: ERROR: old EC interface not supported\n"sizeof(mode)ec_params_flash_protect *ec_response_host_event_mask **(int)sizeof(*resp)EC_HOST_EVENT_MASK(EC_HOST_EVENT_INVALID)cros_ec_set_event_maskcros_ec_get_event_maskec_params_reboot_ec *cros_ec_invalidate_hashdebug("%s:\n", __func__)562ec_params_vboot_hash *ec_response_vboot_hash **sizeof(*hash)"%s: No valid hash (status=%d size=%d). Compute one...\n"__func__, hash->status, hash->sizedebug("%s: No valid hash (status=%d size=%d). Compute one...\n",
	      __func__, hash->status, hash->size)%s: No valid hash (status=%d size=%d). Compute one...
"%s: hash done\n"debug("%s: hash done\n", __func__)542%s: hash done
cros_ec_wait_on_hash_doneCROS_EC_CMD_HASH_TIMEOUT_MS"%s: EC_VBOOT_HASH_GET timeout\n"debug("%s: EC_VBOOT_HASH_GET timeout\n", __func__)%s: EC_VBOOT_HASH_GET timeout
-EC_RES_TIMEOUTsizeof(**versionp)"Got rc %d, expected %u\n", ret, (uint)sizeof(*r)"Got rc %d, expected %u\n"ret, (uint)sizeof(*r)log_err("Got rc %d, expected %u\n", ret, (uint)sizeof(*r))Got rc %d, expected %u
(uint)sizeof(*r)(int)sizeof(r->version_string_ro)sizeof(r->version_string_ro)"Invalid EC image %d\n", r->current_image"Invalid EC image %d\n"r->current_imagelog_err("Invalid EC image %d\n", r->current_image)Invalid EC image %d
sizeof(scan->data)ec_command(din_len == 0) || dinassert((din_len == 0) || din)in_bufferlen <= din_lenassert(len <= din_len)399cmd_versiondout_lendin_lenec_command_inptr-EC_RES_IN_PROGRESSec_response_get_comms_status *ec_response_get_comms_status **CROS_EC_CMD_TIMEOUT_MS"%s: Command %#02x timeout\n"__func__, cmddebug("%s: Command %#02x timeout\n",
				      __func__, cmd)%s: Command %#02x timeout
"%s: len=%d, din=%p\n"__func__, len, dindebug("%s: len=%d, din=%p\n", __func__, len, din)%s: len=%d, din=%p
len <= 0 || !((uintptr_t)din & 7)assert(len <= 0 || !((uintptr_t)din & 7))send_commanddev->devsend_command_proto3out_bytesin_bytescdev->devhandle_proto3_responsein-header"in-header"ec_host_response *sizeof(*rs)"%s: EC response version mismatch\n"debug("%s: EC response version mismatch\n", __func__)%s: EC response version mismatch
-EC_RES_INVALID_RESPONSEdinp"%s: EC response reserved != 0\n"debug("%s: EC response reserved != 0\n", __func__)%s: EC response reserved != 0
"%s: EC returned too much data\n"debug("%s: EC returned too much data\n", __func__)%s: EC returned too much data
-EC_RES_RESPONSE_TOO_BIGin-data"in-data"csum"%s: EC response checksum invalid: 0x%02x\n"__func__, csumdebug("%s: EC response checksum invalid: 0x%02x\n", __func__,
		      csum)%s: EC response checksum invalid: 0x%02x
-EC_RES_INVALID_CHECKSUMprepare_proto3_response_buffersizeof(struct ec_host_response)(int)sizeof(cdev->din)"%s: Cannot receive %d bytes\n"__func__, din_lendebug("%s: Cannot receive %d bytes\n", __func__, din_len)%s: Cannot receive %d bytes
create_proto3_requestec_host_request *rqsizeof(*rq)(int)sizeof(cdev->dout)"%s: Cannot send %d bytes\n"__func__, dout_lendebug("%s: Cannot send %d bytes\n", __func__, dout_len)%s: Cannot send %d bytes
-EC_RES_REQUEST_TRUNCATEDuint8_t[252]unsigned char[252]get_cmdclear_cmdset_cmdcros-ec"cros-ec"584sizeof(struct cros_ec_dev)_u_boot_list_2_uclass_2_cros_ec.u_boot_list_2_uclass_2_cros_ecdebug_trace(fmt,b...)DEBUG_TRACE/* Set lid close event state in the EC SMI event mask *//*
	 * If our EC doesn't support the LIMIT_POWER parameter, assume that
	 * LIMIT_POWER is not requested.
	 *//*
 * Query the EC for specified mask indicating enabled events.
 * The EC maintains separate event masks for SMI, SCI and WAKE.
 *//* We only support a single read message for each transfer *//* Parse response *//* Create a message to write the register address and optional data *//* Remember this device for use by the cros_ec command *//* Write the image *//*
	 * Erase the entire RW section, so that the EC doesn't see any garbage
	 * past the new image if it's smaller than the current image.
	 *
	 * TODO: could optimize this to erase just the current image, since
	 * presumably everything past that is 0xff's.  But would still need to
	 * round up to the nearest multiple of erase size.
	 *//* Invalidate the existing hash, just in case the AP reboots
	 * unexpectedly during the update. If that happened, the EC RW firmware
	 * would be invalid, but the EC would still have the original hash.
	 *//**
 * Read a single block from the flash
 *
 * Read a block of data from the EC flash. The size must not exceed the flash
 * write block size which you can obtain from cros_ec_flash_write_burst_size().
 *
 * The offset starts at 0. You can obtain the region information from
 * cros_ec_flash_offset() to find out where to read for a particular region.
 *
 * @param dev		CROS-EC device
 * @param data		Pointer to data buffer to read into
 * @param offset	Offset within flash to read from
 * @param size		Number of bytes to read
 * @return 0 if ok, -1 on error
 *//**
 * Run verification on a slot
 *
 * @param me     CrosEc instance
 * @param region Region to run verification on
 * @return 0 if success or not applicable. Non-zero if verification failed.
 *//* If the data is empty, there is no point in programming it *//*
	 * TODO: round up to the nearest multiple of write size.  Can get away
	 * without that on link right now because its write size is 4 bytes.
	 *//**
 * Check if a block of data is erased (all 0xff)
 *
 * This function is useful when dealing with flash, for checking whether a
 * data block is erased and thus does not need to be programmed.
 *
 * @param data		Pointer to data to check (must be word-aligned)
 * @param size		Number of bytes to check (must be word-aligned)
 * @return 0 if erased, non-zero if any word is not erased
 *//**
 * Return optimal flash write burst size
 *//**
 * Write a single block to the flash
 *
 * Write a block of data to the EC flash. The size must not exceed the flash
 * write block size which you can obtain from cros_ec_flash_write_burst_size().
 *
 * The offset starts at 0. You can obtain the region information from
 * cros_ec_flash_offset() to find out where to write for a particular region.
 *
 * Attempting to write to the region where the EC is currently running from
 * will result in an error.
 *
 * @param dev		CROS-EC device
 * @param data		Pointer to data buffer to write
 * @param offset	Offset within flash to write to.
 * @param size		Number of bytes to write
 * @return 0 if ok, -1 on error
 *//*
	 * Fail if we're still here, since the EC doesn't understand any
	 * protcol version we speak.  Version 1 interface without command
	 * version is no longer supported, and we don't know about any new
	 * protocol versions.
	 *//* Try sending a version 2 packet *//* Try sending a version 3 packet *//*
	 * TODO(sjg@chromium.org).
	 * There is a strange oddity here with the EC. We could just ignore
	 * the response, i.e. pass the last two parameters as NULL and 0.
	 * In this case we won't read back very many bytes from the EC.
	 * On the I2C bus the EC gets upset about this and will try to send
	 * the bytes anyway. This means that we will have to wait for that
	 * to complete before continuing with a new EC command.
	 *
	 * This problem is probably unique to the I2C bus.
	 *
	 * So for now, just read all the data anyway.
	 *//*
	 * Use the B copy of the event flags, so it affects the data returned
	 * by cros_ec_get_host_events().
	 *//*
	 * Use the B copy of the event flags, because the main copy is already
	 * used by ACPI/SMI.
	 *//* no interrupt support : always poll *//*
		 * TODO(rspangler@chromium.org): Would be nice if we had a
		 * better way to determine when the reboot is complete.  Could
		 * we poll a memory-mapped LPC value?
		 *//*
		 * EC reboot will take place immediately so delay to allow it
		 * to complete.  Note that some reboot types (EC_REBOOT_COLD)
		 * will reboot the AP as well, in which case we won't actually
		 * get to this point.
		 *//* No need to wait for it to finish *//* We don't have an explict command for the EC to discard its current
	 * hash value, so we'll just tell it to calculate one that we know is
	 * wrong (we claim that hashing zero bytes is always invalid).
	 *//* If the hash is valid, we're done. Otherwise, we have to kick it off
	 * again and wait for it to complete. Note that we explicitly assume
	 * that hashing zero bytes is always wrong, even though that would
	 * produce a valid hash value. *//* If the EC is busy calculating the hash, fidget until it's done. *//* Insert some reasonable delay *//*
		 * If we were asked to put it somewhere, do so, otherwise just
		 * disregard the result.
		 *//**
 * Send a command to the CROS-EC device and return the reply.
 *
 * The device's internal input/output buffers are used.
 *
 * @param dev		CROS-EC device
 * @param cmd		Command to send (EC_CMD_...)
 * @param cmd_version	Version of command to send (EC_VER_...)
 * @param dout          Output data (may be NULL If dout_len=0)
 * @param dout_len      Size of output data in bytes
 * @param din           Response data (may be NULL If din_len=0).
 *			It not NULL, it is a place for ec_command() to copy the
 *      data to.
 * @param din_len       Maximum size of response in bytes
 * @return number of bytes in response, or -ve on error
 *//* If we have any data to return, it must be 64bit-aligned *//* not sure why it was 0 for the last argument *//* OK it completed, so read the status response *//* Wait for command to complete *//* If the command doesn't complete, wait a while *//**
 * Send a command to the CROS-EC device and return the reply.
 *
 * The device's internal input/output buffers are used.
 *
 * @param dev		CROS-EC device
 * @param cmd		Command to send (EC_CMD_...)
 * @param cmd_version	Version of command to send (EC_VER_...)
 * @param dout          Output data (may be NULL If dout_len=0)
 * @param dout_len      Size of output data in bytes
 * @param dinp          Response data (may be NULL If din_len=0).
 *			If not NULL, it will be updated to point to the data
 *			and will always be double word aligned (64-bits)
 * @param din_len       Maximum size of response in bytes
 * @return number of bytes in response, or -ve on error
 *//* Handle protocol version 3 support *//* Process the response *//* Prepare response buffer *//* Create request packet *//* If we're still here, set response data pointer and return length *//* Return error result, if any *//* Verify checksum *//* Update in_bytes to actual data size *//* Check input data *//**
 * Handle a protocol version 3 response packet.
 *
 * The packet must already be stored in the device's internal input buffer.
 *
 * @param dev		CROS-EC device
 * @param dinp          Returns pointer to response data
 * @param din_len       Maximum size of response in bytes
 * @return number of bytes of response data, or <0 if error. Note that error
 * codes can be from errno.h or -ve EC_RES_INVALID_CHECKSUM values (and they
 * overlap!)
 *//* Return expected size of response packet *//* Fail if input size is too big *//**
 * Prepare the device to receive a protocol version 3 response.
 *
 * @param dev		CROS-EC device
 * @param din_len       Maximum size of response in bytes
 * @return maximum expected number of bytes in response, or <0 if error.
 *//* Return size of request packet *//* Write checksum field so the entire packet sums to 0 *//* Copy data after header *//* Fill in request packet *//* Fail if output size is too big *//**
 * Create a request packet for protocol version 3.
 *
 * The packet is stored in the device's internal output buffer.
 *
 * @param dev		CROS-EC device
 * @param cmd		Command to send (EC_CMD_...)
 * @param cmd_version	Version of command to send (EC_VER_...)
 * @param dout          Output data (may be NULL If dout_len=0)
 * @param dout_len      Size of output data in bytes
 * @return packet size in bytes, or <0 if error.
 *//*
 * Calculate a simple 8-bit checksum of a data block
 *
 * @param data	Data block to checksum
 * @param size	Size of data block in bytes
 * @return checksum value (0 to 255)
 *//*
 * Map UHEPI masks to non UHEPI commands in order to support old EC FW
 * which does not support UHEPI command.
 *//* Timeout waiting for a synchronous hash to be recomputed *//* Timeout waiting for a flash erase command to complete *//*
 * This is the interface to the Chrome OS EC. It provides keyboard functions,
 * power control and battery management. Quite a few other functions are
 * provided to enable the EC software to be updated, talk to the EC's I2C bus
 * and store a small amount of data in a memory which persists while the EC
 * is not reset.
 *//opt/src/drivers/misc/cros_ec_i2c.ccros_ec_i2ccros_ec_probecros_ec_i2c_commandsizeof(dev->dout)drivers/misc/cros_ec_i2c.csizeof(dev->din)dout_len >= 0assert(dout_len >= 0)assert(dinp)in_ptr"%s: Protocol version %d unsupported\n"__func__, dev->protocol_versiondebug("%s: Protocol version %d unsupported\n",
		      __func__, dev->protocol_version)%s: Protocol version %d unsupported
"%s: Could not execute transfer to %s\n"__func__, udev->namedebug("%s: Could not execute transfer to %s\n", __func__,
		      udev->name)%s: Could not execute transfer to %s
"%s: Received bad result code %d\n"__func__, *in_ptrdebug("%s: Received bad result code %d\n", __func__, *in_ptr)%s: Received bad result code %d
"%s: Received length %#02x too large\n"__func__, lendebug("%s: Received length %#02x too large\n",
		      __func__, len)%s: Received length %#02x too large
"%s: Invalid checksum rx %#02x, calced %#02x\n"__func__, in_ptr[2 + din_len], csumdebug("%s: Invalid checksum rx %#02x, calced %#02x\n",
		      __func__, in_ptr[2 + din_len], csum)%s: Invalid checksum rx %#02x, calced %#02x
cros_ec_i2c_packetec_host_request_i2c *ec_request_i2c%s: Could not execute transfer: %d
"%s: Could not execute transfer: %d\n"ec_host_response_i2c *ec_response_i2c%s: response of %u bytes too short; not a full hdr
"%s: response of %u bytes too short; not a full hdr\n"ec_host_response_i2cec_host_request_i2cec_responsepacket_lengthec_requestcommand_protocol"cros_ec_i2c"_u_boot_list_2_driver_2_cros_ec_i2c.u_boot_list_2_driver_2_cros_ec_i2cgoogle,cros-ec-i2c"google,cros-ec-i2c"cros_ec_idscros_ec_ops/* Return pointer to dword-aligned input data, if any *//* Send output data *//* Expect status, length bytes *//* Something we don't support *//*
	 * in_ptr starts of pointing to a dword-aligned input data buffer.
	 * We decrement it back by the number of header bytes we expect to
	 * receive, so that the first parameter of the resulting input data
	 * will be dword aligned.
	 *//*
	 * Copy command and data into output buffer so we can do a single I2C
	 * burst transaction.
	 *//*
	 * Sanity-check I/O sizes given transaction overhead in internal
	 * buffers.
	 *//* Receive input data, so that args will be dword aligned *//* response8, arglen8, in8[din_len], checksum8 *//* version8, cmd8, arglen8, out8[dout_len], csum8 *//* drop result and packet_len *//* When we send a v3 request to v2 ec, ec won't recognize the 0xda
	 * (EC_COMMAND_PROTOCOL_3) and will return with status
	 * EC_RES_INVALID_COMMAND with zero data length
	 *
	 * In case of invalid command for v3 protocol the data length
	 * will be at least sizeof(struct ec_host_response)
	 *//* two extra bytes for v3 *//* stitch on EC_COMMAND_PROTOCOL_3 *//* one extra byte, to indicate v3 *//*
 * Response format for protocol v3
 * byte 0	result code
 * byte 1	packet_length
 * byte 2-9	struct ec_host_response
 * byte 10-	response data
 *//* Always 0xda to backward compatible with v2 struct *//**
 * Request format for protocol v3
 * byte 0	0xda (EC_COMMAND_PROTOCOL_3)
 * byte 1-8	struct ec_host_request
 * byte 10-	response data
 *//*
 * The Matrix Keyboard Protocol driver handles talking to the keyboard
 * controller chip. Mostly this is for keyboard functions, but some other
 * things have slipped in, so we provide generic services to talk to the
 * KBC.
 *//*
 * Chromium OS cros_ec driver - I2C interface
 *
 * Copyright (c) 2012 The Chromium OS Authors.
 *//opt/src/drivers/misc/cros_ec_lpc.ccros_ec_lpccros_ec_lpc_check_version2336EC_LPC_ADDR_MEMMAP + EC_MEMMAP_ID'E'EC_LPC_ADDR_MEMMAP + EC_MEMMAP_ID + 12343EC_LPC_ADDR_MEMMAP +
				EC_MEMMAP_HOST_CMD_FLAGScros_ec_lpc_init"%s: CROS_EC device not found on LPC bus\n"debug("%s: CROS_EC device not found on LPC bus\n",
			__func__)drivers/misc/cros_ec_lpc.c%s: CROS_EC device not found on LPC bus
cros_ec_lpc_command"%s: Timeout waiting ready\n"debug("%s: Timeout waiting ready\n", __func__)%s: Timeout waiting ready
sizeof(args)args_addr EC_LPC_ADDR_HOST_ARGSec_lpc_host_args *param_addr EC_LPC_ADDR_HOST_PARAM*dcmd_addr EC_LPC_ADDR_HOST_CMD"%s: Timeout waiting for response\n"debug("%s: Timeout waiting for response\n", __func__)%s: Timeout waiting for response
 EC_LPC_ADDR_HOST_DATA"%s: CROS_EC result code %d\n"__func__, idebug("%s: CROS_EC result code %d\n", __func__, i)%s: CROS_EC result code %d
"%s: CROS_EC protocol mismatch\n"debug("%s: CROS_EC protocol mismatch\n", __func__)%s: CROS_EC protocol mismatch
"%s: CROS_EC returned too much data %d > %d\n"__func__, args.data_size, din_lendebug("%s: CROS_EC returned too much data %d > %d\n",
		      __func__, args.data_size, din_len)%s: CROS_EC returned too much data %d > %d
"%s: CROS_EC response has invalid checksum\n"debug("%s: CROS_EC response has invalid checksum\n", __func__)%s: CROS_EC response has invalid checksum
"cmd: %02x, ver: %02x"cmd, cmd_versioncros_ec_lpc_packet"Cannot send that many bytes\n"log_msg_ret("Cannot send that many bytes\n", -E2BIG)-E2BIG)"Cannot send that many bytes\n", __retCannot send that many bytes
"Cannot receive that many bytes\n"log_msg_ret("Cannot receive that many bytes\n", -E2BIG)"Cannot receive that many bytes\n", __retCannot receive that many bytes
"Timeout waiting ready\n"log_msg_ret("Timeout waiting ready\n", -ETIMEDOUT)-ETIMEDOUT)"Timeout waiting ready\n", __retTimeout waiting ready
wait_for_sync"%s: Timeout waiting for CROS_EC sync\n"debug("%s: Timeout waiting for CROS_EC sync\n",
			      __func__)%s: Timeout waiting for CROS_EC sync
"cros_ec_lpc"_u_boot_list_2_driver_2_cros_ec_lpc.u_boot_list_2_driver_2_cros_ec_lpcgoogle,cros-ec-lpc"google,cros-ec-lpc"/*
 * Test if LPC command args are supported.
 *
 * The cheapest way to do this is by looking for the memory-mapped
 * flag.  This is faster than sending a new-style 'hello' command and
 * seeing whether the EC sets the EC_HOST_ARGS_FLAG_FROM_HOST flag
 * in args when it responds.
 *//* See if we can find an EC at the other end *//**
 * Initialize LPC protocol.
 *
 * @param dev		CROS_EC device
 * @param blob		Device tree blob
 * @return 0 if ok, -1 on error
 *//* Return actual amount of data received *//* Read data, if any *//*
	 * If EC didn't modify args flags, then somehow we sent a new-style
	 * command to an old EC, which means it would have read its params
	 * from the wrong place.
	 *//* Read back args *//* Check result *//* Write data, if any *//* Write args *//* Calculate checksum *//* Fill in args *//* Start the command *//* Write data *//*
 * Chromium OS cros_ec driver - LPC interface
 *
 * Copyright (c) 2012 The Chromium OS Authors.
 *//opt/src/arch/sandbox/include/asm/sdl.h__SANDBOX_SDL_HCONFIG_SANDBOX_SDL/**
 * sandbox_sdl_sound_init() - set up the sound system
 *
 * @rate:	Sample rate to use
 * @channels:	Number of channels to use (1=mono, 2=stereo)
 * @return 0 if OK, -ENODEV if no sound is available
 *//**
 * sandbox_sdl_sound_stop() - stop playing a sound
 *
 * @return 0 if OK, -ENODEV if no sound is available
 *//**
 * sandbox_sdl_sound_play() - Play a sound
 *
 * @data:	Data to play (typically 16-bit)
 * @count:	Number of bytes in data
 *//**
 * sandbox_sdl_key_pressed() - check if a particular key is pressed
 *
 * @keycode:	Keycode to check (KEY_... - see include/linux/input.h
 * @return 0 if pressed, -ENOENT if not pressed. -ENODEV if keybord not
 * available,
 *//**
 * sandbox_sdl_scan_keys() - scan for pressed keys
 *
 * Works out which keys are pressed and returns a list
 *
 * @key:	Array to receive keycodes
 * @max_keys:	Size of array
 * @return number of keycodes found, 0 if none, -ENODEV if no keyboard
 *//**
 * sandbox_sdl_sync() - Sync current U-Boot LCD frame buffer to SDL
 *
 * This must be called periodically to update the screen for SDL so that the
 * user can see it.
 *
 * @lcd_base: Base of frame buffer
 * @return 0 if screen was updated, -ENODEV is there is no screen.
 *//**
 * sandbox_sdl_init_display() - Set up SDL video ready for use
 *
 * @width:	Window width in pixels
 * @height	Window height in pixels
 * @log2_bpp:	Log to base 2 of the number of bits per pixel. So a 32bpp
 *		display will pass 5, since 2*5 = 32
 * @return 0 if OK, -ENODEV if no device, -EIO if SDL failed to initialize
 *		and -EPERM if the video failed to come up.
 *//opt/src/drivers/misc/cros_ec_sandbox.ccros_ec_sandboxec_state *ecsizeof(*ec)"%s: Cannot device EC flash\n"debug("%s: Cannot device EC flash\n", __func__)drivers/misc/cros_ec_sandbox.c523%s: Cannot device EC flash
keyb_dev"%s: No cros_ec keyboard found\n"debug("%s: No cros_ec keyboard found\n", __func__)537%s: No cros_ec keyboard found
"%s: Could not read key matrix\n"debug("%s: Could not read key matrix\n", __func__)539%s: Could not read key matrix
EC data length is %x, expected %x, discarding data
"EC data length is %x, expected %x, discarding data\n"Press keys for EC to detect on reset (ESC=recovery)..."Press keys for EC to detect on reset (ESC=recovery)..."<asm/sdl.h>   - EC requests recovery
"   - EC requests recovery\n"cros_ec_sandbox_packetreq_hdrreq_dataresp_hdrresp_datasizeof(*resp_hdr)process_cmd"EC command %#0x\n"req_hdr->commanddebug("EC command %#0x\n", req_hdr->command)EC command %#0x
const ec_params_helloconst ec_params_hello *sandbox_ro"sandbox_ro"sandbox_rw"sandbox_rw""Current image %d\n"resp->current_imagedebug("Current image %d\n", resp->current_image)Current image %d
const ec_params_vbnvcontextconst ec_params_vbnvcontext *ec_response_vbnvcontext *   ** Unknown vbnv_context command %#02x
"   ** Unknown vbnv_context command %#02x\n"const ec_params_reboot_ecconst ec_params_reboot_ec *Request reboot type %d
"Request reboot type %d\n"   ** Unknown type"   ** Unknown type"EC_HOST_EVENT_MASK(
					EC_HOST_EVENT_KEYBOARD_RECOVERY)const ec_params_vboot_hashconst ec_params_vboot_hash *   ** hash_block() failed
"   ** hash_block() failed\n"   ** EC_CMD_VBOOT_HASH: Unknown command %d
"   ** EC_CMD_VBOOT_HASH: Unknown command %d\n"const ec_params_flash_protectconst ec_params_flash_protect *expectEC_FLASH_PROTECT_ALL_NOW |
				EC_FLASH_PROTECT_ALL_AT_BOOTmask=%#x, flags=%#x
"mask=%#x, flags=%#x\n"   ** unexpected flash protect request
"   ** unexpected flash protect request\n"const ec_params_flash_region_infoconst ec_params_flash_region_info *EC flash region %d: offset=%#x, size=%#x
"EC flash region %d: offset=%#x, size=%#x\n"** Unknown flash region %d
"** Unknown flash region %d\n"const ec_params_flash_eraseconst ec_params_flash_erase *const ec_params_flash_writeconst ec_params_flash_write *   ** Unknown EC command %#02x
"   ** Unknown EC command %#02x\n"cros_ec_keyscanKEYBOARD_COLS KEYBOARD_COLSARRAY_SIZE(key)const ec_keymatrix_entryconst ec_keymatrix_entry *ec_keymatrix_entry *"%d: %d,%d\n"matrix->keycode, matrix->row, matrix->coldebug("%d: %d,%d\n", matrix->keycode, matrix->row,
			      matrix->col)%d: %d,%d
keyscan_read_fdt_matrixsizeof(*ec->matrix)"%s: Out of memory for key matrix\n"debug("%s: Out of memory for key matrix\n", __func__)%s: Out of memory for key matrix
*cell++(__force __u32)(__be32)(*cell++)(__u32)(__be32)(*cell++)((__u32)(__be32)(*cell++))fdt32_to_cpu(*cell++)KEYBOARD_ROWS"%s: Matrix pos out of range (%d,%d)\n"__func__, matrix->row, matrix->coldebug("%s: Matrix pos out of range (%d,%d)\n",
			      __func__, matrix->row, matrix->col)%s: Matrix pos out of range (%d,%d)
"%s: Read mismatch from key matrix\n"debug("%s: Read mismatch from key matrix\n", __func__)%s: Read mismatch from key matrix
get_image_used0xeacros_ec_write_statecurrent-image"current-image"vbnv-context"vbnv-context"sizeof(ec->vbnv_context)flash-data"flash-data"cros_ec_read_state"%s: Loaded EC flash data size %#x\n"debug("%s: Loaded EC flash data size %#x\n", __func__, len)%s: Loaded EC flash data size %#x
ec_stateec_keymatrix_entryrecovery_reqkeyscanmatrix_countflash_data_lenflash_dataec_configvbnv_context"cros_ec_sandbox"sizeof(struct ec_state)_u_boot_list_2_driver_2_cros_ec_sandbox.u_boot_list_2_driver_2_cros_ec_sandboxgoogle,cros-ec-sandbox"google,cros-ec-sandbox""google,cros-ec"google,cros-ec_u_boot_list_2_state_io_2_cros_ec.u_boot_list_2_state_io_2_cros_ecg_states_state/* Otherwise allocate the memory *//* If we loaded EC data, check that the length matches *//* TODO(sjg@chromium.org): Support full-size context *//* TODO(sjg@chromium.org): Check checksums *//**
 * Process an emulated EC command
 *
 * @param ec		Current emulated EC state
 * @param req_hdr	Pointer to request header
 * @param req_data	Pointer to body of request
 * @param resp_hdr	Pointer to place to put response header
 * @param resp_data	Pointer to place to put response data, if any
 * @return length of response data, or 0 for no response data, or -1 on error
 *//* Look up keycode in matrix *//**
 * Return the next keyscan message contents
 *
 * @param ec	Current emulated EC state
 * @param scan	Place to put keyscan bytes for the keyscan message (must hold
 *		enough space for a full keyscan)
 * @return number of bytes of valid scan data
 *//* Hard-code some sanity limits for now *//* Now read the data *//**
 * Read the key matrix from the device tree
 *
 * Keymap entries in the fdt take the form of 0xRRCCKKKK where
 * RR=Row CC=Column KKKK=Key Code
 *
 * @param ec	Current emulated EC state
 * @param node	Keyboard node of device tree containing keyscan information
 * @return 0 if ok, -1 on error
 *//* 0xea byte IS part of the image *//*
	 * Scan backwards looking for 0xea byte, which is by definition the
	 * last byte of the image.  See ec.lds.S for how this is inserted at
	 * the end of the image.
	 *//**
 * Return the number of bytes used in the specified image.
 *
 * This is the actual size of code+data in the image, as opposed to the
 * amount of space reserved in flash for that image. This code is similar to
 * that used by the real EC code base.
 *
 * @param ec	Current emulated EC state
 * @param entry	Flash map entry containing the image to check
 * @return actual image size in bytes, 0 if the image contains no content or
 * error.
 *//* We are guaranteed enough space to write basic properties *//**
 * cros_ec_write_state() - Write out our state to the state file
 *
 * The caller will ensure that there is a node ready for the state. The node
 * may already contain the old state, in which case it is overridden.
 *
 * @param blob: Device tree blob holding state
 * @param node: Node to write our state into
 *//* Read the data if available *//* Set everything to defaults *//**
 * cros_ec_read_state() - read the sandbox EC state from the state file
 *
 * If data is available, then blob and node will provide access to it. If
 * not this function sets up an empty EC.
 *
 * @param blob: Pointer to device tree blob, or NULL if no data to read
 * @param node: Node offset to read from
 *//* the key matrix info *//**
 * struct ec_state - Information about the EC state
 *
 * @vbnv_context: Vboot context data stored by EC
 * @ec_config: FDT config information about the EC (e.g. flashmap)
 * @flash_data: Contents of flash memory
 * @flash_data_len: Size of flash memory
 * @current_image: Current image the EC is running
 * @matrix_count: Number of keys to decode in matrix
 * @matrix: Information about keyboard matrix
 * @keyscan: Current keyscan information (bit set for each row/column pressed)
 * @recovery_req: Keyboard recovery requested
 *//* corresponding linux key code *//* key matrix column *//* key matrix row *//* A single entry of the key matrix *//*
 * Ultimately it shold be possible to connect an Chrome OS EC emulation
 * to U-Boot and remove all of this code. But this provides a test
 * environment for bringing up chromeos_sandbox and demonstrating its
 * utility.
 *
 * This emulation includes the following:
 *
 * 1. Emulation of the keyboard, by converting keypresses received from SDL
 * into key scan data, passed back from the EC as key scan messages. The
 * key layout is read from the device tree.
 *
 * 2. Emulation of vboot context - so this can be read/written as required.
 *
 * 3. Save/restore of EC state, so that the vboot context, flash memory
 * contents and current image can be preserved across boots. This is important
 * since the EC is supposed to continue running even if the AP resets.
 *
 * 4. Some event support, in particular allowing Escape to be pressed on boot
 * to enter recovery mode. The EC passes this to U-Boot through the normal
 * event message.
 *
 * 5. Flash read/write/erase support, so that software sync works. The
 * protect messages are supported but no protection is implemented.
 *
 * 6. Hashing of the EC image, again to support software sync.
 *
 * Other features can be added, although a better path is probably to link
 * the EC image in with U-Boot (Vic has demonstrated a prototype for this).
 *//*
 * Chromium OS cros_ec driver - sandbox emulation
 *
 * Copyright (c) 2013 The Chromium OS Authors.
 *//opt/src/drivers/misc/cros_ec_spi.ccros_ec_spicros_ec_spi_command"%s: Unsupported EC protcol version %d\n"debug("%s: Unsupported EC protcol version %d\n",
		      __func__, dev->protocol_version)drivers/misc/cros_ec_spi.c%s: Unsupported EC protcol version %d
"%s: Cannot claim SPI bus\n"debug("%s: Cannot claim SPI bus\n", __func__)%s: Cannot claim SPI bus
"%s: Cannot complete SPI transfer\n"debug("%s: Cannot complete SPI transfer\n", __func__)%s: Cannot complete SPI transfer
(int)p[1]%s: Returned status %d
"%s: Returned status %d\n"__func__, p[2 + len], csumdebug("%s: Invalid checksum rx %#02x, calced %#02x\n", __func__,
		      p[2 + len], csum)cros_ec_spi_packet"cros_ec_spi"_u_boot_list_2_driver_2_cros_ec_spi.u_boot_list_2_driver_2_cros_ec_spigoogle,cros-ec-spi"google,cros-ec-spi"/* Anything else is the response data *//* Check checksum *//* Response code is first byte of message *//*
	 * Send output data and receive input data starting such that the
	 * message body will be dword aligned.
	 *//*
	 * Clear input buffer so we don't get false hits for MSG_HEADER
	 *//* We represent message length as a byte *//*
	 * Sanity-check input size to make sure it plus transaction overhead
	 * fits in the internal device buffer.
	 *//* status, length, checksum, trailer *//**
 * Send a command to a LPC CROS_EC device and return the reply.
 *
 * The device's internal input/output buffers are used.
 *
 * @param dev		CROS_EC device
 * @param cmd		Command to send (EC_CMD_...)
 * @param cmd_version	Version of command to send (EC_VER_...)
 * @param dout		Output data (may be NULL If dout_len=0)
 * @param dout_len      Size of output data in bytes
 * @param dinp		Returns pointer to response data. This will be
 *			untouched unless we return a value > 0.
 * @param din_len	Maximum size of response in bytes
 * @return number of bytes in response, or -1 on error
 *//* Do the transfer *//*
 * Chromium OS cros_ec driver - SPI interface
 *
 * Copyright (c) 2012 The Chromium OS Authors.
 *//opt/src/include/i2c_eeprom.hi2c_eepromi2c_eeprom_opspagewidth__I2C_EEPROMi2c_eeprom_writei2c_eeprom_read/*
 * i2c_eeprom_write() - write bytes to an I2C EEPROM chip
 *
 * @dev:	Chip to write to
 * @offset:	Offset within chip to start writing
 * @buf:	Buffer containing data to write
 * @size:	Number of bytes to write
 *
 * @return 0 on success, -ve on failure
 *//*
 * i2c_eeprom_read() - read bytes from an I2C EEPROM chip
 *
 * @dev:	Chip to read from
 * @offset:	Offset within chip to start reading
 * @buf:	Place to put data
 * @size:	Number of bytes to read
 *
 * @return 0 on success, -ve on failure
 *//* The EEPROM's page width in bits (pagesize = 2^pagewidth) *//* The EEPROM's page size in byte *//opt/src/drivers/misc/i2c_eeprom.ci2c_eeprom_std_probei2c_eeprom_std_ofdata_to_platdata"pagesize"i2c_eeprom *i2c_eeprom_std_writepriv->pagesizei2c_eeprom_std_readconst i2c_eeprom_opsconst i2c_eeprom_ops *i2c_eeprom_ops *UCLASS_I2C_EEPROM"i2c_eeprom"_u_boot_list_2_uclass_2_i2c_eeprom.u_boot_list_2_uclass_2_i2c_eepromconst udevice_id[15]udevice_id[15]sizeof(struct i2c_eeprom)_u_boot_list_2_driver_2_i2c_eeprom_std.u_boot_list_2_driver_2_i2c_eeprom_stdi2c_eeprom_stdi2c-eeprom"i2c-eeprom"microchip,24aa02e48"microchip,24aa02e48"atmel,24c01a"atmel,24c01a"atmel,24c02"atmel,24c02"atmel,24c04"atmel,24c04"atmel,24c08"atmel,24c08"atmel,24c08a"atmel,24c08a"atmel,24c16a"atmel,24c16a"atmel,24mac402"atmel,24mac402"atmel,24c32"atmel,24c32"atmel,24c64"atmel,24c64"atmel,24c128"atmel,24c128"atmel,24c256"atmel,24c256"atmel,24c512"atmel,24c512"i2c_eeprom_std_idsi2c_eeprom_std_ops/* 6 bit -> page size of up to 2^63 (should be sufficient) */<i2c_eeprom.h>/opt/src/drivers/misc/i2c_eeprom_emul.ci2c_eeprom_emulsandbox_i2c_eeprom_removesandbox_i2c_flash *sandbox_i2c_eeprom_probesandbox_i2c_flash_plat_data *sandbox_i2c_eeprom_ofdata_to_platdatasandbox,size"sandbox,size"sandbox,filename"sandbox,filename""%s: No filename for device '%s'\n"debug("%s: No filename for device '%s'\n", __func__,
		      dev->name)drivers/misc/i2c_eeprom_emul.cconst char[38]%s: No filename for device '%s'
sandbox_i2c_eeprom_xfer"\n%s\n"debug("\n%s\n", __func__)
%s
"%s: Address %x, len %x is outside range 0..%x\n"__func__, msg->addr, msg->len, plat->sizedebug("%s: Address %x, len %x is outside range 0..%x\n",
			      __func__, msg->addr, msg->len, plat->size)%s: Address %x, len %x is outside range 0..%x
"   %s: msg->len=%d"msg->flags & I2C_M_RD ? "read" : "write", msg->lendebug("   %s: msg->len=%d",
		      msg->flags & I2C_M_RD ? "read" : "write",
		      msg->len)   %s: msg->len=%d", offset %x, len %x: "debug(", offset %x, len %x: ", offset, len), offset %x, len %x: '\xff'msg->buf, 1, msg->len, 0", set offset %x: "debug(", set offset %x: ", offset), set offset %x: min(len, 1)priv->data, 1, 16, 0sandbox_i2c_flashsandbox_i2c_flash_plat_datasandbox_i2c_eeprom_emul"sandbox_i2c_eeprom_emul"sizeof(struct sandbox_i2c_flash)sizeof(struct sandbox_i2c_flash_plat_data)_u_boot_list_2_driver_2_sandbox_i2c_emul.u_boot_list_2_driver_2_sandbox_i2c_emulsandbox_i2c_emulsandbox,i2c-eeprom"sandbox,i2c-eeprom"sandbox_i2c_emul_opsdebug_buffer(x,__VA_ARGS__...)/* For testing, map offsets into our limited buffer *//* Size of data buffer *//* Length of an offset in bytes *//*
 * Simulate an I2C eeprom
 *
 * Copyright (c) 2014 Google, Inc
 *//opt/src/include/misc.hmisc_opsset_enabledcall_MISC_H_misc_set_enabledmisc_callmisc_ioctlmisc_writemisc_read/* _MISC_H_ *//**
	 * Enable or disable a device, optional.
	 * @dev: the device to enable.
	 * @val: the flag that tells the driver to either enable or disable the
	 *	 device.
	 *
	 * Return: -ve on error, 0 if the previous state was "disabled", 1 if
	 *	   the previous state was "enabled"
	 *//**
	 * Send a message to the device and wait for a response.
	 * @dev: the device
	 * @msgid: the message ID/number to send
	 * @tx_msg: the request/transmit message payload
	 * @tx_size: the size of the buffer pointed at by tx_msg
	 * @rx_msg: the buffer to receive the response message payload. May be
	 *          NULL if the caller only cares about the error code.
	 * @rx_size: the size of the buffer pointed at by rx_msg
	 *
	 * Return: the response message size if OK, -ve on error
	 *//**
	 * Assert command to the device, optional.
	 * @dev: the device
	 * @request: command to be sent to the device
	 * @buf: pointer to buffer related to the request
	 *
	 * Return: 0 if OK, -ve on error
	 *//**
	 * Write buffer to the device, optional.
	 * @dev: the device
	 * @offset: offset to write the device
	 * @buf: pointer to data buffer
	 * @size: data size in bytes to write the device
	 *
	 * Return: number of bytes written if OK (may be < @size), -ve on error
	 *//**
	 * Read the device to buffer, optional.
	 * @dev: the device
	 * @offset: offset to read the device
	 * @buf: pointer to data buffer
	 * @size: data size in bytes to read the device
	 *
	 * Return: number of bytes read if OK (may be 0 if EOF), -ve on error
	 *//*
 * struct misc_ops - Driver model Misc operations
 *
 * The uclass interface is implemented by all miscellaneous devices which
 * use driver model.
 *//**
 * misc_set_enabled() - Enable or disable a device.
 * @dev: the device to enable or disable.
 * @val: the flag that tells the driver to either enable or disable the device.
 *
 * The semantics of "disable" and "enable" should be understood here as
 * activating or deactivating the device's primary function, hence a "disabled"
 * device should be dormant, but still answer to commands and queries.
 *
 * A probed device may start in a disabled or enabled state, depending on the
 * driver and hardware.
 *
 * Return: -ve on error, 0 if the previous state was "disabled", 1 if the
 *	   previous state was "enabled"
 *//**
 * misc_call() - Send a message to the device and wait for a response.
 * @dev: the device.
 * @msgid: the message ID/number to send.
 * @tx_msg: the request/transmit message payload.
 * @tx_size: the size of the buffer pointed at by tx_msg.
 * @rx_msg: the buffer to receive the response message payload. May be NULL if
 *          the caller only cares about the error code.
 * @rx_size: the size of the buffer pointed at by rx_msg.
 *
 * The caller provides the message type/ID and payload to be sent.
 * The callee constructs any message header required, transmits it to the
 * target, waits for a response, checks any error code in the response,
 * strips any message header from the response, and returns the error code
 * (or a parsed version of it) and the response message payload.
 *
 * Return: the response message size if OK, -ve on error
 *//**
 * misc_ioctl() - Assert command to the device, optional.
 * @dev: the device
 * @request: command to be sent to the device
 * @buf: pointer to buffer related to the request
 *
 * Return: 0 if OK, -ve on error
 *//**
 * misc_write() - Write buffer to the device, optional.
 * @dev: the device
 * @offset: offset to write the device
 * @buf: pointer to data buffer
 * @size: data size in bytes to write the device
 *
 * Return: number of bytes written if OK (may be < @size), -ve on error
 *//**
 * misc_read() - Read the device to buffer, optional.
 * @dev: the device
 * @offset: offset to read the device
 * @buf: pointer to data buffer
 * @size: data size in bytes to read the device
 *
 * Return: number of bytes read if OK (may be 0 if EOF), -ve on error
 */msgidtx_msgtx_sizerx_size/opt/src/drivers/misc/misc-uclass.cmisc-uclassconst misc_opsconst misc_ops *misc_ops *"misc"_u_boot_list_2_uclass_2_misc.u_boot_list_2_uclass_2_misc/*
 * Implement a  miscellaneous uclass for those do not fit other more
 * general classes. A set of generic read, write and ioctl methods may
 * be used to access the device.
 *//*
 * Copyright (C) 2010 Thomas Chou <thomas@wytron.com.tw>
 */<misc.h>/opt/src/drivers/misc/misc_sandbox.cmisc_sandboxmisc_sandbox_probemisc_sandbox_priv *misc_sandbox_set_enabledmisc_sandbox_callZero"Zero"One"One"Two"Two"Forty"Forty"Forty-one"Forty-one"Forty-two"Forty-two"sizeof(priv->last_ioctl)sizeof(priv->enabled)misc_sandbox_ioctlmisc_sandbox_writeu8[128]unsigned char[128]misc_sandbox_readmisc_sandbox_privlast_ioctl"misc_sandbox"sizeof(struct misc_sandbox_priv)_u_boot_list_2_driver_2_misc_sandbox.u_boot_list_2_driver_2_misc_sandboxsandbox,misc_sandbox"sandbox,misc_sandbox"misc_sandbox_idsmisc_sandbox_ops/opt/src/include/pwrseq.hpwrseqpwrseq_opsset_powerpwrseq_get_ops(dev)((struct pwrseq_ops *)(dev)->driver->ops)__pwrseq_hpwrseq_set_power/opt/src/drivers/misc/pwrseq-uclass.cpwrseq-uclasspwrseq_ops *UCLASS_PWRSEQ"pwrseq"_u_boot_list_2_uclass_2_pwrseq.u_boot_list_2_uclass_2_pwrseq<pwrseq.h>/opt/src/drivers/misc/qfw.cqemu(__force __u32)(__be32)(qemu)(__u32)(__be32)(qemu)((__u32)(__be32)(qemu))1358954496452198413634764801971213634961921363496277dma_enabled(struct list_head *)iter->entrystruct fw_filelist_entry((struct list_head *)iter->entry,
			  struct fw_file, list)&fw_listlist_entry(entry, struct fw_file, list)(__force __u32)(__be32)(count)(__u32)(__be32)(count)((__u32)(__be32)(count))sizeof(*file)error: allocating resource
"error: allocating resource\n"sizeof(struct fw_cfg_file)fw_cfg_file *nb_cpusqemu_fwcfg_read_entry_dma((size))(uintptr_t)address((uintptr_t)address)(((uintptr_t)address))((1 << 1))(((1 << 1)))FW_CFG_DMA_SELECT | (entry << 16)(1 << 3) | (entry << 16)((1 << 3) | (entry << 16))(((1 << 3) | (entry << 16)))"qemu_fwcfg_read_entry_dma: entry 0x%x, size %u address %p, control 0x%x\n"entry, size, address, be32_to_cpu(dma.control)debug("qemu_fwcfg_read_entry_dma: entry 0x%x, size %u address %p, control 0x%x\n",
	      entry, size, address, be32_to_cpu(dma.control))drivers/misc/qfw.cqemu_fwcfg_read_entry_dma: entry 0x%x, size %u address %p, control 0x%x
dma.control(__force __u32)(__be32)(dma.control)(__u32)(__be32)(dma.control)((__u32)(__be32)(dma.control))qemu_fwcfg_read_entry_pio"qemu_fwcfg_read_entry_pio: entry 0x%x, size %u address %p\n"entry, size, addressdebug("qemu_fwcfg_read_entry_pio: entry 0x%x, size %u address %p\n",
	      entry, size, address)qemu_fwcfg_read_entry_pio: entry 0x%x, size %u address %p
fw_listfwcfg_arch_opsfwcfg_dma_presentfwcfg_present/* don't read it twice *//*
	 * writting FW_CFG_INVALID will cause read operation to resume at
	 * last offset, otherwise read will start at offset 0
	 *//* Read configuration item using fw_cfg DMA interface *//* Read configuration item using fw_cfg PIO interface *//* This function loads and patches ACPI tables provided by QEMU *//*
 * This function updates checksum fields of ACPI tables previously loaded
 * by bios_linker_allocate()
 *
 * @entry : BIOS linker command entry which tells where to update ACPI table
 *          checksums
 * @return: 0 on success, or negative value on failure
 *//*
 * This function patches ACPI tables previously loaded
 * by bios_linker_allocate()
 *
 * @entry : BIOS linker command entry which tells how to patch
 *          ACPI tables
 * @return: 0 on success, or negative value on failure
 *//* adjust address for low memory allocation *//*
	 * ZONE_HIGH means we need to allocate from high memory, since
	 * malloc space is already at the end of RAM, so we directly use it.
	 * If allocation zone is ZONE_FSEG, then we use the 'addr' passed
	 * in which is low memory
	 *//* align must be power of 2 *//*
 * This function allocates memory for ACPI tables
 *
 * @entry : BIOS linker command entry which tells where to allocate memory
 *          (either high memory or low memory)
 * @addr  : The address that should be used for low memory allcation. If the
 *          memory allocation request is 'ZONE_HIGH' then this parameter will
 *          be ignored.
 * @return: 0 on success, or negative value on failure
 *//opt/src/drivers/misc/swap_case.cswap_casesandbox_swap_case_unmap_physmemswap_case_priv *sandbox_swap_case_map_physmem(phys_addr_t)PCI_CAP_EA_BASE_LO0swap_case_op *1114112(phys_addr_t)PCI_CAP_EA_BASE_LO1MEM_TEXT_SIZEpci_bar[6]pci_bar *PCI_CAP_EA_BASE_HI2 << 32(PCI_CAP_EA_BASE_HI2 << 32)1179648562949954600960(PCI_CAP_EA_BASE_HI2 << 32) |
				   PCI_CAP_EA_BASE_LO2(phys_addr_t)((PCI_CAP_EA_BASE_HI2 << 32) |
				   PCI_CAP_EA_BASE_LO2)PCI_CAP_EA_BASE_HI4 << 32(PCI_CAP_EA_BASE_HI4 << 32)13107201125899908153344(PCI_CAP_EA_BASE_HI4 << 32) |
				   PCI_CAP_EA_BASE_LO4(phys_addr_t)((PCI_CAP_EA_BASE_HI4 << 32) |
				   PCI_CAP_EA_BASE_LO4)PCI_CAP_EA_SIZE_HI << 32(PCI_CAP_EA_SIZE_HI << 32)68719542271(PCI_CAP_EA_SIZE_HI << 32) |
				PCI_CAP_EA_SIZE_LO*lenp(ulong)availsandbox_swap_case_write_iosandbox_swap_case_read_io~0xffsandbox_swap_case_do_opOP_TO_UPPER*strOP_TO_LOWEROP_SWAPisupper(*str)sandbox_swap_case_find_barbarinfoARRAY_SIZE(barinfo)barnumpswap_case_platdata *u32[6]~PCI_BASE_ADDRESS_SPACEsandbox_swap_case_write_configoffset_to_barnum(offset)"w bar %d=%lx\n"barnum, valuedebug("w bar %d=%lx\n", barnum, value)drivers/misc/swap_case.cw bar %d=%lx
sandbox_swap_case_read_configPCI_CAP_ID_EA_OFFSET + PCI_CAP_LIST_NEXTconst u32[15]PCI_CAP_ID_EA_SIZEPCI_CAP_ID_EA_OFFSET + PCI_CAP_ID_EA_SIZE466022136SANDBOX_PCI_CLASS_CODE << 8(SANDBOX_PCI_CLASS_CODE << 8)(SANDBOX_PCI_CLASS_CODE << 8) |
					SANDBOX_PCI_CLASS_SUB_CODE"r bar %d=%x\n"barnum, resultdebug("r bar %d=%x\n", barnum, result)const char[30]r bar %d=%x
PCI_CAP_ID_EXP_OFFSET << 8(PCI_CAP_ID_EXP_OFFSET << 8)24577(PCI_CAP_ID_EXP_OFFSET << 8) | PCI_CAP_ID_PMPCI_CAP_ID_PM_OFFSET + PCI_CAP_LIST_NEXT28672PCI_CAP_ID_MSIX_OFFSET << 8(PCI_CAP_ID_MSIX_OFFSET << 8)28688(PCI_CAP_ID_MSIX_OFFSET << 8) | PCI_CAP_ID_EXPPCI_CAP_ID_EXP_OFFSET + PCI_CAP_LIST_NEXTPCI_CAP_ID_EA_OFFSET << 8(PCI_CAP_ID_EA_OFFSET << 8)32785(PCI_CAP_ID_EA_OFFSET << 8) | PCI_CAP_ID_MSIXPCI_CAP_ID_MSIX_OFFSET + PCI_CAP_LIST_NEXTPCI_CAP_ID_EA_ENTRY_CNTPCI_CAP_ID_EA_ENTRY_CNT << 16(PCI_CAP_ID_EA_ENTRY_CNT << 16)262164(PCI_CAP_ID_EA_ENTRY_CNT << 16) | PCI_CAP_ID_EAPCI_EXT_CAP_ID_VC_OFFSET << 20(PCI_EXT_CAP_ID_VC_OFFSET << 20)536870913(PCI_EXT_CAP_ID_VC_OFFSET << 20) | PCI_EXT_CAP_ID_ERR805306368PCI_EXT_CAP_ID_DSN_OFFSET << 20(PCI_EXT_CAP_ID_DSN_OFFSET << 20)805306370(PCI_EXT_CAP_ID_DSN_OFFSET << 20) | PCI_EXT_CAP_ID_VCsandbox_swap_case_read_easandbox_swap_case_use_eause-ea"use-ea"sandbox_swap_case_get_devfnswap_case_privpci_barswap_case_opswap_case_platdatamem_textsandbox_swap_case_emulsandbox_swap_case_supported_u_boot_list_2_pci_driver_entry_2_sandbox_swap_case_emul.u_boot_list_2_pci_driver_entry_2_sandbox_swap_case_emulSANDBOXPCI_VDEVICE(SANDBOX, SANDBOX_PCI_DEVICE_ID)21930"sandbox_swap_case_emul"sizeof(struct swap_case_priv)sizeof(struct swap_case_platdata)_u_boot_list_2_driver_2_sandbox_swap_case_emul.u_boot_list_2_driver_2_sandbox_swap_case_emulsandbox,swap-case"sandbox,swap-case"sandbox_swap_case_idssandbox_swap_case_emul_ops1953789044pci_ea_bar4_magic1920103026pci_ea_bar2_magicconst u32[]2 << 8(2 << 8)(2 << 8) | 2(1 << 4) | 2MEM_TEXT_SIZE - 12 << 4(2 << 4)(2 << 4) | 31179650PCI_CAP_EA_BASE_LO2 | PCI_EA_IS_644 << 4(4 << 4)(4 << 4) | 41310722PCI_CAP_EA_BASE_LO4 | PCI_EA_IS_64PCI_CAP_EA_SIZE_LO | PCI_EA_IS_64ea_regspci_bar[](sizeof(ea_regs) + 4)(((offset) - PCI_BASE_ADDRESS_0) / sizeof(u32))/*
		 * only support mapping base address in EA test for now, we
		 * don't handle mapping an offset inside a BAR.  Seems good
		 * enough for the current test.
		 *//* space indicator (bit#0) is read-only *//*
	 * The content of the EA capability structure is handled elsewhere to
	 * keep the switch/case below sane
	 *//* BEI=4, ES=4, BAR4 64b Base + 64b MaxOffset *//* BEI=2, ES=3, BAR2 64b Base + 32b MaxOffset *//* BEI=1, ES=2, BAR1 32b Base + 32b MaxOffset *//* BEI=0, ES=2, BAR0 32b Base + 32b MaxOffset, I/O space *//* Hardcoded EA structure, excluding 1st DW. *//* Please keep these macros in sync with ea_regs below *//**
 * struct swap_case_platdata - platform data for this device
 *
 * @command:	Current PCI command value
 * @bar:	Current base address values
 *//*
 * PCI emulation device which swaps the case of text
 *
 * Copyright (c) 2014 Google, Inc
 * Written by Simon Glass <sjg@chromium.org>
 *//opt/src/drivers/misc/syscon_sandbox.csyscon_sandboxsandbox_syscon"sandbox_syscon"_u_boot_list_2_driver_2_sandbox_syscon.u_boot_list_2_driver_2_sandbox_sysconsandbox,syscon0"sandbox,syscon0"sandbox,syscon1"sandbox,syscon1"sandbox_syscon_ids/opt/src/drivers/mmc/mmc-uclass.cmmc-uclassmmc_blk_probemmc_uclass_priv *upriv"%s: mmc_init() failed (err=%d)\n"debug("%s: mmc_init() failed (err=%d)\n", __func__, ret)drivers/mmc/mmc-uclass.c%s: mmc_init() failed (err=%d)
mmc_select_hwpartEMEDIUMTYPE-124-EMEDIUMTYPEdm_mmc_ops *"%s: alias ret=%d, devnum=%d\n"__func__, ret, devnumdebug("%s: alias ret=%d, devnum=%d\n", __func__, ret, devnum)%s: alias ret=%d, devnum=%d
"mmc_blk""Cannot create block device\n"debug("Cannot create block device\n")Cannot create block device
bdesc/opt/src/drivers/mmc/mmc_private.h/opt/src/drivers/mmc"mmc_private.h"mmc_typeIS_SD(m)SD"SD"eMMC"eMMC"%s: %d"%s: %d" (%s)" (%s)"mmc_do_preinitmmc_get_next_devnum(blk_find_max_devnum(IF_TYPE_MMC) + 1)max((blk_find_max_devnum(IF_TYPE_MMC) + 1), 0)MMC Device %d not found
"MMC Device %d not found\n"bus-width"bus-width""Invalid \"bus-width\" value %u!\n"dev_err(dev, "Invalid \"bus-width\" value %u!\n", val)Invalid "bus-width" value %u!
max-frequency"max-frequency"cap-sd-highspeed"cap-sd-highspeed"MMC_CAP(SD_HS)MMC_CAP(SD_HScap-mmc-highspeed"cap-mmc-highspeed"MMC_CAP(MMC_HS)MMC_CAP(MMC_HSsd-uhs-sdr12"sd-uhs-sdr12"MMC_CAP(UHS_SDR12)MMC_CAP(UHS_SDR12sd-uhs-sdr25"sd-uhs-sdr25"MMC_CAP(UHS_SDR25)MMC_CAP(UHS_SDR25sd-uhs-sdr50"sd-uhs-sdr50"MMC_CAP(UHS_SDR50)MMC_CAP(UHS_SDR50sd-uhs-sdr104"sd-uhs-sdr104"MMC_CAP(UHS_SDR104)MMC_CAP(UHS_SDR104sd-uhs-ddr50"sd-uhs-ddr50"MMC_CAP(UHS_DDR50)MMC_CAP(UHS_DDR50mmc-ddr-1_8v"mmc-ddr-1_8v"MMC_CAP(MMC_DDR_52mmc-ddr-1_2v"mmc-ddr-1_2v"mmc-hs200-1_8v"mmc-hs200-1_8v"MMC_CAP(MMC_HS_200mmc-hs200-1_2v"mmc-hs200-1_2v"mmc-hs400-1_8v"mmc-hs400-1_8v"MMC_CAP(MMC_HS_400mmc-hs400-1_2v"mmc-hs400-1_2v"mmc-hs400-enhanced-strobe"mmc-hs400-enhanced-strobe"MMC_CAP(MMC_HS_400_ESnon-removable"non-removable"cd-inverted"cd-inverted"broken-cd"broken-cd"no-1-8-v"no-1-8-v"4032UHS_CAPS | MMC_MODE_HS2008128UHS_CAPS | MMC_MODE_HS200 |
				    MMC_MODE_HS40016320UHS_CAPS | MMC_MODE_HS200 |
				    MMC_MODE_HS400 | MMC_MODE_HS400_ES(UHS_CAPS | MMC_MODE_HS200 |
				    MMC_MODE_HS400 | MMC_MODE_HS400_ES)4294950975~(UHS_CAPS | MMC_MODE_HS200 |
				    MMC_MODE_HS400 | MMC_MODE_HS400_ES)mmc_send_cmdsizeof(struct mmc_uclass_priv)_u_boot_list_2_uclass_2_mmc.u_boot_list_2_uclass_2_mmc_u_boot_list_2_driver_2_mmc.u_boot_list_2_driver_2_mmc_u_boot_list_2_driver_2_mmc_blk.u_boot_list_2_driver_2_mmc_blkmmc_blk_ops!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBCOMMON_SUPPORT)CONFIG_FSL_ESDHC_ADAPTER_IDENT/* CONFIG_BLK *//* setup initial part type *//* Setup the universal parts of the block interface just once *//* Setup dsr related values *//* the following chunk was from mmc_register() *//* Use the fixed index with aliase node's index *//* f_max is obtained from the optional "max-frequency" property */mmc_privatemmc_list_addmmc_list_initmmc_trace_statemmmc_trace_after_sendmmmc_trace_before_sendmmc_berasemmc_bwrite_MMC_PRIVATE_H_CONFIG_MMC_TRACEmmc_switchmmc_breadmmc_set_blocklenmmc_poll_for_busymmc_send_status/* _MMC_PRIVATE_H_ *//**
 * mmc_switch() - Issue and MMC switch mode command
 *
 * @mmc:	MMC device
 * @set:	Unused
 * @index:	Cmdarg index
 * @value:	Cmdarg value
 * @return 0 if OK, -ve on error
 *//**
 * mmc_switch_part() - Switch to a new MMC hardware partition
 *
 * @mmc:	MMC device
 * @part_num:	Hardware partition number
 * @return 0 if OK, -ve on error
 *//**
 * mmc_list_add() - Add a new MMC device to the list of devices
 *
 * @mmc:	Device to add
 *//**
 * mmc_list_init() - Set up the list of MMC devices
 *//**
 * mmc_do_preinit() - Get an MMC device ready for use
 *//**
 * mmc_get_next_devnum() - Get the next available MMC device number
 *
 * @return next available device number (0 = first), or -ve on error
 *//* declare dummies to reduce code size. *//* CONFIG_SPL_MMC_WRITE is not defined *//opt/src/drivers/mmc/mmc.cmmc_probe"%s - probe failed: %d\n"pr_err("%s - probe failed: %d\n", dev->name, ret)pr_fmt("%s - probe failed: %d\n")%s - probe failed: %d
"%s: %d, time %lu\n"__func__, err, get_timer(start)pr_info("%s: %d, time %lu\n", __func__, err, get_timer(start))pr_fmt("%s: %d, time %lu\n")%s: %d, time %lu
mmc_complete_initMMC_CAP(SD_LEGACY)MMC_CAP(SD_LEGACYMMC_CAP(MMC_LEGACY)MMC_CAP(MMC_LEGACYno_card"MMC: no card present\n"pr_err("MMC: no card present\n")pr_fmt("MMC: no card present\n")MMC: no card present
ENOMEDIUM-123-ENOMEDIUMMMC_QUIRK_RETRY_SET_BLOCKLEN |
		      MMC_QUIRK_RETRY_SEND_CID"Unable to do a full power cycle. Disabling the UHS modes for safety\n"pr_fmt("Unable to do a full power cycle. Disabling the UHS modes for safety\n")pr_debug("Unable to do a full power cycle. Disabling the UHS modes for safety\n")Unable to do a full power cycle. Disabling the UHS modes for safety
uhs_en4294965311~UHS_CAPS"Card did not respond to voltage select!\n"pr_err("Card did not respond to voltage select!\n")pr_fmt("Card did not respond to voltage select!\n")Card did not respond to voltage select!
mmc_power_cyclemmc_power_off"Error disabling VMMC supply\n"pr_fmt("Error disabling VMMC supply\n")pr_debug("Error disabling VMMC supply\n")Error disabling VMMC supply
mmc_power_onError enabling VMMC supply
"Error enabling VMMC supply\n"mmc_set_initial_state"mmc: failed to set signal voltage\n"pr_fmt("mmc: failed to set signal voltage\n")mmc: failed to set signal voltage
mmc_power_initvmmc-supply"vmmc-supply""%s: No vmmc supply\n"mmc->dev->namepr_fmt("%s: No vmmc supply\n")pr_debug("%s: No vmmc supply\n", mmc->dev->name)%s: No vmmc supply
vqmmc-supply"vqmmc-supply""%s: No vqmmc supply\n"pr_fmt("%s: No vqmmc supply\n")pr_debug("%s: No vqmmc supply\n", mmc->dev->name)%s: No vqmmc supply
mmc_send_if_cond167444480xff80002147614720mmc_startupmmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
		MMC_CMD_ALL_SEND_CID 4!mmc_host_is_spi(mmc)IS_SD(mmc)10738078721073808384107387340810739384321074003968const int[4]int[4]cmult0xc00000002293760x00038000"MMC: SET_DSR failed\n"pr_fmt("MMC: SET_DSR failed\n")MMC: SET_DSR failed
bdesc->blkszLOG2(bdesc->blksz)Man %06x Snr %04x%04x"Man %06x Snr %04x%04x"%c%c%c%c%c%c"%c%c%c%c%c%c"%d.%d"%d.%d"MMC_TINYCONFIG_VAL(MMC_TINY)CONFIG_MMC_TINY__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_MMC_TINY__ARG_PLACEHOLDER_CONFIG_MMC_TINY__ARG_PLACEHOLDER_CONFIG_MMC_TINY 1CONFIG_VAL(MMC_TINY_MODULE)CONFIG_MMC_TINY_MODULEMMC_TINY_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_MMC_TINY_MODULE__ARG_PLACEHOLDER_CONFIG_MMC_TINY_MODULE__ARG_PLACEHOLDER_CONFIG_MMC_TINY_MODULE 1mmc_startup_v4PAD_SIZE((512) * sizeof(u8), 1)(((((512) * sizeof(u8)) - 1) / (1) + 1) * 1)(512) * sizeof(u8)(uintptr_t)__ext_csd((uintptr_t)__ext_csd)(typeof((uintptr_t)__ext_csd))(16)-1ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, MMC_MAX_BLOCK_LEN)__ext_csdmmc_versionsconst u32[9]ARRAY_SIZE(mmc_versions)2626561074004480EXT_CSD_SEC_CNT + 1EXT_CSD_SEC_CNT + 2EXT_CSD_SEC_CNT + 32 * 10242634241074005248part_completedhas_partsEXT_CSD_ENH_SIZE_MULT + 2EXT_CSD_ENH_SIZE_MULT + 1EXT_CSD_ENH_START_ADDR + 3EXT_CSD_ENH_START_ADDR + 2EXT_CSD_ENH_START_ADDR + 1erase_gszerase_gmul317440x00007c009920x000003e0262400107400422426291210740047361074004992263169107400499332768010740695043279361074069760mmc_select_mode_and_width"No ext_csd found!\n"pr_fmt("No ext_csd found!\n")pr_debug("No ext_csd found!\n")No ext_csd found!
const mode_width_tuningconst mode_width_tuning *mode_width_tuning *mwtconst mode_width_tuning[4]mode_width_tuning[4]mmc_modes_by_preffor_each_mmc_mode_by_pref(card_caps, mwt)mwt->modeconst ext_csd_bus_widthconst ext_csd_bus_width *ext_csd_bus_width *ecbwcard_caps & mwt->widthsmmc_is_mode_ddr(mwt->mode)const ext_csd_bus_width[5]ext_csd_bus_width[5]ext_csd_bus_widthfor_each_supported_width(card_caps & mwt->widths,
					 mmc_is_mode_ddr(mwt->mode), ecbw)old_voltage"trying mode %s width %d (at %d MHz)\n"mmc_mode_name(mwt->mode), bus_width(ecbw->cap), mmc_mode2freq(mmc, mwt->mode) / 1000000pr_fmt("trying mode %s width %d (at %d MHz)\n")pr_debug("trying mode %s width %d (at %d MHz)\n",
				 mmc_mode_name(mwt->mode),
				 bus_width(ecbw->cap),
				 mmc_mode2freq(mmc, mwt->mode) / 1000000)trying mode %s width %d (at %d MHz)
~EXT_CSD_DDR_FLAGSelect HS400 failed %d
"Select HS400 failed %d\n"Select HS400ES failed %d
"Select HS400ES failed %d\n""unable to select a mode\n"pr_err("unable to select a mode\n")pr_fmt("unable to select a mode\n")unable to select a mode
mmc_select_hs400esmmc_select_hs400mmc_set_lowest_voltagemmc_read_and_compare_ext_csdtest_csd(uintptr_t)__test_csd((uintptr_t)__test_csd)(typeof((uintptr_t)__test_csd))(16)-1allowed_maskALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, MMC_MAX_BLOCK_LEN)__test_csdsd_select_mode_and_widthconst mode_width_tuning[2]mode_width_tuning[2]sd_modes_by_preffor_each_sd_mode_by_pref(caps, mwt)uint[]widthsARRAY_SIZE(widths)mmc_mode_name(mwt->mode), bus_width(*w), mmc_mode2freq(mmc, mwt->mode) / 1000000pr_debug("trying mode %s width %d (at %d MHz)\n",
					 mmc_mode_name(mwt->mode),
					 bus_width(*w),
					 mmc_mode2freq(mmc, mwt->mode) / 1000000)"unable to read ssr\n"pr_fmt("unable to read ssr\n")unable to read ssr
mmc_set_signal_voltage"%s: widths ["pr_fmt("%s: widths [")pr_debug("%s: widths [", text)%s: widths ["8, "pr_fmt("8, ")pr_debug("8, ")8, "4, "pr_fmt("4, ")pr_debug("4, ")4, "1, "pr_fmt("1, ")pr_debug("1, ")1, "\b\b] modes ["pr_fmt("\b\b] modes [")pr_debug("\b\b] modes [")] modes ["%s, "mmc_mode_name(mode)pr_fmt("%s, ")pr_debug("%s, ", mmc_mode_name(mode))%s, "\b\b]\n"pr_fmt("\b\b]\n")pr_debug("\b\b]\n")]
mmc_set_bus_width"clock is %s (%dHz)\n"disable ? "disabled" : "enabled", clockdebug("clock is %s (%dHz)\n", disable ? "disabled" : "enabled", clock)drivers/mmc/mmc.c1564clock is %s (%dHz)
"invalid bus witdh capability 0x%x\n"pr_fmt("invalid bus witdh capability 0x%x\n")invalid bus witdh capability 0x%x
sd_read_ssrPAD_SIZE((16) * sizeof(uint), 1)(((((16) * sizeof(uint)) - 1) / (1) + 1) * 1)(16) * sizeof(uint)(uintptr_t)__ssr((uintptr_t)__ssr)(typeof((uintptr_t)__ssr))(16)-1ALLOC_CACHE_ALIGN_BUFFER(uint, ssr, 16)__ssrssr[i](__force __u32)(__be32)(ssr[i])(__u32)(__be32)(ssr[i])((__u32)(__be32)(ssr[i]))2147680256const unsigned int[]sd_au_sizeconst unsigned int[16]const unsigned int *eo"Invalid Allocation Unit Size.\n"pr_fmt("Invalid Allocation Unit Size.\n")pr_debug("Invalid Allocation Unit Size.\n")Invalid Allocation Unit Size.
SZ_16K / 512SZ_32K / 512SZ_64K / 512SZ_128K / 512SZ_256K / 512SZ_512K / 512SZ_1M / 512SZ_2M / 512SZ_4M / 512SZ_8M / 51212582912SZ_8M + SZ_4M(SZ_8M + SZ_4M)(SZ_8M + SZ_4M) / 512SZ_16M / 51225165824SZ_16M + SZ_8M(SZ_16M + SZ_8M)(SZ_16M + SZ_8M) / 512SZ_32M / 512SZ_64M / 512sd_select_bus_widthsd_set_card_speedswitch_status(uintptr_t)__switch_status((uintptr_t)__switch_status)(typeof((uintptr_t)__switch_status))(16)-12147549184ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16)__switch_statusswitch_status[4](__force __u32)(__be32)(switch_status[4])(__u32)(__be32)(switch_status[4])((__u32)(__be32)(switch_status[4]))__be32_to_cpu(switch_status[4])retry_ssrsd_get_capabilitiesPAD_SIZE((2) * sizeof(__be32), 1)(((((2) * sizeof(__be32)) - 1) / (1) + 1) * 1)(2) * sizeof(__be32)(uintptr_t)__scr((uintptr_t)__scr)(typeof((uintptr_t)__scr))(16)-1PAD_SIZE((16) * sizeof(__be32), 1)(((((16) * sizeof(__be32)) - 1) / (1) + 1) * 1)(16) * sizeof(__be32)268435458MMC_MODE_1BIT | MMC_CAP(SD_LEGACY)ALLOC_CACHE_ALIGN_BUFFER(__be32, scr, 2)__scrscr[0](__force __u32)(__be32)(scr[0])(__u32)(__be32)(scr[0])((__u32)(__be32)(scr[0]))__be32_to_cpu(scr[0])scr[1](__force __u32)(__be32)(scr[1])(__u32)(__be32)(scr[1])((__u32)(__be32)(scr[1]))__be32_to_cpu(scr[1])680962147551744retry_scrALLOC_CACHE_ALIGN_BUFFER(__be32, switch_status, 16)switch_status[7](__force __u32)(__be32)(switch_status[7])(__u32)(__be32)(switch_status[7])((__u32)(__be32)(switch_status[7]))__be32_to_cpu(switch_status[7])switch_status[3](__force __u32)(__be32)(switch_status[3])(__u32)(__be32)(switch_status[3])((__u32)(__be32)(switch_status[3]))__be32_to_cpu(switch_status[3])sd_switch"eMMC >= 4.4 required for enhanced user data area\n"pr_err("eMMC >= 4.4 required for enhanced user data area\n")pr_fmt("eMMC >= 4.4 required for enhanced user data area\n")eMMC >= 4.4 required for enhanced user data area
"Card does not support partitioning\n"pr_err("Card does not support partitioning\n")pr_fmt("Card does not support partitioning\n")Card does not support partitioning
"Card does not define HC WP group size\n"pr_err("Card does not define HC WP group size\n")pr_fmt("Card does not define HC WP group size\n")Card does not define HC WP group size
"User data enhanced area not HC WP group " "size aligned\n"pr_err("User data enhanced area not HC WP group "
			       "size aligned\n")pr_fmt("User data enhanced area not HC WP group " "size aligned\n")User data enhanced area not HC WP group size aligned
"User data enhanced area not HC WP group "
			       "size aligned\n"part_attrsenh_size_multenh_start_addrtot_enh_size_multpidx"GP%i partition not HC WP group size " "aligned\n"pidx+1pr_err("GP%i partition not HC WP group size "
			       "aligned\n", pidx+1)pr_fmt("GP%i partition not HC WP group size " "aligned\n")GP%i partition not HC WP group size aligned
"GP%i partition not HC WP group size "
			       "aligned\n"gp_size_multEXT_CSD_ENH_GP(pidx)"Card does not support enhanced attribute\n"pr_err("Card does not support enhanced attribute\n")pr_fmt("Card does not support enhanced attribute\n")Card does not support enhanced attribute
max_enh_size_multEXT_CSD_MAX_ENH_SIZE_MULT+2EXT_CSD_MAX_ENH_SIZE_MULT+1"Total enhanced size exceeds maximum (%u > %u)\n"tot_enh_size_mult, max_enh_size_multpr_err("Total enhanced size exceeds maximum (%u > %u)\n",
		       tot_enh_size_mult, max_enh_size_mult)pr_fmt("Total enhanced size exceeds maximum (%u > %u)\n")Total enhanced size exceeds maximum (%u > %u)
~EXT_CSD_WR_DATA_REL_USREXT_CSD_WR_DATA_REL_GP(pidx)Card does not support host controlled partition write reliability settings
"Card does not support host controlled partition write "
		     "reliability settings\n""Card already partitioned\n"pr_err("Card already partitioned\n")pr_fmt("Card already partitioned\n")Card already partitioned
~PART_ACCESS_MASKmmc_set_capacitymmc_get_capabilitiesMMC_MODE_1BIT | MMC_CAP(MMC_LEGACY)pr_err("No ext_csd found!\n")1610612736MMC_MODE_4BIT | MMC_MODE_8BITmmc_set_card_speedhsdowngrade__mmc_switch DEFAULT_CMD6_TIMEOUT_MSis_part_switchMMC_SWITCH_MODE_WRITE_BYTE << 24(MMC_SWITCH_MODE_WRITE_BYTE << 24)"switch failed %d/%d/0x%x !\n"set, index, valuepr_fmt("switch failed %d/%d/0x%x !\n")pr_debug("switch failed %d/%d/0x%x !\n", set, index,
				 value)switch failed %d/%d/0x%x !
mmc_send_ext_csdmmc_complete_op_condmmc_send_op_condmmc_send_op_cond_iter8388480sd_send_op_condsend_statususe_argmmc_go_idleCONFIG_IS_ENABLED(MMC_TINY)"MMC: block number 0x" LBAF " exceeds max(0x" LBAF ")\n""MMC: block number 0x" "%" "l" "x" " exceeds max(0x" "%" "l" "x" ")\n"start + blkcnt, block_dev->lbapr_err("MMC: block number 0x" LBAF " exceeds max(0x" LBAF ")\n",
		       start + blkcnt, block_dev->lba)pr_fmt("MMC: block number 0x" "%" "l" "x" " exceeds max(0x" "%" "l" "x" ")\n")MMC: block number 0x%lx exceeds max(0x%lx)
"%s: Failed to set blocklen\n"pr_fmt("%s: Failed to set blocklen\n")pr_debug("%s: Failed to set blocklen\n", __func__)%s: Failed to set blocklen
blocks_todo"%s: Failed to read blocks\n"pr_fmt("%s: Failed to read blocks\n")pr_debug("%s: Failed to read blocks\n", __func__)%s: Failed to read blocks
mmc_read_blocks"mmc fail to send stop cmd\n"pr_err("mmc fail to send stop cmd\n")pr_fmt("mmc fail to send stop cmd\n")mmc fail to send stop cmd
7680358433996671-339966724260970624"Status Error: 0x%08x\n"pr_err("Status Error: 0x%08x\n", status)pr_fmt("Status Error: 0x%08x\n")Status Error: 0x%08x
ECOMM-70-ECOMM"Timeout waiting card ready\n"pr_err("Timeout waiting card ready\n")pr_fmt("Timeout waiting card ready\n")Timeout waiting card ready
 5mmc_select_mode"selecting mode %s (freq : %d MHz)\n"mmc_mode_name(mode), mmc->tran_speed / 1000000pr_fmt("selecting mode %s (freq : %d MHz)\n")pr_debug("selecting mode %s (freq : %d MHz)\n", mmc_mode_name(mode),
		 mmc->tran_speed / 1000000)selecting mode %s (freq : %d MHz)
mmc_mode2freqconst int[]freqsconst int[14]int[14]25000000260000005000000052000000100000000208000000200000000Unknown mode"Unknown mode"namesconst char *const[14]char *[14]MMC legacy"MMC legacy"SD Legacy"SD Legacy"MMC High Speed (26MHz)"MMC High Speed (26MHz)"SD High Speed (50MHz)"SD High Speed (50MHz)"UHS SDR12 (25MHz)"UHS SDR12 (25MHz)"UHS SDR25 (50MHz)"UHS SDR25 (50MHz)"UHS SDR50 (100MHz)"UHS SDR50 (100MHz)"UHS SDR104 (208MHz)"UHS SDR104 (208MHz)"UHS DDR50 (50MHz)"UHS DDR50 (50MHz)"MMC High Speed (52MHz)"MMC High Speed (52MHz)"MMC DDR52 (52MHz)"MMC DDR52 (52MHz)"HS200 (200MHz)"HS200 (200MHz)"HS400 (200MHz)"HS400 (200MHz)"HS400ES (200MHz)"HS400ES (200MHz)"mode_width_tuningext_csd_bitsis_ddrconst ext_csd_bus_width[]ext_csd_bus_width[]const mode_width_tuning[]mode_width_tuning[]MMC_MODE_8BIT | MMC_MODE_4BIT1879048192MMC_MODE_8BIT | MMC_MODE_4BIT | MMC_MODE_1BITMMC_MODE_4BIT | MMC_MODE_1BITconst u8[]multipliers10000000fbasefor_each_supported_width(caps,ddr,ecbv)for (ecbv = ext_csd_bus_width; ecbv < ext_csd_bus_width + ARRAY_SIZE(ext_csd_bus_width); ecbv++) if ((ddr == ecbv->is_ddr) && (caps & ecbv->cap))for_each_mmc_mode_by_pref(caps,mwt)for (mwt = mmc_modes_by_pref; mwt < mmc_modes_by_pref + ARRAY_SIZE(mmc_modes_by_pref); mwt++) if (caps & MMC_CAP(mwt->mode))for_each_sd_mode_by_pref(caps,mwt)for (mwt = sd_modes_by_pref; mwt < sd_modes_by_pref + ARRAY_SIZE(sd_modes_by_pref); mwt++) if (caps & MMC_CAP(mwt->mode))DEFAULT_CMD6_TIMEOUT_MS!CONFIG_IS_ENABLED(MMC_TINY)CONFIG_IS_ENABLED(MMC_VERBOSE) || defined(DEBUG)CONFIG_MMC_QUIRKSCONFIG_IS_ENABLED(MMC_HS200_SUPPORT) || \CONFIG_IS_ENABLED(MMC_HS400_SUPPORT) || \CONFIG_IS_ENABLED(MMC_IO_VOLTAGE)CONFIG_MMC_SPI_CRC_ON!defined(CONFIG_SPL_BUILD) || \!defined(CONFIG_DM_MMC) && (!defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBDISK_SUPPORT))CONFIG_IS_ENABLED(DM_MMC) && CONFIG_IS_ENABLED(DM_REGULATOR)!defined(CONFIG_MMC_BROKEN_CD)MMC_VERBOSECONFIG_VAL(MMC_VERBOSE_MODULE)CONFIG_MMC_VERBOSE_MODULE__ARG_PLACEHOLDER_CONFIG_MMC_VERBOSE_MODULE__ARG_PLACEHOLDER_CONFIG_MMC_VERBOSE_MODULE 1MMC_VERBOSE_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_MMC_VERBOSE_MODULECONFIG_VAL(MMC_VERBOSE)__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_MMC_VERBOSECONFIG_MMC_VERBOSEMMC_IO_VOLTAGECONFIG_VAL(MMC_IO_VOLTAGE_MODULE)CONFIG_MMC_IO_VOLTAGE_MODULE__ARG_PLACEHOLDER_CONFIG_MMC_IO_VOLTAGE_MODULE__ARG_PLACEHOLDER_CONFIG_MMC_IO_VOLTAGE_MODULE 1MMC_IO_VOLTAGE_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_MMC_IO_VOLTAGE_MODULECONFIG_VAL(MMC_IO_VOLTAGE)CONFIG_MMC_IO_VOLTAGE__ARG_PLACEHOLDER_CONFIG_MMC_IO_VOLTAGE__ARG_PLACEHOLDER_CONFIG_MMC_IO_VOLTAGE 1__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_MMC_IO_VOLTAGE/* Avoid initializing mmc multiple times *//*
	 * Try to add them in sequence order. Really with driver model we
	 * should allow holes, but the current MMC list does not allow that.
	 * So if we request 0, 1, 3 we will get 0, 1, 2.
	 *//* board-specific MMC initializations. *//* CPU-specific MMC initializations *//* we pretend there's no card when init is NULL *//*
	 * all hosts are capable of 1 bit bus-width and able to use the legacy
	 * timings.
	 *//* If the command timed out, we check for an MMC card *//* Now try to get the SD card's operating condition *//* Test for SD version 2 *//* The internal partition reset to user partition(0) at every CMD0*//* Reset the Card *//* made sure it's not NULL earlier *//* The device has already been probed ready for use *//*
		 * if power cycling is not supported, we should not try
		 * to use the UHS modes, because we wouldn't be able to
		 * recover from an error during the UHS initialization.
		 *//*
	 * SD spec recommends at least 1ms of delay. Let's wait for 2ms
	 * to be on the safer side.
	 *//* First try to set 3.3V. If it fails set to 1.8V *//*
 * put the host in the initial state:
 * - turn on Vdd (card power supply)
 * - configure the bus width and clock to minimal values
 *//*
	 * Driver model should use a regulator, as above, rather than calling
	 * out to board code.
	 *//* !CONFIG_DM_MMC *//* board-specific MMC power initializations. *//* We set the bit if the host supports voltages between 2.7 and 3.6 V *//* fill in device description *//* Fix the block length for DDR mode *//*
	 * For SD, its erase group is always one sector
	 *//* cmd not supported in spi *//* Select the card, and put it into Transfer Mode *//* divide frequency by 10, since the mults are 10x bigger *//* Get the Card-Specific Data *//*
	 * For MMC cards, set the Relative Address.
	 * For SD cards, get the Relatvie Address.
	 * This also puts the cards into Standby State
	 *//*
		 * It has been seen that SEND_CID may fail on the first
		 * attempt, let's try a few more time
		 *//* Put the Card in Identify Mode *//* enable CRC check for spi *//* Calculate the group size from the csd value. *//*
		 * if high capacity and partition setting completed
		 * SEC_COUNT is valid even if it is smaller than 2 GiB
		 * JEDEC Standard JESD84-B45, 6.2.4
		 *//* Read out group size from ext_csd *//*
	 * Host needs to enable ERASE_GRP_DEF bit if device is
	 * partitioned. This bit will be lost every time after a reset
	 * or power off. This will affect erase size.
	 *//* store the partition info of emmc *//* Some eMMC set the value too low so set a minimum *//* The partition data may be non-zero but it is only
	 * effective if PARTITION_SETTING_COMPLETED is set in
	 * EXT_CSD, so ignore any data if this bit is not set,
	 * except for enabling the high-capacity group size
	 * definition (see below).
	 *//*
		 * According to the JEDEC Standard, the value of
		 * ext_csd's capacity is valid if the value is more
		 * than 2GB
		 *//* store the ext csd for future reference *//* check  ext_csd version and capacity *//* if an error occured, revert to a safer bus mode *//* do a transfer to check the configuration *//* execute tuning if needed *//* configure the bus mode (host) *//*
				 * configure the bus width AND the ddr mode
				 * (card). The host side will be taken care
				 * of in the next step
				 *//* configure the bus speed (card) *//* configure the bus width (card + host) *//*
	 * In case the eMMC is in HS200/HS400 mode, downgrade to HS mode
	 * before doing anything else, since a transition from either of
	 * the HS200/HS400 mode directly to legacy mode is not supported.
	 *//* this should enver happen *//* Only version 4 of MMC supports wider bus widths *//* Restrict card's capabilities by what the host can do *//* TODO: driver strength *//* Set back to HS *//* Set timing to HS200 for tuning *//* Only compare read only fields *//*
 * read the compare the part of ext csd that is constant.
 * This can be used to check that the transfer is working
 * as expected.
 *//* revert to a safer bus speed *//* configure the bus mode (card) *//*
 * helper function to display the capabilities in a human
 * friendly manner. The capabilities include bus width and
 * supported modes.
 *//* Multiplier values for TRAN_SPEED.  Multiplied by 10 to be nice
 * to platforms without floating point.
 *//* divided by 10 to be nice to platforms without floating point *//* frequency bases *//* SD version 1.00 and 1.01 does not support CMD 6 *//* Version before 3.0 don't support UHS modes *//* If high-speed isn't supported, we return *//* The high-speed function is busy.  Try again *//* Version 1.0 doesn't support switching *//* Read the SCR to find out if this card supports higher speeds *//* Switch the frequency *//* Setting PART_SETTING_COMPLETED confirms the partition
	 * configuration but it only becomes effective after power
	 * cycle, so we do not adjust the partition related settings
	 * in the mmc struct. *//* The WR_REL_SET is a write-once register but shall be
	 * written before setting PART_SETTING_COMPLETED. As it is
	 * write-once we can only write it when completing the
	 * partitioning. *//* all OK, write the configuration *//* update erase group size to be high-capacity *//* Partitioning requires high-capacity size definitions *//* The default value of EXT_CSD_WR_REL_SET is device
	 * dependent, the values can only be changed if the
	 * EXT_CSD_HS_CTRL_REL bit is set. The values can be
	 * changed only once and before partitioning is completed. *//* check partition alignment and total enhanced size *//*
	 * Set the capacity if the switch succeeded or was intended
	 * to return to representing the raw device.
	 *//* Only version 4 supports high-speed *//* No high-speed support *//* Now check to see that it worked *//*
	 * In case the eMMC is in HS200/HS400 mode and we are downgrading
	 * to HS mode, the card clock are still running much faster than
	 * the supported HS mode clock, so we can not reliably read out
	 * Extended CSD. Reconfigure the controller to run at HS mode.
	 *//* Finally wait until the card is ready or indicates a failure
	 * to switch. It doesn't hurt to use CMD13 here even if send_status
	 * is false, because by now (after 'timeout' ms) the bus should be
	 * reliable.
	 *//*
	 * In cases when not allowed to poll by using CMD13 or because we aren't
	 * capable of polling by using mmc_wait_dat0, then rely on waiting the
	 * stated timeout to be sufficient.
	 *//* poll dat0 for rdy/buys status *//* Get the Card Status Register *//* read OCR for spi *//* Some cards seem to need this *//* exit if not busy (flag seems to be inverted) *//* Asking to the card its capabilities *//*
		 * Most cards do not answer if some reserved bits
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 *//*
	 * Failure to switch is indicated by the card holding
	 * dat[0:3] low. Wait for at least 1 ms according to spec
	 *//* Keep clock gated for at least 10 ms, though spec only says 5 ms *//*
	 * During a signal voltage level switch, the clock must be gated
	 * for 5 ms according to the SD spec
	 *//*
	 * The card should drive cmd and dat[0:3] low immediately
	 * after the response of cmd11, but wait 100 us to be sure
	 *//*
	 * Send CMD11 only if the request is to switch the card to
	 * 1.8V signalling.
	 *//*
		 * It has been seen that SET_BLOCKLEN may fail on the first
		 * attempt, let's try a few more time
		 *//*
 * Copyright 2008, Freescale Semiconductor, Inc
 * Andy Fleming
 *
 * Based vaguely on the Linux code
 *//opt/src/include/linux/math64.hmath64mul_u64_u32_divrlrhrh.lldo_div(rh.ll, divisor)mul((rh.ll) >> 32) == 0rl.lldo_div(rl.ll, divisor)((rl.ll) >> 32) == 0mul_u64_u64_shra0rnmul_u64_u32_shralahmul_u32_u32__iter_div_u64_remiter_div_u64_remdiv_s64div_u64div64_s64div64_u64div64_u64_remdiv_s64_remdiv_u64_remdo_div(dividend, divisor)((dividend) >> 32) == 0highlowdiv64_ul(x,y)div_u64((x), (y))div64_long(x,y)div_s64((x), (y))_LINUX_MATH64_Hdefined(CONFIG_ARCH_SUPPORTS_INT128) && defined(__SIZEOF_INT128__)__SIZEOF_INT128__/* _LINUX_MATH64_H *//* mul_u64_u32_div *//* Bits 0-31 of the result will be in rl.l.low.	*//* Bits 32-63 of the result will be in rh.l.low. *//* mul_u64_u64_shr *//*
	 * The 128-bit result of the multiplication is in rl.ll and rh.ll,
	 * shift it right and throw away the high part of the result.
	 *//*
	 * Each of these lines computes a 64-bit intermediate result into "c",
	 * starting at bits 32-95.  The low 32-bits go into the result of the
	 * multiplication, the high 32-bits are carried into the next step.
	 *//* mul_u64_u32_shr *//*
 * Many a GCC version messes this up and generates a 64x64 mult :-(
 *//* The following asm() prevents the compiler from
		   optimising this loop into a modulo operation.  *//**
 * div_s64 - signed 64bit divide with 32bit divisor
 *//**
 * div_u64 - unsigned 64bit divide with 32bit divisor
 *
 * This is the most common 64bit divide and should be used if possible,
 * as many 32bit archs can optimize this variant better than a full 64bit
 * divide.
 *//**
 * div64_s64 - signed 64bit divide with 64bit divisor
 *//**
 * div64_u64 - unsigned 64bit divide with 64bit divisor
 *//**
 * div64_u64_rem - unsigned 64bit divide with 64bit divisor and remainder
 *//**
 * div_s64_rem - signed 64bit divide with 32bit divisor with remainder
 *//**
 * div_u64_rem - unsigned 64bit divide with 32bit divisor with remainder
 *
 * This is commonly provided by 32bit archs to provide an optimized 64bit
 * divide.
 *//opt/src/drivers/mmc/mmc_write.cmmc_write_blocksmmc write failed
"mmc write failed\n"start_remblkcnt_rem

Caution! Your devices Erase group is 0x%x
The erase range would be change to 0x%lx~0x%lx

"\n\nCaution! Your devices Erase group is 0x%x\n"
		       "The erase range would be change to "
		       "0x" LBAF "~0x" LBAF "\n\n"<linux/math64.h>blk_rmmc_erase_tstart_cmdend_cmdmmc erase failed
"mmc erase failed\n"/* Waiting for the ready status *//* SPI multiblock writes terminate using a special
	 * token, not a STOP_TRANSMISSION request.
	 *//*
	 * We want to see if the requested start or total block count are
	 * unaligned.  We discard the whole numbers and only care about the
	 * remainder.
	 *//opt/src/drivers/mmc/sandbox_mmc.csandbox_mmcsandbox_mmc_unbindsandbox_mmc_bindsandbox_mmc_plat *MMC_MODE_HS_52MHz | MMC_MODE_HS1073741852MMC_MODE_HS_52MHz | MMC_MODE_HS | MMC_MODE_8BIT1048704MMC_VDD_165_195 | MMC_VDD_32_333145856MMC_VDD_165_195 | MMC_VDD_32_33 | MMC_VDD_33_34U32_MAXsandbox_mmc_probesandbox_mmc_get_cdsandbox_mmc_set_iossandbox_mmc_send_cmd0 << 1665536010 << 16(0x00020000)((0x00020000))this is a test"this is a test"OCR_BUSY | OCR_HCS"block len %d\n"cmd->cmdargdebug("block len %d\n", cmd->cmdarg)drivers/mmc/sandbox_mmc.cblock len %d
2 << 24 | 1 << 15(2 << 24 | 1 << 15)2 << 2433587200((2 << 24 | 1 << 15))8388610"%s: Unknown command %d\n"__func__, cmd->cmdidxdebug("%s: Unknown command %d\n", __func__, cmd->cmdidx)%s: Unknown command %d
sandbox_mmc_platmmc_sandbox"mmc_sandbox"const dm_mmc_opsconst dm_mmc_ops *sizeof(struct sandbox_mmc_plat)_u_boot_list_2_driver_2_mmc_sandbox.u_boot_list_2_driver_2_mmc_sandboxsandbox,mmc"sandbox,mmc"sandbox_mmc_idssandbox_mmc_ops/* SD version 3 *//* 1 << block_len *//* mmc->rca *//**
 * sandbox_mmc_send_cmd() - Emulate SD commands
 *
 * This emulate an SD card version 2. Single-block reads result in zero data.
 * Multiple-block reads return a test string.
 *//opt/src/include/mtd.hmtd_probe_MTD_H_mtd_probe_devices/* _MTD_H_ *//opt/src/drivers/mtd/mtd_uboot.cmtd_ubootSize exceeds partition or device limit
"Size exceeds partition or device limit\n"device %d "device %d "whole chip
"whole chip\n"offset 0x%llx, size 0x%llx
"offset 0x%llx, size 0x%llx\n"Offset exceeds device limit
"Offset exceeds device limit\n"get_partnot same typ %d != %d
"not same typ %d != %d\n"mtd_probe_uclass_mtd_devscommaequaldev_id_lenget_mtdidsboard_mtdparts_defaultMTD_NAME_MAX_LENdefined(MTDIDS_DEFAULT)defined(CONFIG_MTDIDS_DEFAULT)IS_ENABLED(CONFIG_MTD)defined(CONFIG_MTD_PARTITIONS)defined(MTDPARTS_DEFAULT)defined(CONFIG_MTDPARTS_DEFAULT)CONFIG_CMD_MTDPARTSCONFIG_MTDCONFIG_MTD_MODULE__ARG_PLACEHOLDER_CONFIG_MTD_MODULE__ARG_PLACEHOLDER_CONFIG_MTD_MODULE 1__ARG_PLACEHOLDER_CONFIG_MTD__ARG_PLACEHOLDER_CONFIG_MTD 1/* Legacy *//* defined(CONFIG_MTD_PARTITIONS) *//*
	 * Call mtd_dev_list_updated() to clear updates generated by our own
	 * parts registration loop.
	 *//* Free the structures allocated during the parsing *//* Create the new MTD partitions *//*
		 * Parse the MTD device partitions. It will update the mtdparts
		 * pointer, create an array of parts (that must be freed), and
		 * return the number of partition structures in the array.
		 *//*
		 * Call mtd_del_parts() again, even if it's already been called
		 * in mtd_del_all_parts(). We need to know if old partitions are
		 * still around (because they are still being used by someone),
		 * and if they are, we shouldn't create new partitions, so just
		 * skip this MTD device and try the next one.
		 *//*
			 * If no device could be found, move the mtdparts
			 * pointer forward until the next set of partitions.
			 *//*
			 * The MTD device named "mtd_name" does not exist. Try
			 * to find a correspondance with an MTD device having
			 * the same type and number as defined in the mtdids.
			 *//* Move the pointer forward (including the ':') *//* For each MTD device in mtdparts *//* Start the parsing by ignoring the extra 'mtdparts=' prefix, if any *//* If either mtdparts or mtdids is empty, then exit *//*
	 * Call mtd_dev_list_updated() to clear updates generated by our own
	 * parts removal loop.
	 *//*
	 * Remove all old parts. Note that partition removal can fail in case
	 * one of the partition is still being used by an MTD user, so this
	 * does not guarantee that all old partitions are gone.
	 *//* Update the local copy of mtdparts *//*
	 * Check if mtdparts/mtdids changed, if the MTD dev list was updated
	 * or if our previous attempt to delete existing partititions failed.
	 * In any of these cases we want to update the partitions, otherwise,
	 * everything is up-to-date and we can return 0 directly.
	 *//*
	 * It is not safe to remove entries from the mtd_for_each_device loop
	 * as it uses idr indexes and the partitions removal is done in bulk
	 * (all partitions of one device at the same time), so break and
	 * iterate from start each time a new partition is found and deleted.
	 *//* do not delete partitions if they are in use. *//* Probe devices with DM compliant drivers *//* Go to the next tupple *//* Compare the name we search with the current mtd_id *//* Find the end of the tupple *//* Find the '=' sign *//**
 * mtd_search_alternate_name - Search an alternate name for @mtdname thanks to
 *                             the mtdids legacy environment variable.
 *
 * The mtdids string is a list of comma-separated 'dev_id=mtd_id' tupples.
 * Check if one of the mtd_id matches mtdname, in this case save dev_id in
 * altname.
 *
 * @mtdname: Current MTD device name
 * @altname: Alternate name to return
 * @max_len: Length of the alternate name buffer
 *
 * @return 0 on success, an error otherwise.
 *//* LEGACY *//*
 * (C) Copyright 2014
 * Heiko Schocher, DENX Software Engineering, hs@denx.de.
 *//opt/src/include/linux/mtd/partitions.h/opt/src/drivers/mtd<mtd.h><linux/mtd/partitions.h>partname/opt/src/include/linux/crc32.hcrc32(seed,data,length)crc32_le(seed, (unsigned char const *)data, length)_LINUX_CRC32_H/* _LINUX_CRC32_H *//* #define ether_crc_le(length, data) crc32_le(~0, data, length) *//* #define ether_crc(length, data)    bitrev32(crc32_le(~0, data, length)) *//*
 * Helpers for hash table generation of ethernet nics:
 *
 * Ethernet sends the least significant bit of a byte first, thus crc32_le
 * is used. The output of crc32_le is bit reversed [most significant bit
 * is in bit nr 0], thus it must be reversed before use. Except for
 * nics that bit swap the result internally...
 *//* extern u32  crc32_be(u32 crc, unsigned char const *p, size_t len); *//* #include <linux/bitrev.h> *//*
 * crc32.h
 * See linux/lib/crc32.c for license and changes
 *//opt/src/include/linux/rbtree.hrbtreerb_link_noderb_node *rb_node **rb_replace_noderb_root *rb_next_postorderconst rb_nodeconst rb_node *rb_first_postorderconst rb_rootconst rb_root *rb_lastrb_firstrb_prevrb_nextrb_eraserb_insert_colorrb_rootrb_noderb_leftrb_right__rb_parent_colorrbtree_postorder_for_each_entry_safe(pos,n,root,field)for (pos = rb_entry_safe(rb_first_postorder(root), typeof(*pos), field); pos && ({ n = rb_entry_safe(rb_next_postorder(&pos->field), typeof(*pos), field); 1; }); pos = n)rb_entry_safe(ptr,type,member)({ typeof(ptr) ____ptr = (ptr); ____ptr ? rb_entry(____ptr, type, member) : NULL; })RB_CLEAR_NODE(node)((node)->__rb_parent_color = (unsigned long)(node))RB_EMPTY_NODE(node)((node)->__rb_parent_color == (unsigned long)(node))RB_EMPTY_ROOT(root)((root)->rb_node == NULL)rb_entry(ptr,type,member)RB_ROOT(struct rb_root) { NULL, }rb_parent(r)((struct rb_node *)((r)->__rb_parent_color & ~3))_LINUX_RBTREE_H/* _LINUX_RBTREE_H *//**
 * rbtree_postorder_for_each_entry_safe - iterate over rb_root in post order of
 * given type safe against removal of rb_node entry
 *
 * @pos:	the 'type *' to use as a loop cursor.
 * @n:		another 'type *' to use as temporary storage
 * @root:	'rb_root *' of the rbtree.
 * @field:	the name of the rb_node field within 'type'.
 *//* Fast replacement of a single node without remove/rebalance/add/rebalance *//* Postorder iteration - always visit the parent after its children *//* Find logical next and previous nodes in a tree *//* 'empty' nodes are nodes that are known not to be inserted in an rbree *//* The alignment might seem pointless, but allegedly CRIS needs it *//*
  Red Black Trees
  (C) 1999  Andrea Arcangeli <andrea@suse.de>
  
  linux/include/linux/rbtree.h

  To use rbtrees you'll have to implement your own insert and search cores.
  This will avoid us to use callbacks and to drop drammatically performances.
  I know it's not the cleaner way,  but in C (not in C++) to get
  performances and genericity...

  See Documentation/rbtree.txt for documentation and samples.
*/rb_link/opt/src/include/linux/mtd/ubi.hubiubi_read_sgubi_volume_desc *ubi_sgl *ubi_readubi_flushubi_syncubi_is_mappedubi_leb_mapubi_leb_unmapubi_leb_eraseubi_leb_changeubi_leb_writeubi_leb_read_sgubi_leb_readubi_close_volumeubi_open_volume_pathubi_open_volume_nmubi_open_volumeubi_get_volume_infoubi_volume_info *ubi_get_device_infoubi_device_info *ubi_sgl_initubi_notificationUBI_VOLUME_ADDEDUBI_VOLUME_REMOVEDUBI_VOLUME_RESIZEDUBI_VOLUME_RENAMEDUBI_VOLUME_UPDATEDubi_device_infoubi_sglubi_volume_infoUBI_READONLYUBI_READWRITEUBI_EXCLUSIVEUBI_METAONLYvidiro_modemin_io_sizeleb_startleb_sizeubi_numpage_poslist_posusable_leb_sizeupd_markercorruptedvol_typeused_ebsused_bytesvol_idUBI_MAX_SG_COUNTUBI_ALL__LINUX_UBI_H__ubi_volume_desc/* !__LINUX_UBI_H__ *//*
 * This function is the same as the 'ubi_leb_read_sg()' function, but it does
 * not provide the checking capability.
 *//*
 * This function is the same as the 'ubi_leb_read()' function, but it does not
 * provide the checking capability.
 *//* UBI descriptor given to users when they open UBI volumes *//*
 * struct ubi_notification - UBI notification description structure.
 * @di: UBI device description object
 * @vi: UBI volume description object
 *
 * UBI notifiers are called with a pointer to an object of this type. The
 * object describes the notification. Namely, it provides a description of the
 * UBI device and UBI volume the notification informs about.
 *//*
 * Volume notification types.
 * @UBI_VOLUME_ADDED: a volume has been added (an UBI device was attached or a
 *                    volume was created)
 * @UBI_VOLUME_REMOVED: a volume has been removed (an UBI device was detached
 *			or a volume was removed)
 * @UBI_VOLUME_RESIZED: a volume has been re-sized
 * @UBI_VOLUME_RENAMED: a volume has been re-named
 * @UBI_VOLUME_UPDATED: data has been written to a volume
 *
 * These constants define which type of event has happened when a volume
 * notification function is invoked.
 *//**
 * struct ubi_device_info - UBI device description data structure.
 * @ubi_num: ubi device number
 * @leb_size: logical eraseblock size on this UBI device
 * @leb_start: starting offset of logical eraseblocks within physical
 *             eraseblocks
 * @min_io_size: minimal I/O unit size
 * @max_write_size: maximum amount of bytes the underlying flash can write at a
 *                  time (MTD write buffer size)
 * @ro_mode: if this device is in read-only mode
 * @cdev: UBI character device major and minor numbers
 *
 * Note, @leb_size is the logical eraseblock size offered by the UBI device.
 * Volumes of this UBI device may have smaller logical eraseblock size if their
 * alignment is not equivalent to %1.
 *
 * The @max_write_size field describes flash write maximum write unit. For
 * example, NOR flash allows for changing individual bytes, so @min_io_size is
 * %1. However, it does not mean than NOR flash has to write data byte-by-byte.
 * Instead, CFI NOR flashes have a write-buffer of, e.g., 64 bytes, and when
 * writing large chunks of data, they write 64-bytes at a time. Obviously, this
 * improves write throughput.
 *
 * Also, the MTD device may have N interleaved (striped) flash chips
 * underneath, in which case @min_io_size can be physical min. I/O size of
 * single flash chip, while @max_write_size can be N * @min_io_size.
 *
 * The @max_write_size field is always greater or equivalent to @min_io_size.
 * E.g., some NOR flashes may have (@min_io_size = 1, @max_write_size = 64). In
 * contrast, NAND flashes usually have @min_io_size = @max_write_size = NAND
 * page size.
 *//**
 * ubi_sgl_init - initialize an UBI scatter gather list data structure.
 * @usgl: the UBI scatter gather struct itself
 *
 * Please note that you still have to use sg_init_table() or any adequate
 * function to initialize the unterlaying struct scatterlist.
 *//**
 * struct ubi_sgl - UBI scatter gather list data structure.
 * @list_pos: current position in @sg[]
 * @page_pos: current position in @sg[@list_pos]
 * @sg: the scatter gather list itself
 *
 * ubi_sgl is a wrapper around a scatter list which keeps track of the
 * current position in the list and the current list item such that
 * it can be used across multiple ubi_leb_read_sg() calls.
 *//**
 * struct ubi_volume_info - UBI volume description data structure.
 * @vol_id: volume ID
 * @ubi_num: UBI device number this volume belongs to
 * @size: how many physical eraseblocks are reserved for this volume
 * @used_bytes: how many bytes of data this volume contains
 * @used_ebs: how many physical eraseblocks of this volume actually contain any
 *            data
 * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)
 * @corrupted: non-zero if the volume is corrupted (static volumes only)
 * @upd_marker: non-zero if the volume has update marker set
 * @alignment: volume alignment
 * @usable_leb_size: how many bytes are available in logical eraseblocks of
 *                   this volume
 * @name_len: volume name length
 * @name: volume name
 * @cdev: UBI volume character device major and minor numbers
 *
 * The @corrupted flag is only relevant to static volumes and is always zero
 * for dynamic ones. This is because UBI does not care about dynamic volume
 * data protection and only cares about protecting static volume data.
 *
 * The @upd_marker flag is set if the volume update operation was interrupted.
 * Before touching the volume data during the update operation, UBI first sets
 * the update marker flag for this volume. If the volume update operation was
 * further interrupted, the update marker indicates this. If the update marker
 * is set, the contents of the volume is certainly damaged and a new volume
 * update operation has to be started.
 *
 * To put it differently, @corrupted and @upd_marker fields have different
 * semantics:
 *     o the @corrupted flag means that this static volume is corrupted for some
 *       reasons, but not because an interrupted volume update
 *     o the @upd_marker field means that the volume is damaged because of an
 *       interrupted update operation.
 *
 * I.e., the @corrupted flag is never set if the @upd_marker flag is set.
 *
 * The @used_bytes and @used_ebs fields are only really needed for static
 * volumes and contain the number of bytes stored in this static volume and how
 * many eraseblock this data occupies. In case of dynamic volumes, the
 * @used_bytes field is equivalent to @size*@usable_leb_size, and the @used_ebs
 * field is equivalent to @size.
 *
 * In general, logical eraseblock size is a property of the UBI device, not
 * of the UBI volume. Indeed, the logical eraseblock size depends on the
 * physical eraseblock size and on how much bytes UBI headers consume. But
 * because of the volume alignment (@alignment), the usable size of logical
 * eraseblocks if a volume may be less. The following equation is true:
 *	@usable_leb_size = LEB size - (LEB size mod @alignment),
 * where LEB size is the logical eraseblock size defined by the UBI device.
 *
 * The alignment is multiple to the minimal flash input/output unit size or %1
 * if all the available space is used.
 *
 * To put this differently, alignment may be considered is a way to change
 * volume logical eraseblock sizes.
 *//*
 * enum ubi_open_mode - UBI volume open mode constants.
 *
 * UBI_READONLY: read-only mode
 * UBI_READWRITE: read-write mode
 * UBI_EXCLUSIVE: exclusive mode
 * UBI_METAONLY: modify only the volume meta-data,
 *  i.e. the data stored in the volume table, but not in any of volume LEBs.
 *//*
 * Maximum number of scatter gather list entries,
 * we use only 64 to have a lower memory foot print.
 *//* All voumes/LEBs *//*
 * Copyright (c) International Business Machines Corp., 2006
 *
 * Author: Artem Bityutskiy ( )
 */lnumsglusgl/opt/src/include/ubi_uboot.hubi_uboot__UBOOT_UBI_H__UBIFS_H__/* functions *//* build.c *//* ubi_init() disables returning error codes when built into the Linux
 * kernel so that it doesn't hang the Linux kernel boot process.  Since
 * the U-Boot driver code depends on getting valid error codes from this
 * function we just tell the UBI layer that we are building as a module
 * (which only enables the additional error reporting).
 *//* debug options (Linux: drivers/mtd/ubi/Kconfig.debug) *//* configurable *//*
 * Header file for UBI support for U-Boot
 *
 * Adaptation from kernel to U-Boot
 *
 *  Copyright (C) 2005-2007 Samsung Electronics
 *  Kyungmin Park <kyungmin.park@samsung.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *//opt/src/drivers/mtd/ubi/ubi-media.hubi-mediaubi_fm_ebaubi_fm_volhdrubi_fm_ecubi_fm_scan_poolubi_fm_hdrubi_fm_sbubi_vtbl_recordubi_vid_hdrubi_ec_hdrUBI_COMPAT_DELETEUBI_COMPAT_ROUBI_COMPAT_PRESERVEUBI_COMPAT_REJECTUBI_VTBL_AUTORESIZE_FLGUBI_VID_DYNAMICUBI_VID_STATIC__be32[0]reserved_pebspadding2last_eb_bytesdata_padpadding1__be32[256]unsigned int[256]UBI_FM_MAX_POOL_SIZEpebsvol_counterase_peb_countbad_peb_countscrub_peb_countused_peb_countfree_peb_countsqnum__be32[32]UBI_FM_MAX_BLOCKSblock_ecblock_locused_blocks__u8[23]unsigned char[23]UBI_VOL_NAME_MAXUBI_VOL_NAME_MAX+1padding3copy_flagimage_seqvid_hdr_offsetUBI_FM_MIN_POOL_SIZEUBI_FM_MAX_STARTUBI_FM_EBA_MAGIC0xf0c040a8UBI_FM_POOL_MAGIC0x67AF4D08UBI_FM_VHDR_MAGIC0xFA370ED1UBI_FM_HDR_MAGIC0xD4B82EF7UBI_FM_SB_MAGIC0x7B11D69FUBI_FM_FMT_VERSIONUBI_FM_DATA_VOLUME_ID(UBI_LAYOUT_VOLUME_ID + 2)UBI_FM_SB_VOLUME_ID(UBI_LAYOUT_VOLUME_ID + 1)UBI_VTBL_RECORD_SIZE_CRC(UBI_VTBL_RECORD_SIZE - sizeof(__be32))UBI_VTBL_RECORD_SIZEsizeof(struct ubi_vtbl_record)UBI_MAX_VOLUMESUBI_LAYOUT_VOLUME_COMPATUBI_LAYOUT_VOLUME_NAME"layout volume"UBI_LAYOUT_VOLUME_EBSUBI_LAYOUT_VOLUME_ALIGNUBI_LAYOUT_VOLUME_TYPEUBI_LAYOUT_VOLUME_IDUBI_INTERNAL_VOL_START(0x7FFFFFFF - 4096)UBI_INT_VOL_COUNTUBI_VID_HDR_SIZE_CRC(UBI_VID_HDR_SIZE - sizeof(__be32))UBI_EC_HDR_SIZE_CRC(UBI_EC_HDR_SIZE - sizeof(__be32))UBI_VID_HDR_SIZEsizeof(struct ubi_vid_hdr)UBI_EC_HDR_SIZEsizeof(struct ubi_ec_hdr)UBI_VID_HDR_MAGIC0x55424921UBI_EC_HDR_MAGIC0x55424923UBI_CRC32_INIT0xFFFFFFFFUUBI_MAX_ERASECOUNTER0x7FFFFFFFUBI_VERSION__UBI_MEDIA_H__/* !__UBI_MEDIA_H__ *//**
 * struct ubi_fm_eba - denotes an association beween a PEB and LEB
 * @magic: EBA table magic number
 * @reserved_pebs: number of table entries
 * @pnum: PEB number of LEB (LEB is the index)
 *//* struct ubi_fm_volhdr is followed by one struct ubi_fm_eba records *//**
 * struct ubi_fm_volhdr - Fastmap volume header
 * it identifies the start of an eba table
 * @magic: Fastmap volume header magic number (%UBI_FM_VHDR_MAGIC)
 * @vol_id: volume id of the fastmapped volume
 * @vol_type: type of the fastmapped volume
 * @data_pad: data_pad value of the fastmapped volume
 * @used_ebs: number of used LEBs within this volume
 * @last_eb_bytes: number of bytes used in the last LEB
 *//**
 * struct ubi_fm_ec - stores the erase counter of a PEB
 * @pnum: PEB number
 * @ec: ec of this PEB
 *//* ubi_fm_scan_pool is followed by nfree+nused struct ubi_fm_ec records *//**
 * struct ubi_fm_scan_pool - Fastmap pool PEBs to be scanned while attaching
 * @magic: pool magic numer (%UBI_FM_POOL_MAGIC)
 * @size: current pool size
 * @max_size: maximal pool size
 * @pebs: an array containing the location of all PEBs in this pool
 *//* struct ubi_fm_hdr is followed by two struct ubi_fm_scan_pool *//**
 * struct ubi_fm_hdr - header of the fastmap data set
 * @magic: fastmap header magic number (%UBI_FM_HDR_MAGIC)
 * @free_peb_count: number of free PEBs known by this fastmap
 * @used_peb_count: number of used PEBs known by this fastmap
 * @scrub_peb_count: number of to be scrubbed PEBs known by this fastmap
 * @bad_peb_count: number of bad PEBs known by this fastmap
 * @erase_peb_count: number of bad PEBs which have to be erased
 * @vol_count: number of UBI volumes known by this fastmap
 *//**
 * struct ubi_fm_sb - UBI fastmap super block
 * @magic: fastmap super block magic number (%UBI_FM_SB_MAGIC)
 * @version: format version of this fastmap
 * @data_crc: CRC over the fastmap data
 * @used_blocks: number of PEBs used by this fastmap
 * @block_loc: an array containing the location of all PEBs of the fastmap
 * @block_ec: the erase counter of each used PEB
 * @sqnum: highest sequence number value at the time while taking the fastmap
 *
 *//* 5% of the total number of PEBs have to be scanned while attaching
 * from a fastmap.
 * But the size of this pool is limited to be between UBI_FM_MIN_POOL_SIZE and
 * UBI_FM_MAX_POOL_SIZE *//* A fastmap can use up to UBI_FM_MAX_BLOCKS PEBs *//* A fastmap supber block can be located between PEB 0 and
 * UBI_FM_MAX_START *//* fastmap on-flash data structure format version *//* UBI fastmap on-flash data structures *//**
 * struct ubi_vtbl_record - a record in the volume table.
 * @reserved_pebs: how many physical eraseblocks are reserved for this volume
 * @alignment: volume alignment
 * @data_pad: how many bytes are unused at the end of the each physical
 * eraseblock to satisfy the requested alignment
 * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)
 * @upd_marker: if volume update was started but not finished
 * @name_len: volume name length
 * @name: the volume name
 * @flags: volume flags (%UBI_VTBL_AUTORESIZE_FLG)
 * @padding: reserved, zeroes
 * @crc: a CRC32 checksum of the record
 *
 * The volume table records are stored in the volume table, which is stored in
 * the layout volume. The layout volume consists of 2 logical eraseblock, each
 * of which contains a copy of the volume table (i.e., the volume table is
 * duplicated). The volume table is an array of &struct ubi_vtbl_record
 * objects indexed by the volume ID.
 *
 * If the size of the logical eraseblock is large enough to fit
 * %UBI_MAX_VOLUMES records, the volume table contains %UBI_MAX_VOLUMES
 * records. Otherwise, it contains as many records as it can fit (i.e., size of
 * logical eraseblock divided by sizeof(struct ubi_vtbl_record)).
 *
 * The @upd_marker flag is used to implement volume update. It is set to %1
 * before update and set to %0 after the update. So if the update operation was
 * interrupted, UBI knows that the volume is corrupted.
 *
 * The @alignment field is specified when the volume is created and cannot be
 * later changed. It may be useful, for example, when a block-oriented file
 * system works on top of UBI. The @data_pad field is calculated using the
 * logical eraseblock size and @alignment. The alignment must be multiple to the
 * minimal flash I/O unit. If @alignment is 1, all the available space of
 * the physical eraseblocks is used.
 *
 * Empty records contain all zeroes and the CRC checksum of those zeroes.
 *//* Size of the volume table record without the ending CRC *//* Size of the volume table record *//* The maximum volume name length *//* The maximum number of volumes per one UBI device *//* The layout volume contains the volume table *//*
 * Starting ID of internal volumes: 0x7fffefff.
 * There is reserved room for 4096 internal volumes.
 *//* Internal UBI volumes count *//**
 * struct ubi_vid_hdr - on-flash UBI volume identifier header.
 * @magic: volume identifier header magic number (%UBI_VID_HDR_MAGIC)
 * @version: UBI implementation version which is supposed to accept this UBI
 *           image (%UBI_VERSION)
 * @vol_type: volume type (%UBI_VID_DYNAMIC or %UBI_VID_STATIC)
 * @copy_flag: if this logical eraseblock was copied from another physical
 *             eraseblock (for wear-leveling reasons)
 * @compat: compatibility of this volume (%0, %UBI_COMPAT_DELETE,
 *          %UBI_COMPAT_IGNORE, %UBI_COMPAT_PRESERVE, or %UBI_COMPAT_REJECT)
 * @vol_id: ID of this volume
 * @lnum: logical eraseblock number
 * @padding1: reserved for future, zeroes
 * @data_size: how many bytes of data this logical eraseblock contains
 * @used_ebs: total number of used logical eraseblocks in this volume
 * @data_pad: how many bytes at the end of this physical eraseblock are not
 *            used
 * @data_crc: CRC checksum of the data stored in this logical eraseblock
 * @padding2: reserved for future, zeroes
 * @sqnum: sequence number
 * @padding3: reserved for future, zeroes
 * @hdr_crc: volume identifier header CRC checksum
 *
 * The @sqnum is the value of the global sequence counter at the time when this
 * VID header was created. The global sequence counter is incremented each time
 * UBI writes a new VID header to the flash, i.e. when it maps a logical
 * eraseblock to a new physical eraseblock. The global sequence counter is an
 * unsigned 64-bit integer and we assume it never overflows. The @sqnum
 * (sequence number) is used to distinguish between older and newer versions of
 * logical eraseblocks.
 *
 * There are 2 situations when there may be more than one physical eraseblock
 * corresponding to the same logical eraseblock, i.e., having the same @vol_id
 * and @lnum values in the volume identifier header. Suppose we have a logical
 * eraseblock L and it is mapped to the physical eraseblock P.
 *
 * 1. Because UBI may erase physical eraseblocks asynchronously, the following
 * situation is possible: L is asynchronously erased, so P is scheduled for
 * erasure, then L is written to,i.e. mapped to another physical eraseblock P1,
 * so P1 is written to, then an unclean reboot happens. Result - there are 2
 * physical eraseblocks P and P1 corresponding to the same logical eraseblock
 * L. But P1 has greater sequence number, so UBI picks P1 when it attaches the
 * flash.
 *
 * 2. From time to time UBI moves logical eraseblocks to other physical
 * eraseblocks for wear-leveling reasons. If, for example, UBI moves L from P
 * to P1, and an unclean reboot happens before P is physically erased, there
 * are two physical eraseblocks P and P1 corresponding to L and UBI has to
 * select one of them when the flash is attached. The @sqnum field says which
 * PEB is the original (obviously P will have lower @sqnum) and the copy. But
 * it is not enough to select the physical eraseblock with the higher sequence
 * number, because the unclean reboot could have happen in the middle of the
 * copying process, so the data in P is corrupted. It is also not enough to
 * just select the physical eraseblock with lower sequence number, because the
 * data there may be old (consider a case if more data was added to P1 after
 * the copying). Moreover, the unclean reboot may happen when the erasure of P
 * was just started, so it result in unstable P, which is "mostly" OK, but
 * still has unstable bits.
 *
 * UBI uses the @copy_flag field to indicate that this logical eraseblock is a
 * copy. UBI also calculates data CRC when the data is moved and stores it at
 * the @data_crc field of the copy (P1). So when UBI needs to pick one physical
 * eraseblock of two (P or P1), the @copy_flag of the newer one (P1) is
 * examined. If it is cleared, the situation* is simple and the newer one is
 * picked. If it is set, the data CRC of the copy (P1) is examined. If the CRC
 * checksum is correct, this physical eraseblock is selected (P1). Otherwise
 * the older one (P) is selected.
 *
 * There are 2 sorts of volumes in UBI: user volumes and internal volumes.
 * Internal volumes are not seen from outside and are used for various internal
 * UBI purposes. In this implementation there is only one internal volume - the
 * layout volume. Internal volumes are the main mechanism of UBI extensions.
 * For example, in future one may introduce a journal internal volume. Internal
 * volumes have their own reserved range of IDs.
 *
 * The @compat field is only used for internal volumes and contains the "degree
 * of their compatibility". It is always zero for user volumes. This field
 * provides a mechanism to introduce UBI extensions and to be still compatible
 * with older UBI binaries. For example, if someone introduced a journal in
 * future, he would probably use %UBI_COMPAT_DELETE compatibility for the
 * journal volume.  And in this case, older UBI binaries, which know nothing
 * about the journal volume, would just delete this volume and work perfectly
 * fine. This is similar to what Ext2fs does when it is fed by an Ext3fs image
 * - it just ignores the Ext3fs journal.
 *
 * The @data_crc field contains the CRC checksum of the contents of the logical
 * eraseblock if this is a static volume. In case of dynamic volumes, it does
 * not contain the CRC checksum as a rule. The only exception is when the
 * data of the physical eraseblock was moved by the wear-leveling sub-system,
 * then the wear-leveling sub-system calculates the data CRC and stores it in
 * the @data_crc field. And of course, the @copy_flag is %in this case.
 *
 * The @data_size field is used only for static volumes because UBI has to know
 * how many bytes of data are stored in this eraseblock. For dynamic volumes,
 * this field usually contains zero. The only exception is when the data of the
 * physical eraseblock was moved to another physical eraseblock for
 * wear-leveling reasons. In this case, UBI calculates CRC checksum of the
 * contents and uses both @data_crc and @data_size fields. In this case, the
 * @data_size field contains data size.
 *
 * The @used_ebs field is used only for static volumes and indicates how many
 * eraseblocks the data of the volume takes. For dynamic volumes this field is
 * not used and always contains zero.
 *
 * The @data_pad is calculated when volumes are created using the alignment
 * parameter. So, effectively, the @data_pad field reduces the size of logical
 * eraseblocks of this volume. This is very handy when one uses block-oriented
 * software (say, cramfs) on top of the UBI volume.
 *//* Warning: the current limit is 31-bit anyway! *//**
 * struct ubi_ec_hdr - UBI erase counter header.
 * @magic: erase counter header magic number (%UBI_EC_HDR_MAGIC)
 * @version: version of UBI implementation which is supposed to accept this
 *           UBI image
 * @padding1: reserved for future, zeroes
 * @ec: the erase counter
 * @vid_hdr_offset: where the VID header starts
 * @data_offset: where the user data start
 * @image_seq: image sequence number
 * @padding2: reserved for future, zeroes
 * @hdr_crc: erase counter header CRC checksum
 *
 * The erase counter header takes 64 bytes and has a plenty of unused space for
 * future usage. The unused fields are zeroed. The @version field is used to
 * indicate the version of UBI implementation which is supposed to be able to
 * work with this UBI image. If @version is greater than the current UBI
 * version, the image is rejected. This may be useful in future if something
 * is changed radically. This field is duplicated in the volume identifier
 * header.
 *
 * The @vid_hdr_offset and @data_offset fields contain the offset of the the
 * volume identifier header and user data, relative to the beginning of the
 * physical eraseblock. These values have to be the same for all physical
 * eraseblocks.
 *
 * The @image_seq field is used to validate a UBI image that has been prepared
 * for a UBI device. The @image_seq value can be any value, but it must be the
 * same on all eraseblocks. UBI will ensure that all new erase counter headers
 * also contain this value, and will check the value when attaching the flash.
 * One way to make use of @image_seq is to increase its value by one every time
 * an image is flashed over an existing image, then, if the flashing does not
 * complete, UBI will detect the error when attaching the media.
 *//* Sizes of UBI headers without the ending CRC *//* Sizes of UBI headers *//*
 * Compatibility constants used by internal volumes.
 *
 * @UBI_COMPAT_DELETE: delete this internal volume before anything is written
 *                     to the flash
 * @UBI_COMPAT_RO: attach this device in read-only mode
 * @UBI_COMPAT_PRESERVE: preserve this internal volume - do not touch its
 *                       physical eraseblocks, don't allow the wear-leveling
 *                       sub-system to move them
 * @UBI_COMPAT_REJECT: reject this UBI image
 *//*
 * Volume flags used in the volume table record.
 *
 * @UBI_VTBL_AUTORESIZE_FLG: auto-resize this volume
 *
 * %UBI_VTBL_AUTORESIZE_FLG flag can be set only for one volume in the volume
 * table. UBI automatically re-sizes the volume which has this flag and makes
 * the volume to be of largest possible size. This means that if after the
 * initialization UBI finds out that there are available physical eraseblocks
 * present on the device, it automatically appends all of them to the volume
 * (the physical eraseblocks reserved for bad eraseblocks handling and other
 * reserved physical eraseblocks are not taken). So, if there is a volume with
 * the %UBI_VTBL_AUTORESIZE_FLG flag set, the amount of available logical
 * eraseblocks will be zero after UBI is loaded, because all of them will be
 * reserved for this volume. Note, the %UBI_VTBL_AUTORESIZE_FLG bit is cleared
 * after the volume had been initialized.
 *
 * The auto-resize feature is useful for device production purposes. For
 * example, different NAND flash chips may have different amount of initial bad
 * eraseblocks, depending of particular chip instance. Manufacturers of NAND
 * chips usually guarantee that the amount of initial bad eraseblocks does not
 * exceed certain percent, e.g. 2%. When one creates an UBI image which will be
 * flashed to the end devices in production, he does not know the exact amount
 * of good physical eraseblocks the NAND chip on the device will have, but this
 * number is required to calculate the volume sized and put them to the volume
 * table of the UBI image. In this case, one of the volumes (e.g., the one
 * which will store the root file system) is marked as "auto-resizable", and
 * UBI will adjust its size on the first boot if needed.
 *
 * Note, first UBI reserves some amount of physical eraseblocks for bad
 * eraseblock handling, and then re-sizes the volume, not vice-versa. This
 * means that the pool of reserved physical eraseblocks will always be present.
 *//*
 * Volume type constants used in the volume identifier header.
 *
 * @UBI_VID_DYNAMIC: dynamic volume
 * @UBI_VID_STATIC: static volume
 *//* Volume identifier header magic number (ASCII "UBI!") *//* Erase counter header magic number (ASCII "UBI#") *//* The initial CRC32 value used when calculating CRC checksums *//* The highest erase counter value supported by this implementation *//* The version of UBI images supported by this implementation *//*
 * This file defines the layout of UBI headers and all the other UBI on-flash
 * data structures.
 *//*
 * Copyright (c) International Business Machines Corp., 2006
 *
 * Authors: Artem Bityutskiy ( )
 *          Thomas Gleixner
 *          Frank Haverkamp
 *          Oliver Lohmann
 *          Andreas Arnez
 *//opt/src/drivers/mtd/ubi/opt/src/include/mtd/ubi-user.hubi-userubi_blkcreate_requbi_set_vol_prop_requbi_map_requbi_leb_change_requbi_rnvol_requbi_rsvol_requbi_mkvol_requbi_attach_reqUBI_VOL_PROP_DIRECT_WRITEUBI_DYNAMIC_VOLUMEUBI_STATIC_VOLUME__s8[128]signed char[128]__s8[3]signed char[3]__s8[7]signed char[7]struct <unnamed>[32]UBI_MAX_RNVOLents__s8[12]signed char[12]UBI_MAX_VOLUME_NAMEUBI_MAX_VOLUME_NAME + 1__s8[2]signed char[2]__s8[4]signed char[4]__s8[10]signed char[10]max_beb_per1024mtd_numMAX_UBI_MTD_NAME_LENUBI_IOCVOLRMBLK_IO(UBI_VOL_IOC_MAGIC, 8)UBI_IOCVOLCRBLK_IOW(UBI_VOL_IOC_MAGIC, 7, struct ubi_blkcreate_req)UBI_IOCSETVOLPROP_IOW(UBI_VOL_IOC_MAGIC, 6, struct ubi_set_vol_prop_req)UBI_IOCEBISMAP_IOR(UBI_VOL_IOC_MAGIC, 5, __s32)UBI_IOCEBUNMAP_IOW(UBI_VOL_IOC_MAGIC, 4, __s32)UBI_IOCEBMAP_IOW(UBI_VOL_IOC_MAGIC, 3, struct ubi_map_req)UBI_IOCEBCH_IOW(UBI_VOL_IOC_MAGIC, 2, __s32)UBI_IOCEBER_IOW(UBI_VOL_IOC_MAGIC, 1, __s32)UBI_IOCVOLUP_IOW(UBI_VOL_IOC_MAGIC, 0, __s64)UBI_VOL_IOC_MAGICUBI_IOCDET_IOW(UBI_CTRL_IOC_MAGIC, 65, __s32)UBI_IOCATT_IOW(UBI_CTRL_IOC_MAGIC, 64, struct ubi_attach_req)UBI_CTRL_IOC_MAGICUBI_IOCRNVOL_IOW(UBI_IOC_MAGIC, 3, struct ubi_rnvol_req)UBI_IOCRSVOL_IOW(UBI_IOC_MAGIC, 2, struct ubi_rsvol_req)UBI_IOCRMVOL_IOW(UBI_IOC_MAGIC, 1, __s32)UBI_IOCMKVOL_IOW(UBI_IOC_MAGIC, 0, struct ubi_mkvol_req)UBI_IOC_MAGICUBI_DEV_NUM_AUTOUBI_VOL_NUM_AUTO__UBI_USER_H__/* __UBI_USER_H__ *//**
 * struct ubi_blkcreate_req - a data structure used in block creation requests.
 * @padding: reserved for future, not used, has to be zeroed
 *//**
 * struct ubi_set_vol_prop_req - a data structure used to set an UBI volume
 *                               property.
 * @property: property to set (%UBI_VOL_PROP_DIRECT_WRITE)
 * @padding: reserved for future, not used, has to be zeroed
 * @value: value to set
 *//* obsolete, do not use! *//**
 * struct ubi_map_req - a data structure used in map LEB requests.
 * @dtype: pass "3" for better compatibility with old kernels
 * @lnum: logical eraseblock number to unmap
 * @padding: reserved for future, not used, has to be zeroed
 *//**
 * struct ubi_leb_change_req - a data structure used in atomic LEB change
 *                             requests.
 * @lnum: logical eraseblock number to change
 * @bytes: how many bytes will be written to the logical eraseblock
 * @dtype: pass "3" for better compatibility with old kernels
 * @padding: reserved for future, not used, has to be zeroed
 *
 * The @dtype field used to inform UBI about what kind of data will be written
 * to the LEB: long term (value 1), short term (value 2), unknown (value 3).
 * UBI tried to pick a PEB with lower erase counter for short term data and a
 * PEB with higher erase counter for long term data. But this was not really
 * used because users usually do not know this and could easily mislead UBI. We
 * removed this feature in May 2012. UBI currently just ignores the @dtype
 * field. But for better compatibility with older kernels it is recommended to
 * set @dtype to 3 (unknown).
 *//**
 * struct ubi_rnvol_req - volumes re-name request.
 * @count: count of volumes to re-name
 * @padding1:  reserved for future, not used, has to be zeroed
 * @vol_id: ID of the volume to re-name
 * @name_len: name length
 * @padding2:  reserved for future, not used, has to be zeroed
 * @name: new volume name
 *
 * UBI allows to re-name up to %32 volumes at one go. The count of volumes to
 * re-name is specified in the @count field. The ID of the volumes to re-name
 * and the new names are specified in the @vol_id and @name fields.
 *
 * The UBI volume re-name operation is atomic, which means that should power cut
 * happen, the volumes will have either old name or new name. So the possible
 * use-cases of this command is atomic upgrade. Indeed, to upgrade, say, volumes
 * A and B one may create temporary volumes %A1 and %B1 with the new contents,
 * then atomically re-name A1->A and B1->B, in which case old %A and %B will
 * be removed.
 *
 * If it is not desirable to remove old A and B, the re-name request has to
 * contain 4 entries: A1->A, A->A1, B1->B, B->B1, in which case old A1 and B1
 * become A and B, and old A and B will become A1 and B1.
 *
 * It is also OK to request: A1->A, A1->X, B1->B, B->Y, in which case old A1
 * and B1 become A and B, and old A and B become X and Y.
 *
 * In other words, in case of re-naming into an existing volume name, the
 * existing volume is removed, unless it is re-named as well at the same
 * re-name request.
 *//**
 * struct ubi_rsvol_req - a data structure used in volume re-size requests.
 * @vol_id: ID of the volume to re-size
 * @bytes: new size of the volume in bytes
 *
 * Re-sizing is possible for both dynamic and static volumes. But while dynamic
 * volumes may be re-sized arbitrarily, static volumes cannot be made to be
 * smaller than the number of bytes they bear. To arbitrarily shrink a static
 * volume, it must be wiped out first (by means of volume update operation with
 * zero number of bytes).
 *//**
 * struct ubi_mkvol_req - volume description data structure used in
 *                        volume creation requests.
 * @vol_id: volume number
 * @alignment: volume alignment
 * @bytes: volume size in bytes
 * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)
 * @padding1: reserved for future, not used, has to be zeroed
 * @name_len: volume name length
 * @padding2: reserved for future, not used, has to be zeroed
 * @name: volume name
 *
 * This structure is used by user-space programs when creating new volumes. The
 * @used_bytes field is only necessary when creating static volumes.
 *
 * The @alignment field specifies the required alignment of the volume logical
 * eraseblock. This means, that the size of logical eraseblocks will be aligned
 * to this number, i.e.,
 *	(UBI device logical eraseblock size) mod (@alignment) = 0.
 *
 * To put it differently, the logical eraseblock of this volume may be slightly
 * shortened in order to make it properly aligned. The alignment has to be
 * multiple of the flash minimal input/output unit, or %1 to utilize the entire
 * available space of logical eraseblocks.
 *
 * The @alignment field may be useful, for example, when one wants to maintain
 * a block device on top of an UBI volume. In this case, it is desirable to fit
 * an integer number of blocks in logical eraseblocks of this UBI volume. With
 * alignment it is possible to update this volume using plane UBI volume image
 * BLOBs, without caring about how to properly align them.
 *//**
 * struct ubi_attach_req - attach MTD device request.
 * @ubi_num: UBI device number to create
 * @mtd_num: MTD device number to attach
 * @vid_hdr_offset: VID header offset (use defaults if %0)
 * @max_beb_per1024: maximum expected number of bad PEB per 1024 PEBs
 * @padding: reserved for future, not used, has to be zeroed
 *
 * This data structure is used to specify MTD device UBI has to attach and the
 * parameters it has to use. The number which should be assigned to the new UBI
 * device is passed in @ubi_num. UBI may automatically assign the number if
 * @UBI_DEV_NUM_AUTO is passed. In this case, the device number is returned in
 * @ubi_num.
 *
 * Most applications should pass %0 in @vid_hdr_offset to make UBI use default
 * offset of the VID header within physical eraseblocks. The default offset is
 * the next min. I/O unit after the EC header. For example, it will be offset
 * 512 in case of a 512 bytes page NAND flash with no sub-page support. Or
 * it will be 512 in case of a 2KiB page NAND flash with 4 512-byte sub-pages.
 *
 * But in rare cases, if this optimizes things, the VID header may be placed to
 * a different offset. For example, the boot-loader might do things faster if
 * the VID header sits at the end of the first 2KiB NAND page with 4 sub-pages.
 * As the boot-loader would not normally need to read EC headers (unless it
 * needs UBI in RW mode), it might be faster to calculate ECC. This is weird
 * example, but it real-life example. So, in this example, @vid_hdr_offer would
 * be 2KiB-64 bytes = 1984. Note, that this position is not even 512-bytes
 * aligned, which is OK, as UBI is clever enough to realize this is 4th
 * sub-page of the first page and add needed padding.
 *
 * The @max_beb_per1024 is the maximum amount of bad PEBs UBI expects on the
 * UBI device per 1024 eraseblocks.  This value is often given in an other form
 * in the NAND datasheet (min NVB i.e. minimal number of valid blocks). The
 * maximum expected bad eraseblocks per 1024 is then:
 *    1024 * (1 - MinNVB / MaxNVB)
 * Which gives 20 for most NAND devices.  This limit is used in order to derive
 * amount of eraseblock UBI reserves for handling new bad blocks. If the device
 * has more bad eraseblocks than this limit, UBI does not reserve any physical
 * eraseblocks for new bad eraseblocks, but attempts to use available
 * eraseblocks (if any). The accepted range is 0-768. If 0 is given, the
 * default kernel value of %CONFIG_MTD_UBI_BEB_LIMIT will be used.
 *//*
 * UBI set volume property ioctl constants.
 *
 * @UBI_VOL_PROP_DIRECT_WRITE: allow (any non-zero value) or disallow (value 0)
 *                             user to directly write and erase individual
 *                             eraseblocks on dynamic volumes
 *//*
 * UBI volume type constants.
 *
 * @UBI_DYNAMIC_VOLUME: dynamic volume
 * @UBI_STATIC_VOLUME:  static volume
 *//* Maximum amount of UBI volumes that can be re-named at one go *//* Maximum MTD device name length supported by UBI *//* Remove the R/O block device *//* Create a R/O block device on top of an UBI volume *//* Set an UBI volume property *//* Check if LEB is mapped command *//* Unmap LEB command *//* Map LEB command *//* Atomic LEB change command *//* LEB erasure command, used for debugging, disabled by default *//* Start UBI volume update
 * Note: This actually takes a pointer (__s64*), but we can't change
 *       that without breaking the ABI on 32bit systems
 *//* ioctl commands of UBI volume character devices *//* Detach an MTD device *//* Attach an MTD device *//* ioctl commands of the UBI control character device *//* Re-name volumes *//* Re-size an UBI volume *//* Remove an UBI volume *//* Create an UBI volume *//* ioctl commands of UBI character devices *//* Maximum volume name length *//*
 * When a new UBI volume or UBI device is created, users may either specify the
 * volume/device number they want to create or to let UBI automatically assign
 * the number using these constants.
 *//*
 * UBI device creation (the same as MTD device attachment)
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * MTD devices may be attached using %UBI_IOCATT ioctl command of the UBI
 * control device. The caller has to properly fill and pass
 * &struct ubi_attach_req object - UBI will attach the MTD device specified in
 * the request and return the newly created UBI device number as the ioctl
 * return value.
 *
 * UBI device deletion (the same as MTD device detachment)
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * An UBI device maybe deleted with %UBI_IOCDET ioctl command of the UBI
 * control device.
 *
 * UBI volume creation
 * ~~~~~~~~~~~~~~~~~~~
 *
 * UBI volumes are created via the %UBI_IOCMKVOL ioctl command of UBI character
 * device. A &struct ubi_mkvol_req object has to be properly filled and a
 * pointer to it has to be passed to the ioctl.
 *
 * UBI volume deletion
 * ~~~~~~~~~~~~~~~~~~~
 *
 * To delete a volume, the %UBI_IOCRMVOL ioctl command of the UBI character
 * device should be used. A pointer to the 32-bit volume ID hast to be passed
 * to the ioctl.
 *
 * UBI volume re-size
 * ~~~~~~~~~~~~~~~~~~
 *
 * To re-size a volume, the %UBI_IOCRSVOL ioctl command of the UBI character
 * device should be used. A &struct ubi_rsvol_req object has to be properly
 * filled and a pointer to it has to be passed to the ioctl.
 *
 * UBI volumes re-name
 * ~~~~~~~~~~~~~~~~~~~
 *
 * To re-name several volumes atomically at one go, the %UBI_IOCRNVOL command
 * of the UBI character device should be used. A &struct ubi_rnvol_req object
 * has to be properly filled and a pointer to it has to be passed to the ioctl.
 *
 * UBI volume update
 * ~~~~~~~~~~~~~~~~~
 *
 * Volume update should be done via the %UBI_IOCVOLUP ioctl command of the
 * corresponding UBI volume character device. A pointer to a 64-bit update
 * size should be passed to the ioctl. After this, UBI expects user to write
 * this number of bytes to the volume character device. The update is finished
 * when the claimed number of bytes is passed. So, the volume update sequence
 * is something like:
 *
 * fd = open("/dev/my_volume");
 * ioctl(fd, UBI_IOCVOLUP, &image_size);
 * write(fd, buf, image_size);
 * close(fd);
 *
 * Logical eraseblock erase
 * ~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * To erase a logical eraseblock, the %UBI_IOCEBER ioctl command of the
 * corresponding UBI volume character device should be used. This command
 * unmaps the requested logical eraseblock, makes sure the corresponding
 * physical eraseblock is successfully erased, and returns.
 *
 * Atomic logical eraseblock change
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * Atomic logical eraseblock change operation is called using the %UBI_IOCEBCH
 * ioctl command of the corresponding UBI volume character device. A pointer to
 * a &struct ubi_leb_change_req object has to be passed to the ioctl. Then the
 * user is expected to write the requested amount of bytes (similarly to what
 * should be done in case of the "volume update" ioctl).
 *
 * Logical eraseblock map
 * ~~~~~~~~~~~~~~~~~~~~~
 *
 * To map a logical eraseblock to a physical eraseblock, the %UBI_IOCEBMAP
 * ioctl command should be used. A pointer to a &struct ubi_map_req object is
 * expected to be passed. The ioctl maps the requested logical eraseblock to
 * a physical eraseblock and returns.  Only non-mapped logical eraseblocks can
 * be mapped. If the logical eraseblock specified in the request is already
 * mapped to a physical eraseblock, the ioctl fails and returns error.
 *
 * Logical eraseblock unmap
 * ~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * To unmap a logical eraseblock to a physical eraseblock, the %UBI_IOCEBUNMAP
 * ioctl command should be used. The ioctl unmaps the logical eraseblocks,
 * schedules corresponding physical eraseblock for erasure, and returns. Unlike
 * the "LEB erase" command, it does not wait for the physical eraseblock being
 * erased. Note, the side effect of this is that if an unclean reboot happens
 * after the unmap ioctl returns, you may find the LEB mapped again to the same
 * physical eraseblock after the UBI is run again.
 *
 * Check if logical eraseblock is mapped
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * To check if a logical eraseblock is mapped to a physical eraseblock, the
 * %UBI_IOCEBISMAP ioctl command should be used. It returns %0 if the LEB is
 * not mapped, and %1 if it is mapped.
 *
 * Set an UBI volume property
 * ~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * To set an UBI volume property the %UBI_IOCSETPROP ioctl command should be
 * used. A pointer to a &struct ubi_set_vol_prop_req object is expected to be
 * passed. The object describes which property should be set, and to which value
 * it should be set.
 *
 * Block devices on UBI volumes
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * To create a R/O block device on top of an UBI volume the %UBI_IOCVOLCRBLK
 * should be used. A pointer to a &struct ubi_blkcreate_req object is expected
 * to be passed, which is not used and reserved for future usage.
 *
 * Conversely, to remove a block device the %UBI_IOCVOLRMBLK should be used,
 * which takes no arguments.
 *//*
 * Copyright  International Business Machines Corp., 2006
 *
 * Author: Artem Bityutskiy ( )
 *//opt/src/drivers/mtd/ubi/debug.hubi_dbg_power_cutubi_device *ubi_enable_dbg_chk_fastmapubi_dbg_chk_fastmapconst ubi_deviceconst ubi_device *ubi_dbg_chk_genubi_dbg_chk_ioubi_dbg_is_erase_failureprandom_u32()prandom_u32() % 400(prandom_u32() % 400)!(prandom_u32() % 400)ubi_dbg_is_write_failureprandom_u32() % 500(prandom_u32() % 500)!(prandom_u32() % 500)ubi_dbg_is_bitflipprandom_u32() % 200(prandom_u32() % 200)!(prandom_u32() % 200)ubi_dbg_is_bgt_disabledubi_debugfs_exit_devubi_debugfs_init_devubi_debugfs_exitubi_debugfs_initubi_self_check_all_ffubi_dump_mkvol_reqconst ubi_mkvol_reqconst ubi_mkvol_req *ubi_mkvol_req *ubi_dump_aebconst ubi_ainf_pebconst ubi_ainf_peb *ubi_ainf_peb *ubi_dump_avconst ubi_ainf_volumeconst ubi_ainf_volume *ubi_ainf_volume *ubi_dump_vtbl_recordconst ubi_vtbl_recordconst ubi_vtbl_record *ubi_vtbl_record *ubi_dump_vol_infoconst ubi_volumeconst ubi_volume *ubi_volume *ubi_dump_vid_hdrconst ubi_vid_hdrconst ubi_vid_hdr *ubi_vid_hdr *ubi_dump_ec_hdrconst ubi_ec_hdrconst ubi_ec_hdr *ubi_ec_hdr *ubi_dump_flashdbg_bld(fmt,__VA_ARGS__...)ubi_dbg_msg("bld", fmt, ## __VA_ARGS__)dbg_io(fmt,__VA_ARGS__...)ubi_dbg_msg("io", fmt, ## __VA_ARGS__)dbg_wl(fmt,__VA_ARGS__...)ubi_dbg_msg("wl", fmt, ## __VA_ARGS__)dbg_eba(fmt,__VA_ARGS__...)ubi_dbg_msg("eba", fmt, ## __VA_ARGS__)dbg_gen(fmt,__VA_ARGS__...)ubi_dbg_msg("gen", fmt, ## __VA_ARGS__)ubi_dbg_msg(type,fmt,__VA_ARGS__...)pr_debug("UBI DBG " type " (pid %d): " fmt "\n", current->pid, ## __VA_ARGS__)ubi_dbg_print_hex_dump(ps,pt,r,g,b,len,a)print_hex_dump(ps, pt, r, g, b, len, a)ubi_assert(expr)do { if (unlikely(!(expr))) { pr_debug("UBI assert failed in %s at %u\n", __func__, __LINE__); dump_stack(); } } while (0)__UBI_DEBUG_H__/* !__UBI_DEBUG_H__ *//**
 * ubi_dbg_is_erase_failure - if its time to emulate an erase failure.
 * @ubi: UBI device description object
 *
 * Returns non-zero if an erase failure should be emulated, otherwise returns
 * zero.
 *//**
 * ubi_dbg_is_write_failure - if it is time to emulate a write failure.
 * @ubi: UBI device description object
 *
 * Returns non-zero if a write failure should be emulated, otherwise returns
 * zero.
 *//**
 * ubi_dbg_is_bitflip - if it is time to emulate a bit-flip.
 * @ubi: UBI device description object
 *
 * Returns non-zero if a bit-flip should be emulated, otherwise returns zero.
 *//**
 * ubi_dbg_is_bgt_disabled - if the background thread is disabled.
 * @ubi: UBI device description object
 *
 * Returns non-zero if the UBI background thread is disabled for testing
 * purposes.
 *//* Initialization and build messages *//* Messages from the input/output sub-system *//* Messages from the wear-leveling sub-system *//* Messages from the eraseblock association sub-system *//* General debugging messages */aebvolvid_hdrec_hdr/opt/src/drivers/mtd/ubi/ubi.hubi_do_workeridx2vol_id2147479551vol_id2idxubi_ro_mode"switch to read-only mode"UBI_NAME_STR "%d warning: %s: " "switch to read-only mode" "\n""ubi" "%d warning: %s: " "switch to read-only mode" "\n"ubi->ubi_num, __func__ubi_warn(ubi, "switch to read-only mode")pr_fmt("ubi" "%d warning: %s: " "switch to read-only mode" "\n")ubi%d warning: %s: switch to read-only mode
dump_stack()ubi_io_write_dataoffset >= 0ubi_assert(offset >= 0)!(offset >= 0)"UBI assert failed in %s at %u\n"__func__, __LINE__pr_fmt("UBI assert failed in %s at %u\n")UBI assert failed in %s at %u
ubi_io_read_data1065ubi_free_vid_hdrubi_zalloc_vid_hdrubi_move_aeb_to_listubiblock_removeubiblock_createubiblock_exitubiblock_initubi_update_fastmapubi_compare_lebsubi_do_get_volume_infoubi_do_get_device_infoubi_free_internal_volumesubi_enumerate_volumesnotifier_block *ubi_notify_allubi_volume_notifyubi_major2numubi_get_by_majorubi_put_deviceubi_get_deviceubi_detach_mtd_devubi_attach_mtd_devubi_io_write_vid_hdrubi_io_read_vid_hdrubi_io_write_ec_hdrubi_io_read_ec_hdrubi_io_mark_badubi_io_is_badubi_io_sync_eraseubi_io_writeubi_io_readubi_ensure_anchor_pebsubi_refill_poolsubi_is_erase_workubi_work *ubi_wl_put_fm_pebubi_wl_entry *ubi_wl_get_fm_pebubi_threadubi_wl_closeubi_wl_initubi_attach_info *ubi_wl_scrub_pebubi_wl_flushubi_wl_put_pebubi_wl_get_pebself_check_ebaubi_next_sqnumubi_eba_initubi_eba_copy_lebubi_eba_atomic_leb_changeubi_eba_write_leb_stubi_eba_write_lebubi_eba_read_leb_sgubi_eba_read_lebubi_eba_unmap_lebubi_destroy_gluebiubi_check_patternubi_calculate_reservedubi_update_reservedubi_check_volumeubi_calc_data_lenubi_more_leb_change_dataubi_start_leb_changeconst ubi_leb_change_reqconst ubi_leb_change_req *ubi_leb_change_req *ubi_more_update_dataubi_start_updateubi_free_volumeubi_add_volumeubi_rename_volumesubi_resize_volumeubi_remove_volumeubi_create_volumeubi_read_volume_tableubi_vtbl_rename_volumesubi_change_vtbl_recordubi_destroy_aiubi_attachubi_early_get_pebubi_remove_avubi_find_avconst ubi_attach_infoconst ubi_attach_info *ubi_add_to_avblocking_notifier_headfile_operationsubi_workubi_attach_infoubi_ainf_volumeubi_ainf_pebubi_rename_entryubi_volumeubi_deviceubi_debug_infotask_structubi_fm_poolubi_fastmap_layoutubi_ltree_entryubi_wl_entryPOWER_CUT_EC_WRITEPOWER_CUT_VID_WRITEUBI_NO_FASTMAPUBI_BAD_FASTMAPMOVE_CANCEL_RACEMOVE_SOURCE_RD_ERRMOVE_TARGET_RD_ERRMOVE_TARGET_WR_ERRMOVE_TARGET_BITFLIPSMOVE_RETRYUBI_IO_FFUBI_IO_FF_BITFLIPSUBI_IO_BAD_HDRUBI_IO_BAD_HDR_EBADMSGUBI_IO_BITFLIPStortureaeb_slab_cacheec_countec_summean_ecmax_sqnummax_ecmin_ecis_emptyhighest_vol_idvols_foundmaybe_bad_peb_countalien_peb_countempty_peb_countcorr_peb_countaliencorrvolumesrblast_data_sizeleb_counthighest_lnum"debug.h"<mtd/ubi-user.h>"ubi-media.h"<linux/mtd/ubi.h><ubi_uboot.h>direct_writeschanging_lebupdatingcheckedeba_tblupd_bufupd_receivedupd_bytesch_lnumupd_ebsUBI_VOL_NAME_MAX + 1metaonlyexclusivewritersreadersref_countdbgdentry *dfs_power_cut_maxdfs_power_cut_mindfs_emulate_power_cutdfs_emulate_io_failuresdfs_emulate_bitflipsdfs_disable_bgtdfs_chk_fastmapdfs_chk_iodfs_chk_gendfs_dirUBI_DFS_DIR_LENUBI_DFS_DIR_LEN + 1dfs_dir_namepower_cut_maxpower_cut_minpower_cut_counteremulate_power_cutemulate_io_failuresemulate_bitflipsdisable_bgtchk_fastmapchk_iochk_genckvol_mutexbuf_mutexpeb_bufnor_flashbad_allowedvid_hdr_shiftvid_hdr_aloffsetvid_hdr_alsizeec_hdr_alsizehdrs_min_io_sizemax_erroneouserroneous_peb_countgood_peb_countpeb_sizepeb_countubi_bgt%ddUBI_BGT_NAME_PATTERNUBI_BGT_NAME_PATTERN)sizeof(UBI_BGT_NAME_PATTERN)sizeof(UBI_BGT_NAME_PATTERN)+2bgt_namethread_enabledtask_struct *bgt_threadworks_countworksmove_to_putmove_tomove_fromubi_wl_entry **lookuptblwl_scheduledwork_semmove_mutexwl_lockpq_headlist_head[10]UBI_PROT_QUEUE_LENpqfree_counterroneousfm_work_scheduledfm_sizefm_buffm_protectfm_eba_semfm_wl_poolfm_poolint[256]ubi_fastmap_layout *fmmax_wl_pool_sizemax_pool_sizeint[32]to_be_torturedubi_wl_entry *[32]fm_disabledalc_mutexltreeltree_lockglobal_sqnumdevice_mutexvtblvtbl_sizevtbl_slotsautoresize_vol_idbad_peb_limitbeb_rsvd_levelbeb_rsvd_pebsavail_pebsrsvd_pebsvolumes_lockubi_volume *[129]UBI_MAX_VOLUMES+UBI_INT_VOL_COUNTUBI_NAME_STRUBI_NAME_STR)sizeof(UBI_NAME_STR)sizeof(UBI_NAME_STR)+5ubi_namenew_namenew_name_lenusersconst file_operationsubi_rb_for_each_entry(rb,pos,root,member)for (rb = rb_first(root), pos = (rb ? container_of(rb, typeof(*pos), member) : NULL); rb; rb = rb_next(rb), pos = (rb ? container_of(rb, typeof(*pos), member) : NULL))ubi_for_each_protected_peb(ubi,i,e)for ((i) = 0; (i) < UBI_PROT_QUEUE_LEN; (i)++) list_for_each_entry((e), &(ubi->pq[(i)]), u.list)ubi_for_each_scrub_peb(ubi,e,tmp_rb)ubi_rb_for_each_entry((tmp_rb), (e), &(ubi)->scrub, u.rb)ubi_for_each_used_peb(ubi,e,tmp_rb)ubi_rb_for_each_entry((tmp_rb), (e), &(ubi)->used, u.rb)ubi_for_each_free_peb(ubi,e,tmp_rb)ubi_rb_for_each_entry((tmp_rb), (e), &(ubi)->free, u.rb)ubi_gluebi_updated(vol)ubi_create_gluebi(ubi,vol)(3 + 2 + 1)UBI_DFS_DIR_NAME"ubi%d"UBI_UNKNOWNUBI_IO_RETRIESUBI_LEB_UNMAPPED"ubi_bgt%dd"ubi_err(ubi,fmt,__VA_ARGS__...)pr_err(UBI_NAME_STR "%d error: %s: " fmt "\n", ubi->ubi_num, __func__, ## __VA_ARGS__)ubi_warn(ubi,fmt,__VA_ARGS__...)pr_warn(UBI_NAME_STR "%d warning: %s: " fmt "\n", ubi->ubi_num, __func__, ## __VA_ARGS__)ubi_msg(ubi,fmt,__VA_ARGS__...)printk(UBI_NAME_STR "%d: " fmt "\n", ubi->ubi_num, ## __VA_ARGS__)"ubi"UBI_MAX_DEVICES__UBI_UBI_H__CONFIG_UBI_SILENCE_MSGCONFIG_MTD_UBI_GLUEBICONFIG_MTD_UBI_FASTMAPCONFIG_MTD_UBI_BLOCKubi_notifiersubi_devices_mutexubi_classubi_vol_cdev_operationsubi_cdev_operationsubi_ctrl_cdev_operationsubi_wl_entry_slab/* !__UBI_UBI_H__ *//**
 * idx2vol_id - get volume ID by table index.
 * @ubi: UBI device description object
 * @idx: table index
 *//**
 * vol_id2idx - get table index by volume ID.
 * @ubi: UBI device description object
 * @vol_id: volume ID
 *//**
 * ubi_ro_mode - switch to read-only mode.
 * @ubi: UBI device description object
 *//*
 * This function is equivalent to 'ubi_io_write()', but @offset is relative to
 * the beginning of the logical eraseblock, not to the beginning of the
 * physical eraseblock.
 *//*
 * This function is equivalent to 'ubi_io_read()', but @offset is relative to
 * the beginning of the logical eraseblock, not to the beginning of the
 * physical eraseblock.
 *//**
 * ubi_free_vid_hdr - free a volume identifier header object.
 * @ubi: UBI device description object
 * @vid_hdr: the object to free
 *//*
	 * VID headers may be stored at un-aligned flash offsets, so we shift
	 * the pointer.
	 *//**
 * ubi_zalloc_vid_hdr - allocate a volume identifier header object.
 * @ubi: UBI device description object
 * @gfp_flags: GFP flags to allocate with
 *
 * This function returns a pointer to the newly allocated and zero-filled
 * volume identifier header object in case of success and %NULL in case of
 * failure.
 *//*
 * ubi_move_aeb_to_list - move a PEB from the volume tree to a list.
 *
 * @av: volume attaching information
 * @aeb: attaching eraseblock information
 * @list: the list to move to
 *//*
 * ubi_rb_for_each_entry - walk an RB-tree.
 * @rb: a pointer to type 'struct rb_node' to use as a loop counter
 * @pos: a pointer to RB-tree entry type to use as a loop counter
 * @root: RB-tree's root
 * @member: the name of the 'struct rb_node' within the RB-tree entry
 *//*
 * ubi_for_each_protected_peb - walk the UBI protection queue.
 * @ubi: UBI device description object
 * @i: a integer used as counter
 * @e: a pointer to a ubi_wl_entry to use as cursor
 *//*
 * ubi_for_each_scub_peb - walk the UBI scub RB tree.
 * @ubi: UBI device description object
 * @e: a pointer to a ubi_wl_entry to use as cursor
 * @pos: a pointer to RB-tree entry type to use as a loop counter
 *//*
 * ubi_for_each_used_peb - walk the UBI used RB tree.
 * @ubi: UBI device description object
 * @e: a pointer to a ubi_wl_entry to use as cursor
 * @pos: a pointer to RB-tree entry type to use as a loop counter
 *//*
 * ubi_for_each_free_peb - walk the UBI free RB tree.
 * @ubi: UBI device description object
 * @e: a pointer to a ubi_wl_entry to use as cursor
 * @pos: a pointer to RB-tree entry type to use as a loop counter
 *//* block.c *//* fastmap.c *//* scan.c *//* kapi.c *//* io.c *//* wl.c *//* eba.c *//* gluebi.c *//* misc.c *//* upd.c *//* vmt.c *//* vtbl.c *//* attach.c *//* The below fields are only relevant to erasure works *//**
 * struct ubi_work - UBI work description data structure.
 * @list: a link in the list of pending works
 * @func: worker function
 * @e: physical eraseblock to erase
 * @vol_id: the volume ID on which this erasure is being performed
 * @lnum: the logical eraseblock number
 * @torture: if the physical eraseblock has to be tortured
 * @anchor: produce a anchor PEB to by used by fastmap
 *
 * The @func pointer points to the worker function. If the @shutdown argument is
 * not zero, the worker has to free the resources and exit immediately as the
 * WL sub-system is shutting down.
 * The worker has to return zero in case of success and a negative error code in
 * case of failure.
 *//**
 * struct ubi_attach_info - MTD device attaching information.
 * @volumes: root of the volume RB-tree
 * @corr: list of corrupted physical eraseblocks
 * @free: list of free physical eraseblocks
 * @erase: list of physical eraseblocks which have to be erased
 * @alien: list of physical eraseblocks which should not be used by UBI (e.g.,
 *         those belonging to "preserve"-compatible internal volumes)
 * @corr_peb_count: count of PEBs in the @corr list
 * @empty_peb_count: count of PEBs which are presumably empty (contain only
 *                   0xFF bytes)
 * @alien_peb_count: count of PEBs in the @alien list
 * @bad_peb_count: count of bad physical eraseblocks
 * @maybe_bad_peb_count: count of bad physical eraseblocks which are not marked
 *                       as bad yet, but which look like bad
 * @vols_found: number of volumes found
 * @highest_vol_id: highest volume ID
 * @is_empty: flag indicating whether the MTD device is empty or not
 * @min_ec: lowest erase counter value
 * @max_ec: highest erase counter value
 * @max_sqnum: highest sequence number value
 * @mean_ec: mean erase counter value
 * @ec_sum: a temporary variable used when calculating @mean_ec
 * @ec_count: a temporary variable used when calculating @mean_ec
 * @aeb_slab_cache: slab cache for &struct ubi_ainf_peb objects
 *
 * This data structure contains the result of attaching an MTD device and may
 * be used by other UBI sub-systems to build final UBI data structures, further
 * error-recovery and so on.
 *//**
 * struct ubi_ainf_volume - attaching information about a volume.
 * @vol_id: volume ID
 * @highest_lnum: highest logical eraseblock number in this volume
 * @leb_count: number of logical eraseblocks in this volume
 * @vol_type: volume type
 * @used_ebs: number of used logical eraseblocks in this volume (only for
 *            static volumes)
 * @last_data_size: amount of data in the last logical eraseblock of this
 *                  volume (always equivalent to the usable logical eraseblock
 *                  size in case of dynamic volumes)
 * @data_pad: how many bytes at the end of logical eraseblocks of this volume
 *            are not used (due to volume alignment)
 * @compat: compatibility flags of this volume
 * @rb: link in the volume RB-tree
 * @root: root of the RB-tree containing all the eraseblock belonging to this
 *        volume (&struct ubi_ainf_peb objects)
 *
 * One object of this type is allocated for each volume when attaching an MTD
 * device.
 *//**
 * struct ubi_ainf_peb - attach information about a physical eraseblock.
 * @ec: erase counter (%UBI_UNKNOWN if it is unknown)
 * @pnum: physical eraseblock number
 * @vol_id: ID of the volume this LEB belongs to
 * @lnum: logical eraseblock number
 * @scrub: if this physical eraseblock needs scrubbing
 * @copy_flag: this LEB is a copy (@copy_flag is set in VID header of this LEB)
 * @sqnum: sequence number
 * @u: unions RB-tree or @list links
 * @u.rb: link in the per-volume RB-tree of &struct ubi_ainf_peb objects
 * @u.list: link in one of the eraseblock lists
 *
 * One object of this type is allocated for each physical eraseblock when
 * attaching an MTD device. Note, if this PEB does not belong to any LEB /
 * volume, the @vol_id and @lnum fields are initialized to %UBI_UNKNOWN.
 *//* I/O sub-system's stuff *//* Wear-leveling sub-system's stuff *//* Fastmap stuff *//* EBA sub-system's stuff *//* Note, mean_ec is not updated run-time - should be fixed *//**
 * struct ubi_device - UBI device description structure
 * @dev: UBI device object to use the the Linux device model
 * @cdev: character device object to create character device
 * @ubi_num: UBI device number
 * @ubi_name: UBI device name
 * @vol_count: number of volumes in this UBI device
 * @volumes: volumes of this UBI device
 * @volumes_lock: protects @volumes, @rsvd_pebs, @avail_pebs, beb_rsvd_pebs,
 *                @beb_rsvd_level, @bad_peb_count, @good_peb_count, @vol_count,
 *                @vol->readers, @vol->writers, @vol->exclusive,
 *                @vol->metaonly, @vol->ref_count, @vol->mapping and
 *                @vol->eba_tbl.
 * @ref_count: count of references on the UBI device
 * @image_seq: image sequence number recorded on EC headers
 *
 * @rsvd_pebs: count of reserved physical eraseblocks
 * @avail_pebs: count of available physical eraseblocks
 * @beb_rsvd_pebs: how many physical eraseblocks are reserved for bad PEB
 *                 handling
 * @beb_rsvd_level: normal level of PEBs reserved for bad PEB handling
 *
 * @autoresize_vol_id: ID of the volume which has to be auto-resized at the end
 *                     of UBI initialization
 * @vtbl_slots: how many slots are available in the volume table
 * @vtbl_size: size of the volume table in bytes
 * @vtbl: in-RAM volume table copy
 * @device_mutex: protects on-flash volume table and serializes volume
 *                creation, deletion, update, re-size, re-name and set
 *                property
 *
 * @max_ec: current highest erase counter value
 * @mean_ec: current mean erase counter value
 *
 * @global_sqnum: global sequence number
 * @ltree_lock: protects the lock tree and @global_sqnum
 * @ltree: the lock tree
 * @alc_mutex: serializes "atomic LEB change" operations
 *
 * @fm_disabled: non-zero if fastmap is disabled (default)
 * @fm: in-memory data structure of the currently used fastmap
 * @fm_pool: in-memory data structure of the fastmap pool
 * @fm_wl_pool: in-memory data structure of the fastmap pool used by the WL
 *		sub-system
 * @fm_protect: serializes ubi_update_fastmap(), protects @fm_buf and makes sure
 * that critical sections cannot be interrupted by ubi_update_fastmap()
 * @fm_buf: vmalloc()'d buffer which holds the raw fastmap
 * @fm_size: fastmap size in bytes
 * @fm_eba_sem: allows ubi_update_fastmap() to block EBA table changes
 * @fm_work: fastmap work queue
 * @fm_work_scheduled: non-zero if fastmap work was scheduled
 *
 * @used: RB-tree of used physical eraseblocks
 * @erroneous: RB-tree of erroneous used physical eraseblocks
 * @free: RB-tree of free physical eraseblocks
 * @free_count: Contains the number of elements in @free
 * @scrub: RB-tree of physical eraseblocks which need scrubbing
 * @pq: protection queue (contain physical eraseblocks which are temporarily
 *      protected from the wear-leveling worker)
 * @pq_head: protection queue head
 * @wl_lock: protects the @used, @free, @pq, @pq_head, @lookuptbl, @move_from,
 *	     @move_to, @move_to_put @erase_pending, @wl_scheduled, @works,
 *	     @erroneous, @erroneous_peb_count, @fm_work_scheduled, @fm_pool,
 *	     and @fm_wl_pool fields
 * @move_mutex: serializes eraseblock moves
 * @work_sem: used to wait for all the scheduled works to finish and prevent
 * new works from being submitted
 * @wl_scheduled: non-zero if the wear-leveling was scheduled
 * @lookuptbl: a table to quickly find a &struct ubi_wl_entry object for any
 *             physical eraseblock
 * @move_from: physical eraseblock from where the data is being moved
 * @move_to: physical eraseblock where the data is being moved to
 * @move_to_put: if the "to" PEB was put
 * @works: list of pending works
 * @works_count: count of pending works
 * @bgt_thread: background thread description object
 * @thread_enabled: if the background thread is enabled
 * @bgt_name: background thread name
 *
 * @flash_size: underlying MTD device size (in bytes)
 * @peb_count: count of physical eraseblocks on the MTD device
 * @peb_size: physical eraseblock size
 * @bad_peb_limit: top limit of expected bad physical eraseblocks
 * @bad_peb_count: count of bad physical eraseblocks
 * @good_peb_count: count of good physical eraseblocks
 * @corr_peb_count: count of corrupted physical eraseblocks (preserved and not
 *                  used by UBI)
 * @erroneous_peb_count: count of erroneous physical eraseblocks in @erroneous
 * @max_erroneous: maximum allowed amount of erroneous physical eraseblocks
 * @min_io_size: minimal input/output unit size of the underlying MTD device
 * @hdrs_min_io_size: minimal I/O unit size used for VID and EC headers
 * @ro_mode: if the UBI device is in read-only mode
 * @leb_size: logical eraseblock size
 * @leb_start: starting offset of logical eraseblocks within physical
 *             eraseblocks
 * @ec_hdr_alsize: size of the EC header aligned to @hdrs_min_io_size
 * @vid_hdr_alsize: size of the VID header aligned to @hdrs_min_io_size
 * @vid_hdr_offset: starting offset of the volume identifier header (might be
 *                  unaligned)
 * @vid_hdr_aloffset: starting offset of the VID header aligned to
 *                    @hdrs_min_io_size
 * @vid_hdr_shift: contains @vid_hdr_offset - @vid_hdr_aloffset
 * @bad_allowed: whether the MTD device admits of bad physical eraseblocks or
 *               not
 * @nor_flash: non-zero if working on top of NOR flash
 * @max_write_size: maximum amount of bytes the underlying flash can write at a
 *                  time (MTD write buffer size)
 * @mtd: MTD device descriptor
 *
 * @peb_buf: a buffer of PEB size used for different purposes
 * @buf_mutex: protects @peb_buf
 * @ckvol_mutex: serializes static volume checking when opening
 *
 * @dbg: debugging information for this UBI device
 *//**
 * struct ubi_debug_info - debugging information for an UBI device.
 *
 * @chk_gen: if UBI general extra checks are enabled
 * @chk_io: if UBI I/O extra checks are enabled
 * @chk_fastmap: if UBI fastmap extra checks are enabled
 * @disable_bgt: disable the background task for testing purposes
 * @emulate_bitflips: emulate bit-flips for testing purposes
 * @emulate_io_failures: emulate write/erase failures for testing purposes
 * @emulate_power_cut: emulate power cut for testing purposes
 * @power_cut_counter: count down for writes left until emulated power cut
 * @power_cut_min: minimum number of writes before emulating a power cut
 * @power_cut_max: maximum number of writes until emulating a power cut
 * @dfs_dir_name: name of debugfs directory containing files of this UBI device
 * @dfs_dir: direntry object of the UBI device debugfs directory
 * @dfs_chk_gen: debugfs knob to enable UBI general extra checks
 * @dfs_chk_io: debugfs knob to enable UBI I/O extra checks
 * @dfs_chk_fastmap: debugfs knob to enable UBI fastmap extra checks
 * @dfs_disable_bgt: debugfs knob to disable the background task
 * @dfs_emulate_bitflips: debugfs knob to emulate bit-flips
 * @dfs_emulate_io_failures: debugfs knob to emulate write/erase failures
 * @dfs_emulate_power_cut: debugfs knob to emulate power cuts
 * @dfs_power_cut_min: debugfs knob for minimum writes before power cut
 * @dfs_power_cut_max: debugfs knob for maximum writes until power cut
 *//**
 * struct ubi_volume_desc - UBI volume descriptor returned when it is opened.
 * @vol: reference to the corresponding volume description object
 * @mode: open mode (%UBI_READONLY, %UBI_READWRITE, %UBI_EXCLUSIVE
 * or %UBI_METAONLY)
 *//**
 * struct ubi_volume - UBI volume description data structure.
 * @dev: device object to make use of the the Linux device model
 * @cdev: character device object to create character device
 * @ubi: reference to the UBI device description object
 * @vol_id: volume ID
 * @ref_count: volume reference count
 * @readers: number of users holding this volume in read-only mode
 * @writers: number of users holding this volume in read-write mode
 * @exclusive: whether somebody holds this volume in exclusive mode
 * @metaonly: whether somebody is altering only meta data of this volume
 *
 * @reserved_pebs: how many physical eraseblocks are reserved for this volume
 * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)
 * @usable_leb_size: logical eraseblock size without padding
 * @used_ebs: how many logical eraseblocks in this volume contain data
 * @last_eb_bytes: how many bytes are stored in the last logical eraseblock
 * @used_bytes: how many bytes of data this volume contains
 * @alignment: volume alignment
 * @data_pad: how many bytes are not used at the end of physical eraseblocks to
 *            satisfy the requested alignment
 * @name_len: volume name length
 * @name: volume name
 *
 * @upd_ebs: how many eraseblocks are expected to be updated
 * @ch_lnum: LEB number which is being changing by the atomic LEB change
 *           operation
 * @upd_bytes: how many bytes are expected to be received for volume update or
 *             atomic LEB change
 * @upd_received: how many bytes were already received for volume update or
 *                atomic LEB change
 * @upd_buf: update buffer which is used to collect update data or data for
 *           atomic LEB change
 *
 * @eba_tbl: EBA table of this volume (LEB->PEB mapping)
 * @checked: %1 if this static volume was checked
 * @corrupted: %1 if the volume is corrupted (static volumes only)
 * @upd_marker: %1 if the update marker is set for this volume
 * @updating: %1 if the volume is being updated
 * @changing_leb: %1 if the atomic LEB change ioctl command is in progress
 * @direct_writes: %1 if direct writes are enabled for this volume
 *
 * The @corrupted field indicates that the volume's contents is corrupted.
 * Since UBI protects only static volumes, this field is not relevant to
 * dynamic volumes - it is user's responsibility to assure their data
 * integrity.
 *
 * The @upd_marker flag indicates that this volume is either being updated at
 * the moment or is damaged because of an unclean reboot.
 *//**
 * struct ubi_fm_pool - in-memory fastmap pool
 * @pebs: PEBs in this pool
 * @used: number of used PEBs
 * @size: total number of PEBs in this pool
 * @max_size: maximal size of the pool
 *
 * A pool gets filled with up to max_size.
 * If all PEBs within the pool are used a new fastmap will be written
 * to the flash and the pool gets refilled with empty PEBs.
 *
 *//**
 * struct ubi_fastmap_layout - in-memory fastmap data structure.
 * @e: PEBs used by the current fastmap
 * @to_be_tortured: if non-zero tortured this PEB
 * @used_blocks: number of used PEBs
 * @max_pool_size: maximal size of the user pool
 * @max_wl_pool_size: maximal size of the pool used by the WL sub-system
 *//**
 * struct ubi_rename_entry - volume re-name description data structure.
 * @new_name_len: new volume name length
 * @new_name: new volume name
 * @remove: if not zero, this volume should be removed, not re-named
 * @desc: descriptor of the volume
 * @list: links re-name entries into a list
 *
 * This data structure is utilized in the multiple volume re-name code. Namely,
 * UBI first creates a list of &struct ubi_rename_entry objects from the
 * &struct ubi_rnvol_req request object, and then utilizes this list to do all
 * the job.
 *//**
 * struct ubi_ltree_entry - an entry in the lock tree.
 * @rb: links RB-tree nodes
 * @vol_id: volume ID of the locked logical eraseblock
 * @lnum: locked logical eraseblock number
 * @users: how many tasks are using this logical eraseblock or wait for it
 * @mutex: read/write mutex to implement read/write access serialization to
 *         the (@vol_id, @lnum) logical eraseblock
 *
 * This data structure is used in the EBA sub-system to implement per-LEB
 * locking. When a logical eraseblock is being locked - corresponding
 * &struct ubi_ltree_entry object is inserted to the lock tree (@ubi->ltree).
 * See EBA sub-system for details.
 *//**
 * struct ubi_wl_entry - wear-leveling entry.
 * @u.rb: link in the corresponding (free/used) RB-tree
 * @u.list: link in the protection queue
 * @ec: erase counter
 * @pnum: physical eraseblock number
 *
 * This data structure is used in the WL sub-system. Each physical eraseblock
 * has a corresponding &struct wl_entry object which may be kept in different
 * RB-trees. See WL sub-system for details.
 *//*
 * Flags for emulate_power_cut in ubi_debug_info
 *
 * POWER_CUT_EC_WRITE: Emulate a power cut when writing an EC header
 * POWER_CUT_VID_WRITE: Emulate a power cut when writing a VID header
 *//*
 * Return codes of the fastmap sub-system
 *
 * UBI_NO_FASTMAP: No fastmap super block was found
 * UBI_BAD_FASTMAP: A fastmap was found but it's unusable
 *//*
 * Return codes of the 'ubi_eba_copy_leb()' function.
 *
 * MOVE_CANCEL_RACE: canceled because the volume is being deleted, the source
 *                   PEB was put meanwhile, or there is I/O on the source PEB
 * MOVE_SOURCE_RD_ERR: canceled because there was a read error from the source
 *                     PEB
 * MOVE_TARGET_RD_ERR: canceled because there was a read error from the target
 *                     PEB
 * MOVE_TARGET_WR_ERR: canceled because there was a write error to the target
 *                     PEB
 * MOVE_TARGET_BITFLIPS: canceled because a bit-flip was detected in the
 *                       target PEB
 * MOVE_RETRY: retry scrubbing the PEB
 *//*
 * Error codes returned by the I/O sub-system.
 *
 * UBI_IO_FF: the read region of flash contains only 0xFFs
 * UBI_IO_FF_BITFLIPS: the same as %UBI_IO_FF, but also also there was a data
 *                     integrity error reported by the MTD driver
 *                     (uncorrectable ECC error in case of NAND)
 * UBI_IO_BAD_HDR: the EC or VID header is corrupted (bad magic or CRC)
 * UBI_IO_BAD_HDR_EBADMSG: the same as %UBI_IO_BAD_HDR, but also there was a
 *                         data integrity error reported by the MTD driver
 *                         (uncorrectable ECC error in case of NAND)
 * UBI_IO_BITFLIPS: bit-flips were detected and corrected
 *
 * Note, it is probably better to have bit-flip and ebadmsg as flags which can
 * be or'ed with other error code. But this is a big change because there are
 * may callers, so it does not worth the risk of introducing a bug
 *//*
 * The UBI debugfs directory name pattern and maximum name length (3 for "ubi"
 * + 2 for the number plus 1 for the trailing zero byte.
 *//* The volume ID/LEB number/erase counter is unknown *//*
 * Length of the protection queue. The length is effectively equivalent to the
 * number of (global) erase cycles PEBs are protected from the wear-leveling
 * worker.
 *//*
 * In case of errors, UBI tries to repeat the operation several times before
 * returning error. The below constant defines how many times UBI re-tries.
 *//*
 * This marker in the EBA table means that the LEB is um-mapped.
 * NOTE! It has to have the same value as %UBI_ALL.
 *//* Background thread name pattern *//* UBI error messages *//* UBI warning messages *//* Normal UBI messages *//* UBI name used for character devices, sysfs, etc *//* Maximum number of supported UBI devices *//*
 * Copyright (c) International Business Machines Corp., 2006
 * Copyright (c) Nokia Corporation, 2006, 2007
 *
 * Author: Artem Bityutskiy ( )
 */ntypeanywaywrkused_eaiai_fastmapai_scanpattrename_listno_vtblvtbl_recforce_scanbitflipscmd_ubifs_umountcmd_ubifs_mountubi_volume_readubi_volume_writeubi_partubi_exitubi_initubi_mtd_param_parsekernel_param *ubi_device *[]ubi_sysfs_close(__VA_ARGS__...)ubi_sysfs_init(__VA_ARGS__...)put_device(__VA_ARGS__...)get_device(__VA_ARGS__...)CONFIG_MTD_UBI_MODULECONFIG_MTD_UBI_DEBUG_MSG_BLDCONFIG_MTD_UBI_DEBUG_MSG_IOCONFIG_MTD_UBI_DEBUG_MSG_WLCONFIG_MTD_UBI_DEBUG_MSG_EBACONFIG_MTD_UBI_DEBUG_MSGCONFIG_MTD_UBI_DEBUG_PARANOIDCONFIG_MTD_UBI_DEBUGCONFIG_MTD_UBI_BEB_RESERVEubi_devices"../drivers/mtd/ubi/ubi.h"<linux/rbtree.h><linux/crc32.h>vid_header_offsetkpmtd_free_parsed_partitionsmtd_parse_partitionsmtd_partition **mtd_get_device_sizemtd_del_partitionmtd_add_partitionMTDPART_SIZ_FULLMTDPART_OFS_APPENDMTDPART_OFS_NXTBLKMTDPART_OFS_RETAINMTD_PARTITIONS_H/* defined(MTD_PARTITIONS) *//*
 * Functions dealing with the various ways of partitioning the space
 *//**
 * struct mtd_part_parser_data - used to pass data to MTD partition parsers.
 * @origin: for RedBoot, start address of MTD device
 * @of_node: for OF parsers, device node containing partitioning information
 *//* out of band layout for this partition (NAND only) *//* master MTD flags to mask out for this partition *//* offset within the master MTD space *//* identifier string *//*
 * Partition definition structure:
 *
 * An array of struct partition is passed along with a MTD object to
 * mtd_device_register() to create them.
 *
 * For each partition, these fields are available:
 * name: string that will be used to label the partition's MTD device.
 * size: the partition size; if defined as MTDPART_SIZ_FULL, the partition
 * 	will extend to the end of the master MTD device.
 * offset: absolute starting position within the master MTD device; if
 * 	defined as MTDPART_OFS_APPEND, the partition will start where the
 *	previous one ended; if MTDPART_OFS_NXTBLK, at the next erase block;
 *	if MTDPART_OFS_RETAIN, consume as much as possible, leaving size
 *	after the end of partition.
 * mask_flags: contains flags that have to be masked (removed) from the
 * 	master MTD flag set for the corresponding MTD partition.
 * 	For example, to force a read-only partition, simply adding
 * 	MTD_WRITEABLE to the mask_flags will do the trick.
 *
 * Note: writeable partitions require their size and offset be
 * erasesize aligned (e.g. use MTDPART_OFS_NEXTBLK).
 *//*
 * MTD partitioning layer definitions
 *
 * (C) 2000 Nicolas Pitre <nico@fluxnic.net>
 *
 * This code is GPL
 */_mtdparts_parts_npartspartno/opt/src/drivers/mtd/mtdcore.hmtdcorecleanup_mtdcharinit_mtdcharparse_mtd_partitionsmtd_table_mutex/*
 * These are exported solely for the purpose of mtd_blkdevs.c and mtdchar.c.
 * You should not use them for _anything_ else.
 */pparts/opt/src/drivers/mtd/mtdcore.cEROFS-30-EROFSmtd_ooblayout_count_bytesmtd_ooblayout_set_bytes"mtdcore.h"oobregion.lengthmtd_ooblayout_get_bytesmtd_ooblayout_find_regionsizeof(*oobregion)sizeof(*oobfree)sizeof(*oobecc)ret_code < 0unlikely(ret_code < 0)mtd_check_oob_opsmaxooblensectionp18446744073709551521mtd->usecount < 0BUG_ON(mtd->usecount < 0)drivers/mtd/mtdcore.c865mtd->ownermodule_put(mtd->owner)&mtd_table_mutexothermtd_for_each_device(other)try_module_get(mtd->owner)!try_module_get(mtd->owner)out_unlockidr *"Failed to delete MTD partitions attached to %s (err %d)\n"mtd->name, retdebug("Failed to delete MTD partitions attached to %s (err %d)\n",
		      mtd->name, ret)534Failed to delete MTD partitions attached to %s (err %d)
KERN_NOTICE "Removing MTD device #%d (%s) with use count %d\n""Removing MTD device #%d (%s) with use count %d\n"mtd->index, mtd->name, mtd->usecountRemoving MTD device #%d (%s) with use count %d
module_put(THIS_MODULE)mtd->writesize == 0BUG_ON(mtd->writesize == 0)KERN_WARNING "%s: unlock failed, writes may not work\n""%s: unlock failed, writes may not work\n"mtd->name%s: unlock failed, writes may not work
"mtd: Giving out device %d to %s\n"i, mtd->namepr_fmt("mtd: Giving out device %d to %s\n")pr_debug("mtd: Giving out device %d to %s\n", i, mtd->name)mtd: Giving out device %d to %s
idr_allocMAX_IDR_IDidr_layer *idlidr_layer[64]idr_get_nextidr_findidr_removeout_errorfail_lockedidpgfp_maskidridr_layerupdatedmtd_idrmtd_info *[32]mtd_tableDEFINE_IDR(name)struct idr name;CONFIG_PROC_FS"Core MTD registration and access routines""David Woodhouse <dwmw2@infradead.org>""GPL"/* Init code *//*====================================================================*//* CONFIG_PROC_FS *//* Support for /proc/mtd *//*
	 * For the last resort allocation allow 'kmalloc()' to do all sorts of
	 * things (write-back, dropping caches, etc) by using GFP_KERNEL.
	 *//**
 * mtd_kmalloc_up_to - allocate a contiguous buffer up to the specified size
 * @mtd: mtd device description object pointer
 * @size: a pointer to the ideal or maximum size of the allocation, points
 *        to the actual allocation size on success.
 *
 * This routine attempts to allocate a contiguous kernel buffer up to
 * the specified size, backing off the size of the request exponentially
 * until the request succeeds or until the allocation size falls below
 * the system page size. This attempts to make sure it does not adversely
 * impact system performance, so when allocating more than one page, we
 * ask the memory allocator to avoid re-trying, swapping, writing back
 * or performing I/O.
 *
 * Note, this function also makes sure that the allocated buffer is aligned to
 * the MTD device's min. I/O unit, i.e. the "mtd->writesize" value.
 *
 * This is called, for example by mtd_{read,write} and jffs2_scan_medium,
 * to handle smaller (i.e. degraded) buffer allocations under low- or
 * fragmented-memory situations where such reduced allocations, from a
 * requested ideal, are allowed.
 *
 * Returns a pointer to the allocated buffer on success; otherwise, NULL.
 *//*
 * mtd_writev - the vector-based MTD write method
 * @mtd: mtd device description object pointer
 * @vecs: the vectors to write
 * @count: count of vectors in @vecs
 * @to: the MTD device offset to write to
 * @retlen: on exit contains the count of bytes written to the MTD device.
 *
 * This function returns zero in case of success and a negative error code in
 * case of failure.
 *//*
 * default_mtd_writev - the default writev method
 * @mtd: mtd device description object pointer
 * @vecs: the vectors to write
 * @count: count of vectors in @vecs
 * @to: the MTD device offset to write to
 * @retlen: on exit contains the count of bytes written to the MTD device.
 *
 * This function returns zero in case of success and a negative error code in
 * case of failure.
 *//* Chip-supported device locking *//*
	 * If no data could be written at all, we are out of memory and
	 * must return -ENOSPC.
	 *//*
 * Method to access the protection register area, present in some flash
 * devices. The user data is one time programmable but the factory data is read
 * only.
 *//**
 * mtd_ooblayout_count_freebytes - count the number of ECC bytes in OOB
 * @mtd: mtd info structure
 *
 * Works like mtd_ooblayout_count_bytes(), except it count ECC bytes.
 *
 * Returns zero on success, a negative error code otherwise.
 *//**
 * mtd_ooblayout_count_freebytes - count the number of free bytes in OOB
 * @mtd: mtd info structure
 *
 * Works like mtd_ooblayout_count_bytes(), except it count free bytes.
 *
 * Returns zero on success, a negative error code otherwise.
 *//**
 * mtd_ooblayout_get_eccbytes - set data bytes into the oob buffer
 * @mtd: mtd info structure
 * @eccbuf: source buffer to get data bytes from
 * @oobbuf: OOB buffer
 * @start: first ECC byte to set
 * @nbytes: number of ECC bytes to set
 *
 * Works like mtd_ooblayout_get_bytes(), except it acts on free bytes.
 *
 * Returns zero on success, a negative error code otherwise.
 *//**
 * mtd_ooblayout_get_databytes - extract data bytes from the oob buffer
 * @mtd: mtd info structure
 * @databuf: destination buffer to store ECC bytes
 * @oobbuf: OOB buffer
 * @start: first ECC byte to retrieve
 * @nbytes: number of ECC bytes to retrieve
 *
 * Works like mtd_ooblayout_get_bytes(), except it acts on free bytes.
 *
 * Returns zero on success, a negative error code otherwise.
 *//**
 * mtd_ooblayout_set_eccbytes - set ECC bytes into the oob buffer
 * @mtd: mtd info structure
 * @eccbuf: source buffer to get ECC bytes from
 * @oobbuf: OOB buffer
 * @start: first ECC byte to set
 * @nbytes: number of ECC bytes to set
 *
 * Works like mtd_ooblayout_set_bytes(), except it acts on ECC bytes.
 *
 * Returns zero on success, a negative error code otherwise.
 *//**
 * mtd_ooblayout_get_eccbytes - extract ECC bytes from the oob buffer
 * @mtd: mtd info structure
 * @eccbuf: destination buffer to store ECC bytes
 * @oobbuf: OOB buffer
 * @start: first ECC byte to retrieve
 * @nbytes: number of ECC bytes to retrieve
 *
 * Works like mtd_ooblayout_get_bytes(), except it acts on ECC bytes.
 *
 * Returns zero on success, a negative error code otherwise.
 *//**
 * mtd_ooblayout_count_bytes - count the number of bytes in a OOB category
 * @mtd: mtd info structure
 * @iter: category iterator
 *
 * Count the number of bytes in a given category.
 *
 * Returns a positive value on success, a negative error code otherwise.
 *//**
 * mtd_ooblayout_set_bytes - put OOB bytes into the oob buffer
 * @mtd: mtd info structure
 * @buf: source buffer to get OOB bytes from
 * @oobbuf: OOB buffer
 * @start: first OOB byte to set
 * @nbytes: number of OOB bytes to set
 * @iter: section iterator
 *
 * Fill the OOB buffer with data provided in buf. The category (ECC or free)
 * is selected by passing the appropriate iterator.
 *
 * Returns zero on success, a negative error code otherwise.
 *//**
 * mtd_ooblayout_get_bytes - Extract OOB bytes from the oob buffer
 * @mtd: mtd info structure
 * @buf: destination buffer to store OOB bytes
 * @oobbuf: OOB buffer
 * @start: first byte to retrieve
 * @nbytes: number of bytes to retrieve
 * @iter: section iterator
 *
 * Extract bytes attached to a specific category (ECC or free)
 * from the OOB buffer and copy them into buf.
 *
 * Returns zero on success, a negative error code otherwise.
 *//**
 * mtd_ooblayout_find_eccregion - Find the ECC region attached to a specific
 *				  ECC byte
 * @mtd: mtd info structure
 * @eccbyte: the byte we are searching for
 * @sectionp: pointer where the section id will be stored
 * @oobregion: OOB region information
 *
 * Works like mtd_ooblayout_find_region() except it searches for a specific ECC
 * byte.
 *
 * Returns zero on success, a negative error code otherwise.
 *//*
	 * Adjust region info to make it start at the beginning at the
	 * 'start' ECC byte.
	 *//**
 * mtd_ooblayout_find_region - Find the region attached to a specific byte
 * @mtd: mtd info structure
 * @byte: the byte we are searching for
 * @sectionp: pointer where the section id will be stored
 * @oobregion: used to retrieve the ECC position
 * @iter: iterator function. Should be either mtd_ooblayout_free or
 *	  mtd_ooblayout_ecc depending on the region type you're searching for
 *
 * This function returns the section id and oobregion information of a
 * specific byte. For example, say you want to know where the 4th ECC byte is
 * stored, you'll use:
 *
 * mtd_ooblayout_find_region(mtd, 3, &section, &oobregion, mtd_ooblayout_ecc);
 *
 * Returns zero on success, a negative error code otherwise.
 *//**
 * mtd_ooblayout_free - Get the OOB region definition of a specific free
 *			section
 * @mtd: MTD device structure
 * @section: Free section you are interested in. Depending on the layout
 *	     you may have all the free bytes stored in a single contiguous
 *	     section, or one section per ECC chunk plus an extra section
 *	     for the remaining bytes (or other funky layout).
 * @oobfree: OOB region struct filled with the appropriate free position
 *	     information
 *
 * This function returns free bytes position in the OOB area. If you want
 * to get all the free bytes information, then you should call
 * mtd_ooblayout_free(mtd, section++, oobfree) until it returns -ERANGE.
 *
 * Returns zero on success, a negative error code otherwise.
 *//**
 * mtd_ooblayout_ecc - Get the OOB region definition of a specific ECC section
 * @mtd: MTD device structure
 * @section: ECC section. Depending on the layout you may have all the ECC
 *	     bytes stored in a single contiguous section, or one section
 *	     per ECC chunk (and sometime several sections for a single ECC
 *	     ECC chunk)
 * @oobecc: OOB region struct filled with the appropriate ECC position
 *	    information
 *
 * This function returns ECC section information in the OOB area. If you want
 * to get all the ECC bytes information, then you should call
 * mtd_ooblayout_ecc(mtd, section++, oobecc) until it returns -ERANGE.
 *
 * Returns zero on success, a negative error code otherwise.
 *//* Check the validity of a potential fallback on mtd->_write *//* device lacks ecc *//*
	 * In cases where ops->datbuf != NULL, mtd->_read_oob() has semantics
	 * similar to mtd->_read(), returning a non-negative integer
	 * representing max bitflips. In other cases, mtd->_read_oob() may
	 * return -EUCLEAN. In all cases, perform similar logic to mtd_read().
	 *//* Check the validity of a potential fallback on mtd->_read *//*
	 * Some users are setting ->datbuf or ->oobbuf to NULL, but are leaving
	 * ->len or ->ooblen uninitialized. Force ->len and ->ooblen to 0 in
	 *  this case.
	 *//*
 * In blackbox flight recorder like scenarios we want to make successful writes
 * in interrupt context. panic_write() is only intended to be called when its
 * known the kernel is about to panic and we need the write to succeed. Since
 * the kernel is not going to be running for much longer, this function can
 * break locks and delay to ensure the write succeeds (but not sleep).
 *//*
	 * In the absence of an error, drivers return a non-negative integer
	 * representing the maximum number of bitflips that were corrected on
	 * any one ecc region (if applicable; zero otherwise).
	 *//*
 * Allow NOMMU mmap() to directly map the device (if not NULL)
 * - return the address to which the offset maps
 * - return -ENOSYS to indicate refusal to do the mapping
 *//* We probably shouldn't allow XIP if the unpoint isn't a NULL *//*
 * This stuff for eXecute-In-Place. phys is optional and may be set to NULL.
 *//*
 * Erase is an asynchronous operation.  Device drivers are supposed
 * to call instr->callback() whenever the operation completes, even
 * if it completes with a failure.
 * Callers are supposed to pass a callback function and wait for it
 * to be called before writing to the block.
 *//* defined(CONFIG_CMD_MTDPARTS_SPREAD) *//**
 * mtd_get_len_incl_bad
 *
 * Check if length including bad blocks fits into device.
 *
 * @param mtd an MTD device
 * @param offset offset in flash
 * @param length image length
 * @return image length including bad blocks in *len_incl_bad and whether or not
 *         the length returned was truncated in *truncated
 *//**
 *	get_mtd_device_nm - obtain a validated handle for an MTD device by
 *	device name
 *	@name: MTD device name to open
 *
 * 	This function returns MTD device description structure in case of
 * 	success and an error code in case of failure.
 *//**
 *	get_mtd_device - obtain a validated handle for an MTD device
 *	@mtd: last known address of the required MTD device
 *	@num: internal device number of the required MTD device
 *
 *	Given a number and NULL address, return the num'th entry in the device
 *	table, if any.	Given an address and num == -1, search the device table
 *	for a device with that address and return if it's still present. Given
 *	both, return the num'th driver only if its address matches. Return
 *	error code if not.
 *//**
 *	unregister_mtd_user - unregister a 'user' of MTD devices.
 *	@old: pointer to notifier info structure
 *
 *	Removes a callback function pair from the list of 'users' to be
 *	notified upon addition or removal of MTD devices. Causes the
 *	'remove' callback to be immediately invoked for each MTD device
 *	currently present in the system.
 *//**
 *	register_mtd_user - register a 'user' of MTD devices.
 *	@new: pointer to notifier info structure
 *
 *	Registers a pair of callbacks function to be called upon addition
 *	or removal of MTD devices. Causes the 'add' callback to be immediately
 *	invoked for each MTD device currently present in the system.
 *//**
 * mtd_device_unregister - unregister an existing MTD device.
 *
 * @master: the MTD device to unregister.  This will unregister both the master
 *          and any partitions if registered.
 *//**
 * mtd_device_parse_register - parse partitions and register an MTD device.
 *
 * @mtd: the MTD device to register
 * @types: the list of MTD partition probes to try, see
 *         'parse_mtd_partitions()' for more information
 * @parser_data: MTD partition parser-specific data
 * @parts: fallback partition information to register, if parsing fails;
 *         only valid if %nr_parts > %0
 * @nr_parts: the number of partitions in parts, if zero then the full
 *            MTD device is registered if no partition info is found
 *
 * This function aggregates MTD partitions parsing (done by
 * 'parse_mtd_partitions()') and MTD device and partitions registering. It
 * basically follows the most common pattern found in many MTD drivers:
 *
 * * It first tries to probe partitions on MTD device @mtd using parsers
 *   specified in @types (if @types is %NULL, then the default list of parsers
 *   is used, see 'parse_mtd_partitions()' for more information). If none are
 *   found this functions tries to fallback to information specified in
 *   @parts/@nr_parts.
 * * If any partitioning info was found, this function registers the found
 *   partitions.
 * * If no partitions were found this function just registers the MTD device
 *   @mtd and exits.
 *
 * Returns zero in case of success and a negative error code in case of failure.
 *//* No need to get a refcount on the module containing
		the notifier, since we hold the mtd_table_mutex *//**
 *	del_mtd_device - unregister an MTD device
 *	@mtd: pointer to MTD device info structure
 *
 *	Remove a device from the list of MTD devices present in the system,
 *	and notify each currently active MTD 'user' of its departure.
 *	Returns zero on success or 1 on failure, which currently will happen
 *	if the requested device does not appear to be present in the list.
 *//* We _know_ we aren't being removed, because
	   our caller is still holding us here. So none
	   of this try_ nonsense, and no bitching about it
	   either. :) *//* No need to get a refcount on the module containing
	   the notifier, since we hold the mtd_table_mutex *//* Caller should have set dev.parent to match the
	 * physical device.
	 *//* Some chips always power up locked. Unlock them now *//* default value if not set by driver *//**
 *	add_mtd_device - register an MTD device
 *	@mtd: pointer to new MTD device info structure
 *
 *	Add a device to the list of MTD devices present in the system, and
 *	notify each currently active MTD 'user' of its arrival. Returns
 *	zero on success or 1 on failure, which currently will only happen
 *	if there is insufficient memory or a sysfs error.
 *//* remove /dev/mtdXro node if needed *//* REVISIT once MTD uses the driver model better, whoever allocates
 * the mtd_info will probably want to use the release() hook...
 *//* These are exported solely for the purpose of mtd_blkdevs.c. You
   should not use them for _anything_ else *//*
 * backing device capabilities for writable mappable devices (such as RAM)
 * - permits private mappings, copies are taken of the data
 * - permits non-writable shared mappings
 *//*
 * backing device capabilities for R/O mappable devices (such as ROM)
 * - permits private mappings, copies are taken of the data
 * - permits non-writable shared mappings
 *//*
 * backing device capabilities for non-mappable devices (such as NAND flash)
 * - permits private mappings, copies are taken of the data
 *//*
 * Core registration and callback routines for MTD
 * drivers and users.
 *
 * Copyright  1999-2010 David Woodhouse <dwmw2@infradead.org>
 * Copyright  2006      Red Hat UK Limited 
 *
 */UCLASS_SPI_FLASH/opt/src/arch/sandbox/include/asm/spi.hsandbox_spi_parse_specsandbox_spi_emu_opscs_deactivatecs_activate__ASM_SPI_H__/*
 * Extract the bus/cs from the spi spec and return the start of the spi
 * client spec.  If the bus/cs are invalid for the current config, then
 * it returns NULL.
 *
 * Example: arg="0:1:foo" will set bus to 0, cs to 1, and return "foo"
 *//* The client is rx-ing bytes from the bus, so it should tx some *//* The CS has been "deactivated" -- we won't worry about low/high *//* The CS has been "activated" -- we won't worry about low/high *//* The bus is done with us, so break things down *//* The bus wants to instantiate a new client, so setup everything *//*
 * The interface between the SPI bus and the SPI client.  The bus will
 * instantiate a client, and that then call into it via these entry
 * points.  These should be enough for the client to emulate the SPI
 * device just like the real hardware.
 *//*
 * Simulate a SPI port and clients (see doc/arch/sandbox.rst for details)
 *
 * Copyright (c) 2011-2013 The Chromium OS Authors.
 * See file CREDITS for list of people who contributed to this
 * project.
 *
 * Licensed under the GPL-2 or later.
 *//opt/src/drivers/mtd/spi/sandbox.csandbox_spi_info *"%s: busnum=%u, cs=%u: binding SPI flash emulation: "__func__, busnum, csdebug("%s: busnum=%u, cs=%u: binding SPI flash emulation: ",
		      __func__, busnum, cs)drivers/mtd/spi/sandbox.c%s: busnum=%u, cs=%u: binding SPI flash emulation: "failed (err=%d)\n"debug("failed (err=%d)\n", ret)581failed (err=%d)
debug("OK\n")sizeof(name) - 6-emul"-emul"sandbox_sf_emul"sandbox_sf_emul"Cannot find sandbox_sf_emul driver
"Cannot find sandbox_sf_emul driver\n"Cannot create emul device for spec '%s' (err=%d)
"Cannot create emul device for spec '%s' (err=%d)\n"/opt/src/drivers/mtd/spi/sf_internal.h/opt/src/drivers/mtd/spi<asm/spi.h>"sf_internal.h"sandbox_sf_ofdata_to_platdatasandbox_spi_flash_plat_data *"%s: Missing properties, filename=%s, device_name=%s\n"__func__, pdata->filename, pdata->device_namedebug("%s: Missing properties, filename=%s, device_name=%s\n",
		      __func__, pdata->filename, pdata->device_name)%s: Missing properties, filename=%s, device_name=%s
sandbox_sf_xfer"sandbox_sf: state:%x(%s) bytes:%u\n", sbsf->state, sandbox_sf_state_name(sbsf->state), bytes"sandbox_sf: state:%x(%s) bytes:%u\n"sbsf->state, sandbox_sf_state_name(sbsf->state), byteslog_content("sandbox_sf: state:%x(%s) bytes:%u\n", sbsf->state,
		    sandbox_sf_state_name(sbsf->state), bytes)sandbox_sf: state:%x(%s) bytes:%u
sandbox_spi_flash *sbsfSF_CMDrxtxSF_ID" id: off:%u tx:", sbsf->off" id: off:%u tx:"sbsf->offlog_content(" id: off:%u tx:", sbsf->off) id: off:%u tx:IDCODE_LENsbsf->dataJEDEC_MFR(sbsf->data)JEDEC_ID(sbsf->data)IDCODE_LEN - 1"%d %02x\n", sbsf->off, id"%d %02x\n"sbsf->off, idlog_content("%d %02x\n", sbsf->off, id)355%d %02x
SF_ADDR" addr: bytes:%u rx:%02x ", sbsf->addr_bytes, rx[pos]" addr: bytes:%u rx:%02x "sbsf->addr_bytes, rx[pos]log_content(" addr: bytes:%u rx:%02x ",
				    sbsf->addr_bytes, rx[pos])362 addr: bytes:%u rx:%02x SF_ADDR_LEN"addr:%06x\n", sbsf->off"addr:%06x\n"log_content("addr:%06x\n", sbsf->off)rxptxpaddr:%06x
sandbox_sf: os_lseek() failed"sandbox_sf: os_lseek() failed"SF_READSF_WRITESF_ERASE" cmd: transition to %s state\n", sandbox_sf_state_name(sbsf->state)" cmd: transition to %s state\n"sandbox_sf_state_name(sbsf->state)log_content(" cmd: transition to %s state\n",
				    sandbox_sf_state_name(sbsf->state))396 cmd: transition to %s state
" tx: read(%u)\n", cnt" tx: read(%u)\n"log_content(" tx: read(%u)\n", cnt) tx: read(%u)
assert(tx)sandbox_sf: os_read() failed
"sandbox_sf: os_read() failed\n"SF_READ_STATUS" read status: %#x\n", sbsf->status" read status: %#x\n"sbsf->statuslog_content(" read status: %#x\n", sbsf->status) read status: %#x
SF_READ_STATUS1421SF_WRITE_STATUS" write status: %#x (ignored)\n", rx[pos]" write status: %#x (ignored)\n"rx[pos]log_content(" write status: %#x (ignored)\n", rx[pos]) write status: %#x (ignored)
STAT_WELsandbox_sf: write enable not set before write
"sandbox_sf: write enable not set before write\n"" rx: write(%u)\n", cnt" rx: write(%u)\n"log_content(" rx: write(%u)\n", cnt) rx: write(%u)
sandbox_spi: os_write() failed
"sandbox_spi: os_write() failed\n"~STAT_WELsandbox_sf: write enable not set before erase
"sandbox_sf: write enable not set before erase\n"" sector erase: cmd:%#x needs align:%#x, but we got %#x\n", sbsf->cmd, sbsf->erase_size, sbsf->off" sector erase: cmd:%#x needs align:%#x, but we got %#x\n"sbsf->cmd, sbsf->erase_size, sbsf->offlog_content(" sector erase: cmd:%#x needs align:%#x, but we got %#x\n",
					    sbsf->cmd, sbsf->erase_size,
					    sbsf->off) sector erase: cmd:%#x needs align:%#x, but we got %#x
" sector erase addr: %u, size: %u\n", sbsf->off, sbsf->erase_size" sector erase addr: %u, size: %u\n"sbsf->off, sbsf->erase_sizelog_content(" sector erase addr: %u, size: %u\n",
				    sbsf->off, sbsf->erase_size)471 sector erase addr: %u, size: %u
"sandbox_sf: Erase failed\n"log_content("sandbox_sf: Erase failed\n")sandbox_sf: Erase failed
" ??? no idea what to do ???\n"log_content(" ??? no idea what to do ???\n") ??? no idea what to do ???
sandbox_erase_part(int)sizeof(sandbox_sf_0xff)u8[4096]unsigned char[4096]min(size, (int)sizeof(sandbox_sf_0xff))sandbox_sf_process_cmd" write disabled\n"debug(" write disabled\n") write disabled
case_sf_erase" write enabled\n"debug(" write enabled\n") write enabled
SECT_4K4 << 10" cmd unknown: %#x\n"sbsf->cmddebug(" cmd unknown: %#x\n", sbsf->cmd) cmd unknown: %#x
log_content(" cmd: transition to %s state\n",
			    sandbox_sf_state_name(sbsf->state))sandbox_spi_tristatesandbox_sf_cs_deactivate"sandbox_sf: CS deactivated; cmd done processing!\n"log_content("sandbox_sf: CS deactivated; cmd done processing!\n")sandbox_sf: CS deactivated; cmd done processing!
sandbox_sf_cs_activate"sandbox_sf: CS activated; state is fresh!\n"log_content("sandbox_sf: CS activated; state is fresh!\n")sandbox_sf: CS activated; state is fresh!
sandbox_sf_removesandbox_sf_probe"%s: bus %d, looking for emul=%p: "__func__, bus->seq, devdebug("%s: bus %d, looking for emul=%p: ", __func__, bus->seq, dev)%s: bus %d, looking for emul=%p: Error: Unknown chip select for device '%s'
"Error: Unknown chip select for device '%s'\n"slave_plat"found at cs %d\n"debug("found at cs %d\n", cs)found at cs %d
Error: No filename available
"Error: No filename available\n"idname_len"%s: device='%s'\n"__func__, specdebug("%s: device='%s'\n", __func__, spec)%s: device='%s'
const flash_info[]flash_info[]%s: unknown flash '%*s'
"%s: unknown flash '%*s'\n"sizeof(sandbox_sf_0xff)%s: unable to open file '%s'
"%s: unable to open file '%s'\n""%s: Got error %d\n"debug("%s: Got error %d\n", __func__, ret)%s: Got error %d
STAT_BP_MASK~STAT_BP_MASKSTAT_BP_SHIFTsandbox_sf_state_nameconst char *const[9]char *[9]CMD"CMD"ID"ID"ADDR"ADDR"READ"READ"WRITE"WRITE"ERASE"ERASE"READ_STATUS"READ_STATUS"READ_STATUS1"READ_STATUS1"WRITE_STATUS"WRITE_STATUS"sandbox_spi_flash_plat_datasandbox_spi_flashsandbox_sf_statedevice_namepad_addr_bytesaddr_bytesUCLASS_SPI_EMULsizeof(struct sandbox_spi_flash)sizeof(struct sandbox_spi_flash_plat_data)const dm_spi_emul_opsconst dm_spi_emul_ops *dm_spi_emul_ops *_u_boot_list_2_driver_2_sandbox_sf_emul.u_boot_list_2_driver_2_sandbox_sf_emulsandbox,spi-flash"sandbox,spi-flash"sandbox_sf_idssandbox_sf_emul_opssandbox_sf_0xff(7 << STAT_BP_SHIFT)STAT_WIPCONFIG_SPI_FLASH/* Use the same device tree node as the SPI flash device *//* now the emulator *//*
			 * TODO(vapier@gentoo.org): latch WIP in status, and
			 * delay before clearing it ?
			 *//* verify address is aligned *//*
			 * XXX: need to handle exotic behavior:
			 *      - unaligned addresses
			 *      - more than a page (256) worth of data
			 *      - reading past end of device
			 *//*
			 * XXX: need to handle exotic behavior:
			 *      - reading past end of device
			 *//* assume erase state ... *//* Next state! *//* See if we're done processing *//* Extract correct byte from ID 0x00aabbcc *//* Process the remaining data *//* Figure out the initial state *//* we only support erase here *//* We need to output a byte for the cmd byte we just ate *//* Figure out what command this stream is telling us to do *//* XXX: make this into a user config option ? *//*
 * There are times when the data lines are allowed to tristate.  What
 * is actually sensed on the line depends on the hardware.  It could
 * always be 0xFF/0x00 (if there are pull ups/downs), or things could
 * float and so we'd get garbage back.  This func encapsulates that
 * scenario so we can worry about the details here.
 *//* CS is asserted, so reset state *//* spec = idcode:file *//**
 * This is a very strange probe function. If it has platform data (which may
 * have come from the device tree) then this function gets the filename and
 * device type from there.
 *//* The file on disk to serv up data from *//* Data describing the flash we're emulating *//* The current flash status (see STAT_XXX defines above) *//* How many address bytes we've consumed *//* Current position in the flash; used when reading/writing/etc... *//* Erase size of current erase command *//*
	 * As we receive data over the SPI bus, our flash transitions
	 * between states.  For example, we start off in the SF_CMD
	 * state where the first byte tells us what operation to perform
	 * (such as read or write the flash).  But the operation itself
	 * can go through a few states such as first reading in the
	 * offset in the flash to perform the requested operation.
	 * Thus "state" stores the exact state that our machine is in
	 * while "cmd" stores the overall command we're processing.
	 *//* Chip select we are attached to *//* Internal state data for each SPI flash *//* Used to quickly bulk erase backing store *//* Assume all SPI flashes have 3 byte addresses since they do atm *//* Bits for the status register *//* LOG *//* write the flash's status register *//* read the flash's status register upper 8 bits*//* read the flash's status register *//* erase the flash *//* writing data to the flash, i.e. page programming *//* reading data from the flash *//* processing the offset in the flash to read/etc... *//* read the flash's (jedec) ID code *//* default state -- we're awaiting a command *//*
 * The different states that our SPI flash transitions between.
 * We need to keep track of this across multiple xfer calls since
 * the SPI bus could possibly call down into us multiple times.
 *//*
 * Simulate a SPI flash
 *
 * Copyright (c) 2011-2013 The Chromium OS Authors.
 * See file CREDITS for list of people who contributed to this
 * project.
 *
 * Licensed under the GPL-2 or later.
 */sf_internalspi_flash_cmd_get_sw_write_protspi_flash_cmd_writespi_flash_cmd_readspi_flash_cmdn_sectorsSPI_NOR_MAX_ID_LENJEDEC_ID(info)(((info)->id[1]) << 8 | ((info)->id[2]))JEDEC_MFR(info)((info)->id[0])USE_CLSRSPI_NOR_SKIP_SFDPNO_CHIP_ERASESPI_NOR_4B_OPCODESSPI_S3ANSPI_NOR_HAS_TBSPI_NOR_HAS_LOCKUSE_FSRSPI_NOR_QUAD_READSPI_NOR_DUAL_READSECT_4K_PMCSPI_NOR_NO_FRSST_WRITESPI_NOR_NO_ERASESPI_NOR_MAX_ADDR_WIDTH_SF_INTERNAL_H_!CONFIG_IS_ENABLED(SPI_FLASH_TINY)CONFIG_SPI_FLASH_MTDspi_nor_idsSPI_FLASH_TINYCONFIG_VAL(SPI_FLASH_TINY_MODULE)CONFIG_SPI_FLASH_TINY_MODULE__ARG_PLACEHOLDER_CONFIG_SPI_FLASH_TINY_MODULE__ARG_PLACEHOLDER_CONFIG_SPI_FLASH_TINY_MODULE 1SPI_FLASH_TINY_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_SPI_FLASH_TINY_MODULECONFIG_VAL(SPI_FLASH_TINY)CONFIG_SPI_FLASH_TINY__ARG_PLACEHOLDER_CONFIG_SPI_FLASH_TINY__ARG_PLACEHOLDER_CONFIG_SPI_FLASH_TINY 1__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_SPI_FLASH_TINY/* _SF_INTERNAL_H_ *//* Get software write-protect value (BP bits) *//*
 * Send a multi-byte command to the device followed by (optional)
 * data. Used for programming the flash array, etc.
 *//*
 * Send a multi-byte command to the device and read the response. Used
 * for flash array reads, etc.
 *//* Send a single-byte command to the device and read the response *//* use CLSR command *//* Skip parsing of SFDP tables *//* Chip does not support chip erase *//*
					 * Use dedicated 4byte address op codes
					 * to support memory size above 128Mib.
					 *//*
					 * Xilinx Spartan 3AN In-System Flash
					 * (MFR cannot be used for probing
					 * because it has the same value as
					 * ATMEL flashes)
					 *//*
					 * Flash SR has Top/Bottom (TB) protect
					 * bit. Must be used with
					 * SPI_NOR_HAS_LOCK.
					 *//* Flash supports lock/unlock via SR *//* use flag status register *//* Flash supports Quad Read *//* Flash supports Dual Read *//* SPINOR_OP_BE_4K_PMC works uniformly *//* Can't do fastread *//* use SST byte programming *//* No erase command needed *//* SPINOR_OP_BE_4K works uniformly *//* The size listed here is what works with SPINOR_OP_SE, which isn't
	 * necessarily called a "sector" by the vendor.
	 *//*
	 * This array stores the ID bytes.
	 * The first three bytes are the JEDIC ID.
	 * JEDEC ID zero means "no ID" (mostly older chips).
	 *//*
 * SPI flash internal definitions
 *
 * Copyright (C) 2008 Atmel Corporation
 * Copyright (C) 2013 Jagannadha Sutradharudu Teki, Xilinx Inc.
 */cmd_len/opt/src/drivers/mtd/spi/sf-uclass.csf-uclassspi_flash_post_bindspi_flash@%d:%d"spi_flash@%d:%d"spi_flash_std"spi_flash_std"dm_spi_flash_ops *ops->get_sw_write_prot(dev)log_ret(ops->get_sw_write_prot(dev))drivers/mtd/spi/sf-uclass.csf_get_ops(dev)->erase(dev, offset, len)((struct dm_spi_flash_ops *)(dev)->driver->ops)->erase(dev, offset, len)log_ret(sf_get_ops(dev)->erase(dev, offset, len))sf_get_ops(dev)->write(dev, offset, len, buf)((struct dm_spi_flash_ops *)(dev)->driver->ops)->write(dev, offset, len, buf)log_ret(sf_get_ops(dev)->write(dev, offset, len, buf))sf_get_ops(dev)->read(dev, offset, len, buf)((struct dm_spi_flash_ops *)(dev)->driver->ops)->read(dev, offset, len, buf)log_ret(sf_get_ops(dev)->read(dev, offset, len, buf))"spi_flash"sizeof(struct spi_flash)_u_boot_list_2_uclass_2_spi_nor.u_boot_list_2_uclass_2_spi_nordefined(CONFIG_SPL_BUILD) && defined(CONFIG_USE_TINY_PRINTF)/*
 * TODO(sjg@chromium.org): This is an old-style function. We should remove
 * it when all SPI flash drivers use dm
 *//opt/src/drivers/mtd/spi/sf_probe.csf_probespi_flash_std_removespi_flash_std_probe"%s: slave=%p, cs=%d\n"__func__, slave, plat->csdebug("%s: slave=%p, cs=%d\n", __func__, slave, plat->cs)drivers/mtd/spi/sf_probe.c%s: slave=%p, cs=%d
spi_flash_std_get_sw_write_protspi_flash_std_eraseSF: Erase offset/length not multiple of erase size
"SF: Erase offset/length not multiple of erase size\n"sizeof(instr)spi_flash_std_writespi_flash_std_readmtd->_read(mtd, offset, len, &retlen, buf)log_ret(mtd->_read(mtd, offset, len, &retlen, buf))spi_flash_probe_slaveSF: Failed to set up slave
"SF: Failed to set up slave\n""SF: Failed to claim SPI bus: %d\n"debug("SF: Failed to claim SPI bus: %d\n", ret)SF: Failed to claim SPI bus: %d
err_read_idconst dm_spi_flash_opsconst dm_spi_flash_ops *_u_boot_list_2_driver_2_spi_flash_std.u_boot_list_2_driver_2_spi_flash_stdjedec,spi-nor"jedec,spi-nor"spi_flash_std_idsspi_flash_std_ops/* CONFIG_DM_SPI_FLASH *//* defined CONFIG_DM_SPI_FLASH *//* Allocate space if needed (not used by sf-uclass *//* Claim spi bus *//* Setup spi_slave *//**
 * spi_flash_probe_slave() - Probe for a SPI flash device on a bus
 *
 * @flashp: Pointer to place to put flash info, which may be NULL if the
 * space should be allocated
 *//*
 * SPI flash probing
 *
 * Copyright (C) 2008 Atmel Corporation
 * Copyright (C) 2010 Reinhard Meyer, EMK Elektronik
 * Copyright (C) 2013 Jagannadha Sutradharudu Teki, Xilinx Inc.
 *//opt/src/include/spi-mem.hspi-memspi_mem_exec_opconst spi_mem_opconst spi_mem_op *spi_mem_op *spi_mem_supports_opspi_mem_adjust_op_sizespi_mem_opspi_mem_data_dirSPI_MEM_DATA_INSPI_MEM_DATA_OUTexec_opsupports_opadjust_op_sizebuswidthSPI_MEM_OP(__cmd,__addr,__dummy,__data){ .cmd = __cmd, .addr = __addr, .dummy = __dummy, .data = __data, }SPI_MEM_OP_NO_DATA{ }SPI_MEM_OP_DATA_OUT(__nbytes,__buf,__buswidth){ .dir = SPI_MEM_DATA_OUT, .nbytes = __nbytes, .buf.out = __buf, .buswidth = __buswidth, }SPI_MEM_OP_DATA_IN(__nbytes,__buf,__buswidth){ .dir = SPI_MEM_DATA_IN, .nbytes = __nbytes, .buf.in = __buf, .buswidth = __buswidth, }SPI_MEM_OP_NO_DUMMYSPI_MEM_OP_DUMMY(__nbytes,__buswidth){ .nbytes = __nbytes, .buswidth = __buswidth, }SPI_MEM_OP_NO_ADDRSPI_MEM_OP_ADDR(__nbytes,__val,__buswidth){ .nbytes = __nbytes, .val = __val, .buswidth = __buswidth, }SPI_MEM_OP_CMD(__opcode,__buswidth){ .buswidth = __buswidth, .opcode = __opcode, }__UBOOT_SPI_MEM_HIS_ENABLED(CONFIG_SPI_MEM)/* __LINUX_SPI_MEM_H *//* CONFIG_SPI_MEM *//**
 * struct spi_mem_driver - SPI memory driver
 * @spidrv: inherit from a SPI driver
 * @probe: probe a SPI memory. Usually where detection/initialization takes
 *	   place
 * @remove: remove a SPI memory
 * @shutdown: take appropriate action when the system is shutdown
 *
 * This is just a thin wrapper around a spi_driver. The core takes care of
 * allocating the spi_mem object and forwarding the probe/remove/shutdown
 * request to the spi_mem_driver. The reason we use this wrapper is because
 * we might have to stuff more information into the spi_mem struct to let
 * SPI controllers know more about the SPI memory they interact with, and
 * having this intermediate layer allows us to do that without adding more
 * useless fields to the spi_device object.
 *//**
 * struct spi_controller_mem_ops - SPI memory operations
 * @adjust_op_size: shrink the data xfer of an operation to match controller's
 *		    limitations (can be alignment of max RX/TX size
 *		    limitations)
 * @supports_op: check if an operation is supported by the controller
 * @exec_op: execute a SPI memory operation
 *
 * This interface should be implemented by SPI controllers providing an
 * high-level interface to execute SPI memory operation, which is usually the
 * case for QSPI controllers.
 *//**
 * struct spi_mem_get_drvdata() - get driver private data attached to a SPI mem
 *				  device
 * @mem: memory device
 *
 * Return: the data attached to the mem device.
 *//**
 * struct spi_mem_set_drvdata() - attach driver private data to a SPI mem
 *				  device
 * @mem: memory device
 * @data: data to attach to the memory device
 *//**
 * struct spi_mem - describes a SPI memory device
 * @spi: the underlying SPI device
 * @drvpriv: spi_mem_driver private data
 *
 * Extra information that describe the SPI memory device and may be needed by
 * the controller to properly handle this device should be placed here.
 *
 * One example would be the device size since some controller expose their SPI
 * mem devices through a io-mapped region.
 *//* buf.{in,out} must be DMA-able. *//**
 * struct spi_mem_op - describes a SPI memory operation
 * @cmd.buswidth: number of IO lines used to transmit the command
 * @cmd.opcode: operation opcode
 * @addr.nbytes: number of address bytes to send. Can be zero if the operation
 *		 does not need to send an address
 * @addr.buswidth: number of IO lines used to transmit the address cycles
 * @addr.val: address value. This value is always sent MSB first on the bus.
 *	      Note that only @addr.nbytes are taken into account in this
 *	      address value, so users should make sure the value fits in the
 *	      assigned number of bytes.
 * @dummy.nbytes: number of dummy bytes to send after an opcode or address. Can
 *		  be zero if the operation does not require dummy bytes
 * @dummy.buswidth: number of IO lanes used to transmit the dummy bytes
 * @data.buswidth: number of IO lanes used to send/receive the data
 * @data.dir: direction of the transfer
 * @data.buf.in: input buffer
 * @data.buf.out: output buffer
 *//**
 * enum spi_mem_data_dir - describes the direction of a SPI memory data
 *			   transfer from the controller perspective
 * @SPI_MEM_DATA_IN: data coming from the SPI memory
 * @SPI_MEM_DATA_OUT: data sent the SPI memory
 *//*
 * Copyright (C) 2018 Exceet Electronics GmbH
 * Copyright (C) 2018 Bootlin
 *
 * Author:
 *	Peter Pan <peterpandong@micron.com>
 *	Boris Brezillon <boris.brezillon@bootlin.com>
 *//opt/src/drivers/mtd/spi/spi-nor-core.cspi-nor-coresrhwcapsSNOR_HWCAPS_READ |
			SNOR_HWCAPS_READ_FAST65539SNOR_HWCAPS_READ |
			SNOR_HWCAPS_READ_FAST |
			SNOR_HWCAPS_PP131328SNOR_HWCAPS_READ_1_4_4 |
					SNOR_HWCAPS_PP_1_1_4393472SNOR_HWCAPS_READ_1_4_4 |
					SNOR_HWCAPS_PP_1_1_4 |
					SNOR_HWCAPS_PP_1_4_4(SNOR_HWCAPS_READ_1_4_4 |
					SNOR_HWCAPS_PP_1_1_4 |
					SNOR_HWCAPS_PP_1_4_4)spi_nor_flash_parameter *3072<spi-mem.h>18446744073709551613~SNOR_HWCAPS_READ_FASTconst spi_nor_flash_parameterconst spi_nor_flash_parameter *const spi_nor_hwcapsconst spi_nor_hwcaps *spi_nor_hwcaps *"address width is too large: %u\n"nor->addr_widthdev_dbg(dev, "address width is too large: %u\n",
			nor->addr_width)address width is too large: %u
SF: Detected %s with page size "SF: Detected %s with page size ", erase size ", erase size ", total ", total "spi_nor_initnor->infoJEDEC_MFR(nor->info)nor->dev"quad mode not supported\n"dev_dbg(nor->dev, "quad mode not supported\n")quad mode not supported
enabling reset hack; may not recover from unexpected reboots
"enabling reset hack; may not recover from unexpected reboots\n"spi_nor_setupshared_maskignored_mask544SNOR_HWCAPS_READ_2_2_2 |
			SNOR_HWCAPS_READ_4_4_48736SNOR_HWCAPS_READ_2_2_2 |
			SNOR_HWCAPS_READ_4_4_4 |
			SNOR_HWCAPS_READ_8_8_8533024SNOR_HWCAPS_READ_2_2_2 |
			SNOR_HWCAPS_READ_4_4_4 |
			SNOR_HWCAPS_READ_8_8_8 |
			SNOR_HWCAPS_PP_4_4_44727328SNOR_HWCAPS_READ_2_2_2 |
			SNOR_HWCAPS_READ_4_4_4 |
			SNOR_HWCAPS_READ_8_8_8 |
			SNOR_HWCAPS_PP_4_4_4 |
			SNOR_HWCAPS_PP_8_8_8(SNOR_HWCAPS_READ_2_2_2 |
			SNOR_HWCAPS_READ_4_4_4 |
			SNOR_HWCAPS_READ_8_8_8 |
			SNOR_HWCAPS_PP_4_4_4 |
			SNOR_HWCAPS_PP_8_8_8)"SPI n-n-n protocols are not supported yet.\n"dev_dbg(nor->dev,
			"SPI n-n-n protocols are not supported yet.\n")SPI n-n-n protocols are not supported yet.
"can't select read settings supported by both the SPI controller and memory.\n"dev_dbg(nor->dev,
			"can't select read settings supported by both the SPI controller and memory.\n")can't select read settings supported by both the SPI controller and memory.
char[77]"can't select write settings supported by both the SPI controller and memory.\n"dev_dbg(nor->dev,
			"can't select write settings supported by both the SPI controller and memory.\n")can't select write settings supported by both the SPI controller and memory.
"can't select erase settings supported by both the SPI controller and memory.\n"dev_dbg(nor->dev,
			"can't select erase settings supported by both the SPI controller and memory.\n")can't select erase settings supported by both the SPI controller and memory.
enable_quad_iospi_nor_select_erasespi_nor_select_ppbest_match83886078323072BIT(best_match)const spi_nor_pp_commandconst spi_nor_pp_command *spi_nor_pp_command *spi_nor_pp_command[7]SNOR_CMD_PP_MAXspi_nor_select_readconst spi_nor_read_commandconst spi_nor_read_command *spi_nor_read_command *spi_nor_read_command[15]SNOR_CMD_READ_MAXspi_nor_hwcaps_pp2cmdconst int[2]const int(*)[2]int(*)[2]const int[][2]int[][2]hwcaps_pp2cmdconst int[7][2]int[7][2]ARRAY_SIZE(hwcaps_pp2cmd)SNOR_CMD_PPSNOR_CMD_PP_1_1_4SNOR_CMD_PP_1_4_4SNOR_CMD_PP_4_4_4SNOR_CMD_PP_1_1_8SNOR_CMD_PP_1_8_8SNOR_CMD_PP_8_8_8spi_nor_hwcaps_read2cmdhwcaps_read2cmdconst int[15][2]int[15][2]ARRAY_SIZE(hwcaps_read2cmd)SNOR_CMD_READSNOR_CMD_READ_FASTSNOR_CMD_READ_1_1_1_DTRshared_hwcapsSNOR_CMD_READ_1_1_2SNOR_CMD_READ_1_2_2SNOR_CMD_READ_2_2_2SNOR_CMD_READ_1_2_2_DTRSNOR_CMD_READ_1_1_4SNOR_CMD_READ_1_4_4SNOR_CMD_READ_4_4_4SNOR_CMD_READ_1_4_4_DTRSNOR_CMD_READ_1_1_8SNOR_CMD_READ_1_8_8SNOR_CMD_READ_8_8_8SNOR_CMD_READ_1_8_8_DTRspi_nor_hwcaps2cmdspi_nor_init_paramssizeof(*params)18446744073709551488184467440737094205441048575917504919424SNOR_HWCAPS_READ_QUAD |
				   SNOR_HWCAPS_PP_QUAD(SNOR_HWCAPS_READ_QUAD |
				   SNOR_HWCAPS_PP_QUAD)SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ(SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)sfdp_paramssizeof(sfdp_params)spi_nor_parse_sfdpspi_nor_set_pp_settingsspi_nor_set_read_settingsspansion_read_cr_quad_enable"error while reading configuration register\n"dev_dbg(dev, "error while reading configuration register\n")error while reading configuration register
sr_cr"error while reading status register\n"dev_dbg(dev, "error while reading status register\n")error while reading status register
"Spansion Quad bit not set\n"dev_dbg(nor->dev, "Spansion Quad bit not set\n")Spansion Quad bit not set
write_sr_cr"error while writing configuration register\n"dev_dbg(nor->dev,
			"error while writing configuration register\n")error while writing configuration register
"timeout while writing configuration register\n"dev_dbg(nor->dev,
			"timeout while writing configuration register\n")timeout while writing configuration register
macronix_quad_enable"Macronix Quad bit not set\n"dev_err(nor->dev, "Macronix Quad bit not set\n")Macronix Quad bit not set
spi_nor_write"to 0x%08x, len %zd\n"(u32)to, lendev_dbg(nor->dev, "to 0x%08x, len %zd\n", (u32)to, len)to 0x%08x, len %zd
writtennor->page_sizepage_offsetdo_div(aux, nor->page_size)num_mode_clocksnum_wait_states((aux) >> 32) == 0page_remainnor->page_size - page_offsetsst_writesst_write_byteprogramspi_nor_read"from 0x%08x, len %zd\n"(u32)from, lendev_dbg(nor->dev, "from 0x%08x, len %zd\n", (u32)from, len)from 0x%08x, len %zd
spi_nor_read_id"error %d reading JEDEC ID\n"dev_dbg(nor->dev, "error %d reading JEDEC ID\n", tmp)error %d reading JEDEC ID
"unrecognized JEDEC id bytes: %02x, %02x, %02x\n"id[0], id[1], id[2]dev_err(nor->dev, "unrecognized JEDEC id bytes: %02x, %02x, %02x\n",
		id[0], id[1], id[2])unrecognized JEDEC id bytes: %02x, %02x, %02x
stm_is_lockedstm_unlockstatus_oldcan_be_topcan_be_bottomuse_toplock_lenpowmtd->sizeilog2(mtd->size)write_errsst_write_errread_errorder_base_2(lock_len)(lock_len) - 1SR_BP2 | SR_BP1SR_BP2 | SR_BP1 | SR_BP0status_new18446744073709551583~SR_TB18446744073709551487~SR_SRWDstm_lockilog2(lock_len)stm_is_unlocked_srstm_is_locked_srstm_check_lock_status_srlock_offsstm_get_locked_rangewrite_sr_and_checkspi_nor_erase"at 0x%llx, len %lld\n"(long long)instr->addr, (long long)instr->lendev_dbg(nor->dev, "at 0x%llx, len %lld\n", (long long)instr->addr,
		(long long)instr->len)at 0x%llx, len %lld
spi_nor_erase_sectorSPI_MEM_OP_CMD(nor->erase_opcode, 1){ .buswidth = 1, .opcode = nor->erase_opcode, }SPI_MEM_OP_ADDR(nor->addr_width, addr, 1){ .nbytes = nor->addr_width, .val = addr, .buswidth = 1, }nor->erase_opcodespi_nor_wait_till_readyDEFAULT_READY_WAIT_JIFFIES40000spi_nor_wait_till_ready_with_timeouttimebase"flash operation timed out\n"dev_err(nor->dev, "flash operation timed out\n")flash operation timed out
spi_nor_readyfsrspi_nor_fsr_readyFSR_E_ERR | FSR_P_ERR(FSR_E_ERR | FSR_P_ERR)"Erase operation failed.\n"dev_dbg(nor->dev, "Erase operation failed.\n")Erase operation failed.
"Program operation failed.\n"dev_dbg(nor->dev, "Program operation failed.\n")Program operation failed.
"Attempted to modify a protected sector.\n"dev_dbg(nor->dev,
				"Attempted to modify a protected sector.\n")Attempted to modify a protected sector.
spi_nor_sr_readySR_E_ERR | SR_P_ERR(SR_E_ERR | SR_P_ERR)"Erase Error occurred\n"dev_dbg(nor->dev, "Erase Error occurred\n")Erase Error occurred
"Programming Error occurred\n"dev_dbg(nor->dev, "Programming Error occurred\n")Programming Error occurred
set_4byteneed_wrenspi_nor_set_4byte_opcodesspi_nor_convert_3to4_eraseconst u8[2]const u8(*)[2]unsigned char(*)[2]const u8[][2]unsigned char[][2]spi_nor_3to4_eraseconst u8[3][2]unsigned char[3][2]ARRAY_SIZE(spi_nor_3to4_erase)spi_nor_convert_3to4_programspi_nor_3to4_programARRAY_SIZE(spi_nor_3to4_program)spi_nor_convert_3to4_readspi_nor_3to4_readconst u8[9][2]unsigned char[9][2]ARRAY_SIZE(spi_nor_3to4_read)spi_nor_convert_opcodemtd_to_spi_norwrite_disablewrite_enablewrite_srread_cr"error %d reading CR\n"dev_dbg(nor->dev, "error %d reading CR\n", ret)error %d reading CR
read_fsr"error %d reading FSR\n"pr_fmt("error %d reading FSR\n")pr_debug("error %d reading FSR\n", ret)error %d reading FSR
read_sr"error %d reading SR\n"(int)retpr_fmt("error %d reading SR\n")pr_debug("error %d reading SR\n", (int)ret)error %d reading SR
spi_nor_write_dataSPI_MEM_OP_CMD(nor->program_opcode, 1){ .buswidth = 1, .opcode = nor->program_opcode, }SPI_MEM_OP_ADDR(nor->addr_width, to, 1){ .nbytes = nor->addr_width, .val = to, .buswidth = 1, }SPI_MEM_OP_DATA_OUT(len, buf, 1){ .dir = SPI_MEM_DATA_OUT, .nbytes = len, .buf.out = buf, .buswidth = 1, }nor->program_opcodeSPI_MEM_OP(SPI_MEM_OP_CMD(nor->program_opcode, 1),
				   SPI_MEM_OP_ADDR(nor->addr_width, to, 1),
				   SPI_MEM_OP_NO_DUMMY,
				   SPI_MEM_OP_DATA_OUT(len, buf, 1))spi_nor_read_dataSPI_MEM_OP_CMD(nor->read_opcode, 1){ .buswidth = 1, .opcode = nor->read_opcode, }SPI_MEM_OP_ADDR(nor->addr_width, from, 1){ .nbytes = nor->addr_width, .val = from, .buswidth = 1, }SPI_MEM_OP_DUMMY(nor->read_dummy, 1){ .nbytes = nor->read_dummy, .buswidth = 1, }SPI_MEM_OP_DATA_IN(len, buf, 1){ .dir = SPI_MEM_DATA_IN, .nbytes = len, .buf.in = buf, .buswidth = 1, }nor->read_opcodenor->read_dummySPI_MEM_OP(SPI_MEM_OP_CMD(nor->read_opcode, 1),
				   SPI_MEM_OP_ADDR(nor->addr_width, from, 1),
				   SPI_MEM_OP_DUMMY(nor->read_dummy, 1),
				   SPI_MEM_OP_DATA_IN(len, buf, 1))remainingUINT_MAXspi_nor_write_regSPI_MEM_OP_CMD(opcode, 1){ .buswidth = 1, .opcode = opcode, }SPI_MEM_OP_DATA_OUT(len, NULL, 1){ .dir = SPI_MEM_DATA_OUT, .nbytes = len, .buf.out = ((void *)0), .buswidth = 1, }SPI_MEM_OP(SPI_MEM_OP_CMD(opcode, 1),
					  SPI_MEM_OP_NO_ADDR,
					  SPI_MEM_OP_NO_DUMMY,
					  SPI_MEM_OP_DATA_OUT(len, NULL, 1))spi_nor_read_regSPI_MEM_OP_CMD(code, 1){ .buswidth = 1, .opcode = code, }SPI_MEM_OP_DATA_IN(len, NULL, 1){ .dir = SPI_MEM_DATA_IN, .nbytes = len, .buf.in = ((void *)0), .buswidth = 1, }SPI_MEM_OP(SPI_MEM_OP_CMD(code, 1),
					  SPI_MEM_OP_NO_ADDR,
					  SPI_MEM_OP_NO_DUMMY,
					  SPI_MEM_OP_DATA_IN(len, NULL, 1))&flash->spimem->spi->dev"error %d reading %x\n"ret, codedev_dbg(&flash->spimem->spi->dev, "error %d reading %x\n", ret,
			code)error %d reading %x
spi_nor_read_write_regspi_nor_flash_parameterspi_nor_pp_command_indexspi_nor_read_command_indexspi_nor_pp_commandspi_nor_read_commandpage_programsreads(40UL * HZ)HZdefined(CONFIG_SPI_FLASH_SPANSION) || defined(CONFIG_SPI_FLASH_WINBOND)defined(CONFIG_SPI_FLASH_STMICRO) || defined(CONFIG_SPI_FLASH_SST)CONFIG_SPI_FLASH_SSTCONFIG_SPI_FLASH_MACRONIXCONFIG_IS_ENABLED(SPI_FLASH_SFDP_SUPPORT)CONFIG_MTD_SPI_NOR_USE_4K_SECTORSCONFIG_SPI_FLASH_USE_4K_SECTORSSPI_FLASH_SFDP_SUPPORTCONFIG_VAL(SPI_FLASH_SFDP_SUPPORT_MODULE)CONFIG_SPI_FLASH_SFDP_SUPPORT_MODULE__ARG_PLACEHOLDER_CONFIG_SPI_FLASH_SFDP_SUPPORT_MODULE__ARG_PLACEHOLDER_CONFIG_SPI_FLASH_SFDP_SUPPORT_MODULE 1SPI_FLASH_SFDP_SUPPORT_MODULE__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_SPI_FLASH_SFDP_SUPPORT_MODULECONFIG_VAL(SPI_FLASH_SFDP_SUPPORT)CONFIG_SPI_FLASH_SFDP_SUPPORT__ARG_PLACEHOLDER_CONFIG_SPI_FLASH_SFDP_SUPPORT__ARG_PLACEHOLDER_CONFIG_SPI_FLASH_SFDP_SUPPORT 1__ARG_PLACEHOLDER__IS_SPL CONFIG_SPL_SPI_FLASH_SFDP_SUPPORT/* U-Boot specific functions, need to extend MTD to support these *//* Send all the required SPI flash commands to initialize device *//* Configure the BAR - discover bank cmds and read current bank *//* enable 4-byte addressing if the device exceeds 16MiB *//* already configured from SFDP *//*
	 * Configure the SPI memory:
	 * - select op codes for (Fast) Read, Page Program and Sector Erase.
	 * - set the number of dummy cycles (mode cycles + wait states).
	 * - set the SPI protocols for register and memory accesses.
	 * - set the Quad Enable bit if needed (required by SPI x-y-4 protos).
	 *//* Some devices cannot do fast-read, no matter what DT tells us *//* sst nor chips use AAI word program *//* NOR protection support for STmicro/Micron chips and similar *//* Parse the Serial Flash Discoverable Parameters table. *//* Reset SPI protocol for all commands. *//*
		 * If the RESET# pin isn't hooked up properly, or the system
		 * otherwise doesn't perform a reset command in the boot
		 * sequence, it's impossible to 100% protect against unexpected
		 * reboots (e.g., crashes). Warn the user (or hopefully, system
		 * designer) that this is bad.
		 *//*
	 * Atmel, SST, Intel/Numonyx, and others serial NOR tend to power up
	 * with the software protection bits set
	 *//* Enable Quad I/O if needed. *//* Select the Sector Erase command. *//* Select the Page Program command. *//* Select the (Fast) Read command. *//* SPI n-n-n protocols are not supported yet. *//*
	 * Keep only the hardware capabilities supported by both the SPI
	 * controller and the SPI flash memory.
	 *//* prefer "small sector" erase if possible *//* Do nothing if already configured from SFDP. *//*
	 * In the spi-nor framework, we don't need to make the difference
	 * between mode clock cycles and wait state clock cycles.
	 * Indeed, the value of the mode clock cycles is used by a QSPI
	 * flash memory to know whether it should enter or leave its 0-4-4
	 * (Continuous Read / XIP) mode.
	 * eXecution In Place is out of the scope of the mtd sub-system.
	 * Hence we choose to merge both mode and wait state clock cycles
	 * into the so called dummy clock cycles.
	 *//* Override the parameters with data read from SFDP tables. *//* Kept only for backward compatibility purpose. *//* Select the procedure to set the Quad Enable bit. *//* Page Program settings. *//* (Fast) Read settings. *//* Set SPI NOR sizes. *//* Set legacy flash parameters as default. *//* SPI_FLASH_SFDP_SUPPORT *//* Parse other parameter headers. *//*
	 * Check other parameter headers to get the latest revision of
	 * the basic flash parameter table.
	 *//*
	 * Allocate memory then read all parameter headers with a single
	 * Read SFDP command. These parameter headers will actually be parsed
	 * twice: a first time to get the latest revision of the basic flash
	 * parameter table, then a second time to handle the supported optional
	 * tables.
	 * Hence we read the parameter headers once for all to reduce the
	 * processing time. Also we use kmalloc() instead of devm_kmalloc()
	 * because we don't need to keep these parameter headers: the allocated
	 * memory is always released with kfree() before exiting this function.
	 *//*
	 * Verify that the first and only mandatory parameter header is a
	 * Basic Flash Parameter Table header as specified in JESD216.
	 *//* Check the SFDP header version. *//* Get the SFDP header. *//**
 * spi_nor_parse_sfdp() - parse the Serial Flash Discoverable Parameters.
 * @nor:		pointer to a 'struct spi_nor'
 * @params:		pointer to the 'struct spi_nor_flash_parameter' to be
 *			filled
 *
 * The Serial Flash Discoverable Parameters are described by the JEDEC JESD216
 * specification. This is a standard which tends to supported by almost all
 * (Q)SPI memory manufacturers. Those hard-coded tables allow us to learn at
 * runtime the main parameters needed to perform basic SPI flash operations such
 * as Fast Read, Page Program or Sector Erase commands.
 *
 * Return: 0 on success, -errno otherwise.
 *//* Quad Enable Requirements. *//* Page size: this field specifies 'N' so the page size = 2^N bytes. *//* Stop here if not JESD216 rev A or later. *//* erasesize == 0 means this Erase Type is not supported. *//* Sector Erase settings. *//* Fast Read settings. *//* Convert to bytes. *//*
		 * Prevent overflows on params->size. Anyway, a NOR of 2^64
		 * bits is unlikely to exist so this error probably means
		 * the BFPT we are reading is corrupted/wrong.
		 *//* Flash Memory Density (in bits). *//* Number of address bytes. *//* Fix endianness of the BFPT DWORDs. *//* Read the Basic Flash Parameter Table. *//* JESD216 Basic Flash Parameter Table length is at least 9 DWORDs. *//**
 * spi_nor_parse_bfpt() - read and parse the Basic Flash Parameter Table.
 * @nor:		pointer to a 'struct spi_nor'
 * @bfpt_header:	pointer to the 'struct sfdp_parameter_header' describing
 *			the Basic Flash Parameter Table length and version
 * @params:		pointer to the 'struct spi_nor_flash_parameter' to be
 *			filled
 *
 * The Basic Flash Parameter Table is the main and only mandatory table as
 * defined by the SFDP (JESD216) specification.
 * It provides us with the total size (memory density) of the data array and
 * the number of address bytes for Fast Read, Page Program and Sector Erase
 * commands.
 * For Fast READ commands, it also gives the number of mode clock cycles and
 * wait states (regrouped in the number of dummy clock cycles) for each
 * supported instruction op code.
 * For Page Program, the page size is now available since JESD216 rev A, however
 * the supported instruction op codes are still not provided.
 * For Sector Erase commands, this table stores the supported instruction op
 * codes and the associated sector sizes.
 * Finally, the Quad Enable Requirements (QER) are also available since JESD216
 * rev A. The QER bits encode the manufacturer dependent procedure to be
 * executed to set the Quad Enable (QE) bit in some internal register of the
 * Quad SPI memory. Indeed the QE bit, when it exists, must be set before
 * sending any Quad SPI command to the memory. Actually, setting the QE bit
 * tells the memory to reassign its WP# and HOLD#/RESET# pins to functions IO2
 * and IO3 hence enabling 4 (Quad) I/O lines.
 *
 * Return: 0 on success, -errno otherwise.
 *//* Erase Type 4 in DWORD9 bits[31:16] *//* Erase Type 3 in DWORD9 bits[15:0] *//* Erase Type 2 in DWORD8 bits[31:16] *//* Erase Type 1 in DWORD8 bits[15:0] *//*
	 * The half-word at offset <shift> in DWORD <dwoard> encodes the
	 * op code and erase sector size to be used by Sector Erase commands.
	 *//* Settings *//* Supported bit *//* Fast Read 4-4-4 *//* Fast Read 1-4-4 *//* Fast Read 1-1-4 *//* Fast Read 2-2-2 *//* Fast Read 1-2-2 *//* Fast Read 1-1-2 *//* The SPI protocol for this Fast Read x-y-z command. *//*
	 * The half-word at offset <setting_shift> in <setting_dword> BFPT DWORD
	 * encodes the op code, the number of mode clocks and the number of wait
	 * states to be used by Fast Read x-y-z command.
	 *//*
	 * The <supported_bit> bit in <supported_dword> BFPT DWORD tells us
	 * whether the Fast Read x-y-z command is supported.
	 *//* The Fast Read x-y-z hardware capability in params->hwcaps.mask. *//* Spansion *//* Macronix *//*
 * (from JESD216 rev B)
 * Quad Enable Requirements (QER):
 * - 000b: Device does not have a QE bit. Device detects 1-1-4 and 1-4-4
 *         reads based on instruction. DQ3/HOLD# functions are hold during
 *         instruction phase.
 * - 001b: QE is bit 1 of status register 2. It is set via Write Status with
 *         two data bytes where bit 1 of the second byte is one.
 *         [...]
 *         Writing only one byte to the status register has the side-effect of
 *         clearing status register 2, including the QE bit. The 100b code is
 *         used if writing one byte to the status register does not modify
 *         status register 2.
 * - 010b: QE is bit 6 of status register 1. It is set via Write Status with
 *         one data byte where bit 6 is one.
 *         [...]
 * - 011b: QE is bit 7 of status register 2. It is set via Write status
 *         register 2 instruction 3Eh with one data byte where bit 7 is one.
 *         [...]
 *         The status register 2 is read using instruction 3Fh.
 * - 100b: QE is bit 1 of status register 2. It is set via Write Status with
 *         two data bytes where bit 1 of the second byte is one.
 *         [...]
 *         In contrast to the 001b code, writing one byte to the status
 *         register does not modify status register 2.
 * - 101b: QE is bit 1 of status register 2. Status register 1 is read using
 *         Read Status instruction 05h. Status register2 is read using
 *         instruction 35h. QE is set via Writ Status instruction 01h with
 *         two data bytes where bit 1 of the second byte is one.
 *         [...]
 *//* 15th DWORD. *//* 11th DWORD. *//* 5th DWORD. *//* 1st DWORD. *//* The first version of JESB216 defined only 9 DWORDs. *//*
 * JESD216 rev B defines a Basic Flash Parameter Table of 16 DWORDs.
 * They are indexed from 1 but C arrays are indexed from 0.
 *//* Basic Flash Parameter Table *//* Basic Flash Parameter Table. *//* 0-base number of parameter headers *//* Ox50444653U <=> "SFDP" *//* Sector Map Table *//* byte address *//* in double words *//**
 * spi_nor_read_sfdp() - read Serial Flash Discoverable Parameters.
 * @nor:	pointer to a 'struct spi_nor'
 * @addr:	offset in the SFDP area to start reading data from
 * @len:	number of bytes to read
 * @buf:	buffer where the SFDP data are copied into (dma-safe memory)
 *
 * Whatever the actual numbers of bytes for address and dummy cycles are
 * for (Fast) Read commands, the Read SFDP (5Ah) instruction is always
 * followed by a 3-byte address and 8 dummy clock cycles.
 *
 * Return: 0 on success, -errno otherwise.
 *//*
 * Serial Flash Discoverable Parameters (SFDP) parsing.
 *//* Octo SPI *//* Quad SPI *//* Dual SPI *//* CONFIG_SPI_FLASH_SPANSION *//* CONFIG_SPI_FLASH_SFDP_SUPPORT *//* Keep the current value of the Status Register. *//**
 * spansion_no_read_cr_quad_enable() - set QE bit in Configuration Register.
 * @nor:	pointer to a 'struct spi_nor'
 *
 * Set the Quad Enable (QE) bit in the Configuration Register.
 * This function should be used with QSPI memories not supporting the Read
 * Configuration Register (35h) instruction.
 *
 * bit 1 of the Configuration Register is the QE bit for Spansion like QSPI
 * memories.
 *
 * Return: 0 on success, -errno otherwise.
 *//* Read back and check it. *//* Check current Quad Enable bit value. *//**
 * spansion_read_cr_quad_enable() - set QE bit in Configuration Register.
 * @nor:	pointer to a 'struct spi_nor'
 *
 * Set the Quad Enable (QE) bit in the Configuration Register.
 * This function should be used with QSPI memories supporting the Read
 * Configuration Register (35h) instruction.
 *
 * bit 1 of the Configuration Register is the QE bit for Spansion like QSPI
 * memories.
 *
 * Return: 0 on success, -errno otherwise.
 *//*
 * Write status Register and configuration register with 2 bytes
 * The first byte will be written to the status register, while the
 * second byte will be written to the configuration register.
 * Return negative if error occurred.
 *//**
 * macronix_quad_enable() - set QE bit in Status Register.
 * @nor:	pointer to a 'struct spi_nor'
 *
 * Set the Quad Enable (QE) bit in the Status Register.
 *
 * bit 6 of the Status Register is the QE bit for Macronix like QSPI memories.
 *
 * Return: 0 on success, -errno otherwise.
 *//* the size of data remaining on the first page *//*
		 * If page_size is a power of two, the offset can be quickly
		 * calculated with an AND operation. On the other cases we
		 * need to do a modulus operation (more expensive).
		 * Power of two numbers have only one bit set and we can use
		 * the instruction hweight32 to detect if we need to do a
		 * modulus (do_div()) or not.
		 *//*
 * Write an address range to the nor chip.  Data must be written in
 * FLASH_PAGESIZE chunks.  The address range may be any size provided
 * it is within the physical boundaries.
 *//* Write out trailing byte if it exists. *//* write two bytes. *//* Write out most of the data here. *//* write one byte. *//* Start write from odd address. *//* We shouldn't see 0-length reads *//* CONFIG_SPI_FLASH_STMICRO *//*
 * Check if a region of the flash is (completely) locked. See stm_lock() for
 * more info.
 *
 * Returns 1 if entire region is locked, 0 if any portion is unlocked, and
 * negative on errors.
 *//* Only modify protection if it will not lock other areas *//* Don't bother if they're the same *//* Don't protect status register if we're fully unlocked *//* Some power-of-two sizes are not supported *//* fully unlocked *//*
	 * Need largest pow such that:
	 *
	 *   1 / (2^pow) >= (len / size)
	 *
	 * so (assuming power-of-2 size) we do:
	 *
	 *   pow = floor(log2(size / len)) = log2(size) - ceil(log2(len))
	 *//* lock_len: length of region that should remain locked *//* Prefer top, if both are valid *//* If anything above us is locked, we can't use 'bottom' protection *//* If anything below us is locked, we can't use 'top' protection *//* If nothing in our range is locked, we don't need to do anything *//*
 * Unlock a region of the flash. See stm_lock() for more info
 *
 * Returns negative on errors, 0 on success.
 *//* Only modify protection if it will not unlock other areas *//* Disallow further writes if WP pin is asserted *//* Don't "lock" with no region! *//*
	 * Need smallest pow such that:
	 *
	 *   1 / (2^pow) <= (len / size)
	 *
	 * so (assuming power-of-2 size) we do:
	 *
	 *   pow = ceil(log2(size / len)) = log2(size) - floor(log2(len))
	 *//* lock_len: length of region that should end up locked *//* If anything above us is unlocked, we can't use 'top' protection *//* If anything below us is unlocked, we can't use 'bottom' protection *//* If nothing in our range is unlocked, we don't need to do anything *//*
 * Lock a region of the flash. Compatible with ST Micro and similar flash.
 * Supports the block protection bits BP{0,1,2} in the status register
 * (SR). Does not support these features found in newer SR bitfields:
 *   - SEC: sector/block protect - only handle SEC=0 (block protect)
 *   - CMP: complement protect - only support CMP=0 (range is not complemented)
 *
 * Support for the following is provided conditionally for some flash:
 *   - TB: top/bottom protect
 *
 * Sample table portion for 8MB flash (Winbond w25q64fw):
 *
 *   SEC  |  TB   |  BP2  |  BP1  |  BP0  |  Prot Length  | Protected Portion
 *  --------------------------------------------------------------------------
 *    X   |   X   |   0   |   0   |   0   |  NONE         | NONE
 *    0   |   0   |   0   |   0   |   1   |  128 KB       | Upper 1/64
 *    0   |   0   |   0   |   1   |   0   |  256 KB       | Upper 1/32
 *    0   |   0   |   0   |   1   |   1   |  512 KB       | Upper 1/16
 *    0   |   0   |   1   |   0   |   0   |  1 MB         | Upper 1/8
 *    0   |   0   |   1   |   0   |   1   |  2 MB         | Upper 1/4
 *    0   |   0   |   1   |   1   |   0   |  4 MB         | Upper 1/2
 *    X   |   X   |   1   |   1   |   1   |  8 MB         | ALL
 *  ------|-------|-------|-------|-------|---------------|-------------------
 *    0   |   1   |   0   |   0   |   1   |  128 KB       | Lower 1/64
 *    0   |   1   |   0   |   1   |   0   |  256 KB       | Lower 1/32
 *    0   |   1   |   0   |   1   |   1   |  512 KB       | Lower 1/16
 *    0   |   1   |   1   |   0   |   0   |  1 MB         | Lower 1/8
 *    0   |   1   |   1   |   0   |   1   |  2 MB         | Lower 1/4
 *    0   |   1   |   1   |   1   |   0   |  4 MB         | Lower 1/2
 *
 * Returns negative on errors, 0 on success.
 *//* Requested range does not overlap with locked range *//* Requested range is a sub-range of locked range *//*
 * Return 1 if the entire region is locked (if @locked is true) or unlocked (if
 * @locked is false); 0 otherwise
 *//* No protection *//* Write status register and ensure bits in mask match written values *//*
 * Erase an address range on the nor chip.  The address range may extend
 * one or more erase sectors.  Return an error is there is a problem erasing.
 *//*
	 * Default implementation, if driver doesn't have a specialized HW
	 * control
	 *//*
 * Initiate the erasure of a single sector
 *//*
 * This "clean_bar" is necessary in a situation when one was accessing
 * spi flash memory > 16 MiB by using Bank Address Register's BA24 bit.
 *
 * After it the BA24 bit shall be cleared to allow access to correct
 * memory region after SW reset (by calling "reset" command).
 *
 * Otherwise, the BA24 bit may be left set and then after reset, the
 * ROM would read/write/erase SPL from 16 MiB * bank_sel address.
 *//*
 * Service routine to read status register until ready, or timeout occurs.
 * Returns non-zero if error.
 *//* Spansion style *//*
			 * On Winbond W25Q256FV, leaving 4byte mode causes
			 * the Extended Address Register to be set to 1, so all
			 * 3-byte-address reads come from the second 16M.
			 * We must clear the register to enable normal behavior.
			 *//* Some Micron need WREN command; all will accept it *//* Enable/disable 4-byte addressing mode. *//* !CONFIG_SPI_FLASH_BAR *//* No small sector erase for 4-byte command set *//* Do some manufacturer fixups first *//* No conversion found, keep input op code. *//*
 * Send write disable instruction to the chip.
 *//*
 * Set write enable latch with Write Enable command.
 * Returns negative if error occurred.
 *//*
 * Write status register 1 byte
 * Returns negative if error occurred.
 *//*
 * Read configuration register, returning its value in the
 * location. Return the configuration register value.
 * Returns negative if error occurred.
 *//*
 * Read the flag status register, returning its value in the location
 * Return the status register value.
 * Returns negative if error occurred.
 *//*
 * Read the status register, returning its value in the location
 * Return the status register value.
 * Returns negative if error occurred.
 *//* get transfer protocols. *//* convert the dummy cycles to the number of bytes *//*
 * For everything but full-chip erase; probably could be much smaller, but kept
 * around for safety for now
 *//* Define max times to check status register before we give up. *//*
 * Based on m25p80.c, by Mike Lavender (mike@steroidmicros.com), with
 * influence from lart.c (Abraham Van Der Merwe) and mtd_dataflash.c
 *
 * Copyright (C) 2005, Intec Automation Inc.
 * Copyright (C) 2014, Freescale Semiconductor, Inc.
 *
 * Synced from Linux v4.19
 */erase_err/opt/src/drivers/mtd/spi/spi-nor-ids.cspi-nor-ids"at26df321"0x1f470064 * 1024(1UL << (0))"at25df321a"0x1f4701"at45db011d"0x1f2200"at45db021d"0x1f2300"at45db041d"0x1f2400"at45db081d"0x1f2500"at45db161d"0x1f2600"at45db321d"0x1f2700"at45db641d"0x1f2800"at26df081a"0x1f4501"en25q32b"0x1c3016"en25q64"0x1c3017"en25qh128"0x1c7018"en25s64"0x1c3817"gd25q16"0xc84015SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB(1UL << (0)) | (1UL << (5)) | (1UL << (6)) | (1UL << (8)) | (1UL << (9))"gd25q32"0xc84016"gd25lq32"0xc86016"gd25q64"0xc84017"gd25lq128"0xc86018SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB(1UL << (0)) | (1UL << (5)) | (1UL << (8)) | (1UL << (9))"mx25l2005a"0xc22012"mx25l4005a"0xc22013"mx25l8005"0xc22014"mx25l1606e"0xc22015"mx25l3205d"0xc22016"mx25l6405d"0xc22017"mx25u2033e"0xc22532"mx25u1635e"0xc22535"mx25u6435f"0xc22537"mx25l12805d"0xc22018"mx25l12855e"0xc22618"mx25l25635e"0xc22019(1UL << (5)) | (1UL << (6))"mx25u25635f"0xc22539SECT_4K | SPI_NOR_4B_OPCODES(1UL << (0)) | (1UL << (11))"mx25l25655e"0xc22619"mx66l51235l"0xc2201aSPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES(1UL << (5)) | (1UL << (6)) | (1UL << (11))"mx66u51235f"0xc2253aSECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES(1UL << (0)) | (1UL << (5)) | (1UL << (6)) | (1UL << (11))"mx66u2g45g"0xc2253c"mx66l1g45g"0xc2201bSECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ(1UL << (0)) | (1UL << (5)) | (1UL << (6))"mx25l1633e"0xc22415SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES | SECT_4K(1UL << (6)) | (1UL << (11)) | (1UL << (0))"n25q016a"0x20bb15SECT_4K | SPI_NOR_QUAD_READ(1UL << (0)) | (1UL << (6))"n25q032"0x20ba16(1UL << (6))"n25q032a"0x20bb16"n25q064"0x20ba17"n25q064a"0x20bb17"n25q128a11"0x20bb18"n25q128a13"0x20ba18"n25q256a"0x20ba19"n25q256ax1"0x20bb19SECT_4K | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES(1UL << (0)) | (1UL << (6)) | (1UL << (11))"mt25qu512a"0x20bb200x104400"n25q512a"SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES(1UL << (0)) | (1UL << (7)) | (1UL << (6)) | (1UL << (11))"n25q512ax3"0x20ba20"n25q00"0x20ba21SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | NO_CHIP_ERASE(1UL << (0)) | (1UL << (7)) | (1UL << (6)) | (1UL << (12))"n25q00a"0x20bb21"mt25qu02g"0x20bb22"mt35xu512aba"0x2c5b1a128 * 1024USE_FSR | SPI_NOR_4B_OPCODES(1UL << (7)) | (1UL << (11))"mt35xu02g"0x2c5b1c"s25sl032p"0x0102150x4d00"s25sl064p"0x010216"s25fl256s0"0x010219256 * 1024(1UL << (14))"s25fl256s1"0x4d01SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR(1UL << (5)) | (1UL << (6)) | (1UL << (14))"s25fl512s"0x0102200x4d0081"s25fl512s_256k""s25fl512s_64k""s25fl512s_512k"0x4f00"s25sl12800"0x012018"s25sl12801"0x0301"s25fl128s"0x4d0180"s25fl129p0""s25fl129p1""s25sl008a"0x010213"s25sl016a"0x010214"s25sl032a""s25sl064a""s25fl116k"0x014015"s25fl164k"0x014017"s25fl208k"0x014014SECT_4K | SPI_NOR_DUAL_READ(1UL << (0)) | (1UL << (5))"s25fl064l"0x016017"s25fl128l"0x016018"sst25vf040b"0xbf258dSECT_4K | SST_WRITE(1UL << (0)) | (1UL << (2))"sst25vf080b"0xbf258e"sst25vf016b"0xbf2541"sst25vf032b"0xbf254a"sst25vf064c"0xbf254b"sst25wf512"0xbf2501"sst25wf010"0xbf2502"sst25wf020"0xbf2503"sst25wf020a"0x621612"sst25wf040b"0x621613"sst25wf040"0xbf2504"sst25wf080"0xbf2505"sst26vf064b"0xbf2643"sst26wf016"0xbf2651"sst26wf032"0xbf2622"sst26wf064""m25p10"0x20201132 * 1024"m25p20"0x202012"m25p40"0x202013"m25p80"0x202014"m25p16"0x202015"m25p32"0x202016"m25p64"0x202017"m25p128"0x202018"m25pe16"0x208015"m25px16"0x207115"m25px64"0x207117"w25p80"0xef2014"w25p16"0xef2015"w25p32"0xef2016"w25x05"0xef3010"w25x40"0xef3013"w25x16"0xef3015"w25q16dw"0xef6015"w25x32"0xef3016"w25q20cl"0xef4012"w25q20bw"0xef5012"w25q20ew"0xef6012"w25q32"0xef4016"w25q32dw"0xef6016"w25q32jv"0xef7016"w25x64"0xef3017"w25q64dw"0xef6017"w25q64jv"0xef7017"w25q128fw"0xef6018"w25q128jv"0xef7018"w25q256fw"0xef6019"w25q256jw"0xef7019"w25q80"0xef5014"w25q80bl"0xef4014"w25q16cl"0xef4015"w25q64cv"0xef4017"w25q128"0xef4018"w25q256"0xef4019const flash_info[132]flash_info[132]at26df3212049792INFO("at26df321",	0x1f4700, 0, 64 * 1024, 64, SECT_4K)8007at25df321a2049793INFO("at25df321a",	0x1f4701, 0, 64 * 1024, 64, SECT_4K)at45db011d2040320INFO("at45db011d",	0x1f2200, 0, 64 * 1024,   4, SECT_4K)7970at45db021d2040576INFO("at45db021d",	0x1f2300, 0, 64 * 1024,   8, SECT_4K)7971at45db041d2040832INFO("at45db041d",	0x1f2400, 0, 64 * 1024,   8, SECT_4K)7972at45db081d2041088INFO("at45db081d",	0x1f2500, 0, 64 * 1024,  16, SECT_4K)7973at45db161d2041344INFO("at45db161d",	0x1f2600, 0, 64 * 1024,  32, SECT_4K)7974at45db321d2041600INFO("at45db321d",	0x1f2700, 0, 64 * 1024,  64, SECT_4K)7975at45db641d2041856INFO("at45db641d",	0x1f2800, 0, 64 * 1024, 128, SECT_4K)7976at26df081a2049281INFO("at26df081a", 	0x1f4501, 0, 64 * 1024,  16, SECT_4K)8005en25q32b1847318INFO("en25q32b",   0x1c3016, 0, 64 * 1024,   64, 0)7216en25q641847319INFO("en25q64",    0x1c3017, 0, 64 * 1024,  128, SECT_4K)en25qh1281863704INFO("en25qh128",  0x1c7018, 0, 64 * 1024,  256, 0)7280en25s641849367INFO("en25s64",    0x1c3817, 0, 64 * 1024,  128, SECT_4K)7224gd25q1613123605INFO("gd25q16", 0xc84015, 0, 64 * 1024,  32,
			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)51264gd25q3213123606INFO("gd25q32", 0xc84016, 0, 64 * 1024,  64,
			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)gd25lq3213131798INFO("gd25lq32", 0xc86016, 0, 64 * 1024, 64,
			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)51296gd25q6413123607INFO("gd25q64", 0xc84017, 0, 64 * 1024, 128,
			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)gd25lq12813131800INFO("gd25lq128", 0xc86018, 0, 64 * 1024, 256,
			SECT_4K | SPI_NOR_DUAL_READ |
			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)mx25l2005a12722194INFO("mx25l2005a",  0xc22012, 0, 64 * 1024,   4, SECT_4K)49696mx25l4005a12722195INFO("mx25l4005a",  0xc22013, 0, 64 * 1024,   8, SECT_4K)mx25l800512722196INFO("mx25l8005",   0xc22014, 0, 64 * 1024,  16, 0)mx25l1606e12722197INFO("mx25l1606e",  0xc22015, 0, 64 * 1024,  32, SECT_4K)mx25l3205d12722198INFO("mx25l3205d",  0xc22016, 0, 64 * 1024,  64, SECT_4K)mx25l6405d12722199INFO("mx25l6405d",  0xc22017, 0, 64 * 1024, 128, SECT_4K)mx25u2033e12723506INFO("mx25u2033e",  0xc22532, 0, 64 * 1024,   4, SECT_4K)49701mx25u1635e12723509INFO("mx25u1635e",  0xc22535, 0, 64 * 1024,  32, SECT_4K)mx25u6435f12723511INFO("mx25u6435f",  0xc22537, 0, 64 * 1024, 128, SECT_4K)mx25l12805d12722200INFO("mx25l12805d", 0xc22018, 0, 64 * 1024, 256, 0)mx25l12855e12723736INFO("mx25l12855e", 0xc22618, 0, 64 * 1024, 256, 0)49702mx25l25635e12722201INFO("mx25l25635e", 0xc22019, 0, 64 * 1024, 512, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)mx25u25635f12723513INFO("mx25u25635f", 0xc22539, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_4B_OPCODES)mx25l25655e12723737INFO("mx25l25655e", 0xc22619, 0, 64 * 1024, 512, 0)mx66l51235l12722202INFO("mx66l51235l", 0xc2201a, 0, 64 * 1024, 1024, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES)2144mx66u51235f12723514INFO("mx66u51235f", 0xc2253a, 0, 64 * 1024, 1024, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES)2145mx66u2g45g12723516INFO("mx66u2g45g",  0xc2253c, 0, 64 * 1024, 4096, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES)mx66l1g45g12722203INFO("mx66l1g45g",  0xc2201b, 0, 64 * 1024, 2048, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)mx25l1633e12723221INFO("mx25l1633e", 0xc22415, 0, 64 * 1024,   32, SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES | SECT_4K)4970021122113n25q016a2145045INFO("n25q016a",	 0x20bb15, 0, 64 * 1024,   32, SECT_4K | SPI_NOR_QUAD_READ)8379n25q0322144790INFO("n25q032",	 0x20ba16, 0, 64 * 1024,   64, SPI_NOR_QUAD_READ)8378n25q032a2145046INFO("n25q032a",	0x20bb16, 0, 64 * 1024,   64, SPI_NOR_QUAD_READ)n25q0642144791INFO("n25q064",     0x20ba17, 0, 64 * 1024,  128, SECT_4K | SPI_NOR_QUAD_READ)n25q064a2145047INFO("n25q064a",    0x20bb17, 0, 64 * 1024,  128, SECT_4K | SPI_NOR_QUAD_READ)n25q128a112145048INFO("n25q128a11",  0x20bb18, 0, 64 * 1024,  256, SECT_4K | SPI_NOR_QUAD_READ)n25q128a132144792INFO("n25q128a13",  0x20ba18, 0, 64 * 1024,  256, SECT_4K | SPI_NOR_QUAD_READ)n25q256a2144793INFO("n25q256a",    0x20ba19, 0, 64 * 1024,  512, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES)n25q256ax12145049INFO("n25q256ax1",  0x20bb19, 0, 64 * 1024,  512, SECT_4K | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES)mt25qu512a2145056INFO6("mt25qu512a",  0x20bb20, 0x104400, 64 * 1024, 1024,
		 SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES)10659844164n25q512aINFO("n25q512a",    0x20bb20, 0, 64 * 1024, 1024, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES)2241n25q512ax32144800INFO("n25q512ax3",  0x20ba20, 0, 64 * 1024, 1024, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES)n25q002144801INFO("n25q00",      0x20ba21, 0, 64 * 1024, 2048, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | NO_CHIP_ERASE)4289n25q00a2145057INFO("n25q00a",     0x20bb21, 0, 64 * 1024, 2048, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | NO_CHIP_ERASE)mt25qu02g2145058INFO("mt25qu02g",   0x20bb22, 0, 64 * 1024, 4096, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ | NO_CHIP_ERASE)mt35xu512aba2906906INFO("mt35xu512aba", 0x2c5b1a, 0,  128 * 1024,  512, USE_FSR | SPI_NOR_4B_OPCODES)11355mt35xu02g2906908INFO("mt35xu02g",  0x2c5b1c, 0, 128 * 1024,  2048, USE_FSR | SPI_NOR_4B_OPCODES)s25sl032p66069INFO("s25sl032p",  0x010215, 0x4d00,  64 * 1024,  64, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)s25sl064p66070INFO("s25sl064p",  0x010216, 0x4d00,  64 * 1024, 128, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)s25fl256s066073INFO("s25fl256s0", 0x010219, 0x4d00, 256 * 1024, 128, USE_CLSR)s25fl256s1INFO("s25fl256s1", 0x010219, 0x4d01,  64 * 1024, 512, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR)1971316480s25fl512s66080INFO6("s25fl512s",  0x010220, 0x4d0081, 256 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR)5046401s25fl512s_256kINFO("s25fl512s_256k",  0x010220, 0x4d00, 256 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR)s25fl512s_64kINFO("s25fl512s_64k",  0x010220, 0x4d01, 64 * 1024, 1024, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR)s25fl512s_512kINFO("s25fl512s_512k", 0x010220, 0x4f00, 256 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR)20224s25sl1280073752INFO("s25sl12800", 0x012018, 0x0300, 256 * 1024,  64, 0)s25sl12801INFO("s25sl12801", 0x012018, 0x0301,  64 * 1024, 256, 0)s25fl128sINFO6("s25fl128s",  0x012018, 0x4d0180, 64 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR)5046656s25fl129p0INFO("s25fl129p0", 0x012018, 0x4d00, 256 * 1024,  64, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR)s25fl129p1INFO("s25fl129p1", 0x012018, 0x4d01,  64 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | USE_CLSR)s25sl008a66067INFO("s25sl008a",  0x010213,      0,  64 * 1024,  16, 0)s25sl016a66068INFO("s25sl016a",  0x010214,      0,  64 * 1024,  32, 0)s25sl032aINFO("s25sl032a",  0x010215,      0,  64 * 1024,  64, 0)s25sl064aINFO("s25sl064a",  0x010216,      0,  64 * 1024, 128, 0)s25fl116k81941INFO("s25fl116k",  0x014015,      0,  64 * 1024,  32, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)s25fl164k81943INFO("s25fl164k",  0x014017,      0,  64 * 1024, 128, SECT_4K)s25fl208k81940INFO("s25fl208k",  0x014014,      0,  64 * 1024,  16, SECT_4K | SPI_NOR_DUAL_READ)s25fl064l90135INFO("s25fl064l",  0x016017,      0,  64 * 1024, 128, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES)352s25fl128l90136INFO("s25fl128l",  0x016018,      0,  64 * 1024, 256, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ | SPI_NOR_4B_OPCODES)sst25vf040b12526989INFO("sst25vf040b", 0xbf258d, 0, 64 * 1024,  8, SECT_4K | SST_WRITE)48933sst25vf080b12526990INFO("sst25vf080b", 0xbf258e, 0, 64 * 1024, 16, SECT_4K | SST_WRITE)sst25vf016b12526913INFO("sst25vf016b", 0xbf2541, 0, 64 * 1024, 32, SECT_4K | SST_WRITE)sst25vf032b12526922INFO("sst25vf032b", 0xbf254a, 0, 64 * 1024, 64, SECT_4K | SST_WRITE)sst25vf064c12526923INFO("sst25vf064c", 0xbf254b, 0, 64 * 1024, 128, SECT_4K)sst25wf51212526849INFO("sst25wf512",  0xbf2501, 0, 64 * 1024,  1, SECT_4K | SST_WRITE)sst25wf01012526850INFO("sst25wf010",  0xbf2502, 0, 64 * 1024,  2, SECT_4K | SST_WRITE)sst25wf02012526851INFO("sst25wf020",  0xbf2503, 0, 64 * 1024,  4, SECT_4K | SST_WRITE)sst25wf020a6428178INFO("sst25wf020a", 0x621612, 0, 64 * 1024,  4, SECT_4K)25110sst25wf040b6428179INFO("sst25wf040b", 0x621613, 0, 64 * 1024,  8, SECT_4K)sst25wf04012526852INFO("sst25wf040",  0xbf2504, 0, 64 * 1024,  8, SECT_4K | SST_WRITE)sst25wf08012526853INFO("sst25wf080",  0xbf2505, 0, 64 * 1024, 16, SECT_4K | SST_WRITE)sst26vf064b12527171INFO("sst26vf064b", 0xbf2643, 0, 64 * 1024, 128, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)48934sst26wf01612527185INFO("sst26wf016",  0xbf2651, 0, 64 * 1024,  32, SECT_4K)sst26wf03212527138INFO("sst26wf032",  0xbf2622, 0, 64 * 1024,  64, SECT_4K)sst26wf064INFO("sst26wf064",  0xbf2643, 0, 64 * 1024, 128, SECT_4K)m25p102105361INFO("m25p10",  0x202011,  0,  32 * 1024,   4, 0)8224m25p202105362INFO("m25p20",  0x202012,  0,  64 * 1024,   4, 0)m25p402105363INFO("m25p40",  0x202013,  0,  64 * 1024,   8, 0)m25p802105364INFO("m25p80",  0x202014,  0,  64 * 1024,  16, 0)m25p162105365INFO("m25p16",  0x202015,  0,  64 * 1024,  32, 0)m25p322105366INFO("m25p32",  0x202016,  0,  64 * 1024,  64, 0)m25p642105367INFO("m25p64",  0x202017,  0,  64 * 1024, 128, 0)m25p1282105368INFO("m25p128", 0x202018,  0, 256 * 1024,  64, 0)m25pe162129941INFO("m25pe16", 0x208015,  0, 64 * 1024, 32, SECT_4K)8320m25px162126101INFO("m25px16",    0x207115,  0, 64 * 1024, 32, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)8305m25px642126103INFO("m25px64",    0x207117,  0, 64 * 1024, 128, 0)w25p8015671316INFO("w25p80", 0xef2014, 0x0,	64 * 1024,    16, 0)61216w25p1615671317INFO("w25p16", 0xef2015, 0x0,	64 * 1024,    32, 0)w25p3215671318INFO("w25p32", 0xef2016, 0x0,	64 * 1024,    64, 0)w25x0515675408INFO("w25x05", 0xef3010, 0, 64 * 1024,  1,  SECT_4K)61232w25x4015675411INFO("w25x40", 0xef3013, 0, 64 * 1024,  8,  SECT_4K)w25x1615675413INFO("w25x16", 0xef3015, 0, 64 * 1024,  32, SECT_4K)w25q16dw15687701INFO("w25q16dw", 0xef6015, 0, 64 * 1024,  32,
			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)61280w25x3215675414INFO("w25x32", 0xef3016, 0, 64 * 1024,  64, SECT_4K)w25q20cl15679506INFO("w25q20cl", 0xef4012, 0, 64 * 1024,  4, SECT_4K)61248w25q20bw15683602INFO("w25q20bw", 0xef5012, 0, 64 * 1024,  4, SECT_4K)61264w25q20ew15687698INFO("w25q20ew", 0xef6012, 0, 64 * 1024,  4, SECT_4K)w25q3215679510INFO("w25q32", 0xef4016, 0, 64 * 1024,  64, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)w25q32dw15687702INFO("w25q32dw", 0xef6016, 0, 64 * 1024,  64,
			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)w25q32jv15691798INFO("w25q32jv", 0xef7016, 0, 64 * 1024,  64,
			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)61296w25x6415675415INFO("w25x64", 0xef3017, 0, 64 * 1024, 128, SECT_4K)w25q64dw15687703INFO("w25q64dw", 0xef6017, 0, 64 * 1024, 128,
			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)w25q64jv15691799INFO("w25q64jv", 0xef7017, 0, 64 * 1024, 128,
			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)w25q128fw15687704INFO("w25q128fw", 0xef6018, 0, 64 * 1024, 256,
			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)w25q128jv15691800INFO("w25q128jv", 0xef7018, 0, 64 * 1024, 256,
			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)w25q256fw15687705INFO("w25q256fw", 0xef6019, 0, 64 * 1024, 512,
			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)w25q256jw15691801INFO("w25q256jw", 0xef7019, 0, 64 * 1024, 512,
			SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB)w25q8015683604INFO("w25q80", 0xef5014, 0, 64 * 1024,  16, SECT_4K)w25q80bl15679508INFO("w25q80bl", 0xef4014, 0, 64 * 1024,  16, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)w25q16cl15679509INFO("w25q16cl", 0xef4015, 0, 64 * 1024,  32, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)w25q64cv15679511INFO("w25q64cv", 0xef4017, 0, 64 * 1024,  128, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)w25q12815679512INFO("w25q128", 0xef4018, 0, 64 * 1024, 256, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)w25q25615679513INFO("w25q256", 0xef4019, 0, 64 * 1024, 512, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)INFO6(_name,_jedec_id,_ext_id,_sector_size,_n_sectors,_flags)INFO_NAME(_name) .id = { ((_jedec_id) >> 16) & 0xff, ((_jedec_id) >> 8) & 0xff, (_jedec_id) & 0xff, ((_ext_id) >> 16) & 0xff, ((_ext_id) >> 8) & 0xff, (_ext_id) & 0xff, }, .id_len = 6, .sector_size = (_sector_size), .n_sectors = (_n_sectors), .page_size = 256, .flags = (_flags),INFO(_name,_jedec_id,_ext_id,_sector_size,_n_sectors,_flags)INFO_NAME(_name) .id = { ((_jedec_id) >> 16) & 0xff, ((_jedec_id) >> 8) & 0xff, (_jedec_id) & 0xff, ((_ext_id) >> 8) & 0xff, (_ext_id) & 0xff, }, .id_len = (!(_jedec_id) ? 0 : (3 + ((_ext_id) ? 2 : 0))), .sector_size = (_sector_size), .n_sectors = (_n_sectors), .page_size = 256, .flags = (_flags),INFO_NAME(_name)CONFIG_SPI_FLASH_ATMELCONFIG_SPI_FLASH_EONCONFIG_SPI_FLASH_GIGADEVICECONFIG_SPI_FLASH_ISSICONFIG_SPI_FLASH_STMICROCONFIG_SPI_FLASH_SPANSIONCONFIG_SPI_FLASH_WINBONDCONFIG_SPI_FLASH_XMC/* XMC (Wuhan Xinxin Semiconductor Manufacturing Corp.) *//* Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB *//* WINBOND *//* ST Microelectronics -- newer production may have feature updates *//* STMICRO *//* SST -- large erase sizes are "overlays", "sectors" are 4K *//* SST *//* Spansion/Cypress -- single (large) sector size only, at least
	 * for the chips listed here (without boot sectors).
	 *//* SPANSION *//* MACRONIX *//* ISSI *//* GigaDevice *//* GIGADEVICE *//* EON -- en25xxx *//* EON *//* Atmel -- some are (confusingly) marketed as "DataFlash" *//* ATMEL *//* NOTE: double check command sets and memory organization when you add
 * more nor chips.  This current list focusses on newer chips, which
 * have been converging on command sets which including JEDEC ID.
 *
 * All newly added entries should describe *hardware* and should use SECT_4K
 * (or SECT_4K_PMC) if hardware supports erasing 4 KiB sectors. For usage
 * scenarios excluding small sectors there is config option that can be
 * disabled: CONFIG_MTD_SPI_NOR_USE_4K_SECTORS.
 * For historical (and compatibility) reasons (before we got above config) some
 * old entries may be missing 4K flag.
 *//* Used when the "_ext_id" is two bytes at most *//* Exclude chip names for SPL to save space *//*
 *
 * Copyright (C) 2013 Jagannadha Sutradharudu Teki, Xilinx Inc.
 * Copyright (C) 2016 Jagan Teki <jagan@openedev.com>
 * Copyright (C) 2018 Texas Instruments Incorporated - http://www.ti.com/
 */libfdtfdt_add_alias_regionsfdt_region_state *fdt_next_regionfdt_first_regionfdt_find_regionsfdt_region_statefdt_region_ptrsfdt_subnode_stackwant_tWANT_NOTHINGWANT_NODES_ONLYWANT_NODES_AND_PROPSWANT_ALL_NODES_AND_PROPSptrscan_mergefdt_subnode_stack[32]FDT_MAX_DEPTHwantincludedFDT_IS_ANYFDT_ANY_GLOBAL(FDT_IS_NODE | FDT_IS_PROP | FDT_IS_VALUE | FDT_IS_COMPAT)FDT_NODE_HAS_PROPFDT_IS_COMPATFDT_IS_VALUEFDT_IS_PROPFDT_IS_NODEFDT_REG_ADD_MEM_RSVMAPFDT_REG_ALL_SUBNODESFDT_REG_DIRECT_SUBNODESFDT_REG_SUPERNODESFDT_REG_ADD_STRING_TAB_INCLUDE_LIBFDT_H_SWIG/* _INCLUDE_LIBFDT_H_ *//* Pointer to the working fdt *//* SWIG *//**
 * fdt_add_alias_regions() - find aliases that point to existing regions
 *
 * Once a device tree grep is complete some of the nodes will be present
 * and some will have been dropped. This function checks all the alias nodes
 * to figure out which points point to nodes which are still present. These
 * aliases need to be kept, along with the nodes they reference.
 *
 * Given a list of regions function finds the aliases that still apply and
 * adds more regions to the list for these. This function is called after
 * fdt_next_region() has finished returning regions and requires the same
 * state.
 *
 * @fdt:	Device tree file to reference
 * @region:	List of regions that will be kept
 * @count:	Number of regions
 * @max_regions: Number of entries that can fit in @region
 * @info:	Region state as returned from fdt_next_region()
 * @return new number of regions in @region (i.e. count + the number added)
 * or -FDT_ERR_NOSPACE if there was not enough space.
 *//** fdt_next_region() - find next region
 *
 * See fdt_first_region() for full description. This function finds the
 * next region according to the provided parameters, which must be the same
 * as passed to fdt_first_region().
 *
 * This function can additionally return -FDT_ERR_NOTFOUND when there are no
 * more regions
 *//**
 * fdt_first_region() - find regions in device tree
 *
 * Given a nodes and properties to include and properties to exclude, find
 * the regions of the device tree which describe those included parts.
 *
 * The use for this function is twofold. Firstly it provides a convenient
 * way of performing a structure-aware grep of the tree. For example it is
 * possible to grep for a node and get all the properties associated with
 * that node. Trees can be subsetted easily, by specifying the nodes that
 * are required, and then writing out the regions returned by this function.
 * This is useful for small resource-constrained systems, such as boot
 * loaders, which want to use an FDT but do not need to know about all of
 * it.
 *
 * Secondly it makes it easy to hash parts of the tree and detect changes.
 * The intent is to get a list of regions which will be invariant provided
 * those parts are invariant. For example, if you request a list of regions
 * for all nodes but exclude the property "data", then you will get the
 * same region contents regardless of any change to "data" properties.
 *
 * This function can be used to produce a byte-stream to send to a hashing
 * function to verify that critical parts of the FDT have not changed.
 * Note that semantically null changes in order could still cause false
 * hash misses. Such reordering might happen if the tree is regenerated
 * from source, and nodes are reordered (the bytes-stream will be emitted
 * in a different order and many hash functions will detect this). However
 * if an existing tree is modified using libfdt functions, such as
 * fdt_add_subnode() and fdt_setprop(), then this problem is avoided.
 *
 * The nodes/properties to include/exclude are defined by a function
 * provided by the caller. This function is called for each node and
 * property, and must return:
 *
 *    0 - to exclude this part
 *    1 - to include this part
 *   -1 - for FDT_IS_PROP only: no information is available, so include
 *		if its containing node is included
 *
 * The last case is only used to deal with properties. Often a property is
 * included if its containing node is included - this is the case where
 * -1 is returned.. However if the property is specifically required to be
 * included/excluded, then 0 or 1 can be returned. Note that including a
 * property when the FDT_REG_SUPERNODES flag is given will force its
 * containing node to be included since it is not valid to have a property
 * that is not in a node.
 *
 * Using the information provided, the inclusion of a node can be controlled
 * either by a node name or its compatible string, or any other property
 * that the function can determine.
 *
 * As an example, including node "/" means to include the root node and all
 * root properties. A flag provides a way of also including supernodes (of
 * which there is none for the root node), and another flag includes
 * immediate subnodes, so in this case we would get the FDT_BEGIN_NODE and
 * FDT_END_NODE of all subnodes of /.
 *
 * The subnode feature helps in a hashing situation since it prevents the
 * root node from changing at all. Any change to non-excluded properties,
 * names of subnodes or number of subnodes would be detected.
 *
 * When used with FITs this provides the ability to hash and sign parts of
 * the FIT based on different configurations in the FIT. Then it is
 * impossible to change anything about that configuration (include images
 * attached to the configuration), but it may be possible to add new
 * configurations, new images or new signatures within the existing
 * framework.
 *
 * Adding new properties to a device tree may result in the string table
 * being extended (if the new property names are different from those
 * already added). This function can optionally include a region for
 * the string table so that this can be part of the hash too. This is always
 * the last region.
 *
 * The FDT also has a mem_rsvmap table which can also be included, and is
 * always the first region if so.
 *
 * The device tree header is not included in the region list. Since the
 * contents of the FDT are changing (shrinking, often), the caller will need
 * to regenerate the header anyway.
 *
 * @fdt:	Device tree to check
 * @h_include:	Function to call to determine whether to include a part or
 *		not:
 *
 *		@priv: Private pointer as passed to fdt_find_regions()
 *		@fdt: Pointer to FDT blob
 *		@offset: Offset of this node / property
 *		@type: Type of this part, FDT_IS_...
 *		@data: Pointer to data (node name, property name, compatible
 *			string, value (not yet supported)
 *		@size: Size of data, or 0 if none
 *		@return 0 to exclude, 1 to include, -1 if no information is
 *		available
 * @priv:	Private pointer passed to h_include
 * @region:	Returns list of regions, sorted by offset
 * @max_regions: Maximum length of region list
 * @path:	Pointer to a temporary string for the function to use for
 *		building path names
 * @path_len:	Length of path, must be large enough to hold the longest
 *		path in the tree
 * @flags:	Various flags that control the region algortihm, see
 *		FDT_REG_...
 * @return number of regions in list. If this is >max_regions then the
 * region array was exhausted. You should increase max_regions and try
 * the call again. Only the first max_regions elements are available in the
 * array.
 *
 * On error a -ve value is return, which can be:
 *
 *	-FDT_ERR_BADSTRUCTURE (too deep or more END tags than BEGIN tags
 *	-FDT_ERR_BADLAYOUT
 *	-FDT_ERR_NOSPACE (path area is too small)
 *//**
 * fdt_find_regions() - find regions in device tree
 *
 * Given a list of nodes to include and properties to exclude, find
 * the regions of the device tree which describe those included parts.
 *
 * The intent is to get a list of regions which will be invariant provided
 * those parts are invariant. For example, if you request a list of regions
 * for all nodes but exclude the property "data", then you will get the
 * same region contents regardless of any change to "data" properties.
 *
 * This function can be used to produce a byte-stream to send to a hashing
 * function to verify that critical parts of the FDT have not changed.
 *
 * Nodes which are given in 'inc' are included in the region list, as
 * are the names of the immediate subnodes nodes (but not the properties
 * or subnodes of those subnodes).
 *
 * For eaxample "/" means to include the root node, all root properties
 * and the FDT_BEGIN_NODE and FDT_END_NODE of all subnodes of /. The latter
 * ensures that we capture the names of the subnodes. In a hashing situation
 * it prevents the root node from changing at all Any change to non-excluded
 * properties, names of subnodes or number of subnodes would be detected.
 *
 * When used with FITs this provides the ability to hash and sign parts of
 * the FIT based on different configurations in the FIT. Then it is
 * impossible to change anything about that configuration (include images
 * attached to the configuration), but it may be possible to add new
 * configurations, new images or new signatures within the existing
 * framework.
 *
 * Adding new properties to a device tree may result in the string table
 * being extended (if the new property names are different from those
 * already added). This function can optionally include a region for
 * the string table so that this can be part of the hash too.
 *
 * The device tree header is not included in the list.
 *
 * @fdt:	Device tree to check
 * @inc:	List of node paths to included
 * @inc_count:	Number of node paths in list
 * @exc_prop:	List of properties names to exclude
 * @exc_prop_count:	Number of properties in exclude list
 * @region:	Returns list of regions
 * @max_region:	Maximum length of region list
 * @path:	Pointer to a temporary string for the function to use for
 *		building path names
 * @path_len:	Length of path, must be large enough to hold the longest
 *		path in the tree
 * @add_string_tab:	1 to add a region for the string table
 * @return number of regions in list. If this is >max_regions then the
 * region array was exhausted. You should increase max_regions and try
 * the call again.
 *//* Pointers for what we are up to *//* Start position of current region *//* 1 if we can merge with previous region *//* Maximum regions to find *//* FDT blob *//* Numnber of regions found *//* Contains list of regions found *//* node stack *//* The state of our finding algortihm *//* Next node offset to check *//* Pointer to end of full node path *//* What we are currently including *//* What we have completed scanning *//* Current tree depth *//* 1 if we included this node, 0 if not *//* The 'want' value here *//* Offset of node *//* Keeps track of the state at parent nodes *//* Everything for all levels *//* Everything for one level *//* No properties *//* Decribes what we want to include from the current tag *//* We set a reasonable limit on the number of nested nodes *//* all the above *//* node contains prop *//* used internally *//* not supported *//* Indicates what an fdt part is (node, property, value) *//* Add a region for the mem_rsvmap table (always the first region) *//* Add all subnodes of a matching node *//* Add the FDT_BEGIN_NODE tags of subnodes, including their names *//*
 * Add all supernodes of a matching node/property, useful for creating a
 * valid subset tree
 *//*
 * Flags for fdt_find_regions()
 *
 * Add a region for the string table (always the last region)
 *//* Not available in Python *//* U-Boot local hacks */"../../scripts/dtc/libfdt/libfdt.h"h_includeincinc_countexc_prop_countadd_string_tabbd_tbi_drambi_boot_paramsbi_arch_numberbi_busfreqbi_intfreqbi_ethspeedbi_enetaddrbi_ip_addrbi_bootflagsbi_sramsizebi_sramstartbi_flashoffsetbi_flashsizebi_flashstartbi_memsizebi_memstart__ASM_GENERIC_U_BOOT_H__defined(CONFIG_MPC8xx) || defined(CONFIG_E500) || defined(CONFIG_MPC86xx)/* __ASM_GENERIC_U_BOOT_H__ *//* CONFIG_NR_DRAM_BANKS *//* RAM configuration *//* where this board expects params *//* unique id for this board *//* OLD: see README.enetaddr *//* Flexbus Freq in MHz *//* vco Freq in MHz *//* input Freq in MHz *//* PCI Bus Freq, in MHz *//* IPB Bus Freq, in MHz *//* VCO Out from PLL, in MHz *//* SCC_CLK Freq, in MHz *//* BRG_CLK Freq, in MHz *//* CPM_CLK Freq, in MHz *//* Bus Freq, in MHz *//* Internal Freq, in MHz *//* Ethernet speed in Mbps *//* IP Address *//* boot / reboot flag (Unused) *//* base of IMMR register *//* ddr frequency *//* dsp core frequency *//* arm frequency *//* size	 of SRAM memory *//* start of SRAM memory *//* reserved area for startup monitor *//* size	 of FLASH memory *//* start of FLASH memory *//* size	 of DRAM memory in bytes *//* start of DRAM memory *//*
 * Board information passed to Linux kernel from U-Boot
 *
 * include/asm-ppc/u-boot.h
 *//*
 * Copyright (c) 2011 The Chromium OS Authors.
 *
 * (C) Copyright 2000 - 2002
 * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
 ********************************************************************
 * NOTE: This header file defines an interface to U-Boot. Including
 * this (unmodified) header file in another file is considered normal
 * use of U-Boot, and does *not* fall under the heading of "derived
 * work".
 ********************************************************************
 */membuffmembuff_disposemembuff_newmembuff_uninitmembuff_initmembuff_extend_bymembuff_readlinemembuff_freemembuff_makecontigmembuff_sizemembuff_availmembuff_isemptymembuff_putmembuff_getmembuff_peekbytemembuff_getbytemembuff_putbytemembuff_getrawmembuff_putrawmembuff_purge_MEMBUFF_H/**
 * membuff_dispose() - free memory allocated to a membuff and uninit it
 *
 * @mb: membuff to dispose
 *//**
 * membuff_new() - create a new membuff
 *
 * @mb: membuff to init
 * @size: size of membuff to create
 * @return 0 if OK, -ENOMEM if out of memory
 *//**
 * membuff_uninit() - clear a membuff so it can no longer be used
 *
 * @mb: membuff to uninit
 *//**
 * membuff_init() - set up a new membuff using an existing membuff
 *
 * @mb: membuff to set up
 * @buff: Address of buffer
 * @size: Size of buffer
 *//**
 * membuff_extend_by() - expand a membuff
 *
 * Extends a membuff by the given number of bytes
 *
 * @mb: membuff to adjust
 * @by: Number of bytes to increase the size by
 * @max: Maximum size to allow
 * @return 0 if the expand succeeded, -ENOMEM if not enough memory, -E2BIG
 * if the the size would exceed @max
 *//**
 * membuff_readline() - read a line of text from a membuff
 *
 * Reads a line of text of up to 'maxlen' characters from a membuff and puts
 * it in @str. Any character less than @minch is assumed to be the end of
 * line character
 *
 * @mb: membuff to adjust
 * @str: Place to put the line
 * @maxlen: Maximum line length (excluding terminator)
 * @return number of bytes read (including terminator) if a line has been
 *	   read, 0 if nothing was there
 *//**
 * membuff_free() - find the number of bytes that can be written to a membuff
 *
 * @mb: membuff to check
 * @return returns the number of bytes free in a membuff
 *//**
 * membuff_makecontig() - adjust all membuff data to be contiguous
 *
 * This places all data in a membuff into a single contiguous lump, if
 * possible
 *
 * @mb: membuff to adjust
 * @return true on success
 *//**
 * membuff_size() - get the size of a membuff
 *
 * Note that a membuff can only old data up to one byte less than its size.
 *
 * @mb: membuff to check
 * @return total size
 *//**
 * membuff_avail() - check available data in a membuff
 *
 * @mb: membuff to check
 * @return number of bytes of data available
 *//**
 * membuff_isempty() - check if a membuff is empty
 *
 * @mb: membuff to check
 * @return true if empty, else false
 *//**
 * membuff_put() - write data to a membuff
 *
 * Writes some data to a membuff. Returns the number of bytes added. If this
 * is less than @lnehgt, then the membuff got full
 *
 * @mb: membuff to adjust
 * @data: the data to write
 * @length: number of bytes to write from 'data'
 * @return the number of bytes added
 *//**
 * membuff_get() - get data from a membuff
 *
 * Copies any available data (up to @maxlen bytes) to @buff and removes it
 * from the membuff.
 *
 * @mb: membuff to adjust
 * @Buff: address of membuff to transfer bytes to
 * @maxlen: maximum number of bytes to read
 * @return the number of bytes read
 *//**
 * membuff_peekbyte() - check the next available byte
 *
 * Return the next byte which membuff_getbyte() would return, without
 * removing it from the membuff.
 *
 * @mb: membuff to adjust
 * @return the byte peeked, or -1 if the membuff is empty
 *//**
 * @mb: membuff to adjust
 * membuff_getbyte() - Read a byte from the membuff
 * @return the byte read, or -1 if the membuff is empty
 *//**
 * membuff_putbyte() - Writes a byte to a membuff
 *
 * @mb: membuff to adjust
 * @ch: byte to write
 * @return true on success, false if membuff is full
 *//**
 * membuff_getraw() - find and return a pointer to available bytes
 *
 * Returns a pointer to any valid input data in the given membuff and
 * optionally marks it as read. Note that not all input data may not be
 * returned, since data is not necessarily contiguous in the membuff. However,
 * if you call this function twice (with @update == true) you are guaranteed
 * to get all available data, in at most two installments.
 *
 * @mb: membuff to adjust
 * @maxlen: maximum number of bytes to get
 * @update: true to update the membuff as if the bytes have been read (use
 * false to check bytes without reading them)
 * @data: returns address of data in input membuff
 * @return the number of bytes available at *@data
 *//**
 * membuff_putraw() - find out where bytes can be written
 *
 * Work out where in the membuff some data could be written. Return a pointer
 * to the address and the number of bytes which can be written there. If
 * @update is true, the caller must then write the data immediately, since
 * the membuff is updated as if the write has been done,
 *
 * Note that because the spare space in a membuff may not be contiguous, this
 * function may not return @maxlen even if there is enough space in the
 * membuff. However, by calling this function twice (with @update == true),
 * you will get access to all the spare space.
 *
 * @mb: membuff to adjust
 * @maxlen: the number of bytes we want to write
 * @update: true to update the membuff as if the write happened, false to not
 * @data: the address data can be written to
 * @return number of bytes which can be written
 *//**
 * membuff_purge() - reset a membuff to the empty state
 *
 * Initialise head and tail pointers so that the membuff becomes empty.
 *
 * @mb: membuff to purge
 *//** current buffer tail *//** current buffer head *//** the end of the buffer (start + length) *//** the start of the buffer *//**
 * @struct membuff: holds the state of a membuff - it is used for input and
 * output buffers. The buffer extends from @start to (@start + @size - 1).
 * Data in the buffer extends from @tail to @head: it is written in at
 * @head and read out from @tail. The membuff is empty when @head == @tail
 * and full when adding another character would make @head == @tail. We
 * therefore waste one character in the membuff to avoid having an extra flag
 * to determine whether (when @head == @tail) the membuff is empty or full.
 *
 * xxxxxx  data
 * ......  empty
 *
 * .............xxxxxxxxxxxxxxxx.........................
 *		^		^
 *		tail		head
 *
 * xxxxxxxxxxxxx................xxxxxxxxxxxxxxxxxxxxxxxxx
 *		^		^
 *		head		tail
 *//*
 * Copyright (c) 2015 Google, Inc
 * Written by Simon Glass <sjg@chromium.org>
 *
 * Copyright (c) 1992 Simon Glass
 */byminch/opt/src/drivers/net/mdio_mux_sandbox.cmdio_mux_sandboxmdio_mux_sandbox_probemdio_mux_sandbox_priv *mdio_mux_sandbox_deselectmdio_mux_sandbox_selectmdio_mux_sandbox_mark_selectionUCLASS_MDIOmdio-test"mdio-test"mdio_ops *SANDBOX_PHY_ADDRSANDBOX_PHY_REG_CNTSANDBOX_PHY_REG_CNT - 1mdio_mux_sandbox_privsel"mdio_mux_sandbox"UCLASS_MDIO_MUXconst mdio_mux_opsconst mdio_mux_ops *mdio_mux_ops *sizeof(struct mdio_mux_sandbox_priv)_u_boot_list_2_driver_2_mdio_mux_sandbox.u_boot_list_2_driver_2_mdio_mux_sandboxsandbox,mdio-mux"sandbox,mdio-mux"mdio_mux_sandbox_idsmdio_mux_sandbox_ops/*
	 * find the sandbox parent mdio and write a register on the PHY there
	 * so the mux test can verify selection.
	 *//* macros copied over from mdio_sandbox.c *//*
 * (C) Copyright 2019
 * Alex Marginean, NXP
 *//opt/src/drivers/net/opt/src/drivers/net/mdio_sandbox.cmdio_sandboxmdio_sandbox_probemdio_sandbox_priv *mdio_sandbox_resetu16[2]mdio_sandbox_writemdio_sandbox_readmdio_sandbox_priv"mdio_sandbox"const mdio_opsconst mdio_ops *sizeof(struct mdio_sandbox_priv)_u_boot_list_2_driver_2_mdio_sandbox.u_boot_list_2_driver_2_mdio_sandboxsandbox,mdio"sandbox,mdio"mdio_sandbox_idsmdio_sandbox_ops/opt/src/drivers/net/netconsole.cnetconsolesizeof(dev)nc"nc"nc_stdio_tstcnc_stdio_getcCONFIG_NETCONSOLE_BUFFER_SIZEsizeof(input_buffer)nc_stdio_putssend_len(int)sizeof(input_buffer)min(len, (int)sizeof(input_buffer))nc_stdio_putcnc_stdio_start6666nc_send_packet"output: \"%*.*s\"\n"len, len, bufdebug_cond(DEBUG_DEV_PKT, "output: \"%*.*s\"\n", len, len, buf)drivers/net/netconsole.coutput: "%*.*s"
"input: \"%*.*s\"\n"len, len, pktdebug_cond(DEBUG_DEV_PKT, "input: \"%*.*s\"\n", len, len, pkt)input: "%*.*s"
chunkrefresh_settings_from_envenv_changed_idncip"ncip"ncoutport"ncoutport"ncinport"ncinport"sizeof(nc_ether)is_broadcastour_ipnc_timeout_handlernc_handlernc_wait_arp_handleroutput_packet_lenoutput_packetnc_in_portnc_out_portnc_ipnc_ethernet_timeoutoutput_recursioninput_recursioninput_offsetinput_sizeinput_buffer/* kind of poll *//* inside net loop *//* no timeout *//*
	 * Initialize the static IP settings and buffer pointers
	 * incase we call net_send_udp_packet before net_loop
	 *//* default port *//* wait for arp reply and send packet *//* Copy first (or only) part of pkt after end of current valid input*//* Copy the second part of the pkt to start of input_buffer *//* Check if packet will wrap in input_buffer *//* no space *//* not from our client *//* not for us *//* send arp request *//* going to check for input packet *//**
 * Called from net_loop in net/net.c before each packet
 *//* force arp request *//* broadcast MAC address *//* ncip is not set, so broadcast *//* ncip is 0.0.0.0 *//* update only when the environment has changed *//* bcast to our net *//* on the same net and *//* 255.255.255.255 (global bcast) *//* got input - quit net loop *//* got arp reply - quit net loop *//*
 * Start with a default last protocol.
 * We are only interested in NETCONS or not.
 *//* used by first send udp *//* source input port *//* target output port *//* server ip *//* server enet address *//* offset to valid chars in input buffer *//* char count in input buffer */sip/opt/src/drivers/net/phy/phy.cCould not get PHY for %s: addr %d
"Could not get PHY for %s: addr %d\n"%s:%d is connected to %s.  Reconnecting to %s
"%s:%d is connected to %s.  Reconnecting to %s\n""%s connected to %s\n"dev->name, phydev->drv->namedebug("%s connected to %s\n", dev->name, phydev->drv->name)drivers/net/phy/phy.c911%s connected to %s
"PHY reset failed\n"debug("PHY reset failed\n")837PHY reset failed
 500"PHY status read failed\n"debug("PHY status read failed\n")/opt/src/drivers/net/phy854PHY status read failed
PHY reset timed out
"PHY reset timed out\n"get_phy_deviceget_phy_device_by_mask"\n%s PHY: "bus->namedebug("\n%s PHY: ", bus->name)790
%s PHY: debug("%d ", addr)794797search_for_existing_phycreate_phy_by_mask 0xffffffff5368709110x1fffffffphy_regphy_device_createsizeof(*dev)Failed to allocate PHY device for %s:%d
"Failed to allocate PHY device for %s:%d\n"%s, PHY probe failed
"%s, PHY probe failed\n"get_phy_driver&phy_driversstruct phy_driverlist_entry(entry, struct phy_driver, list)generic_for_interfacephy_probe640SUPPORTED_TP | SUPPORTED_MIISUPPORTED_TP | SUPPORTED_MII
			| SUPPORTED_AUISUPPORTED_TP | SUPPORTED_MII
			| SUPPORTED_AUI | SUPPORTED_FIBRESUPPORTED_TP | SUPPORTED_MII
			| SUPPORTED_AUI | SUPPORTED_FIBRE |
			SUPPORTED_BNC(SUPPORTED_TP | SUPPORTED_MII
			| SUPPORTED_AUI | SUPPORTED_FIBRE |
			SUPPORTED_BNC)lpagblpaestatusSUPPORTED_1000baseT_Full |
					SUPPORTED_1000baseT_Half(SUPPORTED_1000baseT_Full |
					SUPPORTED_1000baseT_Half)"Could not read MII_STAT1000. "debug("Could not read MII_STAT1000. ")Could not read MII_STAT1000. "Ignoring gigabit capability\n"debug("Ignoring gigabit capability\n")Ignoring gigabit capability
PHY_1000BTSR_1000FD | PHY_1000BTSR_1000HD(PHY_1000BTSR_1000FD | PHY_1000BTSR_1000HD)LPA_100FULL | LPA_100HALF(LPA_100FULL | LPA_100HALF)mii_regESTATUS_1000_XFULL | ESTATUS_1000_XHALFESTATUS_1000_XFULL | ESTATUS_1000_XHALF |
				ESTATUS_1000_TFULLESTATUS_1000_XFULL | ESTATUS_1000_XHALF |
				ESTATUS_1000_TFULL | ESTATUS_1000_THALF(ESTATUS_1000_XFULL | ESTATUS_1000_XHALF |
				ESTATUS_1000_TFULL | ESTATUS_1000_THALF)ESTATUS_1000_XFULL | ESTATUS_1000_TFULL(ESTATUS_1000_XFULL | ESTATUS_1000_TFULL)%s Waiting for PHY auto negotiation to complete"%s Waiting for PHY auto negotiation to complete" TIMEOUT !
" TIMEOUT !\n"user interrupt!
"user interrupt!\n" done
" done\n"4608BMCR_ANENABLE | BMCR_ANRESTART(BMCR_ANENABLE | BMCR_ANRESTART)(BMCR_ISOLATE)-1025~(BMCR_ISOLATE)genphy_setup_forced BMCR_ANRESTARTgenphy_config_advertadvertiseoldadvADVERTISE_ALL | ADVERTISE_100BASE4ADVERTISE_ALL | ADVERTISE_100BASE4 | ADVERTISE_PAUSE_CAP4064ADVERTISE_ALL | ADVERTISE_100BASE4 | ADVERTISE_PAUSE_CAP |
		 ADVERTISE_PAUSE_ASYM(ADVERTISE_ALL | ADVERTISE_100BASE4 | ADVERTISE_PAUSE_CAP |
		 ADVERTISE_PAUSE_ASYM)-4065~(ADVERTISE_ALL | ADVERTISE_100BASE4 | ADVERTISE_PAUSE_CAP |
		 ADVERTISE_PAUSE_ASYM)changedbmsrADVERTISE_1000FULL | ADVERTISE_1000HALF(ADVERTISE_1000FULL | ADVERTISE_1000HALF)-769~(ADVERTISE_1000FULL | ADVERTISE_1000HALF)SUPPORTED_1000baseT_Half |
				SUPPORTED_1000baseT_Full(SUPPORTED_1000baseT_Half |
				SUPPORTED_1000baseT_Full)phy_driversGeneric PHY"Generic PHY"PHY_GBIT_FEATURES | SUPPORTED_MIIPHY_GBIT_FEATURES | SUPPORTED_MII |
			  SUPPORTED_AUIPHY_GBIT_FEATURES | SUPPORTED_MII |
			  SUPPORTED_AUI | SUPPORTED_FIBREPHY_GBIT_FEATURES | SUPPORTED_MII |
			  SUPPORTED_AUI | SUPPORTED_FIBRE |
			  SUPPORTED_BNCgenphy_driverCONFIG_B53_SWITCHCONFIG_MV88E61XX_SWITCHCONFIG_PHY_ATHEROSCONFIG_PHY_BROADCOMCONFIG_PHY_CORTINACONFIG_PHY_DAVICOMCONFIG_PHY_ET1011CCONFIG_PHY_LXTCONFIG_PHY_MARVELLCONFIG_PHY_MICREL_KSZ8XXXCONFIG_PHY_MICREL_KSZ90X1CONFIG_PHY_MESON_GXLCONFIG_PHY_NATSEMICONFIG_PHY_REALTEKCONFIG_PHY_SMSCCONFIG_PHY_TERANETICSCONFIG_PHY_TICONFIG_PHY_VITESSECONFIG_PHY_XILINXCONFIG_PHY_MSCCCONFIG_PHY_FIXED/* Invoke an optional board-specific helper *//*
 * Start the PHY.  Returns 0 on success, or a negative error code.
 *//* Soft Reset the PHY *//* Wait 15ms to make sure the PHY has come out of hard reset *//* Reset the bus *//*
	 * miiphy_reset was only used on standard PHYs, so we'll fake it here.
	 * If later code tries to connect with the right interface, this will
	 * be corrected by get_phy_device in phy_connect()
	 *//* If it's 10G, we need to issue reset through one of the MMDs *//**
 * get_phy_device - reads the specified PHY device and returns its
 *                  @phy_device struct
 * @bus: the target MII bus
 * @addr: PHY address on the MII bus
 *
 * Description: Reads the ID registers of the PHY at @addr on the
 *   @bus, then allocates and returns the phy_device to represent it.
 *//* Otherwise we have to try Clause 45 *//* Try Standard (ie Clause 22) access *//* If we have one, return the existing device, with new interface *//* If the PHY ID is mostly f's, we didn't find anything *//*
		 * If the PHY ID is flat 0 we ignore it.  There are C45 PHYs
		 * that return all 0s for C22 reads (like Aquantia AQR112) and
		 * there are C22 PHYs that return all 0s for C45 reads (like
		 * Atheros AR8035).
		 *//* Grab the bits from PHYIR2, and put them in the lower half *//*
	 * Grab the bits from PHYIR1, and put them
	 * in the upper half
	 *//**
 * get_phy_id - reads the specified addr for its ID.
 * @bus: the target MII bus
 * @addr: PHY address on the MII bus
 * @phy_id: where to store the ID retrieved.
 *
 * Description: Reads the ID registers of the PHY at @addr on the
 *   @bus, stores it in @phy_id and returns zero on success.
 *//*
	 * We allocate the device, and initialize the
	 * default values
	 *//* If we made it here, there's no driver for this PHY *//* The default values for phydev->supported are provided by the PHY
	 * driver "features" member, we want to reset to sane defaults first
	 * before supporting higher speeds.
	 *//*
	 * The pointers inside phy_drivers also needs to be updated incase of
	 * manual reloc, without which these points to some invalid
	 * pre reloc address and leads to invalid accesses, hangs.
	 *//* Do we support autonegotiation? *//*
		 * Extended status may indicate that the PHY supports
		 * 1000BASE-T/X even though the 1000BASE-T registers
		 * are missing. In this case we can't tell whether the
		 * peer also supports it, so we only check extended
		 * status if the 1000BASE-T registers are actually
		 * missing.
		 *//* We're done! *//* Check the gigabit fields *//* Set the baseline so we only have to set them
		 * if they're different
		 *//* We want a list of states supported by
			 * both PHYs in the link
			 *//* Check for gigabit capability *//* We're using autonegotiation *//*
 * Generic function which updates the speed and duplex.  If
 * autonegotiation is enabled, it uses the AND of the link
 * partner's advertised capabilities and our advertised
 * capabilities.  If autonegotiation is disabled, we use the
 * appropriate bits in the control register.
 *
 * Stolen from Linux's mii.c and phy_device.c
 *//* Read the link a second time to clear the latched state *//* 1 ms *//*
			 * Timeout reached ?
			 *//*
	 * If we already saw the link up, and it hasn't gone down, then
	 * we don't need to wait for autoneg again
	 *//*
	 * Wait if the link is up, and autonegotiation is in progress
	 * (ie - we're capable and it's not done)
	 *//**
 * genphy_update_link - update link status in @phydev
 * @phydev: target phy_device struct
 *
 * Description: Update the value in phydev->link to reflect the
 *   current link value.  In order to do this, we need to read
 *   the status register twice, keeping the second value.
 *//*
	 * Only restart aneg if we are advertising something different
	 * than we were before.
	 *//* do restart aneg *//*
		 * Advertisment hasn't changed, but maybe aneg was never on to
		 * begin with?  Or maybe phy was isolated?
		 *//**
 * genphy_config_aneg - restart auto-negotiation or write BMCR
 * @phydev: target phy_device struct
 *
 * Description: If auto-negotiation is enabled, we configure the
 *   advertising, and then restart auto-negotiation.  If it is not
 *   enabled, then we write the BMCR.
 *//* Don't isolate the PHY if we're negotiating *//**
 * genphy_restart_aneg - Enable and Restart Autonegotiation
 * @phydev: target phy_device struct
 *//**
 * genphy_setup_forced - configures/forces speed/duplex from @phydev
 * @phydev: target phy_device struct
 *
 * Description: Configures MII_BMCR to force speed/duplex
 *   to the values in phydev. Assumes that the values are valid.
 *//* Configure gigabit if it's supported *//* Per 802.3-2008, Section 22.2.4.2.16 Extended status all
	 * 1000Mbits/sec capable PHYs shall have the BMSR_ESTATEN bit set to a
	 * logical 1.
	 *//* Setup standard advertisement *//* Only allow advertising what this PHY supports *//**
 * genphy_config_advert - sanitize and advertise auto-negotiation parameters
 * @phydev: target phy_device struct
 *
 * Description: Writes MII_ADVERTISE with the appropriate values,
 *   after sanitizing the values to make sure we only advertise
 *   what is supported.  Returns < 0 on error, 0 if the PHY's advertisement
 *   hasn't changed, and > 0 if it has changed.
 *//* Generic PHY support and helper functions *//*
 * Generic PHY Management code
 *
 * Copyright 2011 Freescale Semiconductor, Inc.
 * author Andy Fleming
 *
 * Based loosely off of Linux's PHY Lib
 *//opt/src/drivers/net/sandbox-raw-bus.csandbox-raw-buseth_raw_bus_post_bindniskip-localhost"skip-localhost"skip_localhostub_ifnameub_ifname_pfxhost_const char[6]sizeof(ub_ifname_pfx)IFNAMSIZ + sizeof(ub_ifname_pfx)eth_sandbox_raw"eth_sandbox_raw"sb_eth_raw_bus"sb_eth_raw_bus"_u_boot_list_2_driver_2_sandbox_eth_raw_bus.u_boot_list_2_driver_2_sandbox_eth_raw_bussandbox_eth_raw_bussandbox,eth-raw-bus"sandbox,eth-raw-bus"sandbox_eth_raw_bus_ids/*
 * Copyright (c) 2018 National Instruments
 * Copyright (c) 2018 Joe Hershberger <joe.hershberger@ni.com>
 *//opt/src/drivers/net/sandbox-raw.csandbox-rawsb_eth_raw_ofdata_to_platdataeth_pdata *host-raw-interface"host-raw-interface": Using %s from DT
": Using %s from DT\n"host-raw-interface-idx"host-raw-interface-idx": Using interface index %d from DT (%s)
": Using interface index %d from DT (%s)\n"sb_eth_raw_read_rom_hwaddrsb_eth_raw_stop"eth_sandbox_raw: Stop\n"debug("eth_sandbox_raw: Stop\n")drivers/net/sandbox-raw.ceth_sandbox_raw: Stop
sb_eth_raw_recvarp_hdr *htons(ARP_ETHER)((1))(0x0800)htons(PROT_IP)((0x0800))htons(ARPOP_REPLY)((2))packetppktptrreply_arp ? PROT_ARP : PROT_IPreply_arp ? 0x0806 : 0x0800(reply_arp ? 0x0806 : 0x0800)2054htons(reply_arp ? PROT_ARP : PROT_IP)((reply_arp ? 0x0806 : 0x0800))"eth_sandbox_raw: received packet %d\n"debug("eth_sandbox_raw: received packet %d\n",
		      length)eth_sandbox_raw: received packet %d
sb_eth_raw_send"eth_sandbox_raw: Send packet %d\n"debug("eth_sandbox_raw: Send packet %d\n", length)eth_sandbox_raw: Send packet %d
eth->et_protlen(__force __u16)(__be16)(eth->et_protlen)(__u16)(__be16)(eth->et_protlen)((__u16)(__be16)(eth->et_protlen))ntohs(eth->et_protlen)sb_eth_raw_start"eth_sandbox_raw: Start\n"debug("eth_sandbox_raw: Start\n")eth_sandbox_raw: Start
127.0.0.1"127.0.0.1"UCLASS_ETHconst eth_opsconst eth_ops *eth_ops *sizeof(struct eth_sandbox_raw_priv)sizeof(struct eth_pdata)_u_boot_list_2_driver_2_eth_sandbox_raw.u_boot_list_2_driver_2_eth_sandbox_rawsandbox,eth-raw"sandbox,eth-raw"sb_eth_raw_idssb_eth_raw_opsarp_ipreply_arp/* Fill in enough of the missing Ethernet header *//* If local, the Ethernet header won't be included; skip it *//* Use whatever IP we were looking for (always 127.0.0.1?) *//* Any non-zero MAC address will work *//*
		 * Fake an ARP response. The u-boot network stack is sending an
		 * ARP request (to find the MAC address to address the actual
		 * packet to) and requires an ARP response to continue. Since
		 * this is the localhost interface, there is no Etherent level
		 * traffic at all, so there is no way to send an ARP request or
		 * to get a response. For this reason we fake the response to
		 * make the u-boot network stack happy.
		 *//**
			 * localhost works on a higher-level API in Linux than
			 * ARP packets, so fake it
			 *//opt/src/arch/sandbox/include/asm/eth.heth_sandbox_privsandbox_eth_tx_hand_fsandbox_eth_tx_hand_f *tx_handlerrecv_packetsrecv_packet_lengthrecv_packet_bufferfake_host_ipaddrfake_host_hwaddr__ETH_Hsandbox_eth_set_privsandbox_eth_set_tx_handlersandbox_eth_recv_ping_reqsandbox_eth_recv_arp_reqsandbox_eth_ping_req_to_replysandbox_eth_arp_req_to_replysandbox_eth_skip_timeoutsandbox_eth_disable_response/* __ETH_H *//*
 * Set priv ptr
 *
 * priv - priv void ptr to store in the device
 *//*
 * Set packet handler
 *
 * handler - The func ptr to call on send. If NULL, set to default handler
 *//**
 * struct eth_sandbox_priv - memory for sandbox mock driver
 *
 * fake_host_hwaddr - MAC address of mocked machine
 * fake_host_ipaddr - IP address of mocked machine
 * disabled - Will not respond
 * recv_packet_buffer - buffers of the packet returned as received
 * recv_packet_length - lengths of the packet returned as received
 * recv_packets - number of packets returned
 * tx_handler - function to generate responses to sent packets
 * priv - a pointer to some structure a test may want to keep track of
 *//**
 * A packet handler
 *
 * dev - device pointer
 * pkt - pointer to the "sent" packet
 * len - packet length
 *//*
 * sandbox_eth_recv_ping_req()
 *
 * Inject a ping request for this target
 *
 * @dev: device that received the packet
 * @return 0 if injected, -EOVERFLOW if not
 *//*
 * sandbox_eth_recv_arp_req()
 *
 * Inject an ARP request for this target
 *
 * @dev: device that received the packet
 * @return 0 if injected, -EOVERFLOW if not
 *//*
 * sandbox_eth_ping_req_to_reply()
 *
 * Check for a ping request to be sent. If so, inject a reply
 *
 * @dev: device that received the packet
 * @packet: pointer to the received pacaket buffer
 * @len: length of received packet
 * @return 0 if injected, -EAGAIN if not
 *//*
 * sandbox_eth_arp_req_to_reply()
 *
 * Check for an arp request to be sent. If so, inject a reply
 *
 * @dev: device that received the packet
 * @packet: pointer to the received pacaket buffer
 * @len: length of received packet
 * @return 0 if injected, -EAGAIN if not
 *//opt/src/drivers/net/sandbox.csb_eth_ofdata_to_platdatafake-host-hwaddr"fake-host-hwaddr"'fake-host-hwaddr' is missing from the DT
"'fake-host-hwaddr' is missing from the DT\n"eth_sandbox_priv *sb_eth_removesb_eth_write_hwaddr"eth_sandbox %s: Write HW ADDR - %pM\n"dev->name, pdata->enetaddrdebug("eth_sandbox %s: Write HW ADDR - %pM\n", dev->name,
	      pdata->enetaddr)drivers/net/sandbox.c398eth_sandbox %s: Write HW ADDR - %pM
sb_eth_stop"eth_sandbox: Stop\n"debug("eth_sandbox: Stop\n")eth_sandbox: Stop
sb_eth_free_pktsb_eth_recv11000ULlcl_recv_packet_length"eth_sandbox: received packet[%d], %d waiting\n"lcl_recv_packet_length, priv->recv_packets - 1debug("eth_sandbox: received packet[%d], %d waiting\n",
		      lcl_recv_packet_length, priv->recv_packets - 1)eth_sandbox: received packet[%d], %d waiting
sb_eth_send"eth_sandbox: Send packet %d\n"debug("eth_sandbox: Send packet %d\n", length)<asm/eth.h>eth_sandbox: Send packet %d
sb_eth_start"eth_sandbox: Start\n"debug("eth_sandbox: Start\n")eth_sandbox: Start
dev_privsb_default_handlereth_recvip_udp_hdr *ipr((sizeof(struct ip_hdr)) + (sizeof(struct icmp_hdr)))(((sizeof(struct ip_hdr)) + (sizeof(struct icmp_hdr))))htons(IP_ICMP_HDR_SIZE)((((sizeof(struct ip_hdr)) + (sizeof(struct icmp_hdr)))))(0x4000)htons(IP_FLAGS_DFRAG)((0x4000))icmp_hdr *icmprhtons(1)ETHER_HDR_SIZE + IP_ICMP_HDR_SIZE(0x0806)htons(PROT_ARP)((0x0806))1544arp_recvhtons(ARPOP_REQUEST)ETHER_HDR_SIZE + ARP_HDR_SIZE-EAGAINicmparp->ar_op(__force __u16)(__be16)(arp->ar_op)(__u16)(__be16)(arp->ar_op)((__u16)(__be16)(arp->ar_op))ntohs(arp->ar_op)eth_sandbox"eth_sandbox"sizeof(struct eth_sandbox_priv)_u_boot_list_2_driver_2_eth_sandbox.u_boot_list_2_driver_2_eth_sandboxsandbox,eth"sandbox,eth"sb_eth_idssb_eth_opsskip_timeout/*
 * sandbox_eth_set_tx_handler()
 *
 * Set a custom response to a packet being sent through the sandbox eth test
 *	driver
 *
 * index - interface to set the handler for
 * handler - The func ptr to call on send. If NULL, set to default handler
 *//*
 * sb_default_handler()
 *
 * perform typical responses to simple ping
 *
 * dev - device pointer
 * pkt - "sent" packet buffer
 * len - length of packet
 *//* Formulate a fake ping *//* Don't allow the buffer to overrun *//*
 * sandbox_eth_recv_ping_req()
 *
 * Inject a ping request for this target
 *
 * returns 0 if injected, -EOVERFLOW if not
 *//* Formulate a fake request *//*
 * sandbox_eth_recv_arp_req()
 *
 * Inject an ARP request for this target
 *
 * returns 0 if injected, -EOVERFLOW if not
 *//* reply to the ping *//*
 * sandbox_eth_ping_req_to_reply()
 *
 * Check for a ping request to be sent. If so, inject a reply
 *
 * returns 0 if injected, -EAGAIN if not
 *//* Formulate a fake response *//* store this as the assumed IP of the fake host *//*
 * sandbox_eth_arp_req_to_reply()
 *
 * Check for an arp request to be sent. If so, inject a reply
 *
 * returns 0 if injected, -EAGAIN if not
 *//*
 * sandbox_eth_skip_timeout()
 *
 * When the first packet read is attempted, fast-forward time
 *//*
 * sandbox_eth_disable_response()
 *
 * index - The alias index (also DM seq number)
 * disable - If non-zero, ignore sent packets and don't send mock response
 *//opt/src/drivers/nvme/nvme.hnvme_writeqvolatile __le64volatile __le64 *val_lo__u32 *val_hiptr + 1upper_32_bits(val)nvme_readqnvme_nsnvme_queueNVME_CC_ENABLENVME_CC_CSS_NVM0 << 4NVME_CC_MPS_SHIFTNVME_CC_ARB_RR0 << 11NVME_CC_ARB_WRRUNVME_CC_ARB_VS143367 << 11NVME_CC_SHN_NONE0 << 14NVME_CC_SHN_NORMAL1 << 14NVME_CC_SHN_ABRUPT2 << 14NVME_CC_SHN_MASK3 << 14NVME_CC_IOSQES3932166 << 16NVME_CC_IOCQES4 << 20NVME_CSTS_RDYNVME_CSTS_CFSNVME_CSTS_SHST_NORMAL0 << 2NVME_CSTS_SHST_OCCURNVME_CSTS_SHST_CMPLT2 << 2NVME_CSTS_SHST_MASKnvme_barnvme_completionNVME_SC_SUCCESSNVME_SC_INVALID_OPCODENVME_SC_INVALID_FIELDNVME_SC_CMDID_CONFLICTNVME_SC_DATA_XFER_ERRORNVME_SC_POWER_LOSSNVME_SC_INTERNALNVME_SC_ABORT_REQNVME_SC_ABORT_QUEUENVME_SC_FUSED_FAILNVME_SC_FUSED_MISSINGNVME_SC_INVALID_NS0xbNVME_SC_CMD_SEQ_ERRORNVME_SC_SGL_INVALID_LAST0xdNVME_SC_SGL_INVALID_COUNTNVME_SC_SGL_INVALID_DATANVME_SC_SGL_INVALID_METADATANVME_SC_SGL_INVALID_TYPENVME_SC_LBA_RANGENVME_SC_CAP_EXCEEDEDNVME_SC_NS_NOT_READYNVME_SC_RESERVATION_CONFLICT0x83NVME_SC_CQ_INVALIDNVME_SC_QID_INVALIDNVME_SC_QUEUE_SIZENVME_SC_ABORT_LIMITNVME_SC_ABORT_MISSINGNVME_SC_ASYNC_LIMITNVME_SC_FIRMWARE_SLOTNVME_SC_FIRMWARE_IMAGENVME_SC_INVALID_VECTORNVME_SC_INVALID_LOG_PAGENVME_SC_INVALID_FORMAT0x10aNVME_SC_FIRMWARE_NEEDS_RESET0x10bNVME_SC_INVALID_QUEUE0x10cNVME_SC_FEATURE_NOT_SAVEABLE0x10dNVME_SC_FEATURE_NOT_CHANGEABLE0x10eNVME_SC_FEATURE_NOT_PER_NS0x10fNVME_SC_FW_NEEDS_RESET_SUBSYSNVME_SC_BAD_ATTRIBUTESNVME_SC_INVALID_PI385NVME_SC_READ_ONLYNVME_SC_WRITE_FAULT0x280NVME_SC_READ_ERROR6410x281NVME_SC_GUARD_CHECK6420x282NVME_SC_APPTAG_CHECK0x283NVME_SC_REFTAG_CHECK0x284NVME_SC_COMPARE_FAILED6450x285NVME_SC_ACCESS_DENIED6460x286NVME_SC_DNRnvme_commandnvme_format_cmdnvme_download_firmwarenvme_abort_cmdnvme_delete_queuenvme_create_sqnvme_create_cqnvme_featuresNVME_QUEUE_PHYS_CONTIGNVME_CQ_IRQ_ENABLEDNVME_SQ_PRIO_URGENT0 << 1(0 << 1)NVME_SQ_PRIO_HIGHNVME_SQ_PRIO_MEDIUM2 << 1(2 << 1)NVME_SQ_PRIO_LOW3 << 1(3 << 1)NVME_FEAT_ARBITRATIONNVME_FEAT_POWER_MGMTNVME_FEAT_LBA_RANGENVME_FEAT_TEMP_THRESHNVME_FEAT_ERR_RECOVERYNVME_FEAT_VOLATILE_WCNVME_FEAT_NUM_QUEUESNVME_FEAT_IRQ_COALESCENVME_FEAT_IRQ_CONFIGNVME_FEAT_WRITE_ATOMICNVME_FEAT_ASYNC_EVENTNVME_FEAT_AUTO_PSTNVME_FEAT_SW_PROGRESSNVME_FEAT_HOST_IDNVME_FEAT_RESV_MASKNVME_FEAT_RESV_PERSISTNVME_LOG_ERRORNVME_LOG_SMARTNVME_LOG_FW_SLOTNVME_LOG_RESERVATIONNVME_FWACT_REPL(0 << 3)NVME_FWACT_REPL_ACTVNVME_FWACT_ACTV2 << 3(2 << 3)nvme_admin_opcodenvme_admin_delete_sqnvme_admin_create_sqnvme_admin_get_log_pagenvme_admin_delete_cqnvme_admin_create_cqnvme_admin_identifynvme_admin_abort_cmdnvme_admin_set_featuresnvme_admin_get_featuresnvme_admin_async_eventnvme_admin_activate_fwnvme_admin_download_fwnvme_admin_format_nvmnvme_admin_security_sendnvme_admin_security_recvnvme_dsm_rangeNVME_DSMGMT_IDRNVME_DSMGMT_IDWNVME_DSMGMT_ADnvme_dsm_cmdNVME_RW_LRNVME_RW_FUANVME_RW_DSM_FREQ_UNSPECNVME_RW_DSM_FREQ_TYPICALNVME_RW_DSM_FREQ_RARENVME_RW_DSM_FREQ_READSNVME_RW_DSM_FREQ_WRITESNVME_RW_DSM_FREQ_RWNVME_RW_DSM_FREQ_ONCENVME_RW_DSM_FREQ_PREFETCHNVME_RW_DSM_FREQ_TEMPNVME_RW_DSM_LATENCY_NONENVME_RW_DSM_LATENCY_IDLENVME_RW_DSM_LATENCY_NORMNVME_RW_DSM_LATENCY_LOW3 << 4NVME_RW_DSM_SEQ_REQNVME_RW_DSM_COMPRESSEDNVME_RW_PRINFO_PRCHK_REFNVME_RW_PRINFO_PRCHK_APPNVME_RW_PRINFO_PRCHK_GUARDNVME_RW_PRINFO_PRACTnvme_rw_commandnvme_common_commandnvme_opcodenvme_cmd_flushnvme_cmd_writenvme_cmd_readnvme_cmd_write_uncornvme_cmd_comparenvme_cmd_write_zeroesnvme_cmd_dsmnvme_cmd_resv_registernvme_cmd_resv_reportnvme_cmd_resv_acquirenvme_cmd_resv_releasenvme_reservation_statusNVME_LBART_TYPE_FSNVME_LBART_TYPE_RAIDNVME_LBART_TYPE_CACHENVME_LBART_TYPE_SWAPNVME_LBART_ATTRIB_TEMPNVME_LBART_ATTRIB_HIDEnvme_lba_range_typeNVME_SMART_CRIT_SPARENVME_SMART_CRIT_TEMPERATURENVME_SMART_CRIT_RELIABILITYNVME_SMART_CRIT_MEDIANVME_SMART_CRIT_VOLATILE_MEMORYnvme_smart_logNVME_NS_FEAT_THINNVME_NS_FLBAS_LBA_MASKNVME_NS_FLBAS_META_EXTNVME_LBAF_RP_BESTNVME_LBAF_RP_BETTERNVME_LBAF_RP_GOODNVME_LBAF_RP_DEGRADEDNVME_NS_DPC_PI_LASTNVME_NS_DPC_PI_FIRSTNVME_NS_DPC_PI_TYPE3NVME_NS_DPC_PI_TYPE2NVME_NS_DPC_PI_TYPE1NVME_NS_DPS_PI_FIRSTNVME_NS_DPS_PI_MASKNVME_NS_DPS_PI_TYPE1NVME_NS_DPS_PI_TYPE2NVME_NS_DPS_PI_TYPE3nvme_id_nsnvme_lbafNVME_CTRL_ONCS_COMPARENVME_CTRL_ONCS_WRITE_UNCORRECTABLENVME_CTRL_ONCS_DSMNVME_CTRL_VWC_PRESENTnvme_id_ctrlNVME_PS_FLAGS_MAX_POWER_SCALENVME_PS_FLAGS_NON_OP_STATEnvme_id_power_statemode_select_block_lenmode_select_num_blocksflbaslba_shiftns_idnnprp_entry_numprp_poolvwcstripe_size/opt/src/drivers/nvmemax_transfer_shiftfirmware_revnamespacesnvme_bar *ctrl_configdb_strideq_depthmax_qidonline_queuesqueue_countinstancedbsnvme_queue *nvme_queue **queuesacqasqaqarsvd2cstsrsvd1ccintmcintmsvscommand_idsq_idsq_headrsvddsmdlfwdelete_queuecreate_sqcreate_cqidentify__u32[5]rsvd11cdw10__u64[4]rsvd12numdprp2prp1sqid__u32[9]rsvd10qidcqidsq_flagsqsizersvd8irq_vectorcq_flags__u64[2]unsigned long long[2]slbanlbcattrnrappmaskapptagreftagdsmgmt__le32[6]__le32[2]cdw2regctl_ds__u8[13]resv10ptplsresv5regctlrtyperkeyhostid__u8[5]resv3rcstscntlidrsvd48__u8[14]__u8[296]unsigned char[296]rsvd216__le16[8]temp_sensorcritical_comp_timewarning_temp_timenum_err_log_entriesmedia_errorsunsafe_shutdownspower_on_hourspower_cyclesctrl_busy_timehost_writeshost_readsdata_units_writtendata_units_read__u8[26]unsigned char[26]rsvd6percent_usedspare_threshavail_sparetemperaturecritical_warning__u8[3712]unsigned char[3712]3712__u8[192]rsvd192nvme_lbaf[16]lbafeui64nguid__u8[40]rsvd64__le64[2]nvmcaprsvd46nabspfnabonabsnnacwunawupfnawunrsvd33fpirescapnmicdpsdpcmcnlbafnsfeatnusencapnszerpds__u8[1024]nvme_id_power_state[32]psd__u8[1508]unsigned char[1508]1508rsvd540sglsrsvd534acwursvd531nvsccawupfawunfnafusesoncsrsvd514cqessqes__u8[242]unsigned char[242]rsvd270cctempwctempapstaavsccnpsselpefrmwaerloacs__u8[172]unsigned char[172]rsvd84mdtsmicieeerabfrmnsnssvid__u8[9]unsigned char[9]rsvd23active_work_scaleactive_powerrsvd19idle_scaleidle_powerwrite_latwrite_tputread_latread_tputexit_latentry_latNVME_VS(major,minor)(((major) << 16) | ((minor) << 8))NVME_CAP_MPSMAX(cap)(((cap) >> 52) & 0xf)NVME_CAP_MPSMIN(cap)(((cap) >> 48) & 0xf)NVME_CAP_STRIDE(cap)(((cap) >> 32) & 0xf)NVME_CAP_TIMEOUT(cap)(((cap) >> 24) & 0xff)NVME_CAP_MQES(cap)((cap) & 0xffff)__DRIVER_NVME_H__/* __DRIVER_NVME_H__ *//*
 * An NVM Express namespace is equivalent to a SCSI LUN.
 * Each namespace is operated as an independent "device".
 *//* Represents an NVM Express device. Each nvme_dev is a PCI function. *//* Admin CQ Base Address *//* Admin SQ Base Address *//* Admin Queue Attributes *//* Reserved *//* Controller Status *//* Controller Configuration *//* Interrupt Mask Clear *//* Interrupt Mask Set *//* Controller Capabilities *//*
 * Registers should always be accessed with double word or quad word
 * accesses. Registers with 64-bit address pointers should be written
 * to with dword accesses by writing the low dword first (ptr[0]),
 * then the high dword (ptr[1]) second.
 *//* did the command fail, and if so, why? *//* of the command which completed *//* submission queue that generated this entry *//* how much of this queue may be reclaimed *//* Used by admin commands to return data *//* Admin commands *//* I/O commands *//* microseconds *//* centiwatts *//opt/src/drivers/nvme/nvme-uclass.cnvme-uclassnvme_uclass_post_probendevnvme-blk"nvme-blk"ns_udev_u_boot_list_2_uclass_2_nvme.u_boot_list_2_uclass_2_nvme/* The real blksz and size will be set by nvme_blk_probe() *//*
		 * Encode the namespace id to the device name so that
		 * we can extract it when doing the probe.
		 *//* Create a blk device for each namespace */"nvme.h"/opt/src/drivers/nvme/nvme.cnvme_probe&ndev->bar->cstsError: %s: Out of memory!
"Error: %s: Out of memory!\n"NVME_Q_NUMsizeof(struct nvme_queue *)NVME_Q_NUM * sizeof(struct nvme_queue *)MAX_PRP_POOLMAX_PRP_POOL >> 3__u64 *NVME_CAP_MQES(ndev->cap) + 1((ndev->cap) & 0xffff) + 1NVME_Q_DEPTHndev->capmin_t(int, NVME_CAP_MQES(ndev->cap) + 1, NVME_Q_DEPTH)NVME_CAP_STRIDE(ndev->cap)nvme_bindnvme#%d"nvme#%d"ndev_numnvme_blk_writenvme_blk_readnvme_blk_rwtotal_lennvme_ns *ns->ns_idtotal_lbaslbasfree_nvmefree_queuelbas - 1(ulong)buffernvme_command *NVME_IO_QIO_TIMEOUTtemp_lennvme_blk_probesizeof(struct nvme_id_ns)PAD_SIZE((sizeof(struct nvme_id_ns)) * sizeof(char), 1)(((((sizeof(struct nvme_id_ns)) * sizeof(char)) - 1) / (1) + 1) * 1)(sizeof(struct nvme_id_ns)) * sizeof(char)(uintptr_t)__buf((uintptr_t)__buf)(typeof((uintptr_t)__buf))(16)-1sizeof(*ns)nvme_id_ns *char[4111]ALLOC_CACHE_ALIGN_BUFFER(char, buf, sizeof(struct nvme_id_ns))4111nvme_lbaf *id->nsze0x%.4x"0x%.4x"sizeof(ndev->serial)sizeof(ndev->firmware_rev)nvme_get_info_from_identifysizeof(struct nvme_id_ctrl)PAD_SIZE((sizeof(struct nvme_id_ctrl)) * sizeof(char), 1)(((((sizeof(struct nvme_id_ctrl)) * sizeof(char)) - 1) / (1) + 1) * 1)(sizeof(struct nvme_id_ctrl)) * sizeof(char)dev->capnvme_id_ctrl *ALLOC_CACHE_ALIGN_BUFFER(char, buf, sizeof(struct nvme_id_ctrl))ctrl->nnsizeof(ctrl->sn)sizeof(ctrl->mn)sizeof(ctrl->fr)NVME_CAP_MPSMIN(dev->cap)nvme_setup_io_queuesnr_io_queuesnvme_create_io_queuesnvme_set_queue_countq_countresult & 0xffffresult >> 16nvme_create_queuesizeof(c)nvme_alloc_sq(ulong)nvmeq->sq_cmdsnvmeqrelease_cqrelease_sqnvmeq->q_depth - 1NVME_QUEUE_PHYS_CONTIG | NVME_SQ_PRIO_MEDIUMnvme_alloc_cq(ulong)nvmeq->cqesnvme_completion *NVME_QUEUE_PHYS_CONTIG | NVME_CQ_IRQ_ENABLEDnvmeq->cq_vectornvme_configure_admin_queuedev_page_min"Device minimum page size (%u) too large for host (%u)\n"1 << dev_page_min, 1 << page_shiftdebug("Device minimum page size (%u) too large for host (%u)\n",
		      1 << dev_page_min, 1 << page_shift)drivers/nvme/nvme.cDevice minimum page size (%u) too large for host (%u)
dev_page_max"Device maximum page size (%u) smaller than host (%u)\n"1 << dev_page_max, 1 << page_shiftdebug("Device maximum page size (%u) smaller than host (%u)\n",
		      1 << dev_page_max, 1 << page_shift)348Device maximum page size (%u) smaller than host (%u)
NVME_ADMIN_QNVME_AQ_DEPTHNVME_CC_ARB_RR | NVME_CC_SHN_NONE4587520NVME_CC_IOSQES | NVME_CC_IOCQES&dev->bar->aqanvme_init_queuenvmeq->q_depthNVME_CQ_SIZE(nvmeq->q_depth)free_nvmeqnvme_free_queuesnvme_free_queuenvme_disable_ctrl4294918143~NVME_CC_SHN_MASK~NVME_CC_ENABLEcpu_to_le32(dev->ctrl_config)((__le32)(__u32)(dev->ctrl_config))&dev->bar->ccdev->ctrl_confignvme_enable_ctrlnvme_delete_cqnvme_delete_sqnvme_alloc_queuesizeof(*nvmeq)NVME_CQ_SIZE(depth)NVME_SQ_SIZE(depth)nvme_submit_admin_cmdADMIN_TIMEOUTnvme_submit_sync_cmdERROR: status = %x, phase = %d, head = %d
"ERROR: status = %x, phase = %d, head = %d\n"nvmeq->q_db + nvmeq->dev->db_stridereadl(&(nvmeq->cqes[head].result))iotrace_readl((const void *)(&(nvmeq->cqes[head].result)))&(nvmeq->cqes[head].result)nvme_submit_cmdlowestsizeof(*cmd)nvmeq->q_dbnvme_read_completion_statussizeof(struct nvme_completion)readw(&(nvmeq->cqes[index].status))iotrace_readw((const void *)(&(nvmeq->cqes[index].status)))&(nvmeq->cqes[index].status)nvme_get_cmd_idcmdid(cmdid < USHRT_MAX) ? cmdid++ : 0(cmdid < ((u16)(~0U))) ? cmdid++ : 0nvme_setup_prpsnprpsDIV_ROUND_UP(length, page_size)Error: malloc prp_pool fail
"Error: malloc prp_pool fail\n"(ulong)prp_pool + page_sizenvme_wait_readyNVME_CAP_TIMEOUT(dev->cap)&dev->bar->cstsETIME-62-ETIMEnvme_queue_idcmdid_datacqe_seencq_phasecq_headsq_tailcq_vectorq_dbsq_fullsq_cmdsnvme_supported_u_boot_list_2_pci_driver_entry_2_nvme.u_boot_list_2_pci_driver_entry_2_nvmePCI_CLASS_STORAGE_EXPRESS0x01080267586PCI_DEVICE_CLASS(PCI_CLASS_STORAGE_EXPRESS, ~0)sizeof(struct nvme_dev)_u_boot_list_2_driver_2_nvme.u_boot_list_2_driver_2_nvmesizeof(struct nvme_ns)_u_boot_list_2_driver_2_nvme_blk.u_boot_list_2_driver_2_nvme_blknvme_blknvme_blk_ops(depth * sizeof(struct nvme_completion))(depth * sizeof(struct nvme_command))/* extract the namespace id from the block device name *//*
		 * Maximum Data Transfer Size (MDTS) field indicates the maximum
		 * data transfer size between the host and the controller. The
		 * host should not submit a command that exceeds this transfer
		 * size. The value is in units of the minimum memory page size
		 * and is reported as a power of two (2^n).
		 *
		 * The spec also says: a value of 0h indicates no restrictions
		 * on transfer size. But in nvme_blk_read/write() below we have
		 * the following algorithm for maximum number of logic blocks
		 * per transfer:
		 *
		 * u16 lbas = 1 << (dev->max_transfer_shift - ns->lba_shift);
		 *
		 * In order for lbas not to overflow, the maximum number is 15
		 * which means dev->max_transfer_shift = 15 + 9 (ns->lba_shift).
		 * Let's use 20 which provides 1MB size.
		 *//* Free previously allocated queues *//*
	 * TODO: add cache flush operation when the size of
	 * the DMA buffer is known
	 *//*
	 * TODO: add cache invalidate operation when the size of
	 * the DMA buffer is known
	 *//* most architectures use 4KB as the page size *//**
 * nvme_submit_cmd() - copy a command into a queue and ring the doorbell
 *
 * @nvmeq:	The queue to use
 * @cmd:	The command to send
 *//* Timeout field in the CAP register is in 500 millisecond units *//*
 * An NVM Express queue. Each device has at least two (one for admin
 * commands and one for I/O commands).
 *//opt/src/drivers/nvme/nvme_show.cnvme_showbuf_ns(uintptr_t)__buf_ns((uintptr_t)__buf_ns)(typeof((uintptr_t)__buf_ns))(16)-1buf_ctrl(uintptr_t)__buf_ctrl((uintptr_t)__buf_ctrl)(typeof((uintptr_t)__buf_ctrl))(16)-1ALLOC_CACHE_ALIGN_BUFFER(char, buf_ctrl, sizeof(struct nvme_id_ctrl))__buf_ctrlctrl->oacsctrl->oncsALLOC_CACHE_ALIGN_BUFFER(char, buf_ns, sizeof(struct nvme_id_ns))__buf_nsprint_metadata_capBlk device %d: Metadata capabilities:
"Blk device %d: Metadata capabilities:\n"	As part of a separate buffer: %s
"\tAs part of a separate buffer: %s\n"No"No"	As part of an extended data LBA: %s
"\tAs part of an extended data LBA: %s\n"print_data_protect_capBlk device %d: End-to-End Data"Blk device %d: End-to-End Data"Protect Capabilities:
"Protect Capabilities:\n"	As last eight bytes: %s
"\tAs last eight bytes: %s\n"	As first eight bytes: %s
"\tAs first eight bytes: %s\n"	Support Type3: %s
"\tSupport Type3: %s\n"	Support Type2: %s
"\tSupport Type2: %s\n"	Support Type1: %s
"\tSupport Type1: %s\n"print_formatsBlk device %d: LBA Format Support:
"Blk device %d: LBA Format Support:\n"	LBA Foramt %d Support: "\tLBA Foramt %d Support: "(current)
"(current)\n"print_format		Metadata Size: %d
"\t\tMetadata Size: %d\n"lbaf->ms		LBA Data Size: %d
"\t\tLBA Data Size: %d\n"		Relative Performance: %s
"\t\tRelative Performance: %s\n"u8[][10]unsigned char[][10]u8[4][10]unsigned char[4][10]BestBetterGoodDegradedu8(*)[10]unsigned char(*)[10]print_format_nvme_attributesBlk device %d: Format NVM Attributes:
"Blk device %d: Format NVM Attributes:\n"	Support Cryptographic Erase: %s
"\tSupport Cryptographic Erase: %s\n"	Support erase a particular namespace: %s
"\tSupport erase a particular namespace: %s\n"Yes"Yes"	Support format a particular namespace: %s
"\tSupport format a particular namespace: %s\n"print_optional_nvm_cmdBlk device %d: Optional NVM Command Support:
"Blk device %d: Optional NVM Command Support:\n"	Reservation: %s
"\tReservation: %s\n"	Save/Select field in the Set/Get features: %s
"\tSave/Select field in the Set/Get features: %s\n"	Write Zeroes: %s
"\tWrite Zeroes: %s\n"	Dataset Management: %s
"\tDataset Management: %s\n"	Write Uncorrectable: %s
"\tWrite Uncorrectable: %s\n"print_optional_admin_cmdBlk device %d: Optional Admin Command Support:
"Blk device %d: Optional Admin Command Support:\n"	Namespace Management/Attachment: %s
"\tNamespace Management/Attachment: %s\n"	Firmware Commit/Image download: %s
"\tFirmware Commit/Image download: %s\n"	Format NVM: %s
"\tFormat NVM: %s\n"	Security Send/Receive: %s
"\tSecurity Send/Receive: %s\n"/opt/src/include/pch.hpchpch_opspch_pmbase_infopch_req_tPCH_REQ_HDA_CONFIGPCH_REQ_PMBASE_INFOPCH_REQ_TEST1PCH_REQ_TEST2PCH_REQ_TEST3PCH_REQ_COUNTget_io_baseget_gpio_baseset_spi_protectget_spi_basepm1_cnt_ofspm1_sts_ofsgpio0_en_ofspch_get_ops(dev)((struct pch_ops *)(dev)->driver->ops)BIOS_CTRL_BIOSWEPCH_RCBA__pch_hpch_ioctlpch_get_io_basepch_get_gpio_basepch_set_spi_protectpch_get_spi_base/**
 * pch_ioctl() - perform misc read/write operations
 *
 * This is a catch-all operation intended to avoid adding lots of
 * methods to this uclass, of which few are commonly used. Uncommon
 * operations that pertain only to a few devices in this uclass should
 * use this method instead of adding new methods.
 *
 * @dev:	PCH device to check
 * @req:	PCH request ID
 * @data:	Input/output data
 * @size:	Size of input data (and maximum size of output data)
 * @return size of output data on sucesss, -ve on error
 *//**
 * pch_get_io_base() - get the address of IO base
 *
 * @dev:	PCH device to check
 * @iobasep:	Returns address of IO base if available, else 0
 * @return 0 if OK, -ve on error (e.g. there is no IO base)
 *//**
 * pch_get_gpio_base() - get the address of GPIO base
 *
 * @dev:	PCH device to check
 * @gbasep:	Returns address of GPIO base if available, else 0
 * @return 0 if OK, -ve on error (e.g. there is no GPIO base)
 *//**
 * set_spi_protect() - set whether SPI flash is protected or not
 *
 * @dev:	PCH device to adjust
 * @protect:	true to protect, false to unprotect
 *
 * @return 0 on success, -ENOSYS if not implemented
 *//**
 * pch_get_spi_base() - get the address of SPI base
 *
 * @dev:	PCH device to check
 * @sbasep:	Returns address of SPI base if available, else 0
 * @return 0 if OK, -ve on error (e.g. there is no SPI base)
 *//**
	 * ioctl() - perform misc read/write operations
	 *
	 * This is a catch-all operation intended to avoid adding lots of
	 * methods to this uclass, of which few are commonly used. Uncommon
	 * operations that pertain only to a few devices in this uclass should
	 * use this method instead of adding new methods.
	 *
	 * @dev:	PCH device to check
	 * @req:	PCH request ID
	 * @data:	Input/output data
	 * @size:	Size of input data (and maximum size of output data)
	 * @return size of output data on sucesss, -ve on error
	 *//**
	 * get_io_base() - get the address of IO base
	 *
	 * @dev:	PCH device to check
	 * @iobasep:	Returns address of IO base if available, else 0
	 * @return 0 if OK, -ve on error (e.g. there is no IO base)
	 *//**
	 * get_gpio_base() - get the address of GPIO base
	 *
	 * @dev:	PCH device to check
	 * @gbasep:	Returns address of GPIO base if available, else 0
	 * @return 0 if OK, -ve on error (e.g. there is no GPIO base)
	 *//**
	 * set_spi_protect() - set whether SPI flash is protected or not
	 *
	 * @dev:	PCH device to adjust
	 * @protect:	true to protect, false to unprotect
	 *
	 * @return 0 on success, -ENOSYS if not implemented
	 *//**
	 * get_spi_base() - get the address of SPI base
	 *
	 * @dev:	PCH device to check
	 * @sbasep:	Returns address of SPI base if available, else 0
	 * @return 0 if OK, -ve on error (e.g. there is no SPI base)
	 *//**
 * struct pch_ops - Operations for the Platform Controller Hub
 *
 * Consider using ioctl() to add rarely used or driver-specific operations.
 *//**
 * struct pch_pmbase_info - Information filled in by PCH_REQ_PMBASE_INFO
 *
 * @pmbase: IO address of power-management controller
 * @gpio0_en_ofs: Offset of GPIO0 enable register
 * @pm1_sts_ofs: Offset of status register
 * @pm1_cnt_ofs: Offset of control register
 *//* Number of ioctrls supported *//* Test requests for sandbox driver *//* Fills out a struct pch_pmbase_info if available *//* Returns HDA config info if Azalia V1CTL enabled, -ENOENT if not *//* All the supported PCH ioctls */iobasepgbasepsbasep/opt/src/drivers/pch/pch-uclass.cpch-uclasspch_ops *UCLASS_PCH"pch"_u_boot_list_2_uclass_2_pch.u_boot_list_2_uclass_2_pch/opt/src/drivers/pch<pch.h>/opt/src/drivers/pch/pch7.cpch7pch7_get_gpio_baseGPIO_BASE"%s: unexpected BASE value\n"debug("%s: unexpected BASE value\n", __func__)drivers/pch/pch7.c%s: unexpected BASE value
~15pch7_set_spi_protectBIOS_CTRLbios_cntl~BIOS_CTRL_BIOSWEpch7_get_spi_basercba42949509120xffffc000123200x3020intel-pch7"intel-pch7"const pch_opsconst pch_ops *_u_boot_list_2_driver_2_pch7_drv.u_boot_list_2_driver_2_pch7_drvpch7_drvintel,pch7"intel,pch7"pch7_idspch7_ops/*
	 * Okay, I guess we're looking at the right device. The actual
	 * GPIO registers are in the PCI device's I/O space, starting
	 * at the offset that we just read. Bit 0 indicates that it's
	 * an I/O address, not a memory address, so mask that off.
	 *//*
	 * GPIO_BASE moved to its current offset with ICH6, but prior to
	 * that it was unused (or undocumented). Check that it looks
	 * okay: not all ones or zeros.
	 *
	 * Note we don't need check bit0 here, because the Tunnel Creek
	 * GPIO base address register bit0 is reserved (read returns 0),
	 * while on the Ivybridge the bit0 is used to indicate it is an
	 * I/O space.
	 *//* Adjust the BIOS write protect to dis/allow write commands *//* Bits 31-14 are the base address, 13-1 are reserved, 0 is enable *//*
 * Copyright (C) 2014 Google, Inc
 *//opt/src/drivers/pch/pch9.cpch9pch9_get_io_baseIO_BASEdrivers/pch/pch9.cpch9_get_gpio_basepch9_get_spi_baseSBASE_ADDRsbase_addr42949667840xfffffe00intel-pch9"intel-pch9"_u_boot_list_2_driver_2_pch9_drv.u_boot_list_2_driver_2_pch9_drvpch9_drvintel,pch9"intel,pch9"pch9_idspch9_ops/opt/src/drivers/pch/sandbox_pch.csandbox_pchsandbox_pch_ioctlsandbox_pch_get_io_basesandbox_pch_get_gpio_basesandbox_pch_set_spi_protectsandbox_pch_priv *sandbox_pch_get_spi_basesandbox_pch_privsandbox-pch"sandbox-pch"sizeof(struct sandbox_pch_priv)_u_boot_list_2_driver_2_sandbox_pch_drv.u_boot_list_2_driver_2_sandbox_pch_drvsandbox_pch_drvsandbox,pch"sandbox,pch"sandbox_pch_idssandbox_pch_ops/*
 * Copyright 2018 Google LLC
 *//opt/src/drivers/pci/pci-emul-uclass.cpci-emul-uclasssandbox_pci_emul_pre_removesandbox_pci_emul_priv *sandbox_pci_emul_post_probePCI_MASK_BUS(find_devfn)"%s: Could not find emulator for dev %x\n"__func__, find_devfndebug("%s: Could not find emulator for dev %x\n", __func__,
		      find_devfn)drivers/pci/pci-emul-uclass.c%s: Could not find emulator for dev %x
UCLASS_PCI_GENERICsandbox_pci_emul_privdev_countpci_emul"pci_emul"sizeof(struct sandbox_pci_emul_priv)_u_boot_list_2_uclass_2_pci_emul.u_boot_list_2_uclass_2_pci_emul/opt/src/drivers/pci/opt/src/drivers/pci/pci_internal.hpci_internaldm_pciauto_postscan_setup_bridgedm_pciauto_prescan_setup_bridge__pci_internal_hpci_get_bus/**
 * pci_get_bus() - Get a pointer to a bus, given its number
 *
 * This looks up a PCI bus based on its bus number. The bus is probed if
 * necessary.
 *
 * @busnum:	PCI bus number to look up
 * @busp:	Returns PCI bus on success
 * @return 0 on success, or -ve error
 *//**
 * dm_pciauto_config_device() - Configure a PCI device ready for use
 *
 * If the device is a bridge, downstream devices will be probed.
 *
 * @dev:	Device to configure
 * @return the maximum PCI bus number found by this device. If there are no
 * bridges, this just returns the device's bus number. If the device is a
 * bridge then it will return a larger number, depending on the devices on
 * that bridge. On error, returns a -ve error number.
 *//**
 * dm_pciauto_postscan_setup_bridge() - Finish set up of a bridge after scanning
 *
 * This should be called after a bus scan is complete. It adjusts the memory
 * ranges to fit with the devices actually found on the other side (downstream)
 * of the bridge.
 *
 * @dev:	Bridge device that was scanned
 * @sub_bus:	Bus number of the 'other side' of the bridge
 *//**
 * dm_pciauto_prescan_setup_bridge() - Set up a bridge for scanning
 *
 * This gets a bridge ready so that its downstream devices can be scanned.
 * It sets up the bus number and memory range registers. Once the scan is
 * completed, dm_pciauto_postscan_setup_bridge() should be called.
 *
 * @dev:	Bridge device to be scanned
 * @sub_bus:	Bus number of the 'other side' of the bridge
 *//*
 * Internal PCI functions, not exported outside drivers/pci
 *
 * Copyright (c) 2015 Google, Inc
 * Written by Simon Glass <sjg@chromium.org>
 *//opt/src/drivers/pci/pci-uclass.cpci-uclasspci_initpcie_offPCI_CFG_SPACE_EXP_SIZE - PCI_CFG_SPACE_SIZE(PCI_CFG_SPACE_EXP_SIZE - PCI_CFG_SPACE_SIZE)(PCI_CFG_SPACE_EXP_SIZE - PCI_CFG_SPACE_SIZE) / 8 PCI_CFG_SPACE_SIZE4092_dm_pci_find_next_capability PCI_FIND_CAP_TTLentea_offbar_responsepci_bus_addrdm_pci_bus_to_virt(dev, pci_bus_addr, flags, 0, MAP_NOCACHE)dm_pci_map_ea_barea_entryea_cntentry_size"pci_internal.h"bus_addrpci_hose_phys_to_bus: invalid physical address
"pci_hose_phys_to_bus: invalid physical address\n"_dm_pci_phys_to_busphys_addrpci_hose_bus_to_phys: invalid physical address
"pci_hose_bus_to_phys: invalid physical address\n"_dm_pci_bus_to_physPCI_REGION_MEM | PCI_REGION_PREFETCH(PCI_REGION_MEM | PCI_REGION_PREFETCH)skip_maskbapaoff_maskval_maskldataskip_to_next_devicepci_bridge_write_configpci_bridge_read_configpci_uclass_child_post_bind0xff00pci_uclass_post_probe"%s: probing bus %d\n"__func__, bus->seqdebug("%s: probing bus %d\n", __func__, bus->seq)drivers/pci/pci-uclass.c980%s: probing bus %d
pci_uclass_pre_probe"%s, bus=%d/%s, parent=%s\n"__func__, bus->seq, bus->name, bus->parent->namedebug("%s, bus=%d/%s, parent=%s\n", __func__, bus->seq, bus->name,
	      bus->parent->name)%s, bus=%d/%s, parent=%s
parent_hosedecode_regions"%s: Cannot decode regions\n"debug("%s: Cannot decode regions\n", __func__)parent_node%s: Cannot decode regions
pci_addr_cellsaddr_cellscells_per_record"%s: len=%d, cells_per_record=%d\n"__func__, len, cells_per_recorddebug("%s: len=%d, cells_per_record=%d\n", __func__, len,
	      cells_per_record)867%s: len=%d, cells_per_record=%d
pci_addrspace_codeprop[0](__force __u32)(__be32)(prop[0])(__u32)(__be32)(prop[0])((__u32)(__be32)(prop[0]))fdt32_to_cpu(prop[0])"%s: region %d, pci_addr=%llx, addr=%llx, size=%llx, space_code=%d\n"__func__, hose->region_count, pci_addr, addr, size, space_codedebug("%s: region %d, pci_addr=%llx, addr=%llx, size=%llx, space_code=%d\n",
		      __func__, hose->region_count, pci_addr, addr, size, space_code)886%s: region %d, pci_addr=%llx, addr=%llx, size=%llx, space_code=%d
1U << 30__ARG_PLACEHOLDER_CONFIG_SYS_PCI_64BITIS_ENABLED(CONFIG_SYS_PCI_64BIT)CONFIG_SYS_PCI_64BIT_MODULE__ARG_PLACEHOLDER_CONFIG_SYS_PCI_64BIT_MODULE__ARG_PLACEHOLDER_CONFIG_SYS_PCI_64BIT_MODULE 1__ARG_PLACEHOLDER_CONFIG_SYS_PCI_64BIT 1!IS_ENABLED(CONFIG_SYS_PCI_64BIT)upper_32_bits(pci_addr)" - beyond the 32-bit boundary, ignoring\n"debug(" - beyond the 32-bit boundary, ignoring\n")898 - beyond the 32-bit boundary, ignoring
" - type=%d, pos=%d\n"type, posdebug(" - type=%d, pos=%d\n", type, pos)909 - type=%d, pos=%d
"maximum number of regions parsed, aborting\n"pr_err("maximum number of regions parsed, aborting\n")pr_fmt("maximum number of regions parsed, aborting\n")maximum number of regions parsed, aborting
PCI_REGION_MEM | PCI_REGION_SYS_MEMORYfound_multibus->seqPCI_MAX_PCI_DEVICES - 132 - 1PCI_MAX_PCI_FUNCTIONS - 18 - 1PCI_BDF(bus->seq, PCI_MAX_PCI_DEVICES - 1,
		      PCI_MAX_PCI_FUNCTIONS - 1)PCI_BDF(bus->seq, PCI_MAX_PCI_DEVICES - 1PCI_BDF(bus->seq, PCI_MAX_PCI_DEVICES - 1,
		      PCI_MAX_PCI_FUNCTIONS - 1PCI_FUNC(bdf)"%s: bus %d/%s: found device %x, function %d\n"__func__, bus->seq, bus->name, PCI_DEV(bdf), PCI_FUNC(bdf)debug("%s: bus %d/%s: found device %x, function %d\n", __func__,
		      bus->seq, bus->name, PCI_DEV(bdf), PCI_FUNC(bdf))%s: bus %d/%s: found device %x, function %d
sizeof(find_id)PCI_BDF(bus->seq, 0, 0)PCI_BDF(0, 0, 1)Cannot read bus configuration: %d
"Cannot read bus configuration: %d\n"pci_find_and_bind_driver"%s: Searching for driver: vendor=%x, device=%x\n"__func__, find_id->vendor, find_id->devicedebug("%s: Searching for driver: vendor=%x, device=%x\n", __func__,
	      find_id->vendor, find_id->device)675%s: Searching for driver: vendor=%x, device=%x
ofnode *ofnode_union *pci_driver_entry *ll_entry_start(struct pci_driver_entry, pci_driver_entry).u_boot_list_2_pci_driver_entry_1ll_entry_count(struct pci_driver_entry, pci_driver_entry).u_boot_list_2_pci_driver_entry_3"%s: Match found: %s\n"__func__, drv->namedebug("%s: Match found: %s\n", __func__, drv->name)717%s: Match found: %s
bridge1540PCI_CLASS_BRIDGE_PCIpci_%x:%x.%x"pci_%x:%x.%x"PCI_DEV(bdf)pci_bridge_drv"pci_bridge_drv"pci_generic_drv"pci_generic_drv""%s: Failed to bind generic driver: %d\n"debug("%s: Failed to bind generic driver: %d\n", __func__, ret)743%s: Failed to bind generic driver: %d
"%s: No match found: bound generic driver instead\n"debug("%s: No match found: bound generic driver instead\n", __func__)747%s: No match found: bound generic driver instead
"%s: No match found: error %d\n"debug("%s: No match found: error %d\n", __func__, ret)752%s: No match found: error %d
pci_match_one_id603"%s: bus = %d/%s\n"__func__, sub_bus, bus->namedebug("%s: bus = %d/%s\n", __func__, sub_bus, bus->name)%s: bus = %d/%s
"%s: Cannot probe bus %s: %d\n"__func__, bus->name, retdebug("%s: Cannot probe bus %s: %d\n", __func__, bus->name,
		      ret)find%s: Cannot probe bus %s: %d
%s: Internal error, bus '%s' got seq %d, expected %d
"%s: Internal error, bus '%s' got seq %d, expected %d\n"EPIPE-EPIPE"%s: start\n"debug("%s: start\n", __func__)%s: start
max_bus"%s: device %s\n"debug("%s: device %s\n", __func__, dev->name)%s: device %s
PCI_CLASS_DISPLAY_VGAPCI_CLASS_DISPLAY_VGA << 8(PCI_CLASS_DISPLAY_VGA << 8)"%s: done\n"debug("%s: done\n", __func__)535%s: done
set_vga_bridge_bitsbcpci_read_configPCI_BUS(bdf)dm_pci_ops *pci_write_configdm_pci_bus_find_devicepci_device_matches_idspci_dev_find_ofnodeaddr.phys_hiPCI_MASK_BUS(addr.phys_hi)rnodepci_get_bus_maxPCI_ADD_BUS(bus->seq, pplat->devfn)_u_boot_list_2_driver_2_pci_generic_drv.u_boot_list_2_driver_2_pci_generic_drvpci-generic"pci-generic"pci_generic_idspci_generic"pci_generic"_u_boot_list_2_uclass_2_pci_generic.u_boot_list_2_uclass_2_pci_genericconst dm_pci_opsconst dm_pci_ops *_u_boot_list_2_driver_2_pci_bridge_drv.u_boot_list_2_driver_2_pci_bridge_drvpci-bridge"pci-bridge"pci_bridge_idspci_bridge_opssizeof(struct pci_controller)sizeof(struct pci_child_platdata)_u_boot_list_2_uclass_2_pci.u_boot_list_2_uclass_2_pcidefined(CONFIG_X86) && defined(CONFIG_HAVE_FSP)CONFIG_PCI_PNP/*
	 * Enumerate all known controller devices. Enumeration has the side-
	 * effect of probing them, so PCIe devices will be enumerated too.
	 *//* wait 100ms, per PCI spec *//* check FLR capability *//* look fo ^  +\    